package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/objects/profiles/vulnerability"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &VulnerabilitySecurityProfileDataSource{}
	_ datasource.DataSourceWithConfigure = &VulnerabilitySecurityProfileDataSource{}
)

func NewVulnerabilitySecurityProfileDataSource() datasource.DataSource {
	return &VulnerabilitySecurityProfileDataSource{}
}

type VulnerabilitySecurityProfileDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*vulnerability.Entry, vulnerability.Location, *vulnerability.Service]
}

type VulnerabilitySecurityProfileDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type VulnerabilitySecurityProfileDataSourceModel struct {
	Location                       types.Object `tfsdk:"location"`
	Name                           types.String `tfsdk:"name"`
	CloudInlineAnalysis            types.Bool   `tfsdk:"cloud_inline_analysis"`
	Description                    types.String `tfsdk:"description"`
	DisableOverride                types.String `tfsdk:"disable_override"`
	InlineExceptionEdlUrl          types.List   `tfsdk:"inline_exception_edl_url"`
	InlineExceptionIpAddress       types.List   `tfsdk:"inline_exception_ip_address"`
	MicaEngineVulnerabilityEnabled types.List   `tfsdk:"mica_engine_vulnerability_enabled"`
	Rules                          types.List   `tfsdk:"rules"`
	ThreatException                types.List   `tfsdk:"threat_exception"`
}
type VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject struct {
	Name               types.String `tfsdk:"name"`
	InlinePolicyAction types.String `tfsdk:"inline_policy_action"`
}
type VulnerabilitySecurityProfileDataSourceRulesObject struct {
	Name          types.String `tfsdk:"name"`
	ThreatName    types.String `tfsdk:"threat_name"`
	Host          types.String `tfsdk:"host"`
	Category      types.String `tfsdk:"category"`
	PacketCapture types.String `tfsdk:"packet_capture"`
	Cve           types.List   `tfsdk:"cve"`
	VendorId      types.List   `tfsdk:"vendor_id"`
	Severity      types.List   `tfsdk:"severity"`
	Action        types.Object `tfsdk:"action"`
}
type VulnerabilitySecurityProfileDataSourceRulesActionObject struct {
	Default     types.Object `tfsdk:"default"`
	Allow       types.Object `tfsdk:"allow"`
	Alert       types.Object `tfsdk:"alert"`
	Drop        types.Object `tfsdk:"drop"`
	ResetClient types.Object `tfsdk:"reset_client"`
	ResetServer types.Object `tfsdk:"reset_server"`
	ResetBoth   types.Object `tfsdk:"reset_both"`
	BlockIp     types.Object `tfsdk:"block_ip"`
}
type VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionAllowObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionAlertObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionDropObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject struct {
	TrackBy  types.String `tfsdk:"track_by"`
	Duration types.Int64  `tfsdk:"duration"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionObject struct {
	Name          types.String `tfsdk:"name"`
	PacketCapture types.String `tfsdk:"packet_capture"`
	Action        types.Object `tfsdk:"action"`
	TimeAttribute types.Object `tfsdk:"time_attribute"`
	ExemptIp      types.List   `tfsdk:"exempt_ip"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject struct {
	Default     types.Object `tfsdk:"default"`
	Allow       types.Object `tfsdk:"allow"`
	Alert       types.Object `tfsdk:"alert"`
	Drop        types.Object `tfsdk:"drop"`
	ResetClient types.Object `tfsdk:"reset_client"`
	ResetServer types.Object `tfsdk:"reset_server"`
	ResetBoth   types.Object `tfsdk:"reset_both"`
	BlockIp     types.Object `tfsdk:"block_ip"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject struct {
	TrackBy  types.String `tfsdk:"track_by"`
	Duration types.Int64  `tfsdk:"duration"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject struct {
	Interval  types.Int64  `tfsdk:"interval"`
	Threshold types.Int64  `tfsdk:"threshold"`
	TrackBy   types.String `tfsdk:"track_by"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject struct {
	Name types.String `tfsdk:"name"`
}

func (o *VulnerabilitySecurityProfileDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj VulnerabilitySecurityProfileLocation

	var micaEngineVulnerabilityEnabledObj *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject

	var rulesObj *VulnerabilitySecurityProfileDataSourceRulesObject

	var threatExceptionObj *VulnerabilitySecurityProfileDataSourceThreatExceptionObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":                  types.StringType,
		"cloud_inline_analysis": types.BoolType,
		"description":           types.StringType,
		"disable_override":      types.StringType,
		"inline_exception_edl_url": types.ListType{
			ElemType: types.StringType,
		},
		"inline_exception_ip_address": types.ListType{
			ElemType: types.StringType,
		},
		"mica_engine_vulnerability_enabled": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: micaEngineVulnerabilityEnabledObj.AttributeTypes(),
			},
		},
		"rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rulesObj.AttributeTypes(),
			},
		},
		"threat_exception": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: threatExceptionObj.AttributeTypes(),
			},
		},
	}
}

func (o VulnerabilitySecurityProfileDataSourceModel) AncestorName() string {
	return ""
}

func (o VulnerabilitySecurityProfileDataSourceModel) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                 types.StringType,
		"inline_policy_action": types.StringType,
	}
}

func (o VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) AncestorName() string {
	return "mica-engine-vulnerability-enabled"
}

func (o VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VulnerabilitySecurityProfileDataSourceRulesObject) AttributeTypes() map[string]attr.Type {

	var actionObj *VulnerabilitySecurityProfileDataSourceRulesActionObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"threat_name":    types.StringType,
		"host":           types.StringType,
		"category":       types.StringType,
		"packet_capture": types.StringType,
		"cve": types.ListType{
			ElemType: types.StringType,
		},
		"vendor_id": types.ListType{
			ElemType: types.StringType,
		},
		"severity": types.ListType{
			ElemType: types.StringType,
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VulnerabilitySecurityProfileDataSourceRulesObject) AncestorName() string {
	return "rules"
}

func (o VulnerabilitySecurityProfileDataSourceRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionObject) AttributeTypes() map[string]attr.Type {

	var defaultObj *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject

	var allowObj *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject

	var alertObj *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject

	var dropObj *VulnerabilitySecurityProfileDataSourceRulesActionDropObject

	var resetClientObj *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject

	var resetServerObj *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject

	var resetBothObj *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject

	var blockIpObj *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject
	return map[string]attr.Type{
		"default": types.ObjectType{
			AttrTypes: defaultObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
		"alert": types.ObjectType{
			AttrTypes: alertObj.AttributeTypes(),
		},
		"drop": types.ObjectType{
			AttrTypes: dropObj.AttributeTypes(),
		},
		"reset_client": types.ObjectType{
			AttrTypes: resetClientObj.AttributeTypes(),
		},
		"reset_server": types.ObjectType{
			AttrTypes: resetServerObj.AttributeTypes(),
		},
		"reset_both": types.ObjectType{
			AttrTypes: resetBothObj.AttributeTypes(),
		},
		"block_ip": types.ObjectType{
			AttrTypes: blockIpObj.AttributeTypes(),
		},
	}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionObject) AncestorName() string {
	return "action"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) AncestorName() string {
	return "default"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) AncestorName() string {
	return "alert"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionDropObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionDropObject) AncestorName() string {
	return "drop"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionDropObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) AncestorName() string {
	return "reset-client"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) AncestorName() string {
	return "reset-server"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) AncestorName() string {
	return "reset-both"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"track_by": types.StringType,
		"duration": types.Int64Type,
	}
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) AncestorName() string {
	return "block-ip"
}

func (o VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionObject) AttributeTypes() map[string]attr.Type {

	var actionObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject

	var timeAttributeObj *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject

	var exemptIpObj *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"packet_capture": types.StringType,
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"time_attribute": types.ObjectType{
			AttrTypes: timeAttributeObj.AttributeTypes(),
		},
		"exempt_ip": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exemptIpObj.AttributeTypes(),
			},
		},
	}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionObject) AncestorName() string {
	return "threat-exception"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) AttributeTypes() map[string]attr.Type {

	var defaultObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject

	var allowObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject

	var alertObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject

	var dropObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject

	var resetClientObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject

	var resetServerObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject

	var resetBothObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject

	var blockIpObj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject
	return map[string]attr.Type{
		"default": types.ObjectType{
			AttrTypes: defaultObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
		"alert": types.ObjectType{
			AttrTypes: alertObj.AttributeTypes(),
		},
		"drop": types.ObjectType{
			AttrTypes: dropObj.AttributeTypes(),
		},
		"reset_client": types.ObjectType{
			AttrTypes: resetClientObj.AttributeTypes(),
		},
		"reset_server": types.ObjectType{
			AttrTypes: resetServerObj.AttributeTypes(),
		},
		"reset_both": types.ObjectType{
			AttrTypes: resetBothObj.AttributeTypes(),
		},
		"block_ip": types.ObjectType{
			AttrTypes: blockIpObj.AttributeTypes(),
		},
	}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) AncestorName() string {
	return "action"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) AncestorName() string {
	return "default"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) AncestorName() string {
	return "alert"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) AncestorName() string {
	return "drop"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) AncestorName() string {
	return "reset-client"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) AncestorName() string {
	return "reset-server"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) AncestorName() string {
	return "reset-both"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"track_by": types.StringType,
		"duration": types.Int64Type,
	}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) AncestorName() string {
	return "block-ip"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval":  types.Int64Type,
		"threshold": types.Int64Type,
		"track_by":  types.StringType,
	}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) AncestorName() string {
	return "time-attribute"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) AncestorName() string {
	return "exempt-ip"
}

func (o VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}

func (o *VulnerabilitySecurityProfileDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	cloudInlineAnalysis_value := o.CloudInlineAnalysis.ValueBoolPointer()
	description_value := o.Description.ValueStringPointer()
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	var inlineExceptionEdlUrl_pango_entries []string
	if !o.InlineExceptionEdlUrl.IsUnknown() && !o.InlineExceptionEdlUrl.IsNull() {
		object_entries := make([]types.String, 0, len(o.InlineExceptionEdlUrl.Elements()))
		diags.Append(o.InlineExceptionEdlUrl.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			inlineExceptionEdlUrl_pango_entries = append(inlineExceptionEdlUrl_pango_entries, elt.ValueString())
		}
	}
	var inlineExceptionIpAddress_pango_entries []string
	if !o.InlineExceptionIpAddress.IsUnknown() && !o.InlineExceptionIpAddress.IsNull() {
		object_entries := make([]types.String, 0, len(o.InlineExceptionIpAddress.Elements()))
		diags.Append(o.InlineExceptionIpAddress.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			inlineExceptionIpAddress_pango_entries = append(inlineExceptionIpAddress_pango_entries, elt.ValueString())
		}
	}
	var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject
	var micaEngineVulnerabilityEnabled_pango_entries []vulnerability.MicaEngineVulnerabilityEnabled
	{
		d := o.MicaEngineVulnerabilityEnabled.ElementsAs(ctx, &micaEngineVulnerabilityEnabled_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range micaEngineVulnerabilityEnabled_tf_entries {
			var entry *vulnerability.MicaEngineVulnerabilityEnabled
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			micaEngineVulnerabilityEnabled_pango_entries = append(micaEngineVulnerabilityEnabled_pango_entries, *entry)
		}
	}
	var rules_tf_entries []VulnerabilitySecurityProfileDataSourceRulesObject
	var rules_pango_entries []vulnerability.Rules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *vulnerability.Rules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}
	var threatException_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionObject
	var threatException_pango_entries []vulnerability.ThreatException
	{
		d := o.ThreatException.ElementsAs(ctx, &threatException_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range threatException_tf_entries {
			var entry *vulnerability.ThreatException
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			threatException_pango_entries = append(threatException_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).CloudInlineAnalysis = cloudInlineAnalysis_value
	(*obj).Description = description_value
	(*obj).DisableOverride = disableOverride_value
	(*obj).InlineExceptionEdlUrl = inlineExceptionEdlUrl_pango_entries
	(*obj).InlineExceptionIpAddress = inlineExceptionIpAddress_pango_entries
	(*obj).MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_pango_entries
	(*obj).Rules = rules_pango_entries
	(*obj).ThreatException = threatException_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.MicaEngineVulnerabilityEnabled, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	inlinePolicyAction_value := o.InlinePolicyAction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.MicaEngineVulnerabilityEnabled)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).InlinePolicyAction = inlinePolicyAction_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.Rules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threatName_value := o.ThreatName.ValueStringPointer()
	host_value := o.Host.ValueStringPointer()
	category_value := o.Category.ValueStringPointer()
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	var cve_pango_entries []string
	if !o.Cve.IsUnknown() && !o.Cve.IsNull() {
		object_entries := make([]types.String, 0, len(o.Cve.Elements()))
		diags.Append(o.Cve.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			cve_pango_entries = append(cve_pango_entries, elt.ValueString())
		}
	}
	var vendorId_pango_entries []string
	if !o.VendorId.IsUnknown() && !o.VendorId.IsNull() {
		object_entries := make([]types.String, 0, len(o.VendorId.Elements()))
		diags.Append(o.VendorId.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			vendorId_pango_entries = append(vendorId_pango_entries, elt.ValueString())
		}
	}
	var severity_pango_entries []string
	if !o.Severity.IsUnknown() && !o.Severity.IsNull() {
		object_entries := make([]types.String, 0, len(o.Severity.Elements()))
		diags.Append(o.Severity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			severity_pango_entries = append(severity_pango_entries, elt.ValueString())
		}
	}
	var action_entry *vulnerability.RulesAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.RulesAction)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.Rules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ThreatName = threatName_value
	(*obj).Host = host_value
	(*obj).Category = category_value
	(*obj).PacketCapture = packetCapture_value
	(*obj).Cve = cve_pango_entries
	(*obj).VendorId = vendorId_pango_entries
	(*obj).Severity = severity_pango_entries
	(*obj).Action = action_entry

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_entry *vulnerability.RulesActionDefault
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.RulesActionDefault)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject
		diags.Append(o.Default.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &default_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *vulnerability.RulesActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.RulesActionAllow)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.RulesActionAlert
	if !o.Alert.IsUnknown() && !o.Alert.IsNull() {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.RulesActionAlert)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject
		diags.Append(o.Alert.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &alert_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_entry *vulnerability.RulesActionDrop
	if !o.Drop.IsUnknown() && !o.Drop.IsNull() {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.RulesActionDrop)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionDropObject
		diags.Append(o.Drop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &drop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_entry *vulnerability.RulesActionResetClient
	if !o.ResetClient.IsUnknown() && !o.ResetClient.IsNull() {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.RulesActionResetClient)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject
		diags.Append(o.ResetClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.RulesActionResetServer
	if !o.ResetServer.IsUnknown() && !o.ResetServer.IsNull() {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.RulesActionResetServer)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject
		diags.Append(o.ResetServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.RulesActionResetBoth
	if !o.ResetBoth.IsUnknown() && !o.ResetBoth.IsNull() {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.RulesActionResetBoth)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject
		diags.Append(o.ResetBoth.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetBoth_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.RulesActionBlockIp
	if !o.BlockIp.IsUnknown() && !o.BlockIp.IsNull() {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.RulesActionBlockIp)
		}
		var object *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject
		diags.Append(o.BlockIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &blockIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.RulesAction)
	}
	(*obj).Default = default_entry
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry
	(*obj).Drop = drop_entry
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionDropObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDrop)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatException, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	var action_entry *vulnerability.ThreatExceptionAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.ThreatExceptionAction)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var timeAttribute_entry *vulnerability.ThreatExceptionTimeAttribute
	if !o.TimeAttribute.IsUnknown() && !o.TimeAttribute.IsNull() {
		if *obj != nil && (*obj).TimeAttribute != nil {
			timeAttribute_entry = (*obj).TimeAttribute
		} else {
			timeAttribute_entry = new(vulnerability.ThreatExceptionTimeAttribute)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject
		diags.Append(o.TimeAttribute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timeAttribute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var exemptIp_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject
	var exemptIp_pango_entries []vulnerability.ThreatExceptionExemptIp
	{
		d := o.ExemptIp.ElementsAs(ctx, &exemptIp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exemptIp_tf_entries {
			var entry *vulnerability.ThreatExceptionExemptIp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exemptIp_pango_entries = append(exemptIp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatException)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).PacketCapture = packetCapture_value
	(*obj).Action = action_entry
	(*obj).TimeAttribute = timeAttribute_entry
	(*obj).ExemptIp = exemptIp_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_entry *vulnerability.ThreatExceptionActionDefault
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.ThreatExceptionActionDefault)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject
		diags.Append(o.Default.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &default_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *vulnerability.ThreatExceptionActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.ThreatExceptionActionAllow)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.ThreatExceptionActionAlert
	if !o.Alert.IsUnknown() && !o.Alert.IsNull() {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.ThreatExceptionActionAlert)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject
		diags.Append(o.Alert.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &alert_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_entry *vulnerability.ThreatExceptionActionDrop
	if !o.Drop.IsUnknown() && !o.Drop.IsNull() {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.ThreatExceptionActionDrop)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject
		diags.Append(o.Drop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &drop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_entry *vulnerability.ThreatExceptionActionResetClient
	if !o.ResetClient.IsUnknown() && !o.ResetClient.IsNull() {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.ThreatExceptionActionResetClient)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject
		diags.Append(o.ResetClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.ThreatExceptionActionResetServer
	if !o.ResetServer.IsUnknown() && !o.ResetServer.IsNull() {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.ThreatExceptionActionResetServer)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject
		diags.Append(o.ResetServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.ThreatExceptionActionResetBoth
	if !o.ResetBoth.IsUnknown() && !o.ResetBoth.IsNull() {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.ThreatExceptionActionResetBoth)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject
		diags.Append(o.ResetBoth.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetBoth_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.ThreatExceptionActionBlockIp
	if !o.BlockIp.IsUnknown() && !o.BlockIp.IsNull() {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.ThreatExceptionActionBlockIp)
		}
		var object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject
		diags.Append(o.BlockIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &blockIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionAction)
	}
	(*obj).Default = default_entry
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry
	(*obj).Drop = drop_entry
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDrop)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionTimeAttribute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	trackBy_value := o.TrackBy.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionTimeAttribute)
	}
	(*obj).Interval = interval_value
	(*obj).Threshold = threshold_value
	(*obj).TrackBy = trackBy_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionExemptIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionExemptIp)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var inlineExceptionEdlUrl_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.InlineExceptionEdlUrl.IsNull() || len(obj.InlineExceptionEdlUrl) > 0 {
			entries = obj.InlineExceptionEdlUrl
		}

		inlineExceptionEdlUrl_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var inlineExceptionIpAddress_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.InlineExceptionIpAddress.IsNull() || len(obj.InlineExceptionIpAddress) > 0 {
			entries = obj.InlineExceptionIpAddress
		}

		inlineExceptionIpAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var micaEngineVulnerabilityEnabled_list types.List
	{
		var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject
		if !o.MicaEngineVulnerabilityEnabled.IsNull() {
			diags.Append(o.MicaEngineVulnerabilityEnabled.ElementsAs(ctx, &micaEngineVulnerabilityEnabled_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.MicaEngineVulnerabilityEnabled {
			entry := VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(micaEngineVulnerabilityEnabled_tf_entries) {
				entry = micaEngineVulnerabilityEnabled_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(micaEngineVulnerabilityEnabled_tf_entries) {
				micaEngineVulnerabilityEnabled_tf_entries[idx] = entry
			} else {
				micaEngineVulnerabilityEnabled_tf_entries = append(micaEngineVulnerabilityEnabled_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("mica_engine_vulnerability_enabled")
		micaEngineVulnerabilityEnabled_list, list_diags = types.ListValueFrom(ctx, schemaType, micaEngineVulnerabilityEnabled_tf_entries)
		diags.Append(list_diags...)
	}
	var rules_list types.List
	{
		var rules_tf_entries []VulnerabilitySecurityProfileDataSourceRulesObject
		if !o.Rules.IsNull() {
			diags.Append(o.Rules.ElementsAs(ctx, &rules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Rules {
			entry := VulnerabilitySecurityProfileDataSourceRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rules_tf_entries) {
				entry = rules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rules_tf_entries) {
				rules_tf_entries[idx] = entry
			} else {
				rules_tf_entries = append(rules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}
	var threatException_list types.List
	{
		var threatException_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionObject
		if !o.ThreatException.IsNull() {
			diags.Append(o.ThreatException.ElementsAs(ctx, &threatException_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ThreatException {
			entry := VulnerabilitySecurityProfileDataSourceThreatExceptionObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(threatException_tf_entries) {
				entry = threatException_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(threatException_tf_entries) {
				threatException_tf_entries[idx] = entry
			} else {
				threatException_tf_entries = append(threatException_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("threat_exception")
		threatException_list, list_diags = types.ListValueFrom(ctx, schemaType, threatException_tf_entries)
		diags.Append(list_diags...)
	}

	var cloudInlineAnalysis_value types.Bool
	if obj.CloudInlineAnalysis != nil {
		cloudInlineAnalysis_value = types.BoolValue(*obj.CloudInlineAnalysis)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	o.Name = types.StringValue(obj.Name)
	o.CloudInlineAnalysis = cloudInlineAnalysis_value
	o.Description = description_value
	o.DisableOverride = disableOverride_value
	o.InlineExceptionEdlUrl = inlineExceptionEdlUrl_list
	o.InlineExceptionIpAddress = inlineExceptionIpAddress_list
	o.MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_list
	o.Rules = rules_list
	o.ThreatException = threatException_list

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.MicaEngineVulnerabilityEnabled, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var inlinePolicyAction_value types.String
	if obj.InlinePolicyAction != nil {
		inlinePolicyAction_value = types.StringValue(*obj.InlinePolicyAction)
	}
	o.Name = types.StringValue(obj.Name)
	o.InlinePolicyAction = inlinePolicyAction_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.Rules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var cve_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Cve.IsNull() || len(obj.Cve) > 0 {
			entries = obj.Cve
		}

		cve_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var vendorId_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.VendorId.IsNull() || len(obj.VendorId) > 0 {
			entries = obj.VendorId
		}

		vendorId_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var severity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Severity.IsNull() || len(obj.Severity) > 0 {
			entries = obj.Severity
		}

		severity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VulnerabilitySecurityProfileDataSourceRulesActionObject
	if o.Action.IsNull() {
		action_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var threatName_value types.String
	if obj.ThreatName != nil {
		threatName_value = types.StringValue(*obj.ThreatName)
	}
	var host_value types.String
	if obj.Host != nil {
		host_value = types.StringValue(*obj.Host)
	}
	var category_value types.String
	if obj.Category != nil {
		category_value = types.StringValue(*obj.Category)
	}
	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	o.Name = types.StringValue(obj.Name)
	o.ThreatName = threatName_value
	o.Host = host_value
	o.Category = category_value
	o.PacketCapture = packetCapture_value
	o.Cve = cve_list
	o.VendorId = vendorId_list
	o.Severity = severity_list
	o.Action = action_object

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var default_obj *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject
	if o.Default.IsNull() {
		default_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject)
	} else {
		diags.Append(o.Default.As(ctx, &default_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	default_object := types.ObjectNull(default_obj.AttributeTypes())
	if obj.Default != nil {
		diags.Append(default_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Default, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		default_object, diags_tmp = types.ObjectValueFrom(ctx, default_obj.AttributeTypes(), default_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var alert_obj *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject
	if o.Alert.IsNull() {
		alert_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionAlertObject)
	} else {
		diags.Append(o.Alert.As(ctx, &alert_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	alert_object := types.ObjectNull(alert_obj.AttributeTypes())
	if obj.Alert != nil {
		diags.Append(alert_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Alert, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		alert_object, diags_tmp = types.ObjectValueFrom(ctx, alert_obj.AttributeTypes(), alert_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var drop_obj *VulnerabilitySecurityProfileDataSourceRulesActionDropObject
	if o.Drop.IsNull() {
		drop_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionDropObject)
	} else {
		diags.Append(o.Drop.As(ctx, &drop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	drop_object := types.ObjectNull(drop_obj.AttributeTypes())
	if obj.Drop != nil {
		diags.Append(drop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Drop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		drop_object, diags_tmp = types.ObjectValueFrom(ctx, drop_obj.AttributeTypes(), drop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetClient_obj *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject
	if o.ResetClient.IsNull() {
		resetClient_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject)
	} else {
		diags.Append(o.ResetClient.As(ctx, &resetClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetClient_object := types.ObjectNull(resetClient_obj.AttributeTypes())
	if obj.ResetClient != nil {
		diags.Append(resetClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetClient_object, diags_tmp = types.ObjectValueFrom(ctx, resetClient_obj.AttributeTypes(), resetClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetServer_obj *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject
	if o.ResetServer.IsNull() {
		resetServer_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject)
	} else {
		diags.Append(o.ResetServer.As(ctx, &resetServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetServer_object := types.ObjectNull(resetServer_obj.AttributeTypes())
	if obj.ResetServer != nil {
		diags.Append(resetServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetServer_object, diags_tmp = types.ObjectValueFrom(ctx, resetServer_obj.AttributeTypes(), resetServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetBoth_obj *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject
	if o.ResetBoth.IsNull() {
		resetBoth_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject)
	} else {
		diags.Append(o.ResetBoth.As(ctx, &resetBoth_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetBoth_object := types.ObjectNull(resetBoth_obj.AttributeTypes())
	if obj.ResetBoth != nil {
		diags.Append(resetBoth_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetBoth, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetBoth_object, diags_tmp = types.ObjectValueFrom(ctx, resetBoth_obj.AttributeTypes(), resetBoth_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var blockIp_obj *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject
	if o.BlockIp.IsNull() {
		blockIp_obj = new(VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject)
	} else {
		diags.Append(o.BlockIp.As(ctx, &blockIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	blockIp_object := types.ObjectNull(blockIp_obj.AttributeTypes())
	if obj.BlockIp != nil {
		diags.Append(blockIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BlockIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		blockIp_object, diags_tmp = types.ObjectValueFrom(ctx, blockIp_obj.AttributeTypes(), blockIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Default = default_object
	o.Allow = allow_object
	o.Alert = alert_object
	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDropObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	o.TrackBy = trackBy_value
	o.Duration = duration_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatException, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var exemptIp_list types.List
	{
		var exemptIp_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject
		if !o.ExemptIp.IsNull() {
			diags.Append(o.ExemptIp.ElementsAs(ctx, &exemptIp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExemptIp {
			entry := VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exemptIp_tf_entries) {
				entry = exemptIp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exemptIp_tf_entries) {
				exemptIp_tf_entries[idx] = entry
			} else {
				exemptIp_tf_entries = append(exemptIp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("exempt_ip")
		exemptIp_list, list_diags = types.ListValueFrom(ctx, schemaType, exemptIp_tf_entries)
		diags.Append(list_diags...)
	}

	var action_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject
	if o.Action.IsNull() {
		action_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timeAttribute_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject
	if o.TimeAttribute.IsNull() {
		timeAttribute_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject)
	} else {
		diags.Append(o.TimeAttribute.As(ctx, &timeAttribute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timeAttribute_object := types.ObjectNull(timeAttribute_obj.AttributeTypes())
	if obj.TimeAttribute != nil {
		diags.Append(timeAttribute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.TimeAttribute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timeAttribute_object, diags_tmp = types.ObjectValueFrom(ctx, timeAttribute_obj.AttributeTypes(), timeAttribute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	o.Name = types.StringValue(obj.Name)
	o.PacketCapture = packetCapture_value
	o.Action = action_object
	o.TimeAttribute = timeAttribute_object
	o.ExemptIp = exemptIp_list

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var default_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject
	if o.Default.IsNull() {
		default_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject)
	} else {
		diags.Append(o.Default.As(ctx, &default_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	default_object := types.ObjectNull(default_obj.AttributeTypes())
	if obj.Default != nil {
		diags.Append(default_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Default, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		default_object, diags_tmp = types.ObjectValueFrom(ctx, default_obj.AttributeTypes(), default_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var alert_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject
	if o.Alert.IsNull() {
		alert_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject)
	} else {
		diags.Append(o.Alert.As(ctx, &alert_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	alert_object := types.ObjectNull(alert_obj.AttributeTypes())
	if obj.Alert != nil {
		diags.Append(alert_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Alert, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		alert_object, diags_tmp = types.ObjectValueFrom(ctx, alert_obj.AttributeTypes(), alert_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var drop_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject
	if o.Drop.IsNull() {
		drop_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject)
	} else {
		diags.Append(o.Drop.As(ctx, &drop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	drop_object := types.ObjectNull(drop_obj.AttributeTypes())
	if obj.Drop != nil {
		diags.Append(drop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Drop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		drop_object, diags_tmp = types.ObjectValueFrom(ctx, drop_obj.AttributeTypes(), drop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetClient_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject
	if o.ResetClient.IsNull() {
		resetClient_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject)
	} else {
		diags.Append(o.ResetClient.As(ctx, &resetClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetClient_object := types.ObjectNull(resetClient_obj.AttributeTypes())
	if obj.ResetClient != nil {
		diags.Append(resetClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetClient_object, diags_tmp = types.ObjectValueFrom(ctx, resetClient_obj.AttributeTypes(), resetClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetServer_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject
	if o.ResetServer.IsNull() {
		resetServer_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject)
	} else {
		diags.Append(o.ResetServer.As(ctx, &resetServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetServer_object := types.ObjectNull(resetServer_obj.AttributeTypes())
	if obj.ResetServer != nil {
		diags.Append(resetServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetServer_object, diags_tmp = types.ObjectValueFrom(ctx, resetServer_obj.AttributeTypes(), resetServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetBoth_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject
	if o.ResetBoth.IsNull() {
		resetBoth_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject)
	} else {
		diags.Append(o.ResetBoth.As(ctx, &resetBoth_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetBoth_object := types.ObjectNull(resetBoth_obj.AttributeTypes())
	if obj.ResetBoth != nil {
		diags.Append(resetBoth_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetBoth, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetBoth_object, diags_tmp = types.ObjectValueFrom(ctx, resetBoth_obj.AttributeTypes(), resetBoth_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var blockIp_obj *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject
	if o.BlockIp.IsNull() {
		blockIp_obj = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject)
	} else {
		diags.Append(o.BlockIp.As(ctx, &blockIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	blockIp_object := types.ObjectNull(blockIp_obj.AttributeTypes())
	if obj.BlockIp != nil {
		diags.Append(blockIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BlockIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		blockIp_object, diags_tmp = types.ObjectValueFrom(ctx, blockIp_obj.AttributeTypes(), blockIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Default = default_object
	o.Allow = allow_object
	o.Alert = alert_object
	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	o.TrackBy = trackBy_value
	o.Duration = duration_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionTimeAttribute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	o.Interval = interval_value
	o.Threshold = threshold_value
	o.TrackBy = trackBy_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionExemptIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func VulnerabilitySecurityProfileDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": VulnerabilitySecurityProfileDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"cloud_inline_analysis": dsschema.BoolAttribute{
				Description: "Enable cloud inline analysis",
				Optional:    true,
				Computed:    true,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"disable_override": dsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Optional:    true,
				Computed:    true,
			},

			"inline_exception_edl_url": dsschema.ListAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
			},

			"inline_exception_ip_address": dsschema.ListAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
			},

			"mica_engine_vulnerability_enabled": dsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				Computed:     true,
				NestedObject: VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledSchema(),
			},

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				Computed:     true,
				NestedObject: VulnerabilitySecurityProfileDataSourceRulesSchema(),
			},

			"threat_exception": dsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				Computed:     true,
				NestedObject: VulnerabilitySecurityProfileDataSourceThreatExceptionSchema(),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceModel) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"inline_policy_action": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"threat_name": dsschema.StringAttribute{
				Description: "Threat name",
				Optional:    true,
				Computed:    true,
			},

			"host": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"category": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"packet_capture": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"cve": dsschema.ListAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
			},

			"vendor_id": dsschema.ListAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
			},

			"severity": dsschema.ListAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
			},

			"action": VulnerabilitySecurityProfileDataSourceRulesActionSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,
		Attributes: map[string]dsschema.Attribute{

			"default": VulnerabilitySecurityProfileDataSourceRulesActionDefaultSchema(),

			"allow": VulnerabilitySecurityProfileDataSourceRulesActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileDataSourceRulesActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileDataSourceRulesActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileDataSourceRulesActionResetClientSchema(),

			"reset_server": VulnerabilitySecurityProfileDataSourceRulesActionResetServerSchema(),

			"reset_both": VulnerabilitySecurityProfileDataSourceRulesActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileDataSourceRulesActionBlockIpSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionDefaultSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionAlertSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionDropSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionResetClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionResetServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionResetBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionBlockIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"track_by": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"duration": dsschema.Int64Attribute{
				Description: "Duration for block ip",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"packet_capture": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"action": VulnerabilitySecurityProfileDataSourceThreatExceptionActionSchema(),

			"time_attribute": VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeSchema(),

			"exempt_ip": dsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				Computed:     true,
				NestedObject: VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpSchema(),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,
		Attributes: map[string]dsschema.Attribute{

			"default": VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultSchema(),

			"allow": VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientSchema(),

			"reset_server": VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerSchema(),

			"reset_both": VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"track_by": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"duration": dsschema.Int64Attribute{
				Description: "Duration for block ip",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Computed:    true,
		Attributes: map[string]dsschema.Attribute{

			"interval": dsschema.Int64Attribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},

			"track_by": dsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Required:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceLocationSchema() rsschema.Attribute {
	return VulnerabilitySecurityProfileLocationSchema()
}

// Metadata returns the data source type name.
func (d *VulnerabilitySecurityProfileDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_vulnerability_security_profile"
}

// Schema defines the schema for this data source.
func (d *VulnerabilitySecurityProfileDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = VulnerabilitySecurityProfileDataSourceSchema()
}

// Configure prepares the struct.
func (d *VulnerabilitySecurityProfileDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := vulnerability.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*vulnerability.Entry, vulnerability.Location, *vulnerability.Service](d.client, vulnerability.NewService(d.client), batchSize, specifier, vulnerability.SpecMatches)
}
func (o *VulnerabilitySecurityProfileDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state VulnerabilitySecurityProfileDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location vulnerability.Location

	{
		var terraformLocation VulnerabilitySecurityProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &vulnerability.SharedLocation{}
			var innerLocation VulnerabilitySecurityProfileSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &vulnerability.DeviceGroupLocation{}
			var innerLocation VulnerabilitySecurityProfileDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &VulnerabilitySecurityProfileResource{}
	_ resource.ResourceWithConfigure   = &VulnerabilitySecurityProfileResource{}
	_ resource.ResourceWithImportState = &VulnerabilitySecurityProfileResource{}
)

func NewVulnerabilitySecurityProfileResource() resource.Resource {
	if _, found := resourceFuncMap["panos_vulnerability_security_profile"]; !found {
		resourceFuncMap["panos_vulnerability_security_profile"] = resourceFuncs{
			CreateImportId: VulnerabilitySecurityProfileImportStateCreator,
		}
	}
	return &VulnerabilitySecurityProfileResource{}
}

type VulnerabilitySecurityProfileResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*vulnerability.Entry, vulnerability.Location, *vulnerability.Service]
}

func VulnerabilitySecurityProfileResourceLocationSchema() rsschema.Attribute {
	return VulnerabilitySecurityProfileLocationSchema()
}

type VulnerabilitySecurityProfileResourceModel struct {
	Location                       types.Object `tfsdk:"location"`
	Name                           types.String `tfsdk:"name"`
	CloudInlineAnalysis            types.Bool   `tfsdk:"cloud_inline_analysis"`
	Description                    types.String `tfsdk:"description"`
	DisableOverride                types.String `tfsdk:"disable_override"`
	InlineExceptionEdlUrl          types.List   `tfsdk:"inline_exception_edl_url"`
	InlineExceptionIpAddress       types.List   `tfsdk:"inline_exception_ip_address"`
	MicaEngineVulnerabilityEnabled types.List   `tfsdk:"mica_engine_vulnerability_enabled"`
	Rules                          types.List   `tfsdk:"rules"`
	ThreatException                types.List   `tfsdk:"threat_exception"`
}
type VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject struct {
	Name               types.String `tfsdk:"name"`
	InlinePolicyAction types.String `tfsdk:"inline_policy_action"`
}
type VulnerabilitySecurityProfileResourceRulesObject struct {
	Name          types.String `tfsdk:"name"`
	ThreatName    types.String `tfsdk:"threat_name"`
	Host          types.String `tfsdk:"host"`
	Category      types.String `tfsdk:"category"`
	PacketCapture types.String `tfsdk:"packet_capture"`
	Cve           types.List   `tfsdk:"cve"`
	VendorId      types.List   `tfsdk:"vendor_id"`
	Severity      types.List   `tfsdk:"severity"`
	Action        types.Object `tfsdk:"action"`
}
type VulnerabilitySecurityProfileResourceRulesActionObject struct {
	Default     types.Object `tfsdk:"default"`
	Allow       types.Object `tfsdk:"allow"`
	Alert       types.Object `tfsdk:"alert"`
	Drop        types.Object `tfsdk:"drop"`
	ResetClient types.Object `tfsdk:"reset_client"`
	ResetServer types.Object `tfsdk:"reset_server"`
	ResetBoth   types.Object `tfsdk:"reset_both"`
	BlockIp     types.Object `tfsdk:"block_ip"`
}
type VulnerabilitySecurityProfileResourceRulesActionDefaultObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionAllowObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionAlertObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionDropObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionResetClientObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionResetServerObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionResetBothObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionBlockIpObject struct {
	TrackBy  types.String `tfsdk:"track_by"`
	Duration types.Int64  `tfsdk:"duration"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionObject struct {
	Name          types.String `tfsdk:"name"`
	PacketCapture types.String `tfsdk:"packet_capture"`
	Action        types.Object `tfsdk:"action"`
	TimeAttribute types.Object `tfsdk:"time_attribute"`
	ExemptIp      types.List   `tfsdk:"exempt_ip"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionObject struct {
	Default     types.Object `tfsdk:"default"`
	Allow       types.Object `tfsdk:"allow"`
	Alert       types.Object `tfsdk:"alert"`
	Drop        types.Object `tfsdk:"drop"`
	ResetClient types.Object `tfsdk:"reset_client"`
	ResetServer types.Object `tfsdk:"reset_server"`
	ResetBoth   types.Object `tfsdk:"reset_both"`
	BlockIp     types.Object `tfsdk:"block_ip"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject struct {
	TrackBy  types.String `tfsdk:"track_by"`
	Duration types.Int64  `tfsdk:"duration"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject struct {
	Interval  types.Int64  `tfsdk:"interval"`
	Threshold types.Int64  `tfsdk:"threshold"`
	TrackBy   types.String `tfsdk:"track_by"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject struct {
	Name types.String `tfsdk:"name"`
}

func (o *VulnerabilitySecurityProfileResourceModel) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
	if !o.MicaEngineVulnerabilityEnabled.IsUnknown() && !o.MicaEngineVulnerabilityEnabled.IsNull() {
		var elements []VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject
		diags := o.MicaEngineVulnerabilityEnabled.ElementsAs(ctx, &elements, false)
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			for i, element := range elements {
				element.ValidateConfig(ctx, resp, path.AtName("mica_engine_vulnerability_enabled").AtListIndex(i))
			}
		}
	}
	if !o.Rules.IsUnknown() && !o.Rules.IsNull() {
		var elements []VulnerabilitySecurityProfileResourceRulesObject
		diags := o.Rules.ElementsAs(ctx, &elements, false)
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			for i, element := range elements {
				element.ValidateConfig(ctx, resp, path.AtName("rules").AtListIndex(i))
			}
		}
	}
	if !o.ThreatException.IsUnknown() && !o.ThreatException.IsNull() {
		var elements []VulnerabilitySecurityProfileResourceThreatExceptionObject
		diags := o.ThreatException.ElementsAs(ctx, &elements, false)
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			for i, element := range elements {
				element.ValidateConfig(ctx, resp, path.AtName("threat_exception").AtListIndex(i))
			}
		}
	}
}

func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionObject
		diags := o.Action.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("action"))
		}
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionDefaultObject
		diags := o.Default.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("default"))
		}
	}
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionAllowObject
		diags := o.Allow.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("allow"))
		}
	}
	if !o.Alert.IsUnknown() && !o.Alert.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionAlertObject
		diags := o.Alert.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("alert"))
		}
	}
	if !o.Drop.IsUnknown() && !o.Drop.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionDropObject
		diags := o.Drop.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("drop"))
		}
	}
	if !o.ResetClient.IsUnknown() && !o.ResetClient.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionResetClientObject
		diags := o.ResetClient.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("reset_client"))
		}
	}
	if !o.ResetServer.IsUnknown() && !o.ResetServer.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionResetServerObject
		diags := o.ResetServer.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("reset_server"))
		}
	}
	if !o.ResetBoth.IsUnknown() && !o.ResetBoth.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionResetBothObject
		diags := o.ResetBoth.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("reset_both"))
		}
	}
	if !o.BlockIp.IsUnknown() && !o.BlockIp.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceRulesActionBlockIpObject
		diags := o.BlockIp.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("block_ip"))
		}
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionObject
		diags := o.Action.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("action"))
		}
	}
	if !o.TimeAttribute.IsUnknown() && !o.TimeAttribute.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject
		diags := o.TimeAttribute.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("time_attribute"))
		}
	}
	if !o.ExemptIp.IsUnknown() && !o.ExemptIp.IsNull() {
		var elements []VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject
		diags := o.ExemptIp.ElementsAs(ctx, &elements, false)
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			for i, element := range elements {
				element.ValidateConfig(ctx, resp, path.AtName("exempt_ip").AtListIndex(i))
			}
		}
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject
		diags := o.Default.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("default"))
		}
	}
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject
		diags := o.Allow.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("allow"))
		}
	}
	if !o.Alert.IsUnknown() && !o.Alert.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject
		diags := o.Alert.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("alert"))
		}
	}
	if !o.Drop.IsUnknown() && !o.Drop.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject
		diags := o.Drop.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("drop"))
		}
	}
	if !o.ResetClient.IsUnknown() && !o.ResetClient.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject
		diags := o.ResetClient.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("reset_client"))
		}
	}
	if !o.ResetServer.IsUnknown() && !o.ResetServer.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject
		diags := o.ResetServer.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("reset_server"))
		}
	}
	if !o.ResetBoth.IsUnknown() && !o.ResetBoth.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject
		diags := o.ResetBoth.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("reset_both"))
		}
	}
	if !o.BlockIp.IsUnknown() && !o.BlockIp.IsNull() {
		var nestedObj VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject
		diags := o.BlockIp.As(ctx, &nestedObj, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			resp.Diagnostics.Append(diags...)
		} else {
			nestedObj.ValidateConfig(ctx, resp, path.AtName("block_ip"))
		}
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) ValidateConfig(ctx context.Context, resp *resource.ValidateConfigResponse, path path.Path) {
}

func (o *VulnerabilitySecurityProfileResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {

	var resource VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &resource)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resource.ValidateConfig(ctx, resp, path.Empty())
}

// <ResourceSchema>

func VulnerabilitySecurityProfileResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": VulnerabilitySecurityProfileResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"cloud_inline_analysis": rsschema.BoolAttribute{
				Description: "Enable cloud inline analysis",
				Optional:    true,
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
			},

			"disable_override": rsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Optional:    true,

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"yes",
						"no",
					}...),
				},
			},

			"inline_exception_edl_url": rsschema.ListAttribute{
				Description: "",
				Optional:    true,
				ElementType: types.StringType,
			},

			"inline_exception_ip_address": rsschema.ListAttribute{
				Description: "",
				Optional:    true,
				ElementType: types.StringType,
			},

			"mica_engine_vulnerability_enabled": rsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				NestedObject: VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledSchema(),
			},

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				NestedObject: VulnerabilitySecurityProfileResourceRulesSchema(),
			},

			"threat_exception": rsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				NestedObject: VulnerabilitySecurityProfileResourceThreatExceptionSchema(),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceModel) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"inline_policy_action": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("alert"),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"threat_name": rsschema.StringAttribute{
				Description: "Threat name",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("any"),
			},

			"host": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("any"),
			},

			"category": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("any"),
			},

			"packet_capture": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("disable"),
			},

			"cve": rsschema.ListAttribute{
				Description: "",
				Optional:    true,
				ElementType: types.StringType,
			},

			"vendor_id": rsschema.ListAttribute{
				Description: "",
				Optional:    true,
				ElementType: types.StringType,
			},

			"severity": rsschema.ListAttribute{
				Description: "",
				Optional:    true,
				ElementType: types.StringType,
			},

			"action": VulnerabilitySecurityProfileResourceRulesActionSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Attributes: map[string]rsschema.Attribute{

			"default": VulnerabilitySecurityProfileResourceRulesActionDefaultSchema(),

			"allow": VulnerabilitySecurityProfileResourceRulesActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileResourceRulesActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileResourceRulesActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileResourceRulesActionResetClientSchema(),

			"reset_server": VulnerabilitySecurityProfileResourceRulesActionResetServerSchema(),

			"reset_both": VulnerabilitySecurityProfileResourceRulesActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileResourceRulesActionBlockIpSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionDefaultSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionAlertSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionDropSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionResetClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionResetServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionResetBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionBlockIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"track_by": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
			},

			"duration": rsschema.Int64Attribute{
				Description: "Duration for block ip",
				Optional:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Required:    true,
			},

			"packet_capture": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("disable"),
			},

			"action": VulnerabilitySecurityProfileResourceThreatExceptionActionSchema(),

			"time_attribute": VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeSchema(),

			"exempt_ip": rsschema.ListNestedAttribute{
				Description:  "",
				Optional:     true,
				NestedObject: VulnerabilitySecurityProfileResourceThreatExceptionExemptIpSchema(),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Attributes: map[string]rsschema.Attribute{

			"default": VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultSchema(),

			"allow": VulnerabilitySecurityProfileResourceThreatExceptionActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileResourceThreatExceptionActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileResourceThreatExceptionActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientSchema(),

			"reset_server": VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerSchema(),

			"reset_both": VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionAlertSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionDropSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"track_by": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
			},

			"duration": rsschema.Int64Attribute{
				Description: "Duration for block ip",
				Optional:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Optional:    true,
		Attributes: map[string]rsschema.Attribute{

			"interval": rsschema.Int64Attribute{
				Description: "",
				Optional:    true,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "",
				Optional:    true,
			},

			"track_by": rsschema.StringAttribute{
				Description: "",
				Optional:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionExemptIpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Required:    true,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionExemptIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *VulnerabilitySecurityProfileResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_vulnerability_security_profile"
}

func (o *VulnerabilitySecurityProfileResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = VulnerabilitySecurityProfileResourceSchema()
}

// </ResourceSchema>

func (o *VulnerabilitySecurityProfileResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := vulnerability.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*vulnerability.Entry, vulnerability.Location, *vulnerability.Service](o.client, vulnerability.NewService(o.client), batchSize, specifier, vulnerability.SpecMatches)
}

func (o *VulnerabilitySecurityProfileResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj VulnerabilitySecurityProfileLocation

	var micaEngineVulnerabilityEnabledObj *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject

	var rulesObj *VulnerabilitySecurityProfileResourceRulesObject

	var threatExceptionObj *VulnerabilitySecurityProfileResourceThreatExceptionObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":                  types.StringType,
		"cloud_inline_analysis": types.BoolType,
		"description":           types.StringType,
		"disable_override":      types.StringType,
		"inline_exception_edl_url": types.ListType{
			ElemType: types.StringType,
		},
		"inline_exception_ip_address": types.ListType{
			ElemType: types.StringType,
		},
		"mica_engine_vulnerability_enabled": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: micaEngineVulnerabilityEnabledObj.AttributeTypes(),
			},
		},
		"rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rulesObj.AttributeTypes(),
			},
		},
		"threat_exception": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: threatExceptionObj.AttributeTypes(),
			},
		},
	}
}

func (o VulnerabilitySecurityProfileResourceModel) AncestorName() string {
	return ""
}

func (o VulnerabilitySecurityProfileResourceModel) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                 types.StringType,
		"inline_policy_action": types.StringType,
	}
}

func (o VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) AncestorName() string {
	return "mica-engine-vulnerability-enabled"
}

func (o VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VulnerabilitySecurityProfileResourceRulesObject) AttributeTypes() map[string]attr.Type {

	var actionObj *VulnerabilitySecurityProfileResourceRulesActionObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"threat_name":    types.StringType,
		"host":           types.StringType,
		"category":       types.StringType,
		"packet_capture": types.StringType,
		"cve": types.ListType{
			ElemType: types.StringType,
		},
		"vendor_id": types.ListType{
			ElemType: types.StringType,
		},
		"severity": types.ListType{
			ElemType: types.StringType,
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VulnerabilitySecurityProfileResourceRulesObject) AncestorName() string {
	return "rules"
}

func (o VulnerabilitySecurityProfileResourceRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VulnerabilitySecurityProfileResourceRulesActionObject) AttributeTypes() map[string]attr.Type {

	var defaultObj *VulnerabilitySecurityProfileResourceRulesActionDefaultObject

	var allowObj *VulnerabilitySecurityProfileResourceRulesActionAllowObject

	var alertObj *VulnerabilitySecurityProfileResourceRulesActionAlertObject

	var dropObj *VulnerabilitySecurityProfileResourceRulesActionDropObject

	var resetClientObj *VulnerabilitySecurityProfileResourceRulesActionResetClientObject

	var resetServerObj *VulnerabilitySecurityProfileResourceRulesActionResetServerObject

	var resetBothObj *VulnerabilitySecurityProfileResourceRulesActionResetBothObject

	var blockIpObj *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject
	return map[string]attr.Type{
		"default": types.ObjectType{
			AttrTypes: defaultObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
		"alert": types.ObjectType{
			AttrTypes: alertObj.AttributeTypes(),
		},
		"drop": types.ObjectType{
			AttrTypes: dropObj.AttributeTypes(),
		},
		"reset_client": types.ObjectType{
			AttrTypes: resetClientObj.AttributeTypes(),
		},
		"reset_server": types.ObjectType{
			AttrTypes: resetServerObj.AttributeTypes(),
		},
		"reset_both": types.ObjectType{
			AttrTypes: resetBothObj.AttributeTypes(),
		},
		"block_ip": types.ObjectType{
			AttrTypes: blockIpObj.AttributeTypes(),
		},
	}
}

func (o VulnerabilitySecurityProfileResourceRulesActionObject) AncestorName() string {
	return "action"
}

func (o VulnerabilitySecurityProfileResourceRulesActionObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceRulesActionDefaultObject) AncestorName() string {
	return "default"
}

func (o VulnerabilitySecurityProfileResourceRulesActionDefaultObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceRulesActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VulnerabilitySecurityProfileResourceRulesActionAllowObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceRulesActionAlertObject) AncestorName() string {
	return "alert"
}

func (o VulnerabilitySecurityProfileResourceRulesActionAlertObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceRulesActionDropObject) AncestorName() string {
	return "drop"
}

func (o VulnerabilitySecurityProfileResourceRulesActionDropObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceRulesActionResetClientObject) AncestorName() string {
	return "reset-client"
}

func (o VulnerabilitySecurityProfileResourceRulesActionResetClientObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceRulesActionResetServerObject) AncestorName() string {
	return "reset-server"
}

func (o VulnerabilitySecurityProfileResourceRulesActionResetServerObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceRulesActionResetBothObject) AncestorName() string {
	return "reset-both"
}

func (o VulnerabilitySecurityProfileResourceRulesActionResetBothObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"track_by": types.StringType,
		"duration": types.Int64Type,
	}
}

func (o VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) AncestorName() string {
	return "block-ip"
}

func (o VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) AttributeTypes() map[string]attr.Type {

	var actionObj *VulnerabilitySecurityProfileResourceThreatExceptionActionObject

	var timeAttributeObj *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject

	var exemptIpObj *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"packet_capture": types.StringType,
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"time_attribute": types.ObjectType{
			AttrTypes: timeAttributeObj.AttributeTypes(),
		},
		"exempt_ip": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exemptIpObj.AttributeTypes(),
			},
		},
	}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionObject) AncestorName() string {
	return "threat-exception"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) AttributeTypes() map[string]attr.Type {

	var defaultObj *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject

	var allowObj *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject

	var alertObj *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject

	var dropObj *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject

	var resetClientObj *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject

	var resetServerObj *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject

	var resetBothObj *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject

	var blockIpObj *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject
	return map[string]attr.Type{
		"default": types.ObjectType{
			AttrTypes: defaultObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
		"alert": types.ObjectType{
			AttrTypes: alertObj.AttributeTypes(),
		},
		"drop": types.ObjectType{
			AttrTypes: dropObj.AttributeTypes(),
		},
		"reset_client": types.ObjectType{
			AttrTypes: resetClientObj.AttributeTypes(),
		},
		"reset_server": types.ObjectType{
			AttrTypes: resetServerObj.AttributeTypes(),
		},
		"reset_both": types.ObjectType{
			AttrTypes: resetBothObj.AttributeTypes(),
		},
		"block_ip": types.ObjectType{
			AttrTypes: blockIpObj.AttributeTypes(),
		},
	}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionObject) AncestorName() string {
	return "action"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) AncestorName() string {
	return "default"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) AncestorName() string {
	return "alert"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) AncestorName() string {
	return "drop"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) AncestorName() string {
	return "reset-client"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) AncestorName() string {
	return "reset-server"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) AncestorName() string {
	return "reset-both"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"track_by": types.StringType,
		"duration": types.Int64Type,
	}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) AncestorName() string {
	return "block-ip"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval":  types.Int64Type,
		"threshold": types.Int64Type,
		"track_by":  types.StringType,
	}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) AncestorName() string {
	return "time-attribute"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) EntryName() *string {
	return nil
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) AncestorName() string {
	return "exempt-ip"
}

func (o VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}

func (o *VulnerabilitySecurityProfileResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	cloudInlineAnalysis_value := o.CloudInlineAnalysis.ValueBoolPointer()
	description_value := o.Description.ValueStringPointer()
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	var inlineExceptionEdlUrl_pango_entries []string
	if !o.InlineExceptionEdlUrl.IsUnknown() && !o.InlineExceptionEdlUrl.IsNull() {
		object_entries := make([]types.String, 0, len(o.InlineExceptionEdlUrl.Elements()))
		diags.Append(o.InlineExceptionEdlUrl.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			inlineExceptionEdlUrl_pango_entries = append(inlineExceptionEdlUrl_pango_entries, elt.ValueString())
		}
	}
	var inlineExceptionIpAddress_pango_entries []string
	if !o.InlineExceptionIpAddress.IsUnknown() && !o.InlineExceptionIpAddress.IsNull() {
		object_entries := make([]types.String, 0, len(o.InlineExceptionIpAddress.Elements()))
		diags.Append(o.InlineExceptionIpAddress.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			inlineExceptionIpAddress_pango_entries = append(inlineExceptionIpAddress_pango_entries, elt.ValueString())
		}
	}
	var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject
	var micaEngineVulnerabilityEnabled_pango_entries []vulnerability.MicaEngineVulnerabilityEnabled
	{
		d := o.MicaEngineVulnerabilityEnabled.ElementsAs(ctx, &micaEngineVulnerabilityEnabled_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range micaEngineVulnerabilityEnabled_tf_entries {
			var entry *vulnerability.MicaEngineVulnerabilityEnabled
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			micaEngineVulnerabilityEnabled_pango_entries = append(micaEngineVulnerabilityEnabled_pango_entries, *entry)
		}
	}
	var rules_tf_entries []VulnerabilitySecurityProfileResourceRulesObject
	var rules_pango_entries []vulnerability.Rules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *vulnerability.Rules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}
	var threatException_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionObject
	var threatException_pango_entries []vulnerability.ThreatException
	{
		d := o.ThreatException.ElementsAs(ctx, &threatException_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range threatException_tf_entries {
			var entry *vulnerability.ThreatException
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			threatException_pango_entries = append(threatException_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).CloudInlineAnalysis = cloudInlineAnalysis_value
	(*obj).Description = description_value
	(*obj).DisableOverride = disableOverride_value
	(*obj).InlineExceptionEdlUrl = inlineExceptionEdlUrl_pango_entries
	(*obj).InlineExceptionIpAddress = inlineExceptionIpAddress_pango_entries
	(*obj).MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_pango_entries
	(*obj).Rules = rules_pango_entries
	(*obj).ThreatException = threatException_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.MicaEngineVulnerabilityEnabled, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	inlinePolicyAction_value := o.InlinePolicyAction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.MicaEngineVulnerabilityEnabled)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).InlinePolicyAction = inlinePolicyAction_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.Rules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threatName_value := o.ThreatName.ValueStringPointer()
	host_value := o.Host.ValueStringPointer()
	category_value := o.Category.ValueStringPointer()
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	var cve_pango_entries []string
	if !o.Cve.IsUnknown() && !o.Cve.IsNull() {
		object_entries := make([]types.String, 0, len(o.Cve.Elements()))
		diags.Append(o.Cve.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			cve_pango_entries = append(cve_pango_entries, elt.ValueString())
		}
	}
	var vendorId_pango_entries []string
	if !o.VendorId.IsUnknown() && !o.VendorId.IsNull() {
		object_entries := make([]types.String, 0, len(o.VendorId.Elements()))
		diags.Append(o.VendorId.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			vendorId_pango_entries = append(vendorId_pango_entries, elt.ValueString())
		}
	}
	var severity_pango_entries []string
	if !o.Severity.IsUnknown() && !o.Severity.IsNull() {
		object_entries := make([]types.String, 0, len(o.Severity.Elements()))
		diags.Append(o.Severity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			severity_pango_entries = append(severity_pango_entries, elt.ValueString())
		}
	}
	var action_entry *vulnerability.RulesAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.RulesAction)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.Rules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ThreatName = threatName_value
	(*obj).Host = host_value
	(*obj).Category = category_value
	(*obj).PacketCapture = packetCapture_value
	(*obj).Cve = cve_pango_entries
	(*obj).VendorId = vendorId_pango_entries
	(*obj).Severity = severity_pango_entries
	(*obj).Action = action_entry

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_entry *vulnerability.RulesActionDefault
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.RulesActionDefault)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionDefaultObject
		diags.Append(o.Default.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &default_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *vulnerability.RulesActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.RulesActionAllow)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.RulesActionAlert
	if !o.Alert.IsUnknown() && !o.Alert.IsNull() {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.RulesActionAlert)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionAlertObject
		diags.Append(o.Alert.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &alert_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_entry *vulnerability.RulesActionDrop
	if !o.Drop.IsUnknown() && !o.Drop.IsNull() {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.RulesActionDrop)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionDropObject
		diags.Append(o.Drop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &drop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_entry *vulnerability.RulesActionResetClient
	if !o.ResetClient.IsUnknown() && !o.ResetClient.IsNull() {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.RulesActionResetClient)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionResetClientObject
		diags.Append(o.ResetClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.RulesActionResetServer
	if !o.ResetServer.IsUnknown() && !o.ResetServer.IsNull() {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.RulesActionResetServer)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionResetServerObject
		diags.Append(o.ResetServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.RulesActionResetBoth
	if !o.ResetBoth.IsUnknown() && !o.ResetBoth.IsNull() {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.RulesActionResetBoth)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionResetBothObject
		diags.Append(o.ResetBoth.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetBoth_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.RulesActionBlockIp
	if !o.BlockIp.IsUnknown() && !o.BlockIp.IsNull() {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.RulesActionBlockIp)
		}
		var object *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject
		diags.Append(o.BlockIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &blockIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.RulesAction)
	}
	(*obj).Default = default_entry
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry
	(*obj).Drop = drop_entry
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDrop)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.RulesActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatException, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	var action_entry *vulnerability.ThreatExceptionAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.ThreatExceptionAction)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var timeAttribute_entry *vulnerability.ThreatExceptionTimeAttribute
	if !o.TimeAttribute.IsUnknown() && !o.TimeAttribute.IsNull() {
		if *obj != nil && (*obj).TimeAttribute != nil {
			timeAttribute_entry = (*obj).TimeAttribute
		} else {
			timeAttribute_entry = new(vulnerability.ThreatExceptionTimeAttribute)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject
		diags.Append(o.TimeAttribute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timeAttribute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var exemptIp_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject
	var exemptIp_pango_entries []vulnerability.ThreatExceptionExemptIp
	{
		d := o.ExemptIp.ElementsAs(ctx, &exemptIp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exemptIp_tf_entries {
			var entry *vulnerability.ThreatExceptionExemptIp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exemptIp_pango_entries = append(exemptIp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatException)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).PacketCapture = packetCapture_value
	(*obj).Action = action_entry
	(*obj).TimeAttribute = timeAttribute_entry
	(*obj).ExemptIp = exemptIp_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_entry *vulnerability.ThreatExceptionActionDefault
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.ThreatExceptionActionDefault)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject
		diags.Append(o.Default.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &default_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *vulnerability.ThreatExceptionActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.ThreatExceptionActionAllow)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.ThreatExceptionActionAlert
	if !o.Alert.IsUnknown() && !o.Alert.IsNull() {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.ThreatExceptionActionAlert)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject
		diags.Append(o.Alert.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &alert_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_entry *vulnerability.ThreatExceptionActionDrop
	if !o.Drop.IsUnknown() && !o.Drop.IsNull() {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.ThreatExceptionActionDrop)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject
		diags.Append(o.Drop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &drop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_entry *vulnerability.ThreatExceptionActionResetClient
	if !o.ResetClient.IsUnknown() && !o.ResetClient.IsNull() {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.ThreatExceptionActionResetClient)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject
		diags.Append(o.ResetClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.ThreatExceptionActionResetServer
	if !o.ResetServer.IsUnknown() && !o.ResetServer.IsNull() {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.ThreatExceptionActionResetServer)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject
		diags.Append(o.ResetServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.ThreatExceptionActionResetBoth
	if !o.ResetBoth.IsUnknown() && !o.ResetBoth.IsNull() {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.ThreatExceptionActionResetBoth)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject
		diags.Append(o.ResetBoth.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &resetBoth_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.ThreatExceptionActionBlockIp
	if !o.BlockIp.IsUnknown() && !o.BlockIp.IsNull() {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.ThreatExceptionActionBlockIp)
		}
		var object *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject
		diags.Append(o.BlockIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &blockIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionAction)
	}
	(*obj).Default = default_entry
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry
	(*obj).Drop = drop_entry
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDrop)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionTimeAttribute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	trackBy_value := o.TrackBy.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionTimeAttribute)
	}
	(*obj).Interval = interval_value
	(*obj).Threshold = threshold_value
	(*obj).TrackBy = trackBy_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **vulnerability.ThreatExceptionExemptIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionExemptIp)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}

func (o *VulnerabilitySecurityProfileResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var inlineExceptionEdlUrl_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.InlineExceptionEdlUrl.IsNull() || len(obj.InlineExceptionEdlUrl) > 0 {
			entries = obj.InlineExceptionEdlUrl
		}

		inlineExceptionEdlUrl_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var inlineExceptionIpAddress_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.InlineExceptionIpAddress.IsNull() || len(obj.InlineExceptionIpAddress) > 0 {
			entries = obj.InlineExceptionIpAddress
		}

		inlineExceptionIpAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var micaEngineVulnerabilityEnabled_list types.List
	{
		var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject
		if !o.MicaEngineVulnerabilityEnabled.IsNull() {
			diags.Append(o.MicaEngineVulnerabilityEnabled.ElementsAs(ctx, &micaEngineVulnerabilityEnabled_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.MicaEngineVulnerabilityEnabled {
			entry := VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(micaEngineVulnerabilityEnabled_tf_entries) {
				entry = micaEngineVulnerabilityEnabled_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(micaEngineVulnerabilityEnabled_tf_entries) {
				micaEngineVulnerabilityEnabled_tf_entries[idx] = entry
			} else {
				micaEngineVulnerabilityEnabled_tf_entries = append(micaEngineVulnerabilityEnabled_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("mica_engine_vulnerability_enabled")
		micaEngineVulnerabilityEnabled_list, list_diags = types.ListValueFrom(ctx, schemaType, micaEngineVulnerabilityEnabled_tf_entries)
		diags.Append(list_diags...)
	}
	var rules_list types.List
	{
		var rules_tf_entries []VulnerabilitySecurityProfileResourceRulesObject
		if !o.Rules.IsNull() {
			diags.Append(o.Rules.ElementsAs(ctx, &rules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Rules {
			entry := VulnerabilitySecurityProfileResourceRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rules_tf_entries) {
				entry = rules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rules_tf_entries) {
				rules_tf_entries[idx] = entry
			} else {
				rules_tf_entries = append(rules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}
	var threatException_list types.List
	{
		var threatException_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionObject
		if !o.ThreatException.IsNull() {
			diags.Append(o.ThreatException.ElementsAs(ctx, &threatException_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ThreatException {
			entry := VulnerabilitySecurityProfileResourceThreatExceptionObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(threatException_tf_entries) {
				entry = threatException_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(threatException_tf_entries) {
				threatException_tf_entries[idx] = entry
			} else {
				threatException_tf_entries = append(threatException_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("threat_exception")
		threatException_list, list_diags = types.ListValueFrom(ctx, schemaType, threatException_tf_entries)
		diags.Append(list_diags...)
	}

	var cloudInlineAnalysis_value types.Bool
	if obj.CloudInlineAnalysis != nil {
		cloudInlineAnalysis_value = types.BoolValue(*obj.CloudInlineAnalysis)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	o.Name = types.StringValue(obj.Name)
	o.CloudInlineAnalysis = cloudInlineAnalysis_value
	o.Description = description_value
	o.DisableOverride = disableOverride_value
	o.InlineExceptionEdlUrl = inlineExceptionEdlUrl_list
	o.InlineExceptionIpAddress = inlineExceptionIpAddress_list
	o.MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_list
	o.Rules = rules_list
	o.ThreatException = threatException_list

	return diags
}

func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.MicaEngineVulnerabilityEnabled, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var inlinePolicyAction_value types.String
	if obj.InlinePolicyAction != nil {
		inlinePolicyAction_value = types.StringValue(*obj.InlinePolicyAction)
	}
	o.Name = types.StringValue(obj.Name)
	o.InlinePolicyAction = inlinePolicyAction_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.Rules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var cve_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Cve.IsNull() || len(obj.Cve) > 0 {
			entries = obj.Cve
		}

		cve_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var vendorId_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.VendorId.IsNull() || len(obj.VendorId) > 0 {
			entries = obj.VendorId
		}

		vendorId_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var severity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Severity.IsNull() || len(obj.Severity) > 0 {
			entries = obj.Severity
		}

		severity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VulnerabilitySecurityProfileResourceRulesActionObject
	if o.Action.IsNull() {
		action_obj = new(VulnerabilitySecurityProfileResourceRulesActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var threatName_value types.String
	if obj.ThreatName != nil {
		threatName_value = types.StringValue(*obj.ThreatName)
	}
	var host_value types.String
	if obj.Host != nil {
		host_value = types.StringValue(*obj.Host)
	}
	var category_value types.String
	if obj.Category != nil {
		category_value = types.StringValue(*obj.Category)
	}
	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	o.Name = types.StringValue(obj.Name)
	o.ThreatName = threatName_value
	o.Host = host_value
	o.Category = category_value
	o.PacketCapture = packetCapture_value
	o.Cve = cve_list
	o.VendorId = vendorId_list
	o.Severity = severity_list
	o.Action = action_object

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var default_obj *VulnerabilitySecurityProfileResourceRulesActionDefaultObject
	if o.Default.IsNull() {
		default_obj = new(VulnerabilitySecurityProfileResourceRulesActionDefaultObject)
	} else {
		diags.Append(o.Default.As(ctx, &default_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	default_object := types.ObjectNull(default_obj.AttributeTypes())
	if obj.Default != nil {
		diags.Append(default_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Default, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		default_object, diags_tmp = types.ObjectValueFrom(ctx, default_obj.AttributeTypes(), default_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VulnerabilitySecurityProfileResourceRulesActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VulnerabilitySecurityProfileResourceRulesActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var alert_obj *VulnerabilitySecurityProfileResourceRulesActionAlertObject
	if o.Alert.IsNull() {
		alert_obj = new(VulnerabilitySecurityProfileResourceRulesActionAlertObject)
	} else {
		diags.Append(o.Alert.As(ctx, &alert_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	alert_object := types.ObjectNull(alert_obj.AttributeTypes())
	if obj.Alert != nil {
		diags.Append(alert_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Alert, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		alert_object, diags_tmp = types.ObjectValueFrom(ctx, alert_obj.AttributeTypes(), alert_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var drop_obj *VulnerabilitySecurityProfileResourceRulesActionDropObject
	if o.Drop.IsNull() {
		drop_obj = new(VulnerabilitySecurityProfileResourceRulesActionDropObject)
	} else {
		diags.Append(o.Drop.As(ctx, &drop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	drop_object := types.ObjectNull(drop_obj.AttributeTypes())
	if obj.Drop != nil {
		diags.Append(drop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Drop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		drop_object, diags_tmp = types.ObjectValueFrom(ctx, drop_obj.AttributeTypes(), drop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetClient_obj *VulnerabilitySecurityProfileResourceRulesActionResetClientObject
	if o.ResetClient.IsNull() {
		resetClient_obj = new(VulnerabilitySecurityProfileResourceRulesActionResetClientObject)
	} else {
		diags.Append(o.ResetClient.As(ctx, &resetClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetClient_object := types.ObjectNull(resetClient_obj.AttributeTypes())
	if obj.ResetClient != nil {
		diags.Append(resetClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetClient_object, diags_tmp = types.ObjectValueFrom(ctx, resetClient_obj.AttributeTypes(), resetClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetServer_obj *VulnerabilitySecurityProfileResourceRulesActionResetServerObject
	if o.ResetServer.IsNull() {
		resetServer_obj = new(VulnerabilitySecurityProfileResourceRulesActionResetServerObject)
	} else {
		diags.Append(o.ResetServer.As(ctx, &resetServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetServer_object := types.ObjectNull(resetServer_obj.AttributeTypes())
	if obj.ResetServer != nil {
		diags.Append(resetServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetServer_object, diags_tmp = types.ObjectValueFrom(ctx, resetServer_obj.AttributeTypes(), resetServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetBoth_obj *VulnerabilitySecurityProfileResourceRulesActionResetBothObject
	if o.ResetBoth.IsNull() {
		resetBoth_obj = new(VulnerabilitySecurityProfileResourceRulesActionResetBothObject)
	} else {
		diags.Append(o.ResetBoth.As(ctx, &resetBoth_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetBoth_object := types.ObjectNull(resetBoth_obj.AttributeTypes())
	if obj.ResetBoth != nil {
		diags.Append(resetBoth_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetBoth, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetBoth_object, diags_tmp = types.ObjectValueFrom(ctx, resetBoth_obj.AttributeTypes(), resetBoth_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var blockIp_obj *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject
	if o.BlockIp.IsNull() {
		blockIp_obj = new(VulnerabilitySecurityProfileResourceRulesActionBlockIpObject)
	} else {
		diags.Append(o.BlockIp.As(ctx, &blockIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	blockIp_object := types.ObjectNull(blockIp_obj.AttributeTypes())
	if obj.BlockIp != nil {
		diags.Append(blockIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BlockIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		blockIp_object, diags_tmp = types.ObjectValueFrom(ctx, blockIp_obj.AttributeTypes(), blockIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Default = default_object
	o.Allow = allow_object
	o.Alert = alert_object
	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.RulesActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	o.TrackBy = trackBy_value
	o.Duration = duration_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatException, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var exemptIp_list types.List
	{
		var exemptIp_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject
		if !o.ExemptIp.IsNull() {
			diags.Append(o.ExemptIp.ElementsAs(ctx, &exemptIp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExemptIp {
			entry := VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exemptIp_tf_entries) {
				entry = exemptIp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exemptIp_tf_entries) {
				exemptIp_tf_entries[idx] = entry
			} else {
				exemptIp_tf_entries = append(exemptIp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("exempt_ip")
		exemptIp_list, list_diags = types.ListValueFrom(ctx, schemaType, exemptIp_tf_entries)
		diags.Append(list_diags...)
	}

	var action_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionObject
	if o.Action.IsNull() {
		action_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timeAttribute_obj *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject
	if o.TimeAttribute.IsNull() {
		timeAttribute_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject)
	} else {
		diags.Append(o.TimeAttribute.As(ctx, &timeAttribute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timeAttribute_object := types.ObjectNull(timeAttribute_obj.AttributeTypes())
	if obj.TimeAttribute != nil {
		diags.Append(timeAttribute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.TimeAttribute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timeAttribute_object, diags_tmp = types.ObjectValueFrom(ctx, timeAttribute_obj.AttributeTypes(), timeAttribute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	o.Name = types.StringValue(obj.Name)
	o.PacketCapture = packetCapture_value
	o.Action = action_object
	o.TimeAttribute = timeAttribute_object
	o.ExemptIp = exemptIp_list

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var default_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject
	if o.Default.IsNull() {
		default_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject)
	} else {
		diags.Append(o.Default.As(ctx, &default_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	default_object := types.ObjectNull(default_obj.AttributeTypes())
	if obj.Default != nil {
		diags.Append(default_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Default, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		default_object, diags_tmp = types.ObjectValueFrom(ctx, default_obj.AttributeTypes(), default_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var alert_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject
	if o.Alert.IsNull() {
		alert_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject)
	} else {
		diags.Append(o.Alert.As(ctx, &alert_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	alert_object := types.ObjectNull(alert_obj.AttributeTypes())
	if obj.Alert != nil {
		diags.Append(alert_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Alert, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		alert_object, diags_tmp = types.ObjectValueFrom(ctx, alert_obj.AttributeTypes(), alert_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var drop_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject
	if o.Drop.IsNull() {
		drop_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject)
	} else {
		diags.Append(o.Drop.As(ctx, &drop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	drop_object := types.ObjectNull(drop_obj.AttributeTypes())
	if obj.Drop != nil {
		diags.Append(drop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Drop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		drop_object, diags_tmp = types.ObjectValueFrom(ctx, drop_obj.AttributeTypes(), drop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetClient_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject
	if o.ResetClient.IsNull() {
		resetClient_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject)
	} else {
		diags.Append(o.ResetClient.As(ctx, &resetClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetClient_object := types.ObjectNull(resetClient_obj.AttributeTypes())
	if obj.ResetClient != nil {
		diags.Append(resetClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetClient_object, diags_tmp = types.ObjectValueFrom(ctx, resetClient_obj.AttributeTypes(), resetClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetServer_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject
	if o.ResetServer.IsNull() {
		resetServer_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject)
	} else {
		diags.Append(o.ResetServer.As(ctx, &resetServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetServer_object := types.ObjectNull(resetServer_obj.AttributeTypes())
	if obj.ResetServer != nil {
		diags.Append(resetServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetServer_object, diags_tmp = types.ObjectValueFrom(ctx, resetServer_obj.AttributeTypes(), resetServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var resetBoth_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject
	if o.ResetBoth.IsNull() {
		resetBoth_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject)
	} else {
		diags.Append(o.ResetBoth.As(ctx, &resetBoth_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	resetBoth_object := types.ObjectNull(resetBoth_obj.AttributeTypes())
	if obj.ResetBoth != nil {
		diags.Append(resetBoth_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ResetBoth, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		resetBoth_object, diags_tmp = types.ObjectValueFrom(ctx, resetBoth_obj.AttributeTypes(), resetBoth_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var blockIp_obj *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject
	if o.BlockIp.IsNull() {
		blockIp_obj = new(VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject)
	} else {
		diags.Append(o.BlockIp.As(ctx, &blockIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	blockIp_object := types.ObjectNull(blockIp_obj.AttributeTypes())
	if obj.BlockIp != nil {
		diags.Append(blockIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BlockIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		blockIp_object, diags_tmp = types.ObjectValueFrom(ctx, blockIp_obj.AttributeTypes(), blockIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Default = default_object
	o.Allow = allow_object
	o.Alert = alert_object
	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionAlert, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionDrop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionResetClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionResetServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionResetBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionActionBlockIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	o.TrackBy = trackBy_value
	o.Duration = duration_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionTimeAttribute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	o.Interval = interval_value
	o.Threshold = threshold_value
	o.TrackBy = trackBy_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *vulnerability.ThreatExceptionExemptIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VulnerabilitySecurityProfileResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *VulnerabilitySecurityProfileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location vulnerability.Location

	{
		var terraformLocation VulnerabilitySecurityProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &vulnerability.SharedLocation{}
			var innerLocation VulnerabilitySecurityProfileSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &vulnerability.DeviceGroupLocation{}
			var innerLocation VulnerabilitySecurityProfileDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *vulnerability.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *VulnerabilitySecurityProfileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location vulnerability.Location

	{
		var terraformLocation VulnerabilitySecurityProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &vulnerability.SharedLocation{}
			var innerLocation VulnerabilitySecurityProfileSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &vulnerability.DeviceGroupLocation{}
			var innerLocation VulnerabilitySecurityProfileDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *VulnerabilitySecurityProfileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location vulnerability.Location

	{
		var terraformLocation VulnerabilitySecurityProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &vulnerability.SharedLocation{}
			var innerLocation VulnerabilitySecurityProfileSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &vulnerability.DeviceGroupLocation{}
			var innerLocation VulnerabilitySecurityProfileDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var obj *vulnerability.Entry
	if state.Name.ValueString() != plan.Name.ValueString() {
		obj, err = o.manager.Read(ctx, location, components, state.Name.ValueString())
	} else {
		obj, err = o.manager.Read(ctx, location, components, plan.Name.ValueString())
	}
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	// If name differs between plan and state, we need to set old name for the object
	// before calling SDK Update() function to properly handle rename + edit cycle.
	var newName string
	if state.Name.ValueString() != plan.Name.ValueString() {
		newName = plan.Name.ValueString()
		obj.Name = state.Name.ValueString()
	}

	updated, err := o.manager.Update(ctx, location, components, obj, newName)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *VulnerabilitySecurityProfileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location vulnerability.Location

	{
		var terraformLocation VulnerabilitySecurityProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &vulnerability.SharedLocation{}
			var innerLocation VulnerabilitySecurityProfileSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &vulnerability.DeviceGroupLocation{}
			var innerLocation VulnerabilitySecurityProfileDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type VulnerabilitySecurityProfileImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o VulnerabilitySecurityProfileImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location interface{} `json:"location"`
		Name     *string     `json:"name"`
	}
	var location_object interface{}
	{
		var err error
		location_object, err = TypesObjectToMap(o.Location, VulnerabilitySecurityProfileLocationSchema())
		if err != nil {
			return nil, fmt.Errorf("failed to marshal location into JSON document: %w", err)
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VulnerabilitySecurityProfileImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location interface{} `json:"location"`
		Name     *string     `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		location_map, ok := shadow.Location.(map[string]interface{})
		if !ok {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location: expected map[string]interface{}", nil)
		}
		var err error
		location_object, err = MapToTypesObject(location_map, VulnerabilitySecurityProfileLocationSchema())
		if err != nil {
			return fmt.Errorf("failed to unmarshal location from JSON: %w", err)
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func VulnerabilitySecurityProfileImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := VulnerabilitySecurityProfileImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *VulnerabilitySecurityProfileResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj VulnerabilitySecurityProfileImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type VulnerabilitySecurityProfileSharedLocation struct {
}
type VulnerabilitySecurityProfileDeviceGroupLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
}
type VulnerabilitySecurityProfileLocation struct {
	Shared      types.Object `tfsdk:"shared"`
	DeviceGroup types.Object `tfsdk:"device_group"`
}

func VulnerabilitySecurityProfileLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.SingleNestedAttribute{
				Description: "Panorama shared object",
				Optional:    true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("shared"),
						path.MatchRelative().AtParent().AtName("device_group"),
					}...),
				},
			},
			"device_group": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Device Group",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Panorama device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Device Group name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o VulnerabilitySecurityProfileSharedLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
	}

	obj := shadow{}

	return json.Marshal(obj)
}

func (o *VulnerabilitySecurityProfileSharedLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}

	return nil
}
func (o VulnerabilitySecurityProfileDeviceGroupLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VulnerabilitySecurityProfileDeviceGroupLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o VulnerabilitySecurityProfileLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Shared      *VulnerabilitySecurityProfileSharedLocation      `json:"shared,omitempty"`
		DeviceGroup *VulnerabilitySecurityProfileDeviceGroupLocation `json:"device_group,omitempty"`
	}
	var shared_object *VulnerabilitySecurityProfileSharedLocation
	{
		diags := o.Shared.As(context.TODO(), &shared_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal shared into JSON document", diags.Errors())
		}
	}
	var deviceGroup_object *VulnerabilitySecurityProfileDeviceGroupLocation
	{
		diags := o.DeviceGroup.As(context.TODO(), &deviceGroup_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal device_group into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Shared:      shared_object,
		DeviceGroup: deviceGroup_object,
	}

	return json.Marshal(obj)
}

func (o *VulnerabilitySecurityProfileLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared      *VulnerabilitySecurityProfileSharedLocation      `json:"shared,omitempty"`
		DeviceGroup *VulnerabilitySecurityProfileDeviceGroupLocation `json:"device_group,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var shared_object types.Object
	{
		var diags_tmp diag.Diagnostics
		shared_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Shared.AttributeTypes(), shadow.Shared)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into shared", diags_tmp.Errors())
		}
	}
	var deviceGroup_object types.Object
	{
		var diags_tmp diag.Diagnostics
		deviceGroup_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.DeviceGroup.AttributeTypes(), shadow.DeviceGroup)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into device_group", diags_tmp.Errors())
		}
	}
	o.Shared = shared_object
	o.DeviceGroup = deviceGroup_object

	return nil
}

func (o *VulnerabilitySecurityProfileSharedLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}
func (o *VulnerabilitySecurityProfileDeviceGroupLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
	}
}
func (o *VulnerabilitySecurityProfileLocation) AttributeTypes() map[string]attr.Type {
	var sharedObj VulnerabilitySecurityProfileSharedLocation
	var deviceGroupObj VulnerabilitySecurityProfileDeviceGroupLocation
	return map[string]attr.Type{
		"shared": types.ObjectType{
			AttrTypes: sharedObj.AttributeTypes(),
		},
		"device_group": types.ObjectType{
			AttrTypes: deviceGroupObj.AttributeTypes(),
		},
	}
}
