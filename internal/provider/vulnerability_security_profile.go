package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/objects/profiles/vulnerability"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &VulnerabilitySecurityProfileDataSource{}
	_ datasource.DataSourceWithConfigure = &VulnerabilitySecurityProfileDataSource{}
)

func NewVulnerabilitySecurityProfileDataSource() datasource.DataSource {
	return &VulnerabilitySecurityProfileDataSource{}
}

type VulnerabilitySecurityProfileDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*vulnerability.Entry, vulnerability.Location, *vulnerability.Service]
}

type VulnerabilitySecurityProfileDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type VulnerabilitySecurityProfileDataSourceModel struct {
	Location                       VulnerabilitySecurityProfileLocation `tfsdk:"location"`
	Name                           types.String                         `tfsdk:"name"`
	InlineExceptionIpAddress       types.List                           `tfsdk:"inline_exception_ip_address"`
	MicaEngineVulnerabilityEnabled types.List                           `tfsdk:"mica_engine_vulnerability_enabled"`
	Description                    types.String                         `tfsdk:"description"`
	DisableOverride                types.String                         `tfsdk:"disable_override"`
	Rules                          types.List                           `tfsdk:"rules"`
	ThreatException                types.List                           `tfsdk:"threat_exception"`
	CloudInlineAnalysis            types.Bool                           `tfsdk:"cloud_inline_analysis"`
	InlineExceptionEdlUrl          types.List                           `tfsdk:"inline_exception_edl_url"`
}
type VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject struct {
	Name               types.String `tfsdk:"name"`
	InlinePolicyAction types.String `tfsdk:"inline_policy_action"`
}
type VulnerabilitySecurityProfileDataSourceRulesObject struct {
	Name          types.String                                             `tfsdk:"name"`
	Action        *VulnerabilitySecurityProfileDataSourceRulesActionObject `tfsdk:"action"`
	ThreatName    types.String                                             `tfsdk:"threat_name"`
	Host          types.String                                             `tfsdk:"host"`
	Category      types.String                                             `tfsdk:"category"`
	PacketCapture types.String                                             `tfsdk:"packet_capture"`
	Cve           types.List                                               `tfsdk:"cve"`
	VendorId      types.List                                               `tfsdk:"vendor_id"`
	Severity      types.List                                               `tfsdk:"severity"`
}
type VulnerabilitySecurityProfileDataSourceRulesActionObject struct {
	ResetClient *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject `tfsdk:"reset_client"`
	ResetServer *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject `tfsdk:"reset_server"`
	ResetBoth   *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject   `tfsdk:"reset_both"`
	BlockIp     *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject     `tfsdk:"block_ip"`
	Default     *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject     `tfsdk:"default"`
	Allow       *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject       `tfsdk:"allow"`
	Alert       *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject       `tfsdk:"alert"`
	Drop        *VulnerabilitySecurityProfileDataSourceRulesActionDropObject        `tfsdk:"drop"`
}
type VulnerabilitySecurityProfileDataSourceRulesActionAllowObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionAlertObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionDropObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject struct {
}
type VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject struct {
	TrackBy  types.String `tfsdk:"track_by"`
	Duration types.Int64  `tfsdk:"duration"`
}
type VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionObject struct {
	Name          types.String                                                              `tfsdk:"name"`
	ExemptIp      types.List                                                                `tfsdk:"exempt_ip"`
	PacketCapture types.String                                                              `tfsdk:"packet_capture"`
	Action        *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject        `tfsdk:"action"`
	TimeAttribute *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject `tfsdk:"time_attribute"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject struct {
	ResetBoth   *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject   `tfsdk:"reset_both"`
	BlockIp     *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject     `tfsdk:"block_ip"`
	Default     *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject     `tfsdk:"default"`
	Allow       *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject       `tfsdk:"allow"`
	Alert       *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject       `tfsdk:"alert"`
	Drop        *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject        `tfsdk:"drop"`
	ResetClient *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject `tfsdk:"reset_client"`
	ResetServer *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject `tfsdk:"reset_server"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject struct {
	Duration types.Int64  `tfsdk:"duration"`
	TrackBy  types.String `tfsdk:"track_by"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject struct {
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject struct {
	Interval  types.Int64  `tfsdk:"interval"`
	Threshold types.Int64  `tfsdk:"threshold"`
	TrackBy   types.String `tfsdk:"track_by"`
}
type VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject struct {
	Name types.String `tfsdk:"name"`
}

func (o *VulnerabilitySecurityProfileDataSourceModel) CopyToPango(ctx context.Context, obj **vulnerability.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	cloudInlineAnalysis_value := o.CloudInlineAnalysis.ValueBoolPointer()
	inlineExceptionEdlUrl_pango_entries := make([]string, 0)
	diags.Append(o.InlineExceptionEdlUrl.ElementsAs(ctx, &inlineExceptionEdlUrl_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	inlineExceptionIpAddress_pango_entries := make([]string, 0)
	diags.Append(o.InlineExceptionIpAddress.ElementsAs(ctx, &inlineExceptionIpAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject
	var micaEngineVulnerabilityEnabled_pango_entries []vulnerability.MicaEngineVulnerabilityEnabled
	{
		d := o.MicaEngineVulnerabilityEnabled.ElementsAs(ctx, &micaEngineVulnerabilityEnabled_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range micaEngineVulnerabilityEnabled_tf_entries {
			var entry *vulnerability.MicaEngineVulnerabilityEnabled
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			micaEngineVulnerabilityEnabled_pango_entries = append(micaEngineVulnerabilityEnabled_pango_entries, *entry)
		}
	}
	description_value := o.Description.ValueStringPointer()
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	var rules_tf_entries []VulnerabilitySecurityProfileDataSourceRulesObject
	var rules_pango_entries []vulnerability.Rules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *vulnerability.Rules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}
	var threatException_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionObject
	var threatException_pango_entries []vulnerability.ThreatException
	{
		d := o.ThreatException.ElementsAs(ctx, &threatException_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range threatException_tf_entries {
			var entry *vulnerability.ThreatException
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			threatException_pango_entries = append(threatException_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).CloudInlineAnalysis = cloudInlineAnalysis_value
	(*obj).InlineExceptionEdlUrl = inlineExceptionEdlUrl_pango_entries
	(*obj).InlineExceptionIpAddress = inlineExceptionIpAddress_pango_entries
	(*obj).MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_pango_entries
	(*obj).Description = description_value
	(*obj).DisableOverride = disableOverride_value
	(*obj).Rules = rules_pango_entries
	(*obj).ThreatException = threatException_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatException, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	var action_entry *vulnerability.ThreatExceptionAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.ThreatExceptionAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timeAttribute_entry *vulnerability.ThreatExceptionTimeAttribute
	if o.TimeAttribute != nil {
		if *obj != nil && (*obj).TimeAttribute != nil {
			timeAttribute_entry = (*obj).TimeAttribute
		} else {
			timeAttribute_entry = new(vulnerability.ThreatExceptionTimeAttribute)
		}

		diags.Append(o.TimeAttribute.CopyToPango(ctx, &timeAttribute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var exemptIp_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject
	var exemptIp_pango_entries []vulnerability.ThreatExceptionExemptIp
	{
		d := o.ExemptIp.ElementsAs(ctx, &exemptIp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exemptIp_tf_entries {
			var entry *vulnerability.ThreatExceptionExemptIp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exemptIp_pango_entries = append(exemptIp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatException)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).PacketCapture = packetCapture_value
	(*obj).Action = action_entry
	(*obj).TimeAttribute = timeAttribute_entry
	(*obj).ExemptIp = exemptIp_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_entry *vulnerability.ThreatExceptionActionDefault
	if o.Default != nil {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.ThreatExceptionActionDefault)
		}

		diags.Append(o.Default.CopyToPango(ctx, &default_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *vulnerability.ThreatExceptionActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.ThreatExceptionActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.ThreatExceptionActionAlert
	if o.Alert != nil {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.ThreatExceptionActionAlert)
		}

		diags.Append(o.Alert.CopyToPango(ctx, &alert_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_entry *vulnerability.ThreatExceptionActionDrop
	if o.Drop != nil {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.ThreatExceptionActionDrop)
		}

		diags.Append(o.Drop.CopyToPango(ctx, &drop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_entry *vulnerability.ThreatExceptionActionResetClient
	if o.ResetClient != nil {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.ThreatExceptionActionResetClient)
		}

		diags.Append(o.ResetClient.CopyToPango(ctx, &resetClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.ThreatExceptionActionResetServer
	if o.ResetServer != nil {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.ThreatExceptionActionResetServer)
		}

		diags.Append(o.ResetServer.CopyToPango(ctx, &resetServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.ThreatExceptionActionResetBoth
	if o.ResetBoth != nil {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.ThreatExceptionActionResetBoth)
		}

		diags.Append(o.ResetBoth.CopyToPango(ctx, &resetBoth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.ThreatExceptionActionBlockIp
	if o.BlockIp != nil {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.ThreatExceptionActionBlockIp)
		}

		diags.Append(o.BlockIp.CopyToPango(ctx, &blockIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionAction)
	}
	(*obj).Default = default_entry
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry
	(*obj).Drop = drop_entry
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDrop)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionTimeAttribute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	trackBy_value := o.TrackBy.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionTimeAttribute)
	}
	(*obj).Interval = interval_value
	(*obj).Threshold = threshold_value
	(*obj).TrackBy = trackBy_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionExemptIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionExemptIp)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) CopyToPango(ctx context.Context, obj **vulnerability.MicaEngineVulnerabilityEnabled, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	inlinePolicyAction_value := o.InlinePolicyAction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.MicaEngineVulnerabilityEnabled)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).InlinePolicyAction = inlinePolicyAction_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesObject) CopyToPango(ctx context.Context, obj **vulnerability.Rules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *vulnerability.RulesAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.RulesAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	threatName_value := o.ThreatName.ValueStringPointer()
	host_value := o.Host.ValueStringPointer()
	category_value := o.Category.ValueStringPointer()
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	cve_pango_entries := make([]string, 0)
	diags.Append(o.Cve.ElementsAs(ctx, &cve_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	vendorId_pango_entries := make([]string, 0)
	diags.Append(o.VendorId.ElementsAs(ctx, &vendorId_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	severity_pango_entries := make([]string, 0)
	diags.Append(o.Severity.ElementsAs(ctx, &severity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(vulnerability.Rules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_entry
	(*obj).ThreatName = threatName_value
	(*obj).Host = host_value
	(*obj).Category = category_value
	(*obj).PacketCapture = packetCapture_value
	(*obj).Cve = cve_pango_entries
	(*obj).VendorId = vendorId_pango_entries
	(*obj).Severity = severity_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var resetClient_entry *vulnerability.RulesActionResetClient
	if o.ResetClient != nil {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.RulesActionResetClient)
		}

		diags.Append(o.ResetClient.CopyToPango(ctx, &resetClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.RulesActionResetServer
	if o.ResetServer != nil {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.RulesActionResetServer)
		}

		diags.Append(o.ResetServer.CopyToPango(ctx, &resetServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.RulesActionResetBoth
	if o.ResetBoth != nil {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.RulesActionResetBoth)
		}

		diags.Append(o.ResetBoth.CopyToPango(ctx, &resetBoth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.RulesActionBlockIp
	if o.BlockIp != nil {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.RulesActionBlockIp)
		}

		diags.Append(o.BlockIp.CopyToPango(ctx, &blockIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var default_entry *vulnerability.RulesActionDefault
	if o.Default != nil {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.RulesActionDefault)
		}

		diags.Append(o.Default.CopyToPango(ctx, &default_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *vulnerability.RulesActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.RulesActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.RulesActionAlert
	if o.Alert != nil {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.RulesActionAlert)
		}

		diags.Append(o.Alert.CopyToPango(ctx, &alert_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_entry *vulnerability.RulesActionDrop
	if o.Drop != nil {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.RulesActionDrop)
		}

		diags.Append(o.Drop.CopyToPango(ctx, &drop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.RulesAction)
	}
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry
	(*obj).Default = default_entry
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry
	(*obj).Drop = drop_entry

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileDataSourceRulesActionDropObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDrop)
	}

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceModel) CopyFromPango(ctx context.Context, obj *vulnerability.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VulnerabilitySecurityProfileDataSourceRulesObject
		for _, elt := range obj.Rules {
			var entry VulnerabilitySecurityProfileDataSourceRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			rules_tf_entries = append(rules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}
	var threatException_list types.List
	{
		var threatException_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionObject
		for _, elt := range obj.ThreatException {
			var entry VulnerabilitySecurityProfileDataSourceThreatExceptionObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			threatException_tf_entries = append(threatException_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("threat_exception")
		threatException_list, list_diags = types.ListValueFrom(ctx, schemaType, threatException_tf_entries)
		diags.Append(list_diags...)
	}
	var inlineExceptionEdlUrl_list types.List
	{
		var list_diags diag.Diagnostics
		inlineExceptionEdlUrl_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.InlineExceptionEdlUrl)
		diags.Append(list_diags...)
	}
	var inlineExceptionIpAddress_list types.List
	{
		var list_diags diag.Diagnostics
		inlineExceptionIpAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.InlineExceptionIpAddress)
		diags.Append(list_diags...)
	}
	var micaEngineVulnerabilityEnabled_list types.List
	{
		var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject
		for _, elt := range obj.MicaEngineVulnerabilityEnabled {
			var entry VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			micaEngineVulnerabilityEnabled_tf_entries = append(micaEngineVulnerabilityEnabled_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("mica_engine_vulnerability_enabled")
		micaEngineVulnerabilityEnabled_list, list_diags = types.ListValueFrom(ctx, schemaType, micaEngineVulnerabilityEnabled_tf_entries)
		diags.Append(list_diags...)
	}

	var cloudInlineAnalysis_value types.Bool
	if obj.CloudInlineAnalysis != nil {
		cloudInlineAnalysis_value = types.BoolValue(*obj.CloudInlineAnalysis)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	o.Name = types.StringValue(obj.Name)
	o.Rules = rules_list
	o.ThreatException = threatException_list
	o.CloudInlineAnalysis = cloudInlineAnalysis_value
	o.InlineExceptionEdlUrl = inlineExceptionEdlUrl_list
	o.InlineExceptionIpAddress = inlineExceptionIpAddress_list
	o.MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_list
	o.Description = description_value
	o.DisableOverride = disableOverride_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesObject) CopyFromPango(ctx context.Context, obj *vulnerability.Rules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var cve_list types.List
	{
		var list_diags diag.Diagnostics
		cve_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Cve)
		diags.Append(list_diags...)
	}
	var vendorId_list types.List
	{
		var list_diags diag.Diagnostics
		vendorId_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.VendorId)
		diags.Append(list_diags...)
	}
	var severity_list types.List
	{
		var list_diags diag.Diagnostics
		severity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Severity)
		diags.Append(list_diags...)
	}
	var action_object *VulnerabilitySecurityProfileDataSourceRulesActionObject
	if obj.Action != nil {
		action_object = new(VulnerabilitySecurityProfileDataSourceRulesActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var host_value types.String
	if obj.Host != nil {
		host_value = types.StringValue(*obj.Host)
	}
	var category_value types.String
	if obj.Category != nil {
		category_value = types.StringValue(*obj.Category)
	}
	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	var threatName_value types.String
	if obj.ThreatName != nil {
		threatName_value = types.StringValue(*obj.ThreatName)
	}
	o.Name = types.StringValue(obj.Name)
	o.Host = host_value
	o.Category = category_value
	o.PacketCapture = packetCapture_value
	o.Cve = cve_list
	o.VendorId = vendorId_list
	o.Severity = severity_list
	o.Action = action_object
	o.ThreatName = threatName_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var alert_object *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject
	if obj.Alert != nil {
		alert_object = new(VulnerabilitySecurityProfileDataSourceRulesActionAlertObject)

		diags.Append(alert_object.CopyFromPango(ctx, obj.Alert, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_object *VulnerabilitySecurityProfileDataSourceRulesActionDropObject
	if obj.Drop != nil {
		drop_object = new(VulnerabilitySecurityProfileDataSourceRulesActionDropObject)

		diags.Append(drop_object.CopyFromPango(ctx, obj.Drop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_object *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject
	if obj.ResetClient != nil {
		resetClient_object = new(VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject)

		diags.Append(resetClient_object.CopyFromPango(ctx, obj.ResetClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_object *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject
	if obj.ResetServer != nil {
		resetServer_object = new(VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject)

		diags.Append(resetServer_object.CopyFromPango(ctx, obj.ResetServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_object *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject
	if obj.ResetBoth != nil {
		resetBoth_object = new(VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject)

		diags.Append(resetBoth_object.CopyFromPango(ctx, obj.ResetBoth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_object *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject
	if obj.BlockIp != nil {
		blockIp_object = new(VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject)

		diags.Append(blockIp_object.CopyFromPango(ctx, obj.BlockIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var default_object *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject
	if obj.Default != nil {
		default_object = new(VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject)

		diags.Append(default_object.CopyFromPango(ctx, obj.Default, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_object *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VulnerabilitySecurityProfileDataSourceRulesActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Alert = alert_object
	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object
	o.Default = default_object
	o.Allow = allow_object

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	o.TrackBy = trackBy_value
	o.Duration = duration_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDropObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatException, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exemptIp_list types.List
	{
		var exemptIp_tf_entries []VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject
		for _, elt := range obj.ExemptIp {
			var entry VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exemptIp_tf_entries = append(exemptIp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("exempt_ip")
		exemptIp_list, list_diags = types.ListValueFrom(ctx, schemaType, exemptIp_tf_entries)
		diags.Append(list_diags...)
	}
	var action_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject
	if obj.Action != nil {
		action_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timeAttribute_object *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject
	if obj.TimeAttribute != nil {
		timeAttribute_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject)

		diags.Append(timeAttribute_object.CopyFromPango(ctx, obj.TimeAttribute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	o.Name = types.StringValue(obj.Name)
	o.PacketCapture = packetCapture_value
	o.Action = action_object
	o.TimeAttribute = timeAttribute_object
	o.ExemptIp = exemptIp_list

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionExemptIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var drop_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject
	if obj.Drop != nil {
		drop_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject)

		diags.Append(drop_object.CopyFromPango(ctx, obj.Drop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject
	if obj.ResetClient != nil {
		resetClient_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject)

		diags.Append(resetClient_object.CopyFromPango(ctx, obj.ResetClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject
	if obj.ResetServer != nil {
		resetServer_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject)

		diags.Append(resetServer_object.CopyFromPango(ctx, obj.ResetServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject
	if obj.ResetBoth != nil {
		resetBoth_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject)

		diags.Append(resetBoth_object.CopyFromPango(ctx, obj.ResetBoth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject
	if obj.BlockIp != nil {
		blockIp_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject)

		diags.Append(blockIp_object.CopyFromPango(ctx, obj.BlockIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var default_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject
	if obj.Default != nil {
		default_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject)

		diags.Append(default_object.CopyFromPango(ctx, obj.Default, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_object *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject
	if obj.Alert != nil {
		alert_object = new(VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject)

		diags.Append(alert_object.CopyFromPango(ctx, obj.Alert, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object
	o.Default = default_object
	o.Allow = allow_object
	o.Alert = alert_object

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	o.Duration = duration_value
	o.TrackBy = trackBy_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionTimeAttribute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Threshold = threshold_value
	o.TrackBy = trackBy_value
	o.Interval = interval_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) CopyFromPango(ctx context.Context, obj *vulnerability.MicaEngineVulnerabilityEnabled, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var inlinePolicyAction_value types.String
	if obj.InlinePolicyAction != nil {
		inlinePolicyAction_value = types.StringValue(*obj.InlinePolicyAction)
	}
	o.Name = types.StringValue(obj.Name)
	o.InlinePolicyAction = inlinePolicyAction_value

	return diags
}

func (o *VulnerabilitySecurityProfileDataSourceModel) resourceXpathComponents() ([]string, error) {
	var components []string
	components = append(components, pangoutil.AsEntryXpath(
		[]string{o.Name.ValueString()},
	))
	return components, nil
}

func VulnerabilitySecurityProfileDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": VulnerabilitySecurityProfileDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"inline_exception_edl_url": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"inline_exception_ip_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"mica_engine_vulnerability_enabled": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledSchema(),
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_override": dsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileDataSourceRulesSchema(),
			},

			"threat_exception": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileDataSourceThreatExceptionSchema(),
			},

			"cloud_inline_analysis": dsschema.BoolAttribute{
				Description: "Enable cloud inline analysis",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceModel) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"inline_policy_action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceMicaEngineVulnerabilityEnabledSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": VulnerabilitySecurityProfileDataSourceRulesActionSchema(),

			"threat_name": dsschema.StringAttribute{
				Description: "Threat name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"host": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"category": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"packet_capture": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cve": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"vendor_id": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"severity": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"reset_both": VulnerabilitySecurityProfileDataSourceRulesActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileDataSourceRulesActionBlockIpSchema(),

			"default": VulnerabilitySecurityProfileDataSourceRulesActionDefaultSchema(),

			"allow": VulnerabilitySecurityProfileDataSourceRulesActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileDataSourceRulesActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileDataSourceRulesActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileDataSourceRulesActionResetClientSchema(),

			"reset_server": VulnerabilitySecurityProfileDataSourceRulesActionResetServerSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionResetServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionResetBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionBlockIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"track_by": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"duration": dsschema.Int64Attribute{
				Description: "Duration for block ip",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionDefaultSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionAlertSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionDropSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceRulesActionResetClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceRulesActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceRulesActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"packet_capture": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": VulnerabilitySecurityProfileDataSourceThreatExceptionActionSchema(),

			"time_attribute": VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeSchema(),

			"exempt_ip": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpSchema(),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"allow": VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientSchema(),

			"reset_server": VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerSchema(),

			"reset_both": VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpSchema(),

			"default": VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"track_by": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"duration": dsschema.Int64Attribute{
				Description: "Duration for block ip",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interval": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"track_by": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionTimeAttributeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileDataSourceThreatExceptionExemptIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileDataSourceLocationSchema() rsschema.Attribute {
	return VulnerabilitySecurityProfileLocationSchema()
}

// Metadata returns the data source type name.
func (d *VulnerabilitySecurityProfileDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_vulnerability_security_profile"
}

// Schema defines the schema for this data source.
func (d *VulnerabilitySecurityProfileDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = VulnerabilitySecurityProfileDataSourceSchema()
}

// Configure prepares the struct.
func (d *VulnerabilitySecurityProfileDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := vulnerability.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewEntryObjectManager(d.client, vulnerability.NewService(d.client), specifier, vulnerability.SpecMatches)
}
func (o *VulnerabilitySecurityProfileDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state VulnerabilitySecurityProfileDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location vulnerability.Location

	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if savestate.Location.DeviceGroup != nil {
		location.DeviceGroup = &vulnerability.DeviceGroupLocation{

			PanoramaDevice: savestate.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    savestate.Location.DeviceGroup.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	components, err := savestate.resourceXpathComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	object, err := o.manager.Read(ctx, location, components)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &VulnerabilitySecurityProfileResource{}
	_ resource.ResourceWithConfigure   = &VulnerabilitySecurityProfileResource{}
	_ resource.ResourceWithImportState = &VulnerabilitySecurityProfileResource{}
)

func NewVulnerabilitySecurityProfileResource() resource.Resource {
	if _, found := resourceFuncMap["panos_vulnerability_security_profile"]; !found {
		resourceFuncMap["panos_vulnerability_security_profile"] = resourceFuncs{
			CreateImportId: VulnerabilitySecurityProfileImportStateCreator,
		}
	}
	return &VulnerabilitySecurityProfileResource{}
}

type VulnerabilitySecurityProfileResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*vulnerability.Entry, vulnerability.Location, *vulnerability.Service]
}

func VulnerabilitySecurityProfileResourceLocationSchema() rsschema.Attribute {
	return VulnerabilitySecurityProfileLocationSchema()
}

type VulnerabilitySecurityProfileResourceModel struct {
	Location                       VulnerabilitySecurityProfileLocation `tfsdk:"location"`
	Name                           types.String                         `tfsdk:"name"`
	InlineExceptionIpAddress       types.List                           `tfsdk:"inline_exception_ip_address"`
	MicaEngineVulnerabilityEnabled types.List                           `tfsdk:"mica_engine_vulnerability_enabled"`
	Description                    types.String                         `tfsdk:"description"`
	DisableOverride                types.String                         `tfsdk:"disable_override"`
	Rules                          types.List                           `tfsdk:"rules"`
	ThreatException                types.List                           `tfsdk:"threat_exception"`
	CloudInlineAnalysis            types.Bool                           `tfsdk:"cloud_inline_analysis"`
	InlineExceptionEdlUrl          types.List                           `tfsdk:"inline_exception_edl_url"`
}
type VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject struct {
	Name               types.String `tfsdk:"name"`
	InlinePolicyAction types.String `tfsdk:"inline_policy_action"`
}
type VulnerabilitySecurityProfileResourceRulesObject struct {
	Name          types.String                                           `tfsdk:"name"`
	PacketCapture types.String                                           `tfsdk:"packet_capture"`
	Cve           types.List                                             `tfsdk:"cve"`
	VendorId      types.List                                             `tfsdk:"vendor_id"`
	Severity      types.List                                             `tfsdk:"severity"`
	Action        *VulnerabilitySecurityProfileResourceRulesActionObject `tfsdk:"action"`
	ThreatName    types.String                                           `tfsdk:"threat_name"`
	Host          types.String                                           `tfsdk:"host"`
	Category      types.String                                           `tfsdk:"category"`
}
type VulnerabilitySecurityProfileResourceRulesActionObject struct {
	Allow       *VulnerabilitySecurityProfileResourceRulesActionAllowObject       `tfsdk:"allow"`
	Alert       *VulnerabilitySecurityProfileResourceRulesActionAlertObject       `tfsdk:"alert"`
	Drop        *VulnerabilitySecurityProfileResourceRulesActionDropObject        `tfsdk:"drop"`
	ResetClient *VulnerabilitySecurityProfileResourceRulesActionResetClientObject `tfsdk:"reset_client"`
	ResetServer *VulnerabilitySecurityProfileResourceRulesActionResetServerObject `tfsdk:"reset_server"`
	ResetBoth   *VulnerabilitySecurityProfileResourceRulesActionResetBothObject   `tfsdk:"reset_both"`
	BlockIp     *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject     `tfsdk:"block_ip"`
	Default     *VulnerabilitySecurityProfileResourceRulesActionDefaultObject     `tfsdk:"default"`
}
type VulnerabilitySecurityProfileResourceRulesActionResetServerObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionResetBothObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionBlockIpObject struct {
	TrackBy  types.String `tfsdk:"track_by"`
	Duration types.Int64  `tfsdk:"duration"`
}
type VulnerabilitySecurityProfileResourceRulesActionDefaultObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionAllowObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionAlertObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionDropObject struct {
}
type VulnerabilitySecurityProfileResourceRulesActionResetClientObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionObject struct {
	Name          types.String                                                            `tfsdk:"name"`
	Action        *VulnerabilitySecurityProfileResourceThreatExceptionActionObject        `tfsdk:"action"`
	TimeAttribute *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject `tfsdk:"time_attribute"`
	ExemptIp      types.List                                                              `tfsdk:"exempt_ip"`
	PacketCapture types.String                                                            `tfsdk:"packet_capture"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionObject struct {
	ResetClient *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject `tfsdk:"reset_client"`
	ResetServer *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject `tfsdk:"reset_server"`
	ResetBoth   *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject   `tfsdk:"reset_both"`
	BlockIp     *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject     `tfsdk:"block_ip"`
	Default     *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject     `tfsdk:"default"`
	Allow       *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject       `tfsdk:"allow"`
	Alert       *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject       `tfsdk:"alert"`
	Drop        *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject        `tfsdk:"drop"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject struct {
}
type VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject struct {
	TrackBy  types.String `tfsdk:"track_by"`
	Duration types.Int64  `tfsdk:"duration"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject struct {
	Threshold types.Int64  `tfsdk:"threshold"`
	TrackBy   types.String `tfsdk:"track_by"`
	Interval  types.Int64  `tfsdk:"interval"`
}
type VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject struct {
	Name types.String `tfsdk:"name"`
}

func (r *VulnerabilitySecurityProfileResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func VulnerabilitySecurityProfileResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": VulnerabilitySecurityProfileResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"disable_override": rsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("no"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"yes",
						"no",
					}...),
				},
			},

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileResourceRulesSchema(),
			},

			"threat_exception": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileResourceThreatExceptionSchema(),
			},

			"cloud_inline_analysis": rsschema.BoolAttribute{
				Description: "Enable cloud inline analysis",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inline_exception_edl_url": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"inline_exception_ip_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"mica_engine_vulnerability_enabled": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledSchema(),
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceModel) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"severity": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"action": VulnerabilitySecurityProfileResourceRulesActionSchema(),

			"threat_name": rsschema.StringAttribute{
				Description: "Threat name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"host": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"category": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"packet_capture": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("disable"),
			},

			"cve": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"vendor_id": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"reset_server": VulnerabilitySecurityProfileResourceRulesActionResetServerSchema(),

			"reset_both": VulnerabilitySecurityProfileResourceRulesActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileResourceRulesActionBlockIpSchema(),

			"default": VulnerabilitySecurityProfileResourceRulesActionDefaultSchema(),

			"allow": VulnerabilitySecurityProfileResourceRulesActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileResourceRulesActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileResourceRulesActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileResourceRulesActionResetClientSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionAlertSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionDropSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionResetClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionResetServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionResetBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionBlockIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"track_by": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"duration": rsschema.Int64Attribute{
				Description: "Duration for block ip",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceRulesActionDefaultSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceRulesActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"packet_capture": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("disable"),
			},

			"action": VulnerabilitySecurityProfileResourceThreatExceptionActionSchema(),

			"time_attribute": VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeSchema(),

			"exempt_ip": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VulnerabilitySecurityProfileResourceThreatExceptionExemptIpSchema(),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"default": VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultSchema(),

			"allow": VulnerabilitySecurityProfileResourceThreatExceptionActionAllowSchema(),

			"alert": VulnerabilitySecurityProfileResourceThreatExceptionActionAlertSchema(),

			"drop": VulnerabilitySecurityProfileResourceThreatExceptionActionDropSchema(),

			"reset_client": VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientSchema(),

			"reset_server": VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerSchema(),

			"reset_both": VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothSchema(),

			"block_ip": VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpSchema(),
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionAlertSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionAlertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionDropSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionDropSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"track_by": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"duration": rsschema.Int64Attribute{
				Description: "Duration for block ip",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("reset_client"),
				path.MatchRelative().AtParent().AtName("reset_server"),
				path.MatchRelative().AtParent().AtName("reset_both"),
				path.MatchRelative().AtParent().AtName("block_ip"),
				path.MatchRelative().AtParent().AtName("default"),
				path.MatchRelative().AtParent().AtName("allow"),
				path.MatchRelative().AtParent().AtName("alert"),
				path.MatchRelative().AtParent().AtName("drop"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"track_by": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceThreatExceptionExemptIpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceThreatExceptionExemptIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"inline_policy_action": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("alert"),
			},
		},
	}
}

func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) getTypeFor(name string) attr.Type {
	schema := VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *VulnerabilitySecurityProfileResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_vulnerability_security_profile"
}

func (r *VulnerabilitySecurityProfileResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = VulnerabilitySecurityProfileResourceSchema()
}

// </ResourceSchema>

func (r *VulnerabilitySecurityProfileResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := vulnerability.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewEntryObjectManager(r.client, vulnerability.NewService(r.client), specifier, vulnerability.SpecMatches)
}

func (o *VulnerabilitySecurityProfileResourceModel) CopyToPango(ctx context.Context, obj **vulnerability.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	var rules_tf_entries []VulnerabilitySecurityProfileResourceRulesObject
	var rules_pango_entries []vulnerability.Rules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *vulnerability.Rules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}
	var threatException_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionObject
	var threatException_pango_entries []vulnerability.ThreatException
	{
		d := o.ThreatException.ElementsAs(ctx, &threatException_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range threatException_tf_entries {
			var entry *vulnerability.ThreatException
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			threatException_pango_entries = append(threatException_pango_entries, *entry)
		}
	}
	cloudInlineAnalysis_value := o.CloudInlineAnalysis.ValueBoolPointer()
	inlineExceptionEdlUrl_pango_entries := make([]string, 0)
	diags.Append(o.InlineExceptionEdlUrl.ElementsAs(ctx, &inlineExceptionEdlUrl_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	inlineExceptionIpAddress_pango_entries := make([]string, 0)
	diags.Append(o.InlineExceptionIpAddress.ElementsAs(ctx, &inlineExceptionIpAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject
	var micaEngineVulnerabilityEnabled_pango_entries []vulnerability.MicaEngineVulnerabilityEnabled
	{
		d := o.MicaEngineVulnerabilityEnabled.ElementsAs(ctx, &micaEngineVulnerabilityEnabled_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range micaEngineVulnerabilityEnabled_tf_entries {
			var entry *vulnerability.MicaEngineVulnerabilityEnabled
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			micaEngineVulnerabilityEnabled_pango_entries = append(micaEngineVulnerabilityEnabled_pango_entries, *entry)
		}
	}
	description_value := o.Description.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).DisableOverride = disableOverride_value
	(*obj).Rules = rules_pango_entries
	(*obj).ThreatException = threatException_pango_entries
	(*obj).CloudInlineAnalysis = cloudInlineAnalysis_value
	(*obj).InlineExceptionEdlUrl = inlineExceptionEdlUrl_pango_entries
	(*obj).InlineExceptionIpAddress = inlineExceptionIpAddress_pango_entries
	(*obj).MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_pango_entries
	(*obj).Description = description_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) CopyToPango(ctx context.Context, obj **vulnerability.MicaEngineVulnerabilityEnabled, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	inlinePolicyAction_value := o.InlinePolicyAction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.MicaEngineVulnerabilityEnabled)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).InlinePolicyAction = inlinePolicyAction_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesObject) CopyToPango(ctx context.Context, obj **vulnerability.Rules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	severity_pango_entries := make([]string, 0)
	diags.Append(o.Severity.ElementsAs(ctx, &severity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var action_entry *vulnerability.RulesAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.RulesAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	threatName_value := o.ThreatName.ValueStringPointer()
	host_value := o.Host.ValueStringPointer()
	category_value := o.Category.ValueStringPointer()
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	cve_pango_entries := make([]string, 0)
	diags.Append(o.Cve.ElementsAs(ctx, &cve_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	vendorId_pango_entries := make([]string, 0)
	diags.Append(o.VendorId.ElementsAs(ctx, &vendorId_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(vulnerability.Rules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Severity = severity_pango_entries
	(*obj).Action = action_entry
	(*obj).ThreatName = threatName_value
	(*obj).Host = host_value
	(*obj).Category = category_value
	(*obj).PacketCapture = packetCapture_value
	(*obj).Cve = cve_pango_entries
	(*obj).VendorId = vendorId_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var allow_entry *vulnerability.RulesActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.RulesActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.RulesActionAlert
	if o.Alert != nil {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.RulesActionAlert)
		}

		diags.Append(o.Alert.CopyToPango(ctx, &alert_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_entry *vulnerability.RulesActionDrop
	if o.Drop != nil {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.RulesActionDrop)
		}

		diags.Append(o.Drop.CopyToPango(ctx, &drop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_entry *vulnerability.RulesActionResetClient
	if o.ResetClient != nil {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.RulesActionResetClient)
		}

		diags.Append(o.ResetClient.CopyToPango(ctx, &resetClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.RulesActionResetServer
	if o.ResetServer != nil {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.RulesActionResetServer)
		}

		diags.Append(o.ResetServer.CopyToPango(ctx, &resetServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.RulesActionResetBoth
	if o.ResetBoth != nil {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.RulesActionResetBoth)
		}

		diags.Append(o.ResetBoth.CopyToPango(ctx, &resetBoth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.RulesActionBlockIp
	if o.BlockIp != nil {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.RulesActionBlockIp)
		}

		diags.Append(o.BlockIp.CopyToPango(ctx, &blockIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var default_entry *vulnerability.RulesActionDefault
	if o.Default != nil {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.RulesActionDefault)
		}

		diags.Append(o.Default.CopyToPango(ctx, &default_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.RulesAction)
	}
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry
	(*obj).Drop = drop_entry
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry
	(*obj).Default = default_entry

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDrop)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) CopyToPango(ctx context.Context, obj **vulnerability.RulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.RulesActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatException, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	packetCapture_value := o.PacketCapture.ValueStringPointer()
	var action_entry *vulnerability.ThreatExceptionAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(vulnerability.ThreatExceptionAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timeAttribute_entry *vulnerability.ThreatExceptionTimeAttribute
	if o.TimeAttribute != nil {
		if *obj != nil && (*obj).TimeAttribute != nil {
			timeAttribute_entry = (*obj).TimeAttribute
		} else {
			timeAttribute_entry = new(vulnerability.ThreatExceptionTimeAttribute)
		}

		diags.Append(o.TimeAttribute.CopyToPango(ctx, &timeAttribute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var exemptIp_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject
	var exemptIp_pango_entries []vulnerability.ThreatExceptionExemptIp
	{
		d := o.ExemptIp.ElementsAs(ctx, &exemptIp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exemptIp_tf_entries {
			var entry *vulnerability.ThreatExceptionExemptIp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exemptIp_pango_entries = append(exemptIp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatException)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).PacketCapture = packetCapture_value
	(*obj).Action = action_entry
	(*obj).TimeAttribute = timeAttribute_entry
	(*obj).ExemptIp = exemptIp_pango_entries

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var drop_entry *vulnerability.ThreatExceptionActionDrop
	if o.Drop != nil {
		if *obj != nil && (*obj).Drop != nil {
			drop_entry = (*obj).Drop
		} else {
			drop_entry = new(vulnerability.ThreatExceptionActionDrop)
		}

		diags.Append(o.Drop.CopyToPango(ctx, &drop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_entry *vulnerability.ThreatExceptionActionResetClient
	if o.ResetClient != nil {
		if *obj != nil && (*obj).ResetClient != nil {
			resetClient_entry = (*obj).ResetClient
		} else {
			resetClient_entry = new(vulnerability.ThreatExceptionActionResetClient)
		}

		diags.Append(o.ResetClient.CopyToPango(ctx, &resetClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_entry *vulnerability.ThreatExceptionActionResetServer
	if o.ResetServer != nil {
		if *obj != nil && (*obj).ResetServer != nil {
			resetServer_entry = (*obj).ResetServer
		} else {
			resetServer_entry = new(vulnerability.ThreatExceptionActionResetServer)
		}

		diags.Append(o.ResetServer.CopyToPango(ctx, &resetServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_entry *vulnerability.ThreatExceptionActionResetBoth
	if o.ResetBoth != nil {
		if *obj != nil && (*obj).ResetBoth != nil {
			resetBoth_entry = (*obj).ResetBoth
		} else {
			resetBoth_entry = new(vulnerability.ThreatExceptionActionResetBoth)
		}

		diags.Append(o.ResetBoth.CopyToPango(ctx, &resetBoth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_entry *vulnerability.ThreatExceptionActionBlockIp
	if o.BlockIp != nil {
		if *obj != nil && (*obj).BlockIp != nil {
			blockIp_entry = (*obj).BlockIp
		} else {
			blockIp_entry = new(vulnerability.ThreatExceptionActionBlockIp)
		}

		diags.Append(o.BlockIp.CopyToPango(ctx, &blockIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var default_entry *vulnerability.ThreatExceptionActionDefault
	if o.Default != nil {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(vulnerability.ThreatExceptionActionDefault)
		}

		diags.Append(o.Default.CopyToPango(ctx, &default_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *vulnerability.ThreatExceptionActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(vulnerability.ThreatExceptionActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_entry *vulnerability.ThreatExceptionActionAlert
	if o.Alert != nil {
		if *obj != nil && (*obj).Alert != nil {
			alert_entry = (*obj).Alert
		} else {
			alert_entry = new(vulnerability.ThreatExceptionActionAlert)
		}

		diags.Append(o.Alert.CopyToPango(ctx, &alert_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionAction)
	}
	(*obj).Drop = drop_entry
	(*obj).ResetClient = resetClient_entry
	(*obj).ResetServer = resetServer_entry
	(*obj).ResetBoth = resetBoth_entry
	(*obj).BlockIp = blockIp_entry
	(*obj).Default = default_entry
	(*obj).Allow = allow_entry
	(*obj).Alert = alert_entry

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetServer)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetBoth)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	trackBy_value := o.TrackBy.ValueStringPointer()
	duration_value := o.Duration.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionBlockIp)
	}
	(*obj).TrackBy = trackBy_value
	(*obj).Duration = duration_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDefault)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAllow)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionAlert)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionDrop)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionActionResetClient)
	}

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionTimeAttribute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	trackBy_value := o.TrackBy.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionTimeAttribute)
	}
	(*obj).Interval = interval_value
	(*obj).Threshold = threshold_value
	(*obj).TrackBy = trackBy_value

	return diags
}
func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) CopyToPango(ctx context.Context, obj **vulnerability.ThreatExceptionExemptIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(vulnerability.ThreatExceptionExemptIp)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}

func (o *VulnerabilitySecurityProfileResourceModel) CopyFromPango(ctx context.Context, obj *vulnerability.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var threatException_list types.List
	{
		var threatException_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionObject
		for _, elt := range obj.ThreatException {
			var entry VulnerabilitySecurityProfileResourceThreatExceptionObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			threatException_tf_entries = append(threatException_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("threat_exception")
		threatException_list, list_diags = types.ListValueFrom(ctx, schemaType, threatException_tf_entries)
		diags.Append(list_diags...)
	}
	var inlineExceptionEdlUrl_list types.List
	{
		var list_diags diag.Diagnostics
		inlineExceptionEdlUrl_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.InlineExceptionEdlUrl)
		diags.Append(list_diags...)
	}
	var inlineExceptionIpAddress_list types.List
	{
		var list_diags diag.Diagnostics
		inlineExceptionIpAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.InlineExceptionIpAddress)
		diags.Append(list_diags...)
	}
	var micaEngineVulnerabilityEnabled_list types.List
	{
		var micaEngineVulnerabilityEnabled_tf_entries []VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject
		for _, elt := range obj.MicaEngineVulnerabilityEnabled {
			var entry VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			micaEngineVulnerabilityEnabled_tf_entries = append(micaEngineVulnerabilityEnabled_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("mica_engine_vulnerability_enabled")
		micaEngineVulnerabilityEnabled_list, list_diags = types.ListValueFrom(ctx, schemaType, micaEngineVulnerabilityEnabled_tf_entries)
		diags.Append(list_diags...)
	}
	var rules_list types.List
	{
		var rules_tf_entries []VulnerabilitySecurityProfileResourceRulesObject
		for _, elt := range obj.Rules {
			var entry VulnerabilitySecurityProfileResourceRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			rules_tf_entries = append(rules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	var cloudInlineAnalysis_value types.Bool
	if obj.CloudInlineAnalysis != nil {
		cloudInlineAnalysis_value = types.BoolValue(*obj.CloudInlineAnalysis)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	o.Name = types.StringValue(obj.Name)
	o.ThreatException = threatException_list
	o.CloudInlineAnalysis = cloudInlineAnalysis_value
	o.InlineExceptionEdlUrl = inlineExceptionEdlUrl_list
	o.InlineExceptionIpAddress = inlineExceptionIpAddress_list
	o.MicaEngineVulnerabilityEnabled = micaEngineVulnerabilityEnabled_list
	o.Description = description_value
	o.DisableOverride = disableOverride_value
	o.Rules = rules_list

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesObject) CopyFromPango(ctx context.Context, obj *vulnerability.Rules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var cve_list types.List
	{
		var list_diags diag.Diagnostics
		cve_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Cve)
		diags.Append(list_diags...)
	}
	var vendorId_list types.List
	{
		var list_diags diag.Diagnostics
		vendorId_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.VendorId)
		diags.Append(list_diags...)
	}
	var severity_list types.List
	{
		var list_diags diag.Diagnostics
		severity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Severity)
		diags.Append(list_diags...)
	}
	var action_object *VulnerabilitySecurityProfileResourceRulesActionObject
	if obj.Action != nil {
		action_object = new(VulnerabilitySecurityProfileResourceRulesActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var threatName_value types.String
	if obj.ThreatName != nil {
		threatName_value = types.StringValue(*obj.ThreatName)
	}
	var host_value types.String
	if obj.Host != nil {
		host_value = types.StringValue(*obj.Host)
	}
	var category_value types.String
	if obj.Category != nil {
		category_value = types.StringValue(*obj.Category)
	}
	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	o.Name = types.StringValue(obj.Name)
	o.Cve = cve_list
	o.VendorId = vendorId_list
	o.Severity = severity_list
	o.Action = action_object
	o.ThreatName = threatName_value
	o.Host = host_value
	o.Category = category_value
	o.PacketCapture = packetCapture_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_object *VulnerabilitySecurityProfileResourceRulesActionDefaultObject
	if obj.Default != nil {
		default_object = new(VulnerabilitySecurityProfileResourceRulesActionDefaultObject)

		diags.Append(default_object.CopyFromPango(ctx, obj.Default, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_object *VulnerabilitySecurityProfileResourceRulesActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VulnerabilitySecurityProfileResourceRulesActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_object *VulnerabilitySecurityProfileResourceRulesActionAlertObject
	if obj.Alert != nil {
		alert_object = new(VulnerabilitySecurityProfileResourceRulesActionAlertObject)

		diags.Append(alert_object.CopyFromPango(ctx, obj.Alert, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_object *VulnerabilitySecurityProfileResourceRulesActionDropObject
	if obj.Drop != nil {
		drop_object = new(VulnerabilitySecurityProfileResourceRulesActionDropObject)

		diags.Append(drop_object.CopyFromPango(ctx, obj.Drop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_object *VulnerabilitySecurityProfileResourceRulesActionResetClientObject
	if obj.ResetClient != nil {
		resetClient_object = new(VulnerabilitySecurityProfileResourceRulesActionResetClientObject)

		diags.Append(resetClient_object.CopyFromPango(ctx, obj.ResetClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_object *VulnerabilitySecurityProfileResourceRulesActionResetServerObject
	if obj.ResetServer != nil {
		resetServer_object = new(VulnerabilitySecurityProfileResourceRulesActionResetServerObject)

		diags.Append(resetServer_object.CopyFromPango(ctx, obj.ResetServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_object *VulnerabilitySecurityProfileResourceRulesActionResetBothObject
	if obj.ResetBoth != nil {
		resetBoth_object = new(VulnerabilitySecurityProfileResourceRulesActionResetBothObject)

		diags.Append(resetBoth_object.CopyFromPango(ctx, obj.ResetBoth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_object *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject
	if obj.BlockIp != nil {
		blockIp_object = new(VulnerabilitySecurityProfileResourceRulesActionBlockIpObject)

		diags.Append(blockIp_object.CopyFromPango(ctx, obj.BlockIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Default = default_object
	o.Allow = allow_object
	o.Alert = alert_object
	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetBothObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionBlockIpObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	o.TrackBy = trackBy_value
	o.Duration = duration_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDefaultObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAllowObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionAlertObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionDropObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetClientObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceRulesActionResetServerObject) CopyFromPango(ctx context.Context, obj *vulnerability.RulesActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatException, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exemptIp_list types.List
	{
		var exemptIp_tf_entries []VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject
		for _, elt := range obj.ExemptIp {
			var entry VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exemptIp_tf_entries = append(exemptIp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("exempt_ip")
		exemptIp_list, list_diags = types.ListValueFrom(ctx, schemaType, exemptIp_tf_entries)
		diags.Append(list_diags...)
	}
	var action_object *VulnerabilitySecurityProfileResourceThreatExceptionActionObject
	if obj.Action != nil {
		action_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timeAttribute_object *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject
	if obj.TimeAttribute != nil {
		timeAttribute_object = new(VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject)

		diags.Append(timeAttribute_object.CopyFromPango(ctx, obj.TimeAttribute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var packetCapture_value types.String
	if obj.PacketCapture != nil {
		packetCapture_value = types.StringValue(*obj.PacketCapture)
	}
	o.Name = types.StringValue(obj.Name)
	o.ExemptIp = exemptIp_list
	o.PacketCapture = packetCapture_value
	o.Action = action_object
	o.TimeAttribute = timeAttribute_object

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_object *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject
	if obj.Default != nil {
		default_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject)

		diags.Append(default_object.CopyFromPango(ctx, obj.Default, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_object *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var alert_object *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject
	if obj.Alert != nil {
		alert_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject)

		diags.Append(alert_object.CopyFromPango(ctx, obj.Alert, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var drop_object *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject
	if obj.Drop != nil {
		drop_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject)

		diags.Append(drop_object.CopyFromPango(ctx, obj.Drop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetClient_object *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject
	if obj.ResetClient != nil {
		resetClient_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject)

		diags.Append(resetClient_object.CopyFromPango(ctx, obj.ResetClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetServer_object *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject
	if obj.ResetServer != nil {
		resetServer_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject)

		diags.Append(resetServer_object.CopyFromPango(ctx, obj.ResetServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var resetBoth_object *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject
	if obj.ResetBoth != nil {
		resetBoth_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject)

		diags.Append(resetBoth_object.CopyFromPango(ctx, obj.ResetBoth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var blockIp_object *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject
	if obj.BlockIp != nil {
		blockIp_object = new(VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject)

		diags.Append(blockIp_object.CopyFromPango(ctx, obj.BlockIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Default = default_object
	o.Allow = allow_object
	o.Alert = alert_object
	o.Drop = drop_object
	o.ResetClient = resetClient_object
	o.ResetServer = resetServer_object
	o.ResetBoth = resetBoth_object
	o.BlockIp = blockIp_object

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAlertObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionAlert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDropObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionDrop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetClientObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionResetClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetServerObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionResetServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionResetBothObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionResetBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionBlockIpObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionBlockIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	var duration_value types.Int64
	if obj.Duration != nil {
		duration_value = types.Int64Value(*obj.Duration)
	}
	o.TrackBy = trackBy_value
	o.Duration = duration_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionDefaultObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionDefault, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionActionAllowObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionTimeAttributeObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionTimeAttribute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	var trackBy_value types.String
	if obj.TrackBy != nil {
		trackBy_value = types.StringValue(*obj.TrackBy)
	}
	o.Interval = interval_value
	o.Threshold = threshold_value
	o.TrackBy = trackBy_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceThreatExceptionExemptIpObject) CopyFromPango(ctx context.Context, obj *vulnerability.ThreatExceptionExemptIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VulnerabilitySecurityProfileResourceMicaEngineVulnerabilityEnabledObject) CopyFromPango(ctx context.Context, obj *vulnerability.MicaEngineVulnerabilityEnabled, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var inlinePolicyAction_value types.String
	if obj.InlinePolicyAction != nil {
		inlinePolicyAction_value = types.StringValue(*obj.InlinePolicyAction)
	}
	o.Name = types.StringValue(obj.Name)
	o.InlinePolicyAction = inlinePolicyAction_value

	return diags
}

func (o *VulnerabilitySecurityProfileResourceModel) resourceXpathComponents() ([]string, error) {
	var components []string
	components = append(components, pangoutil.AsEntryXpath(
		[]string{o.Name.ValueString()},
	))
	return components, nil
}

func (r *VulnerabilitySecurityProfileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location vulnerability.Location

	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &vulnerability.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *vulnerability.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := r.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *VulnerabilitySecurityProfileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location vulnerability.Location

	if savestate.Location.DeviceGroup != nil {
		location.DeviceGroup = &vulnerability.DeviceGroupLocation{

			PanoramaDevice: savestate.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    savestate.Location.DeviceGroup.Name.ValueString(),
		}
	}
	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	components, err := savestate.resourceXpathComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	object, err := o.manager.Read(ctx, location, components)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *VulnerabilitySecurityProfileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location vulnerability.Location

	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &vulnerability.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}
	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	obj, err := r.manager.Read(ctx, location, components)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj, obj.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *VulnerabilitySecurityProfileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state VulnerabilitySecurityProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_vulnerability_security_profile_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location vulnerability.Location

	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &vulnerability.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}

	err := r.manager.Delete(ctx, location, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

type VulnerabilitySecurityProfileImportState struct {
	Location VulnerabilitySecurityProfileLocation `json:"location"`
	Name     string                               `json:"name"`
}

func VulnerabilitySecurityProfileImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location VulnerabilitySecurityProfileLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}

	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name string
	switch value := nameAttr.(type) {
	case types.String:
		name = value.ValueString()
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := VulnerabilitySecurityProfileImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *VulnerabilitySecurityProfileResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj VulnerabilitySecurityProfileImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)

}

type VulnerabilitySecurityProfileDeviceGroupLocation struct {
	Name           types.String `tfsdk:"name"`
	PanoramaDevice types.String `tfsdk:"panorama_device"`
}
type VulnerabilitySecurityProfileLocation struct {
	Shared      types.Bool                                       `tfsdk:"shared"`
	DeviceGroup *VulnerabilitySecurityProfileDeviceGroupLocation `tfsdk:"device_group"`
}

func VulnerabilitySecurityProfileLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.BoolAttribute{
				Description: "Location in Shared Panorama",
				Optional:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Bool{
					boolvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("shared"),
						path.MatchRelative().AtParent().AtName("device_group"),
					}...),
				},
			},
			"device_group": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Device Group",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Panorama device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Device Group name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o VulnerabilitySecurityProfileDeviceGroupLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VulnerabilitySecurityProfileDeviceGroupLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o VulnerabilitySecurityProfileLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Shared      *bool                                            `json:"shared"`
		DeviceGroup *VulnerabilitySecurityProfileDeviceGroupLocation `json:"device_group"`
	}{
		Shared:      o.Shared.ValueBoolPointer(),
		DeviceGroup: o.DeviceGroup,
	}

	return json.Marshal(obj)
}

func (o *VulnerabilitySecurityProfileLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared      *bool                                            `json:"shared"`
		DeviceGroup *VulnerabilitySecurityProfileDeviceGroupLocation `json:"device_group"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Shared = types.BoolPointerValue(shadow.Shared)
	o.DeviceGroup = shadow.DeviceGroup

	return nil
}
