package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/policies/rules/nat"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &NatPolicyRulesDataSource{}
	_ datasource.DataSourceWithConfigure = &NatPolicyRulesDataSource{}
)

func NewNatPolicyRulesDataSource() datasource.DataSource {
	return &NatPolicyRulesDataSource{}
}

type NatPolicyRulesDataSource struct {
	client  *pango.Client
	manager *sdkmanager.UuidObjectManager[*nat.Entry, nat.Location, *nat.Service]
}

type NatPolicyRulesDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type NatPolicyRulesDataSourceModel struct {
	Location NatPolicyRulesLocation  `tfsdk:"location"`
	Position TerraformPositionObject `tfsdk:"position"`
	Rules    types.List              `tfsdk:"rules"`
}
type NatPolicyRulesDataSourceRulesObject struct {
	Name                          types.String                                                      `tfsdk:"name"`
	ActiveActiveDeviceBinding     types.String                                                      `tfsdk:"active_active_device_binding"`
	Description                   types.String                                                      `tfsdk:"description"`
	DestinationAddresses          types.List                                                        `tfsdk:"destination_addresses"`
	Disabled                      types.Bool                                                        `tfsdk:"disabled"`
	SourceZones                   types.List                                                        `tfsdk:"source_zones"`
	GroupTag                      types.String                                                      `tfsdk:"group_tag"`
	NatType                       types.String                                                      `tfsdk:"nat_type"`
	Service                       types.String                                                      `tfsdk:"service"`
	SourceAddresses               types.List                                                        `tfsdk:"source_addresses"`
	SourceTranslation             *NatPolicyRulesDataSourceRulesSourceTranslationObject             `tfsdk:"source_translation"`
	Tag                           types.List                                                        `tfsdk:"tag"`
	Target                        *NatPolicyRulesDataSourceRulesTargetObject                        `tfsdk:"target"`
	DestinationZone               types.List                                                        `tfsdk:"destination_zone"`
	ToInterface                   types.String                                                      `tfsdk:"to_interface"`
	DestinationTranslation        *NatPolicyRulesDataSourceRulesDestinationTranslationObject        `tfsdk:"destination_translation"`
	DynamicDestinationTranslation *NatPolicyRulesDataSourceRulesDynamicDestinationTranslationObject `tfsdk:"dynamic_destination_translation"`
}
type NatPolicyRulesDataSourceRulesSourceTranslationObject struct {
	DynamicIp        *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpObject        `tfsdk:"dynamic_ip"`
	DynamicIpAndPort *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortObject `tfsdk:"dynamic_ip_and_port"`
	StaticIp         *NatPolicyRulesDataSourceRulesSourceTranslationStaticIpObject         `tfsdk:"static_ip"`
}
type NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpObject struct {
	Fallback          *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackObject `tfsdk:"fallback"`
	TranslatedAddress types.List                                                             `tfsdk:"translated_address"`
}
type NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackObject struct {
	InterfaceAddress  *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                             `tfsdk:"translated_address"`
}
type NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortObject struct {
	InterfaceAddress  *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                            `tfsdk:"translated_address"`
}
type NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyRulesDataSourceRulesSourceTranslationStaticIpObject struct {
	BiDirectional     types.String `tfsdk:"bi_directional"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
}
type NatPolicyRulesDataSourceRulesTargetObject struct {
	Devices types.List `tfsdk:"devices"`
	Negate  types.Bool `tfsdk:"negate"`
	Tags    types.List `tfsdk:"tags"`
}
type NatPolicyRulesDataSourceRulesTargetDevicesObject struct {
	Name types.String `tfsdk:"name"`
	Vsys types.List   `tfsdk:"vsys"`
}
type NatPolicyRulesDataSourceRulesTargetDevicesVsysObject struct {
	Name types.String `tfsdk:"name"`
}
type NatPolicyRulesDataSourceRulesDestinationTranslationObject struct {
	TranslatedAddress types.String                                                         `tfsdk:"translated_address"`
	TranslatedPort    types.Int64                                                          `tfsdk:"translated_port"`
	DnsRewrite        *NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteObject `tfsdk:"dns_rewrite"`
}
type NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteObject struct {
	Direction types.String `tfsdk:"direction"`
}
type NatPolicyRulesDataSourceRulesDynamicDestinationTranslationObject struct {
	Distribution      types.String `tfsdk:"distribution"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
	TranslatedPort    types.Int64  `tfsdk:"translated_port"`
}

func (o *NatPolicyRulesDataSourceRulesObject) CopyToPango(ctx context.Context, obj **nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	activeActiveDeviceBinding_value := o.ActiveActiveDeviceBinding.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	destinationAddresses_pango_entries := make([]string, 0)
	diags.Append(o.DestinationAddresses.ElementsAs(ctx, &destinationAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	disabled_value := o.Disabled.ValueBoolPointer()
	sourceZones_pango_entries := make([]string, 0)
	diags.Append(o.SourceZones.ElementsAs(ctx, &sourceZones_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	groupTag_value := o.GroupTag.ValueStringPointer()
	natType_value := o.NatType.ValueStringPointer()
	service_value := o.Service.ValueStringPointer()
	sourceAddresses_pango_entries := make([]string, 0)
	diags.Append(o.SourceAddresses.ElementsAs(ctx, &sourceAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var sourceTranslation_entry *nat.SourceTranslation
	if o.SourceTranslation != nil {
		if *obj != nil && (*obj).SourceTranslation != nil {
			sourceTranslation_entry = (*obj).SourceTranslation
		} else {
			sourceTranslation_entry = new(nat.SourceTranslation)
		}

		diags.Append(o.SourceTranslation.CopyToPango(ctx, &sourceTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var target_entry *nat.Target
	if o.Target != nil {
		if *obj != nil && (*obj).Target != nil {
			target_entry = (*obj).Target
		} else {
			target_entry = new(nat.Target)
		}

		diags.Append(o.Target.CopyToPango(ctx, &target_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	destinationZone_pango_entries := make([]string, 0)
	diags.Append(o.DestinationZone.ElementsAs(ctx, &destinationZone_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	toInterface_value := o.ToInterface.ValueStringPointer()
	var destinationTranslation_entry *nat.DestinationTranslation
	if o.DestinationTranslation != nil {
		if *obj != nil && (*obj).DestinationTranslation != nil {
			destinationTranslation_entry = (*obj).DestinationTranslation
		} else {
			destinationTranslation_entry = new(nat.DestinationTranslation)
		}

		diags.Append(o.DestinationTranslation.CopyToPango(ctx, &destinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_entry *nat.DynamicDestinationTranslation
	if o.DynamicDestinationTranslation != nil {
		if *obj != nil && (*obj).DynamicDestinationTranslation != nil {
			dynamicDestinationTranslation_entry = (*obj).DynamicDestinationTranslation
		} else {
			dynamicDestinationTranslation_entry = new(nat.DynamicDestinationTranslation)
		}

		diags.Append(o.DynamicDestinationTranslation.CopyToPango(ctx, &dynamicDestinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	(*obj).Description = description_value
	(*obj).Destination = destinationAddresses_pango_entries
	(*obj).Disabled = disabled_value
	(*obj).From = sourceZones_pango_entries
	(*obj).GroupTag = groupTag_value
	(*obj).NatType = natType_value
	(*obj).Service = service_value
	(*obj).Source = sourceAddresses_pango_entries
	(*obj).SourceTranslation = sourceTranslation_entry
	(*obj).Tag = tag_pango_entries
	(*obj).Target = target_entry
	(*obj).To = destinationZone_pango_entries
	(*obj).ToInterface = toInterface_value
	(*obj).DestinationTranslation = destinationTranslation_entry
	(*obj).DynamicDestinationTranslation = dynamicDestinationTranslation_entry

	return diags
}
func (o *NatPolicyRulesDataSourceRulesSourceTranslationObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_entry *nat.SourceTranslationDynamicIp
	if o.DynamicIp != nil {
		if *obj != nil && (*obj).DynamicIp != nil {
			dynamicIp_entry = (*obj).DynamicIp
		} else {
			dynamicIp_entry = new(nat.SourceTranslationDynamicIp)
		}

		diags.Append(o.DynamicIp.CopyToPango(ctx, &dynamicIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_entry *nat.SourceTranslationDynamicIpAndPort
	if o.DynamicIpAndPort != nil {
		if *obj != nil && (*obj).DynamicIpAndPort != nil {
			dynamicIpAndPort_entry = (*obj).DynamicIpAndPort
		} else {
			dynamicIpAndPort_entry = new(nat.SourceTranslationDynamicIpAndPort)
		}

		diags.Append(o.DynamicIpAndPort.CopyToPango(ctx, &dynamicIpAndPort_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *nat.SourceTranslationStaticIp
	if o.StaticIp != nil {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(nat.SourceTranslationStaticIp)
		}

		diags.Append(o.StaticIp.CopyToPango(ctx, &staticIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslation)
	}
	(*obj).DynamicIp = dynamicIp_entry
	(*obj).DynamicIpAndPort = dynamicIpAndPort_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fallback_entry *nat.SourceTranslationDynamicIpFallback
	if o.Fallback != nil {
		if *obj != nil && (*obj).Fallback != nil {
			fallback_entry = (*obj).Fallback
		} else {
			fallback_entry = new(nat.SourceTranslationDynamicIpFallback)
		}

		diags.Append(o.Fallback.CopyToPango(ctx, &fallback_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIp)
	}
	(*obj).Fallback = fallback_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpFallbackInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallback)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpAndPortInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPort)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyRulesDataSourceRulesSourceTranslationStaticIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	biDirectional_value := o.BiDirectional.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationStaticIp)
	}
	(*obj).BiDirectional = biDirectional_value
	(*obj).TranslatedAddress = translatedAddress_value

	return diags
}
func (o *NatPolicyRulesDataSourceRulesTargetObject) CopyToPango(ctx context.Context, obj **nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_tf_entries []NatPolicyRulesDataSourceRulesTargetDevicesObject
	var devices_pango_entries []nat.TargetDevices
	{
		d := o.Devices.ElementsAs(ctx, &devices_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range devices_tf_entries {
			var entry *nat.TargetDevices
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			devices_pango_entries = append(devices_pango_entries, *entry)
		}
	}
	negate_value := o.Negate.ValueBoolPointer()
	tags_pango_entries := make([]string, 0)
	diags.Append(o.Tags.ElementsAs(ctx, &tags_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.Target)
	}
	(*obj).Devices = devices_pango_entries
	(*obj).Negate = negate_value
	(*obj).Tags = tags_pango_entries

	return diags
}
func (o *NatPolicyRulesDataSourceRulesTargetDevicesObject) CopyToPango(ctx context.Context, obj **nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_tf_entries []NatPolicyRulesDataSourceRulesTargetDevicesVsysObject
	var vsys_pango_entries []nat.TargetDevicesVsys
	{
		d := o.Vsys.ElementsAs(ctx, &vsys_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vsys_tf_entries {
			var entry *nat.TargetDevicesVsys
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			vsys_pango_entries = append(vsys_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(nat.TargetDevices)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vsys = vsys_pango_entries

	return diags
}
func (o *NatPolicyRulesDataSourceRulesTargetDevicesVsysObject) CopyToPango(ctx context.Context, obj **nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(nat.TargetDevicesVsys)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *NatPolicyRulesDataSourceRulesDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()
	var dnsRewrite_entry *nat.DestinationTranslationDnsRewrite
	if o.DnsRewrite != nil {
		if *obj != nil && (*obj).DnsRewrite != nil {
			dnsRewrite_entry = (*obj).DnsRewrite
		} else {
			dnsRewrite_entry = new(nat.DestinationTranslationDnsRewrite)
		}

		diags.Append(o.DnsRewrite.CopyToPango(ctx, &dnsRewrite_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslation)
	}
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value
	(*obj).DnsRewrite = dnsRewrite_entry

	return diags
}
func (o *NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	direction_value := o.Direction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslationDnsRewrite)
	}
	(*obj).Direction = direction_value

	return diags
}
func (o *NatPolicyRulesDataSourceRulesDynamicDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	distribution_value := o.Distribution.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(nat.DynamicDestinationTranslation)
	}
	(*obj).Distribution = distribution_value
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value

	return diags
}

func (o *NatPolicyRulesDataSourceRulesObject) CopyFromPango(ctx context.Context, obj *nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var destinationAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		destinationAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var sourceZones_list types.List
	{
		var list_diags diag.Diagnostics
		sourceZones_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.From)
		diags.Append(list_diags...)
	}
	var sourceAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		sourceAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Source)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}
	var destinationZone_list types.List
	{
		var list_diags diag.Diagnostics
		destinationZone_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.To)
		diags.Append(list_diags...)
	}
	var sourceTranslation_object *NatPolicyRulesDataSourceRulesSourceTranslationObject
	if obj.SourceTranslation != nil {
		sourceTranslation_object = new(NatPolicyRulesDataSourceRulesSourceTranslationObject)

		diags.Append(sourceTranslation_object.CopyFromPango(ctx, obj.SourceTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var target_object *NatPolicyRulesDataSourceRulesTargetObject
	if obj.Target != nil {
		target_object = new(NatPolicyRulesDataSourceRulesTargetObject)

		diags.Append(target_object.CopyFromPango(ctx, obj.Target, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var destinationTranslation_object *NatPolicyRulesDataSourceRulesDestinationTranslationObject
	if obj.DestinationTranslation != nil {
		destinationTranslation_object = new(NatPolicyRulesDataSourceRulesDestinationTranslationObject)

		diags.Append(destinationTranslation_object.CopyFromPango(ctx, obj.DestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_object *NatPolicyRulesDataSourceRulesDynamicDestinationTranslationObject
	if obj.DynamicDestinationTranslation != nil {
		dynamicDestinationTranslation_object = new(NatPolicyRulesDataSourceRulesDynamicDestinationTranslationObject)

		diags.Append(dynamicDestinationTranslation_object.CopyFromPango(ctx, obj.DynamicDestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var activeActiveDeviceBinding_value types.String
	if obj.ActiveActiveDeviceBinding != nil {
		activeActiveDeviceBinding_value = types.StringValue(*obj.ActiveActiveDeviceBinding)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var groupTag_value types.String
	if obj.GroupTag != nil {
		groupTag_value = types.StringValue(*obj.GroupTag)
	}
	var natType_value types.String
	if obj.NatType != nil {
		natType_value = types.StringValue(*obj.NatType)
	}
	var service_value types.String
	if obj.Service != nil {
		service_value = types.StringValue(*obj.Service)
	}
	var toInterface_value types.String
	if obj.ToInterface != nil {
		toInterface_value = types.StringValue(*obj.ToInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	o.Description = description_value
	o.DestinationAddresses = destinationAddresses_list
	o.Disabled = disabled_value
	o.SourceZones = sourceZones_list
	o.GroupTag = groupTag_value
	o.NatType = natType_value
	o.Service = service_value
	o.SourceAddresses = sourceAddresses_list
	o.SourceTranslation = sourceTranslation_object
	o.Tag = tag_list
	o.Target = target_object
	o.DestinationZone = destinationZone_list
	o.ToInterface = toInterface_value
	o.DestinationTranslation = destinationTranslation_object
	o.DynamicDestinationTranslation = dynamicDestinationTranslation_object

	return diags
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_object *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpObject
	if obj.DynamicIp != nil {
		dynamicIp_object = new(NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpObject)

		diags.Append(dynamicIp_object.CopyFromPango(ctx, obj.DynamicIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_object *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortObject
	if obj.DynamicIpAndPort != nil {
		dynamicIpAndPort_object = new(NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortObject)

		diags.Append(dynamicIpAndPort_object.CopyFromPango(ctx, obj.DynamicIpAndPort, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_object *NatPolicyRulesDataSourceRulesSourceTranslationStaticIpObject
	if obj.StaticIp != nil {
		staticIp_object = new(NatPolicyRulesDataSourceRulesSourceTranslationStaticIpObject)

		diags.Append(staticIp_object.CopyFromPango(ctx, obj.StaticIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.DynamicIp = dynamicIp_object
	o.DynamicIpAndPort = dynamicIpAndPort_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var fallback_object *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackObject
	if obj.Fallback != nil {
		fallback_object = new(NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackObject)

		diags.Append(fallback_object.CopyFromPango(ctx, obj.Fallback, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Fallback = fallback_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationStaticIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var biDirectional_value types.String
	if obj.BiDirectional != nil {
		biDirectional_value = types.StringValue(*obj.BiDirectional)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	o.BiDirectional = biDirectional_value
	o.TranslatedAddress = translatedAddress_value

	return diags
}

func (o *NatPolicyRulesDataSourceRulesTargetObject) CopyFromPango(ctx context.Context, obj *nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_list types.List
	{
		var devices_tf_entries []NatPolicyRulesDataSourceRulesTargetDevicesObject
		for _, elt := range obj.Devices {
			var entry NatPolicyRulesDataSourceRulesTargetDevicesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			devices_tf_entries = append(devices_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("devices")
		devices_list, list_diags = types.ListValueFrom(ctx, schemaType, devices_tf_entries)
		diags.Append(list_diags...)
	}
	var tags_list types.List
	{
		var list_diags diag.Diagnostics
		tags_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tags)
		diags.Append(list_diags...)
	}

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Devices = devices_list
	o.Negate = negate_value
	o.Tags = tags_list

	return diags
}

func (o *NatPolicyRulesDataSourceRulesTargetDevicesObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_list types.List
	{
		var vsys_tf_entries []NatPolicyRulesDataSourceRulesTargetDevicesVsysObject
		for _, elt := range obj.Vsys {
			var entry NatPolicyRulesDataSourceRulesTargetDevicesVsysObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			vsys_tf_entries = append(vsys_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vsys")
		vsys_list, list_diags = types.ListValueFrom(ctx, schemaType, vsys_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vsys = vsys_list

	return diags
}

func (o *NatPolicyRulesDataSourceRulesTargetDevicesVsysObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *NatPolicyRulesDataSourceRulesDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsRewrite_object *NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteObject
	if obj.DnsRewrite != nil {
		dnsRewrite_object = new(NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteObject)

		diags.Append(dnsRewrite_object.CopyFromPango(ctx, obj.DnsRewrite, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value
	o.DnsRewrite = dnsRewrite_object

	return diags
}

func (o *NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var direction_value types.String
	if obj.Direction != nil {
		direction_value = types.StringValue(*obj.Direction)
	}
	o.Direction = direction_value

	return diags
}

func (o *NatPolicyRulesDataSourceRulesDynamicDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var distribution_value types.String
	if obj.Distribution != nil {
		distribution_value = types.StringValue(*obj.Distribution)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.Distribution = distribution_value
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value

	return diags
}

func NatPolicyRulesDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": NatPolicyRulesDataSourceLocationSchema(),

			"position": TerraformPositionObjectSchema(),

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     true,
				Optional:     false,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyRulesDataSourceRulesSchema(),
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceModel) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"active_active_device_binding": dsschema.StringAttribute{
				Description: "Device binding configuration in HA Active-Active mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"disabled": dsschema.BoolAttribute{
				Description: "Disable the rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_zones": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_tag": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nat_type": dsschema.StringAttribute{
				Description: "type of nat",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"service": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"source_translation": NatPolicyRulesDataSourceRulesSourceTranslationSchema(),

			"tag": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"target": NatPolicyRulesDataSourceRulesTargetSchema(),

			"destination_zone": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"to_interface": dsschema.StringAttribute{
				Description: "Egress interface from route lookup",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination_translation": NatPolicyRulesDataSourceRulesDestinationTranslationSchema(),

			"dynamic_destination_translation": NatPolicyRulesDataSourceRulesDynamicDestinationTranslationSchema(),
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSourceTranslationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dynamic_ip": NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpSchema(),

			"dynamic_ip_and_port": NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortSchema(),

			"static_ip": NatPolicyRulesDataSourceRulesSourceTranslationStaticIpSchema(),
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSourceTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"fallback": NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackSchema(),

			"translated_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface_address": NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema(),

			"translated_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface_address": NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema(),

			"translated_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesSourceTranslationStaticIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"bi_directional": dsschema.StringAttribute{
				Description: "allow reverse translation from translated address to original address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesSourceTranslationStaticIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesSourceTranslationStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesTargetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"devices": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: NatPolicyRulesDataSourceRulesTargetDevicesSchema(),
			},

			"negate": dsschema.BoolAttribute{
				Description: "Target to all but these specified devices and tags",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tags": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesTargetObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesTargetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesTargetDevicesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vsys": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: NatPolicyRulesDataSourceRulesTargetDevicesVsysSchema(),
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesTargetDevicesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesTargetDevicesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesTargetDevicesVsysSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesTargetDevicesVsysObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesTargetDevicesVsysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesDestinationTranslationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"translated_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_rewrite": NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteSchema(),
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"direction": dsschema.StringAttribute{
				Description: "Select direction to apply DNS rewrite",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesDestinationTranslationDnsRewriteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceRulesDynamicDestinationTranslationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"distribution": dsschema.StringAttribute{
				Description: "Distribution algorithm for destination address pool",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesDataSourceRulesDynamicDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesDataSourceRulesDynamicDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesDataSourceLocationSchema() rsschema.Attribute {
	return NatPolicyRulesLocationSchema()
}

// Metadata returns the data source type name.
func (d *NatPolicyRulesDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_nat_policy_rules"
}

// Schema defines the schema for this data source.
func (d *NatPolicyRulesDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = NatPolicyRulesDataSourceSchema()
}

// Configure prepares the struct.
func (d *NatPolicyRulesDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := nat.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewUuidObjectManager(d.client, nat.NewService(d.client), specifier, nat.SpecMatches)
}
func (o *NatPolicyRulesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state NatPolicyRulesDataSourceModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy_rules",
		"function":      "Create",
	})

	var location nat.Location

	if state.Location.Shared != nil {
		location.Shared = &nat.SharedLocation{

			Rulebase: state.Location.Shared.Rulebase.ValueString(),
		}
	}
	if state.Location.Vsys != nil {
		location.Vsys = &nat.VsysLocation{

			NgfwDevice: state.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       state.Location.Vsys.Name.ValueString(),
		}
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &nat.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
			Rulebase:       state.Location.DeviceGroup.Rulebase.ValueString(),
		}
	}

	var elements []NatPolicyRulesDataSourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() || len(elements) == 0 {
		return
	}

	entries := make([]*nat.Entry, 0, len(elements))
	for _, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		entries = append(entries, entry)
	}

	readEntries, err := o.manager.ReadMany(ctx, location, entries, sdkmanager.NonExhaustive)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Failed to read entries from the server", err.Error())
		}
		return
	}

	var objects []NatPolicyRulesDataSourceRulesObject
	for _, elt := range readEntries {
		var object NatPolicyRulesDataSourceRulesObject
		err := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(err...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects = append(objects, object)
	}

	var list_diags diag.Diagnostics
	state.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &NatPolicyRulesResource{}
	_ resource.ResourceWithConfigure   = &NatPolicyRulesResource{}
	_ resource.ResourceWithImportState = &NatPolicyRulesResource{}
)

func NewNatPolicyRulesResource() resource.Resource {
	if _, found := resourceFuncMap["panos_nat_policy_rules"]; !found {
		resourceFuncMap["panos_nat_policy_rules"] = resourceFuncs{
			CreateImportId: NatPolicyRulesImportStateCreator,
		}
	}
	return &NatPolicyRulesResource{}
}

type NatPolicyRulesResource struct {
	client  *pango.Client
	manager *sdkmanager.UuidObjectManager[*nat.Entry, nat.Location, *nat.Service]
}

func NatPolicyRulesResourceLocationSchema() rsschema.Attribute {
	return NatPolicyRulesLocationSchema()
}

type NatPolicyRulesResourceModel struct {
	Location NatPolicyRulesLocation  `tfsdk:"location"`
	Position TerraformPositionObject `tfsdk:"position"`
	Rules    types.List              `tfsdk:"rules"`
}
type NatPolicyRulesResourceRulesObject struct {
	Name                          types.String                                                    `tfsdk:"name"`
	ActiveActiveDeviceBinding     types.String                                                    `tfsdk:"active_active_device_binding"`
	Description                   types.String                                                    `tfsdk:"description"`
	DestinationAddresses          types.List                                                      `tfsdk:"destination_addresses"`
	Disabled                      types.Bool                                                      `tfsdk:"disabled"`
	SourceZones                   types.List                                                      `tfsdk:"source_zones"`
	GroupTag                      types.String                                                    `tfsdk:"group_tag"`
	NatType                       types.String                                                    `tfsdk:"nat_type"`
	Service                       types.String                                                    `tfsdk:"service"`
	SourceAddresses               types.List                                                      `tfsdk:"source_addresses"`
	SourceTranslation             *NatPolicyRulesResourceRulesSourceTranslationObject             `tfsdk:"source_translation"`
	Tag                           types.List                                                      `tfsdk:"tag"`
	Target                        *NatPolicyRulesResourceRulesTargetObject                        `tfsdk:"target"`
	DestinationZone               types.List                                                      `tfsdk:"destination_zone"`
	ToInterface                   types.String                                                    `tfsdk:"to_interface"`
	DestinationTranslation        *NatPolicyRulesResourceRulesDestinationTranslationObject        `tfsdk:"destination_translation"`
	DynamicDestinationTranslation *NatPolicyRulesResourceRulesDynamicDestinationTranslationObject `tfsdk:"dynamic_destination_translation"`
}
type NatPolicyRulesResourceRulesSourceTranslationObject struct {
	DynamicIp        *NatPolicyRulesResourceRulesSourceTranslationDynamicIpObject        `tfsdk:"dynamic_ip"`
	DynamicIpAndPort *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortObject `tfsdk:"dynamic_ip_and_port"`
	StaticIp         *NatPolicyRulesResourceRulesSourceTranslationStaticIpObject         `tfsdk:"static_ip"`
}
type NatPolicyRulesResourceRulesSourceTranslationDynamicIpObject struct {
	Fallback          *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackObject `tfsdk:"fallback"`
	TranslatedAddress types.List                                                           `tfsdk:"translated_address"`
}
type NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackObject struct {
	InterfaceAddress  *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                           `tfsdk:"translated_address"`
}
type NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortObject struct {
	InterfaceAddress  *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                          `tfsdk:"translated_address"`
}
type NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyRulesResourceRulesSourceTranslationStaticIpObject struct {
	BiDirectional     types.String `tfsdk:"bi_directional"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
}
type NatPolicyRulesResourceRulesTargetObject struct {
	Devices types.List `tfsdk:"devices"`
	Negate  types.Bool `tfsdk:"negate"`
	Tags    types.List `tfsdk:"tags"`
}
type NatPolicyRulesResourceRulesTargetDevicesObject struct {
	Name types.String `tfsdk:"name"`
	Vsys types.List   `tfsdk:"vsys"`
}
type NatPolicyRulesResourceRulesTargetDevicesVsysObject struct {
	Name types.String `tfsdk:"name"`
}
type NatPolicyRulesResourceRulesDestinationTranslationObject struct {
	TranslatedAddress types.String                                                       `tfsdk:"translated_address"`
	TranslatedPort    types.Int64                                                        `tfsdk:"translated_port"`
	DnsRewrite        *NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteObject `tfsdk:"dns_rewrite"`
}
type NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteObject struct {
	Direction types.String `tfsdk:"direction"`
}
type NatPolicyRulesResourceRulesDynamicDestinationTranslationObject struct {
	Distribution      types.String `tfsdk:"distribution"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
	TranslatedPort    types.Int64  `tfsdk:"translated_port"`
}

func (r *NatPolicyRulesResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	{
		var resource NatPolicyRulesResourceModel
		resp.Diagnostics.Append(req.Config.Get(ctx, &resource)...)
		if resp.Diagnostics.HasError() {
			return
		}
		resource.Position.ValidateConfig(resp)
	}
	{
		var resource NatPolicyRulesResourceModel
		resp.Diagnostics.Append(req.Config.Get(ctx, &resource)...)
		if resp.Diagnostics.HasError() {
			return
		}

		entries := make(map[string]struct{})
		var elements []NatPolicyRulesResourceRulesObject
		resource.Rules.ElementsAs(ctx, &elements, false)

		for _, elt := range elements {
			entry := elt.Name.ValueString()
			if _, found := entries[entry]; found {
				resp.Diagnostics.AddError("Failed to validate resource", "List entries must have unique names")
				return
			}
			entries[entry] = struct{}{}
		}
	}
}

// <ResourceSchema>

func NatPolicyRulesResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": NatPolicyRulesResourceLocationSchema(),

			"position": TerraformPositionObjectSchema(),

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     true,
				Optional:     false,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyRulesResourceRulesSchema(),
			},
		},
	}
}

func (o *NatPolicyRulesResourceModel) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"active_active_device_binding": rsschema.StringAttribute{
				Description: "Device binding configuration in HA Active-Active mode",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"primary",
						"both",
						"0",
						"1",
					}...),
				},
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"disabled": rsschema.BoolAttribute{
				Description: "Disable the rule",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_zones": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_tag": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nat_type": rsschema.StringAttribute{
				Description: "type of nat",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"ipv4",
						"nat64",
						"nptv6",
					}...),
				},
			},

			"service": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"source_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"source_translation": NatPolicyRulesResourceRulesSourceTranslationSchema(),

			"tag": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"target": NatPolicyRulesResourceRulesTargetSchema(),

			"destination_zone": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"to_interface": rsschema.StringAttribute{
				Description: "Egress interface from route lookup",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"destination_translation": NatPolicyRulesResourceRulesDestinationTranslationSchema(),

			"dynamic_destination_translation": NatPolicyRulesResourceRulesDynamicDestinationTranslationSchema(),
		},
	}
}

func (o *NatPolicyRulesResourceRulesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSourceTranslationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dynamic_ip": NatPolicyRulesResourceRulesSourceTranslationDynamicIpSchema(),

			"dynamic_ip_and_port": NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortSchema(),

			"static_ip": NatPolicyRulesResourceRulesSourceTranslationStaticIpSchema(),
		},
	}
}

func (o *NatPolicyRulesResourceRulesSourceTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSourceTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSourceTranslationDynamicIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"fallback": NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackSchema(),

			"translated_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSourceTranslationDynamicIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface_address": NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema(),

			"translated_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface_address": NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema(),

			"translated_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesSourceTranslationStaticIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"bi_directional": rsschema.StringAttribute{
				Description: "allow reverse translation from translated address to original address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("no"),
			},

			"translated_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesSourceTranslationStaticIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesSourceTranslationStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesTargetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"devices": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyRulesResourceRulesTargetDevicesSchema(),
			},

			"negate": rsschema.BoolAttribute{
				Description: "Target to all but these specified devices and tags",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tags": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesTargetObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesTargetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesTargetDevicesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vsys": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyRulesResourceRulesTargetDevicesVsysSchema(),
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesTargetDevicesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesTargetDevicesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesTargetDevicesVsysSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesTargetDevicesVsysObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesTargetDevicesVsysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesDestinationTranslationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ConflictsWith(path.Expressions{
				path.MatchRelative().AtParent().AtName("destination_translation"),
				path.MatchRelative().AtParent().AtName("dynamic_destination_translation"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"translated_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_rewrite": NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteSchema(),
		},
	}
}

func (o *NatPolicyRulesResourceRulesDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"direction": rsschema.StringAttribute{
				Description: "Select direction to apply DNS rewrite",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("reverse"),
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyRulesResourceRulesDynamicDestinationTranslationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"distribution": rsschema.StringAttribute{
				Description: "Distribution algorithm for destination address pool",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("round-robin"),
			},

			"translated_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyRulesResourceRulesDynamicDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyRulesResourceRulesDynamicDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *NatPolicyRulesResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_nat_policy_rules"
}

func (r *NatPolicyRulesResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = NatPolicyRulesResourceSchema()
}

// </ResourceSchema>

func (r *NatPolicyRulesResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := nat.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewUuidObjectManager(r.client, nat.NewService(r.client), specifier, nat.SpecMatches)
}

func (o *NatPolicyRulesResourceRulesObject) CopyToPango(ctx context.Context, obj **nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	activeActiveDeviceBinding_value := o.ActiveActiveDeviceBinding.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	destinationAddresses_pango_entries := make([]string, 0)
	diags.Append(o.DestinationAddresses.ElementsAs(ctx, &destinationAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	disabled_value := o.Disabled.ValueBoolPointer()
	sourceZones_pango_entries := make([]string, 0)
	diags.Append(o.SourceZones.ElementsAs(ctx, &sourceZones_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	groupTag_value := o.GroupTag.ValueStringPointer()
	natType_value := o.NatType.ValueStringPointer()
	service_value := o.Service.ValueStringPointer()
	sourceAddresses_pango_entries := make([]string, 0)
	diags.Append(o.SourceAddresses.ElementsAs(ctx, &sourceAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var sourceTranslation_entry *nat.SourceTranslation
	if o.SourceTranslation != nil {
		if *obj != nil && (*obj).SourceTranslation != nil {
			sourceTranslation_entry = (*obj).SourceTranslation
		} else {
			sourceTranslation_entry = new(nat.SourceTranslation)
		}

		diags.Append(o.SourceTranslation.CopyToPango(ctx, &sourceTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var target_entry *nat.Target
	if o.Target != nil {
		if *obj != nil && (*obj).Target != nil {
			target_entry = (*obj).Target
		} else {
			target_entry = new(nat.Target)
		}

		diags.Append(o.Target.CopyToPango(ctx, &target_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	destinationZone_pango_entries := make([]string, 0)
	diags.Append(o.DestinationZone.ElementsAs(ctx, &destinationZone_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	toInterface_value := o.ToInterface.ValueStringPointer()
	var destinationTranslation_entry *nat.DestinationTranslation
	if o.DestinationTranslation != nil {
		if *obj != nil && (*obj).DestinationTranslation != nil {
			destinationTranslation_entry = (*obj).DestinationTranslation
		} else {
			destinationTranslation_entry = new(nat.DestinationTranslation)
		}

		diags.Append(o.DestinationTranslation.CopyToPango(ctx, &destinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_entry *nat.DynamicDestinationTranslation
	if o.DynamicDestinationTranslation != nil {
		if *obj != nil && (*obj).DynamicDestinationTranslation != nil {
			dynamicDestinationTranslation_entry = (*obj).DynamicDestinationTranslation
		} else {
			dynamicDestinationTranslation_entry = new(nat.DynamicDestinationTranslation)
		}

		diags.Append(o.DynamicDestinationTranslation.CopyToPango(ctx, &dynamicDestinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	(*obj).Description = description_value
	(*obj).Destination = destinationAddresses_pango_entries
	(*obj).Disabled = disabled_value
	(*obj).From = sourceZones_pango_entries
	(*obj).GroupTag = groupTag_value
	(*obj).NatType = natType_value
	(*obj).Service = service_value
	(*obj).Source = sourceAddresses_pango_entries
	(*obj).SourceTranslation = sourceTranslation_entry
	(*obj).Tag = tag_pango_entries
	(*obj).Target = target_entry
	(*obj).To = destinationZone_pango_entries
	(*obj).ToInterface = toInterface_value
	(*obj).DestinationTranslation = destinationTranslation_entry
	(*obj).DynamicDestinationTranslation = dynamicDestinationTranslation_entry

	return diags
}
func (o *NatPolicyRulesResourceRulesSourceTranslationObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_entry *nat.SourceTranslationDynamicIp
	if o.DynamicIp != nil {
		if *obj != nil && (*obj).DynamicIp != nil {
			dynamicIp_entry = (*obj).DynamicIp
		} else {
			dynamicIp_entry = new(nat.SourceTranslationDynamicIp)
		}

		diags.Append(o.DynamicIp.CopyToPango(ctx, &dynamicIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_entry *nat.SourceTranslationDynamicIpAndPort
	if o.DynamicIpAndPort != nil {
		if *obj != nil && (*obj).DynamicIpAndPort != nil {
			dynamicIpAndPort_entry = (*obj).DynamicIpAndPort
		} else {
			dynamicIpAndPort_entry = new(nat.SourceTranslationDynamicIpAndPort)
		}

		diags.Append(o.DynamicIpAndPort.CopyToPango(ctx, &dynamicIpAndPort_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *nat.SourceTranslationStaticIp
	if o.StaticIp != nil {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(nat.SourceTranslationStaticIp)
		}

		diags.Append(o.StaticIp.CopyToPango(ctx, &staticIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslation)
	}
	(*obj).DynamicIp = dynamicIp_entry
	(*obj).DynamicIpAndPort = dynamicIpAndPort_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fallback_entry *nat.SourceTranslationDynamicIpFallback
	if o.Fallback != nil {
		if *obj != nil && (*obj).Fallback != nil {
			fallback_entry = (*obj).Fallback
		} else {
			fallback_entry = new(nat.SourceTranslationDynamicIpFallback)
		}

		diags.Append(o.Fallback.CopyToPango(ctx, &fallback_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIp)
	}
	(*obj).Fallback = fallback_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpFallbackInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallback)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpAndPortInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPort)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyRulesResourceRulesSourceTranslationStaticIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	biDirectional_value := o.BiDirectional.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationStaticIp)
	}
	(*obj).BiDirectional = biDirectional_value
	(*obj).TranslatedAddress = translatedAddress_value

	return diags
}
func (o *NatPolicyRulesResourceRulesTargetObject) CopyToPango(ctx context.Context, obj **nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_tf_entries []NatPolicyRulesResourceRulesTargetDevicesObject
	var devices_pango_entries []nat.TargetDevices
	{
		d := o.Devices.ElementsAs(ctx, &devices_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range devices_tf_entries {
			var entry *nat.TargetDevices
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			devices_pango_entries = append(devices_pango_entries, *entry)
		}
	}
	negate_value := o.Negate.ValueBoolPointer()
	tags_pango_entries := make([]string, 0)
	diags.Append(o.Tags.ElementsAs(ctx, &tags_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.Target)
	}
	(*obj).Devices = devices_pango_entries
	(*obj).Negate = negate_value
	(*obj).Tags = tags_pango_entries

	return diags
}
func (o *NatPolicyRulesResourceRulesTargetDevicesObject) CopyToPango(ctx context.Context, obj **nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_tf_entries []NatPolicyRulesResourceRulesTargetDevicesVsysObject
	var vsys_pango_entries []nat.TargetDevicesVsys
	{
		d := o.Vsys.ElementsAs(ctx, &vsys_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vsys_tf_entries {
			var entry *nat.TargetDevicesVsys
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			vsys_pango_entries = append(vsys_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(nat.TargetDevices)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vsys = vsys_pango_entries

	return diags
}
func (o *NatPolicyRulesResourceRulesTargetDevicesVsysObject) CopyToPango(ctx context.Context, obj **nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(nat.TargetDevicesVsys)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *NatPolicyRulesResourceRulesDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()
	var dnsRewrite_entry *nat.DestinationTranslationDnsRewrite
	if o.DnsRewrite != nil {
		if *obj != nil && (*obj).DnsRewrite != nil {
			dnsRewrite_entry = (*obj).DnsRewrite
		} else {
			dnsRewrite_entry = new(nat.DestinationTranslationDnsRewrite)
		}

		diags.Append(o.DnsRewrite.CopyToPango(ctx, &dnsRewrite_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslation)
	}
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value
	(*obj).DnsRewrite = dnsRewrite_entry

	return diags
}
func (o *NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	direction_value := o.Direction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslationDnsRewrite)
	}
	(*obj).Direction = direction_value

	return diags
}
func (o *NatPolicyRulesResourceRulesDynamicDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	distribution_value := o.Distribution.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(nat.DynamicDestinationTranslation)
	}
	(*obj).Distribution = distribution_value
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value

	return diags
}

func (o *NatPolicyRulesResourceRulesObject) CopyFromPango(ctx context.Context, obj *nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var destinationAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		destinationAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var sourceZones_list types.List
	{
		var list_diags diag.Diagnostics
		sourceZones_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.From)
		diags.Append(list_diags...)
	}
	var sourceAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		sourceAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Source)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}
	var destinationZone_list types.List
	{
		var list_diags diag.Diagnostics
		destinationZone_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.To)
		diags.Append(list_diags...)
	}
	var sourceTranslation_object *NatPolicyRulesResourceRulesSourceTranslationObject
	if obj.SourceTranslation != nil {
		sourceTranslation_object = new(NatPolicyRulesResourceRulesSourceTranslationObject)

		diags.Append(sourceTranslation_object.CopyFromPango(ctx, obj.SourceTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var target_object *NatPolicyRulesResourceRulesTargetObject
	if obj.Target != nil {
		target_object = new(NatPolicyRulesResourceRulesTargetObject)

		diags.Append(target_object.CopyFromPango(ctx, obj.Target, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var destinationTranslation_object *NatPolicyRulesResourceRulesDestinationTranslationObject
	if obj.DestinationTranslation != nil {
		destinationTranslation_object = new(NatPolicyRulesResourceRulesDestinationTranslationObject)

		diags.Append(destinationTranslation_object.CopyFromPango(ctx, obj.DestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_object *NatPolicyRulesResourceRulesDynamicDestinationTranslationObject
	if obj.DynamicDestinationTranslation != nil {
		dynamicDestinationTranslation_object = new(NatPolicyRulesResourceRulesDynamicDestinationTranslationObject)

		diags.Append(dynamicDestinationTranslation_object.CopyFromPango(ctx, obj.DynamicDestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var activeActiveDeviceBinding_value types.String
	if obj.ActiveActiveDeviceBinding != nil {
		activeActiveDeviceBinding_value = types.StringValue(*obj.ActiveActiveDeviceBinding)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var groupTag_value types.String
	if obj.GroupTag != nil {
		groupTag_value = types.StringValue(*obj.GroupTag)
	}
	var natType_value types.String
	if obj.NatType != nil {
		natType_value = types.StringValue(*obj.NatType)
	}
	var service_value types.String
	if obj.Service != nil {
		service_value = types.StringValue(*obj.Service)
	}
	var toInterface_value types.String
	if obj.ToInterface != nil {
		toInterface_value = types.StringValue(*obj.ToInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	o.Description = description_value
	o.DestinationAddresses = destinationAddresses_list
	o.Disabled = disabled_value
	o.SourceZones = sourceZones_list
	o.GroupTag = groupTag_value
	o.NatType = natType_value
	o.Service = service_value
	o.SourceAddresses = sourceAddresses_list
	o.SourceTranslation = sourceTranslation_object
	o.Tag = tag_list
	o.Target = target_object
	o.DestinationZone = destinationZone_list
	o.ToInterface = toInterface_value
	o.DestinationTranslation = destinationTranslation_object
	o.DynamicDestinationTranslation = dynamicDestinationTranslation_object

	return diags
}

func (o *NatPolicyRulesResourceRulesSourceTranslationObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_object *NatPolicyRulesResourceRulesSourceTranslationDynamicIpObject
	if obj.DynamicIp != nil {
		dynamicIp_object = new(NatPolicyRulesResourceRulesSourceTranslationDynamicIpObject)

		diags.Append(dynamicIp_object.CopyFromPango(ctx, obj.DynamicIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_object *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortObject
	if obj.DynamicIpAndPort != nil {
		dynamicIpAndPort_object = new(NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortObject)

		diags.Append(dynamicIpAndPort_object.CopyFromPango(ctx, obj.DynamicIpAndPort, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_object *NatPolicyRulesResourceRulesSourceTranslationStaticIpObject
	if obj.StaticIp != nil {
		staticIp_object = new(NatPolicyRulesResourceRulesSourceTranslationStaticIpObject)

		diags.Append(staticIp_object.CopyFromPango(ctx, obj.StaticIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.DynamicIp = dynamicIp_object
	o.DynamicIpAndPort = dynamicIpAndPort_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var fallback_object *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackObject
	if obj.Fallback != nil {
		fallback_object = new(NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackObject)

		diags.Append(fallback_object.CopyFromPango(ctx, obj.Fallback, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Fallback = fallback_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyRulesResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyRulesResourceRulesSourceTranslationStaticIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var biDirectional_value types.String
	if obj.BiDirectional != nil {
		biDirectional_value = types.StringValue(*obj.BiDirectional)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	o.BiDirectional = biDirectional_value
	o.TranslatedAddress = translatedAddress_value

	return diags
}

func (o *NatPolicyRulesResourceRulesTargetObject) CopyFromPango(ctx context.Context, obj *nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_list types.List
	{
		var devices_tf_entries []NatPolicyRulesResourceRulesTargetDevicesObject
		for _, elt := range obj.Devices {
			var entry NatPolicyRulesResourceRulesTargetDevicesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			devices_tf_entries = append(devices_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("devices")
		devices_list, list_diags = types.ListValueFrom(ctx, schemaType, devices_tf_entries)
		diags.Append(list_diags...)
	}
	var tags_list types.List
	{
		var list_diags diag.Diagnostics
		tags_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tags)
		diags.Append(list_diags...)
	}

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Devices = devices_list
	o.Negate = negate_value
	o.Tags = tags_list

	return diags
}

func (o *NatPolicyRulesResourceRulesTargetDevicesObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_list types.List
	{
		var vsys_tf_entries []NatPolicyRulesResourceRulesTargetDevicesVsysObject
		for _, elt := range obj.Vsys {
			var entry NatPolicyRulesResourceRulesTargetDevicesVsysObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			vsys_tf_entries = append(vsys_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vsys")
		vsys_list, list_diags = types.ListValueFrom(ctx, schemaType, vsys_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vsys = vsys_list

	return diags
}

func (o *NatPolicyRulesResourceRulesTargetDevicesVsysObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *NatPolicyRulesResourceRulesDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsRewrite_object *NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteObject
	if obj.DnsRewrite != nil {
		dnsRewrite_object = new(NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteObject)

		diags.Append(dnsRewrite_object.CopyFromPango(ctx, obj.DnsRewrite, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value
	o.DnsRewrite = dnsRewrite_object

	return diags
}

func (o *NatPolicyRulesResourceRulesDestinationTranslationDnsRewriteObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var direction_value types.String
	if obj.Direction != nil {
		direction_value = types.StringValue(*obj.Direction)
	}
	o.Direction = direction_value

	return diags
}

func (o *NatPolicyRulesResourceRulesDynamicDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var distribution_value types.String
	if obj.Distribution != nil {
		distribution_value = types.StringValue(*obj.Distribution)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.Distribution = distribution_value
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value

	return diags
}

func (r *NatPolicyRulesResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	var state NatPolicyRulesResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy_rules_resource",
		"function":      "Create",
	})

	var location nat.Location

	if state.Location.Shared != nil {
		location.Shared = &nat.SharedLocation{

			Rulebase: state.Location.Shared.Rulebase.ValueString(),
		}
	}
	if state.Location.Vsys != nil {
		location.Vsys = &nat.VsysLocation{

			NgfwDevice: state.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       state.Location.Vsys.Name.ValueString(),
		}
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &nat.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
			Rulebase:       state.Location.DeviceGroup.Rulebase.ValueString(),
		}
	}

	var elements []NatPolicyRulesResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	entries := make([]*nat.Entry, len(elements))
	for idx, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		entries[idx] = entry
	}
	position := state.Position.CopyToPango()
	processed, err := r.manager.CreateMany(ctx, location, entries, sdkmanager.NonExhaustive, position)
	if err != nil {
		resp.Diagnostics.AddError("Error during CreateMany() call", err.Error())
		return
	}
	objects := make([]NatPolicyRulesResourceRulesObject, len(processed))
	for idx, elt := range processed {
		var object NatPolicyRulesResourceRulesObject
		copy_diags := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(copy_diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects[idx] = object
	}

	var list_diags diag.Diagnostics
	state.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *NatPolicyRulesResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state NatPolicyRulesResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy_rules",
		"function":      "Create",
	})

	var location nat.Location

	if state.Location.Shared != nil {
		location.Shared = &nat.SharedLocation{

			Rulebase: state.Location.Shared.Rulebase.ValueString(),
		}
	}
	if state.Location.Vsys != nil {
		location.Vsys = &nat.VsysLocation{

			NgfwDevice: state.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       state.Location.Vsys.Name.ValueString(),
		}
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &nat.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
			Rulebase:       state.Location.DeviceGroup.Rulebase.ValueString(),
		}
	}

	var elements []NatPolicyRulesResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() || len(elements) == 0 {
		return
	}

	entries := make([]*nat.Entry, 0, len(elements))
	for _, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		entries = append(entries, entry)
	}

	readEntries, err := o.manager.ReadMany(ctx, location, entries, sdkmanager.NonExhaustive)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Failed to read entries from the server", err.Error())
		}
		return
	}

	var objects []NatPolicyRulesResourceRulesObject
	for _, elt := range readEntries {
		var object NatPolicyRulesResourceRulesObject
		err := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(err...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects = append(objects, object)
	}

	var list_diags diag.Diagnostics
	state.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *NatPolicyRulesResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var state, plan NatPolicyRulesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy_rules_resource",
		"function":      "Create",
	})

	var location nat.Location

	if plan.Location.Shared != nil {
		location.Shared = &nat.SharedLocation{

			Rulebase: plan.Location.Shared.Rulebase.ValueString(),
		}
	}
	if plan.Location.Vsys != nil {
		location.Vsys = &nat.VsysLocation{

			NgfwDevice: plan.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       plan.Location.Vsys.Name.ValueString(),
		}
	}
	if plan.Location.DeviceGroup != nil {
		location.DeviceGroup = &nat.DeviceGroupLocation{

			PanoramaDevice: plan.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    plan.Location.DeviceGroup.Name.ValueString(),
			Rulebase:       plan.Location.DeviceGroup.Rulebase.ValueString(),
		}
	}

	var elements []NatPolicyRulesResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	stateEntries := make([]*nat.Entry, len(elements))
	for idx, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		stateEntries[idx] = entry
	}

	position := plan.Position.CopyToPango()

	existing, err := r.manager.ReadMany(ctx, location, stateEntries, sdkmanager.NonExhaustive)
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error while reading entries from the server", err.Error())
		return
	}

	existingEntriesByName := make(map[string]*nat.Entry, len(existing))
	for _, elt := range existing {
		existingEntriesByName[elt.Name] = elt
	}

	resp.Diagnostics.Append(plan.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	planEntries := make([]*nat.Entry, len(elements))
	for idx, elt := range elements {
		entry, _ := existingEntriesByName[elt.Name.ValueString()]
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		planEntries[idx] = entry
	}

	processed, err := r.manager.UpdateMany(ctx, location, stateEntries, planEntries, sdkmanager.NonExhaustive, position)
	if err != nil {
		resp.Diagnostics.AddError("Failed to udpate entries", err.Error())
	}

	objects := make([]*NatPolicyRulesResourceRulesObject, len(processed))
	for idx, elt := range processed {
		var object NatPolicyRulesResourceRulesObject
		copy_diags := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(copy_diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects[idx] = &object
	}

	var list_diags diag.Diagnostics
	plan.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (r *NatPolicyRulesResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state NatPolicyRulesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_nat_policy_rules_resource",
		"function":      "Delete",
	})
	var elements []NatPolicyRulesResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location nat.Location

	if state.Location.Shared != nil {
		location.Shared = &nat.SharedLocation{

			Rulebase: state.Location.Shared.Rulebase.ValueString(),
		}
	}
	if state.Location.Vsys != nil {
		location.Vsys = &nat.VsysLocation{

			NgfwDevice: state.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       state.Location.Vsys.Name.ValueString(),
		}
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &nat.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
			Rulebase:       state.Location.DeviceGroup.Rulebase.ValueString(),
		}
	}

	var names []string
	for _, elt := range elements {
		names = append(names, elt.Name.ValueString())
	}
	err := r.manager.Delete(ctx, location, names, sdkmanager.NonExhaustive)
	if err != nil {
		resp.Diagnostics.AddError("error while deleting entries", err.Error())
		return
	}

}

type NatPolicyRulesImportState struct {
	Location NatPolicyRulesLocation `json:"location"`
	Names    []string               `json:"names"`
}

func NatPolicyRulesImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location NatPolicyRulesLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	itemsAttr, ok := attrs["rules"]
	if !ok {
		return nil, fmt.Errorf("rules attribute missing")
	}

	var items []*NatPolicyRulesResourceRulesObject
	switch value := itemsAttr.(type) {
	case types.List:
		diags := value.ElementsAs(ctx, &items, false)
		if diags.HasError() {
			return nil, fmt.Errorf("Invalid rules attribute element type, expected list of valid objects")
		}
	default:
		return nil, fmt.Errorf("Invalid names attribute type, expected list of strings")
	}

	var names []string
	for _, elt := range items {
		names = append(names, elt.Name.ValueString())
	}

	importStruct := NatPolicyRulesImportState{
		Location: location,
		Names:    names,
	}

	return json.Marshal(importStruct)
}

func (r *NatPolicyRulesResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj NatPolicyRulesImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	var names []*NatPolicyRulesResourceRulesObject
	for _, elt := range obj.Names {
		object := &NatPolicyRulesResourceRulesObject{}
		resp.Diagnostics.Append(object.CopyFromPango(ctx, &nat.Entry{}, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		object.Name = types.StringValue(elt)
		names = append(names, object)
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("rules"), names)...)
}

type NatPolicyRulesSharedLocation struct {
	Rulebase types.String `tfsdk:"rulebase"`
}
type NatPolicyRulesVsysLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
	Name       types.String `tfsdk:"name"`
}
type NatPolicyRulesDeviceGroupLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	Rulebase       types.String `tfsdk:"rulebase"`
}
type NatPolicyRulesLocation struct {
	Shared      *NatPolicyRulesSharedLocation      `tfsdk:"shared"`
	Vsys        *NatPolicyRulesVsysLocation        `tfsdk:"vsys"`
	DeviceGroup *NatPolicyRulesDeviceGroupLocation `tfsdk:"device_group"`
}

func NatPolicyRulesLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.SingleNestedAttribute{
				Description: "Located in a shared rulebase",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"rulebase": rsschema.StringAttribute{
						Description: "Rulebase name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("pre-rulebase"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("shared"),
						path.MatchRelative().AtParent().AtName("vsys"),
						path.MatchRelative().AtParent().AtName("device_group"),
					}...),
				},
			},
			"vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The vsys name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"device_group": rsschema.SingleNestedAttribute{
				Description: "Located in a specific device group.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The device group.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"rulebase": rsschema.StringAttribute{
						Description: "The rulebase.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("pre-rulebase"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o NatPolicyRulesSharedLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Rulebase *string `json:"rulebase"`
	}{
		Rulebase: o.Rulebase.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *NatPolicyRulesSharedLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Rulebase *string `json:"rulebase"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Rulebase = types.StringPointerValue(shadow.Rulebase)

	return nil
}
func (o NatPolicyRulesVsysLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		NgfwDevice *string `json:"ngfw_device"`
		Name       *string `json:"name"`
	}{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
		Name:       o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *NatPolicyRulesVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device"`
		Name       *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o NatPolicyRulesDeviceGroupLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		Rulebase       *string `json:"rulebase"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		Rulebase:       o.Rulebase.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *NatPolicyRulesDeviceGroupLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		Rulebase       *string `json:"rulebase"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.Rulebase = types.StringPointerValue(shadow.Rulebase)

	return nil
}
func (o NatPolicyRulesLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Shared      *NatPolicyRulesSharedLocation      `json:"shared"`
		Vsys        *NatPolicyRulesVsysLocation        `json:"vsys"`
		DeviceGroup *NatPolicyRulesDeviceGroupLocation `json:"device_group"`
	}{
		Shared:      o.Shared,
		Vsys:        o.Vsys,
		DeviceGroup: o.DeviceGroup,
	}

	return json.Marshal(obj)
}

func (o *NatPolicyRulesLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared      *NatPolicyRulesSharedLocation      `json:"shared"`
		Vsys        *NatPolicyRulesVsysLocation        `json:"vsys"`
		DeviceGroup *NatPolicyRulesDeviceGroupLocation `json:"device_group"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Shared = shadow.Shared
	o.Vsys = shadow.Vsys
	o.DeviceGroup = shadow.DeviceGroup

	return nil
}
