package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"fmt"

	"github.com/PaloAltoNetworks/pango"

	"github.com/hashicorp/terraform-plugin-framework/action"
	"github.com/hashicorp/terraform-plugin-framework/action/schema"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

var (
	_ action.ActionWithConfigure      = &PushToDevicesAction{}
	_ action.ActionWithValidateConfig = &PushToDevicesAction{}
)

func NewPushToDevicesAction() action.Action {
	return &PushToDevicesAction{}
}

type PushToDevicesAction struct {
	client *pango.Client
}

type PushToDevicesActionModel struct {
	Type                types.String `tfsdk:"type"`
	Name                types.String `tfsdk:"name"`
	Description         types.String `tfsdk:"description"`
	IncludeTemplate     types.Bool   `tfsdk:"include_template"`
	ForceTemplateValues types.Bool   `tfsdk:"force_template_values"`
	Devices             types.List   `tfsdk:"devices"`
}

func PushToDevicesActionSchema() schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{

			"type": schema.StringAttribute{
				Description: "Type of push operation. Valid values: device_group, template, template_stack, log_collector_group, wildfire_appliance, wildfire_cluster",
				Required:    true,
			},

			"name": schema.StringAttribute{
				Description: "Name of the target (device group, template, etc.) to push configuration to",
				Required:    true,
			},

			"description": schema.StringAttribute{
				Description: "Push operation description",
				Optional:    true,
			},

			"include_template": schema.BoolAttribute{
				Description: "Include template configuration when pushing to a device group. Only applicable when type is device_group",
				Optional:    true,
			},

			"force_template_values": schema.BoolAttribute{
				Description: "Force template values to override local values on devices. Applicable for device_group, template, and template_stack types",
				Optional:    true,
			},

			"devices": schema.ListAttribute{
				Description: "List of device serial numbers to push configuration to. If not specified, pushes to all devices in the target",
				Optional:    true,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *PushToDevicesActionModel) getTypeFor(name string) attr.Type {
	schema := PushToDevicesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *PushToDevicesAction) Metadata(ctx context.Context, req action.MetadataRequest, resp *action.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_push_to_devices"
}

func (o *PushToDevicesAction) Schema(_ context.Context, _ action.SchemaRequest, resp *action.SchemaResponse) {
	resp.Schema = PushToDevicesActionSchema()
}

func (o *PushToDevicesAction) Invoke(ctx context.Context, req action.InvokeRequest, resp *action.InvokeResponse) {
	o.InvokeCustom(ctx, req, resp)
}

func (o *PushToDevicesAction) Configure(ctx context.Context, req action.ConfigureRequest, resp *action.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
}

func (o *PushToDevicesAction) ValidateConfig(ctx context.Context, req action.ValidateConfigRequest, resp *action.ValidateConfigResponse) {
}
