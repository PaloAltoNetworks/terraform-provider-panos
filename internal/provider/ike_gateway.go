package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/crypto/ike/gateway"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &IkeGatewayDataSource{}
	_ datasource.DataSourceWithConfigure = &IkeGatewayDataSource{}
)

func NewIkeGatewayDataSource() datasource.DataSource {
	return &IkeGatewayDataSource{}
}

type IkeGatewayDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service]
}

type IkeGatewayDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type IkeGatewayDataSourceModel struct {
	Location       types.Object `tfsdk:"location"`
	Name           types.String `tfsdk:"name"`
	Authentication types.Object `tfsdk:"authentication"`
	Comment        types.String `tfsdk:"comment"`
	Disabled       types.Bool   `tfsdk:"disabled"`
	Ipv6           types.Bool   `tfsdk:"ipv6"`
	LocalAddress   types.Object `tfsdk:"local_address"`
	LocalId        types.Object `tfsdk:"local_id"`
	PeerAddress    types.Object `tfsdk:"peer_address"`
	PeerId         types.Object `tfsdk:"peer_id"`
	Protocol       types.Object `tfsdk:"protocol"`
	ProtocolCommon types.Object `tfsdk:"protocol_common"`
}
type IkeGatewayDataSourceAuthenticationObject struct {
	Certificate  types.Object `tfsdk:"certificate"`
	PreSharedKey types.Object `tfsdk:"pre_shared_key"`
}
type IkeGatewayDataSourceAuthenticationCertificateObject struct {
	AllowIdPayloadMismatch     types.Bool   `tfsdk:"allow_id_payload_mismatch"`
	CertificateProfile         types.String `tfsdk:"certificate_profile"`
	LocalCertificate           types.Object `tfsdk:"local_certificate"`
	StrictValidationRevocation types.Bool   `tfsdk:"strict_validation_revocation"`
	UseManagementAsSource      types.Bool   `tfsdk:"use_management_as_source"`
}
type IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject struct {
	HashAndUrl types.Object `tfsdk:"hash_and_url"`
	Name       types.String `tfsdk:"name"`
}
type IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject struct {
	BaseUrl types.String `tfsdk:"base_url"`
	Enable  types.Bool   `tfsdk:"enable"`
}
type IkeGatewayDataSourceAuthenticationPreSharedKeyObject struct {
	Key types.String `tfsdk:"key"`
}
type IkeGatewayDataSourceLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type IkeGatewayDataSourceLocalIdObject struct {
	Id   types.String `tfsdk:"id"`
	Type types.String `tfsdk:"type"`
}
type IkeGatewayDataSourcePeerAddressObject struct {
	Dynamic types.Object `tfsdk:"dynamic"`
	Fqdn    types.String `tfsdk:"fqdn"`
	Ip      types.String `tfsdk:"ip"`
}
type IkeGatewayDataSourcePeerAddressDynamicObject struct {
}
type IkeGatewayDataSourcePeerIdObject struct {
	Id       types.String `tfsdk:"id"`
	Matching types.String `tfsdk:"matching"`
	Type     types.String `tfsdk:"type"`
}
type IkeGatewayDataSourceProtocolObject struct {
	Ikev1   types.Object `tfsdk:"ikev1"`
	Ikev2   types.Object `tfsdk:"ikev2"`
	Version types.String `tfsdk:"version"`
}
type IkeGatewayDataSourceProtocolIkev1Object struct {
	Dpd              types.Object `tfsdk:"dpd"`
	ExchangeMode     types.String `tfsdk:"exchange_mode"`
	IkeCryptoProfile types.String `tfsdk:"ike_crypto_profile"`
}
type IkeGatewayDataSourceProtocolIkev1DpdObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	Interval types.Int64 `tfsdk:"interval"`
	Retry    types.Int64 `tfsdk:"retry"`
}
type IkeGatewayDataSourceProtocolIkev2Object struct {
	Dpd              types.Object `tfsdk:"dpd"`
	IkeCryptoProfile types.String `tfsdk:"ike_crypto_profile"`
	RequireCookie    types.Bool   `tfsdk:"require_cookie"`
}
type IkeGatewayDataSourceProtocolIkev2DpdObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	Interval types.Int64 `tfsdk:"interval"`
}
type IkeGatewayDataSourceProtocolCommonObject struct {
	Fragmentation types.Object `tfsdk:"fragmentation"`
	NatTraversal  types.Object `tfsdk:"nat_traversal"`
	PassiveMode   types.Bool   `tfsdk:"passive_mode"`
}
type IkeGatewayDataSourceProtocolCommonFragmentationObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IkeGatewayDataSourceProtocolCommonNatTraversalObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	KeepAliveInterval types.Int64 `tfsdk:"keep_alive_interval"`
	UdpChecksumEnable types.Bool  `tfsdk:"udp_checksum_enable"`
}

func (o *IkeGatewayDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj IkeGatewayLocation

	var authenticationObj *IkeGatewayDataSourceAuthenticationObject

	var localAddressObj *IkeGatewayDataSourceLocalAddressObject

	var localIdObj *IkeGatewayDataSourceLocalIdObject

	var peerAddressObj *IkeGatewayDataSourcePeerAddressObject

	var peerIdObj *IkeGatewayDataSourcePeerIdObject

	var protocolObj *IkeGatewayDataSourceProtocolObject

	var protocolCommonObj *IkeGatewayDataSourceProtocolCommonObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"authentication": types.ObjectType{
			AttrTypes: authenticationObj.AttributeTypes(),
		},
		"comment":  types.StringType,
		"disabled": types.BoolType,
		"ipv6":     types.BoolType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"local_id": types.ObjectType{
			AttrTypes: localIdObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"peer_id": types.ObjectType{
			AttrTypes: peerIdObj.AttributeTypes(),
		},
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
		"protocol_common": types.ObjectType{
			AttrTypes: protocolCommonObj.AttributeTypes(),
		},
	}
}

func (o IkeGatewayDataSourceModel) AncestorName() string {
	return ""
}

func (o IkeGatewayDataSourceModel) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceAuthenticationObject) AttributeTypes() map[string]attr.Type {

	var certificateObj *IkeGatewayDataSourceAuthenticationCertificateObject

	var preSharedKeyObj *IkeGatewayDataSourceAuthenticationPreSharedKeyObject
	return map[string]attr.Type{
		"certificate": types.ObjectType{
			AttrTypes: certificateObj.AttributeTypes(),
		},
		"pre_shared_key": types.ObjectType{
			AttrTypes: preSharedKeyObj.AttributeTypes(),
		},
	}
}

func (o IkeGatewayDataSourceAuthenticationObject) AncestorName() string {
	return "authentication"
}

func (o IkeGatewayDataSourceAuthenticationObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceAuthenticationCertificateObject) AttributeTypes() map[string]attr.Type {

	var localCertificateObj *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject

	return map[string]attr.Type{
		"allow_id_payload_mismatch": types.BoolType,
		"certificate_profile":       types.StringType,
		"local_certificate": types.ObjectType{
			AttrTypes: localCertificateObj.AttributeTypes(),
		},
		"strict_validation_revocation": types.BoolType,
		"use_management_as_source":     types.BoolType,
	}
}

func (o IkeGatewayDataSourceAuthenticationCertificateObject) AncestorName() string {
	return "certificate"
}

func (o IkeGatewayDataSourceAuthenticationCertificateObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) AttributeTypes() map[string]attr.Type {

	var hashAndUrlObj *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject

	return map[string]attr.Type{
		"hash_and_url": types.ObjectType{
			AttrTypes: hashAndUrlObj.AttributeTypes(),
		},
		"name": types.StringType,
	}
}

func (o IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) AncestorName() string {
	return "local-certificate"
}

func (o IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"base_url": types.StringType,
		"enable":   types.BoolType,
	}
}

func (o IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) AncestorName() string {
	return "hash-and-url"
}

func (o IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceAuthenticationPreSharedKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IkeGatewayDataSourceAuthenticationPreSharedKeyObject) AncestorName() string {
	return "pre-shared-key"
}

func (o IkeGatewayDataSourceAuthenticationPreSharedKeyObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}

func (o IkeGatewayDataSourceLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o IkeGatewayDataSourceLocalAddressObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceLocalIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"id":   types.StringType,
		"type": types.StringType,
	}
}

func (o IkeGatewayDataSourceLocalIdObject) AncestorName() string {
	return "local-id"
}

func (o IkeGatewayDataSourceLocalIdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourcePeerAddressObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *IkeGatewayDataSourcePeerAddressDynamicObject

	return map[string]attr.Type{
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"fqdn": types.StringType,
		"ip":   types.StringType,
	}
}

func (o IkeGatewayDataSourcePeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o IkeGatewayDataSourcePeerAddressObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourcePeerAddressDynamicObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IkeGatewayDataSourcePeerAddressDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o IkeGatewayDataSourcePeerAddressDynamicObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourcePeerIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"id":       types.StringType,
		"matching": types.StringType,
		"type":     types.StringType,
	}
}

func (o IkeGatewayDataSourcePeerIdObject) AncestorName() string {
	return "peer-id"
}

func (o IkeGatewayDataSourcePeerIdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolObject) AttributeTypes() map[string]attr.Type {

	var ikev1Obj *IkeGatewayDataSourceProtocolIkev1Object

	var ikev2Obj *IkeGatewayDataSourceProtocolIkev2Object

	return map[string]attr.Type{
		"ikev1": types.ObjectType{
			AttrTypes: ikev1Obj.AttributeTypes(),
		},
		"ikev2": types.ObjectType{
			AttrTypes: ikev2Obj.AttributeTypes(),
		},
		"version": types.StringType,
	}
}

func (o IkeGatewayDataSourceProtocolObject) AncestorName() string {
	return "protocol"
}

func (o IkeGatewayDataSourceProtocolObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolIkev1Object) AttributeTypes() map[string]attr.Type {

	var dpdObj *IkeGatewayDataSourceProtocolIkev1DpdObject

	return map[string]attr.Type{
		"dpd": types.ObjectType{
			AttrTypes: dpdObj.AttributeTypes(),
		},
		"exchange_mode":      types.StringType,
		"ike_crypto_profile": types.StringType,
	}
}

func (o IkeGatewayDataSourceProtocolIkev1Object) AncestorName() string {
	return "ikev1"
}

func (o IkeGatewayDataSourceProtocolIkev1Object) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolIkev1DpdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":   types.BoolType,
		"interval": types.Int64Type,
		"retry":    types.Int64Type,
	}
}

func (o IkeGatewayDataSourceProtocolIkev1DpdObject) AncestorName() string {
	return "dpd"
}

func (o IkeGatewayDataSourceProtocolIkev1DpdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolIkev2Object) AttributeTypes() map[string]attr.Type {

	var dpdObj *IkeGatewayDataSourceProtocolIkev2DpdObject

	return map[string]attr.Type{
		"dpd": types.ObjectType{
			AttrTypes: dpdObj.AttributeTypes(),
		},
		"ike_crypto_profile": types.StringType,
		"require_cookie":     types.BoolType,
	}
}

func (o IkeGatewayDataSourceProtocolIkev2Object) AncestorName() string {
	return "ikev2"
}

func (o IkeGatewayDataSourceProtocolIkev2Object) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolIkev2DpdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":   types.BoolType,
		"interval": types.Int64Type,
	}
}

func (o IkeGatewayDataSourceProtocolIkev2DpdObject) AncestorName() string {
	return "dpd"
}

func (o IkeGatewayDataSourceProtocolIkev2DpdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolCommonObject) AttributeTypes() map[string]attr.Type {

	var fragmentationObj *IkeGatewayDataSourceProtocolCommonFragmentationObject

	var natTraversalObj *IkeGatewayDataSourceProtocolCommonNatTraversalObject

	return map[string]attr.Type{
		"fragmentation": types.ObjectType{
			AttrTypes: fragmentationObj.AttributeTypes(),
		},
		"nat_traversal": types.ObjectType{
			AttrTypes: natTraversalObj.AttributeTypes(),
		},
		"passive_mode": types.BoolType,
	}
}

func (o IkeGatewayDataSourceProtocolCommonObject) AncestorName() string {
	return "protocol-common"
}

func (o IkeGatewayDataSourceProtocolCommonObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolCommonFragmentationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable": types.BoolType,
	}
}

func (o IkeGatewayDataSourceProtocolCommonFragmentationObject) AncestorName() string {
	return "fragmentation"
}

func (o IkeGatewayDataSourceProtocolCommonFragmentationObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayDataSourceProtocolCommonNatTraversalObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":              types.BoolType,
		"keep_alive_interval": types.Int64Type,
		"udp_checksum_enable": types.BoolType,
	}
}

func (o IkeGatewayDataSourceProtocolCommonNatTraversalObject) AncestorName() string {
	return "nat-traversal"
}

func (o IkeGatewayDataSourceProtocolCommonNatTraversalObject) EntryName() *string {
	return nil
}

func (o *IkeGatewayDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *gateway.Authentication
	if !o.Authentication.IsUnknown() && !o.Authentication.IsNull() {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(gateway.Authentication)
		}
		var object *IkeGatewayDataSourceAuthenticationObject
		diags.Append(o.Authentication.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &authentication_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	var localAddress_entry *gateway.LocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(gateway.LocalAddress)
		}
		var object *IkeGatewayDataSourceLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localId_entry *gateway.LocalId
	if !o.LocalId.IsUnknown() && !o.LocalId.IsNull() {
		if *obj != nil && (*obj).LocalId != nil {
			localId_entry = (*obj).LocalId
		} else {
			localId_entry = new(gateway.LocalId)
		}
		var object *IkeGatewayDataSourceLocalIdObject
		diags.Append(o.LocalId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &localId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *gateway.PeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(gateway.PeerAddress)
		}
		var object *IkeGatewayDataSourcePeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerId_entry *gateway.PeerId
	if !o.PeerId.IsUnknown() && !o.PeerId.IsNull() {
		if *obj != nil && (*obj).PeerId != nil {
			peerId_entry = (*obj).PeerId
		} else {
			peerId_entry = new(gateway.PeerId)
		}
		var object *IkeGatewayDataSourcePeerIdObject
		diags.Append(o.PeerId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &peerId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *gateway.Protocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(gateway.Protocol)
		}
		var object *IkeGatewayDataSourceProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocolCommon_entry *gateway.ProtocolCommon
	if !o.ProtocolCommon.IsUnknown() && !o.ProtocolCommon.IsNull() {
		if *obj != nil && (*obj).ProtocolCommon != nil {
			protocolCommon_entry = (*obj).ProtocolCommon
		} else {
			protocolCommon_entry = new(gateway.ProtocolCommon)
		}
		var object *IkeGatewayDataSourceProtocolCommonObject
		diags.Append(o.ProtocolCommon.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &protocolCommon_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_entry
	(*obj).Comment = comment_value
	(*obj).Disabled = disabled_value
	(*obj).Ipv6 = ipv6_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).LocalId = localId_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).PeerId = peerId_entry
	(*obj).Protocol = protocol_entry
	(*obj).ProtocolCommon = protocolCommon_entry

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Authentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var certificate_entry *gateway.AuthenticationCertificate
	if !o.Certificate.IsUnknown() && !o.Certificate.IsNull() {
		if *obj != nil && (*obj).Certificate != nil {
			certificate_entry = (*obj).Certificate
		} else {
			certificate_entry = new(gateway.AuthenticationCertificate)
		}
		var object *IkeGatewayDataSourceAuthenticationCertificateObject
		diags.Append(o.Certificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &certificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var preSharedKey_entry *gateway.AuthenticationPreSharedKey
	if !o.PreSharedKey.IsUnknown() && !o.PreSharedKey.IsNull() {
		if *obj != nil && (*obj).PreSharedKey != nil {
			preSharedKey_entry = (*obj).PreSharedKey
		} else {
			preSharedKey_entry = new(gateway.AuthenticationPreSharedKey)
		}
		var object *IkeGatewayDataSourceAuthenticationPreSharedKeyObject
		diags.Append(o.PreSharedKey.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &preSharedKey_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Authentication)
	}
	(*obj).Certificate = certificate_entry
	(*obj).PreSharedKey = preSharedKey_entry

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowIdPayloadMismatch_value := o.AllowIdPayloadMismatch.ValueBoolPointer()
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var localCertificate_entry *gateway.AuthenticationCertificateLocalCertificate
	if !o.LocalCertificate.IsUnknown() && !o.LocalCertificate.IsNull() {
		if *obj != nil && (*obj).LocalCertificate != nil {
			localCertificate_entry = (*obj).LocalCertificate
		} else {
			localCertificate_entry = new(gateway.AuthenticationCertificateLocalCertificate)
		}
		var object *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject
		diags.Append(o.LocalCertificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localCertificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	strictValidationRevocation_value := o.StrictValidationRevocation.ValueBoolPointer()
	useManagementAsSource_value := o.UseManagementAsSource.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificate)
	}
	(*obj).AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_entry
	(*obj).StrictValidationRevocation = strictValidationRevocation_value
	(*obj).UseManagementAsSource = useManagementAsSource_value

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationCertificateLocalCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var hashAndUrl_entry *gateway.AuthenticationCertificateLocalCertificateHashAndUrl
	if !o.HashAndUrl.IsUnknown() && !o.HashAndUrl.IsNull() {
		if *obj != nil && (*obj).HashAndUrl != nil {
			hashAndUrl_entry = (*obj).HashAndUrl
		} else {
			hashAndUrl_entry = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
		}
		var object *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject
		diags.Append(o.HashAndUrl.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hashAndUrl_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	name_value := o.Name.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificate)
	}
	(*obj).HashAndUrl = hashAndUrl_entry
	(*obj).Name = name_value

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationCertificateLocalCertificateHashAndUrl, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	baseUrl_value := o.BaseUrl.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
	}
	(*obj).BaseUrl = baseUrl_value
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationPreSharedKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationPreSharedKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.Key.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		key_value = o.Key.ValueStringPointer()
	}

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationPreSharedKey)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IkeGatewayDataSourceLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayDataSourceLocalIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalId)
	}
	(*obj).Id = id_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayDataSourcePeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.PeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *gateway.PeerAddressDynamic
	if !o.Dynamic.IsUnknown() && !o.Dynamic.IsNull() {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(gateway.PeerAddressDynamic)
		}
		var object *IkeGatewayDataSourcePeerAddressDynamicObject
		diags.Append(o.Dynamic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	fqdn_value := o.Fqdn.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerAddress)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayDataSourcePeerAddressDynamicObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.PeerAddressDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(gateway.PeerAddressDynamic)
	}

	return diags
}
func (o *IkeGatewayDataSourcePeerIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.PeerId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	matching_value := o.Matching.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerId)
	}
	(*obj).Id = id_value
	(*obj).Matching = matching_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikev1_entry *gateway.ProtocolIkev1
	if !o.Ikev1.IsUnknown() && !o.Ikev1.IsNull() {
		if *obj != nil && (*obj).Ikev1 != nil {
			ikev1_entry = (*obj).Ikev1
		} else {
			ikev1_entry = new(gateway.ProtocolIkev1)
		}
		var object *IkeGatewayDataSourceProtocolIkev1Object
		diags.Append(o.Ikev1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ikev1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ikev2_entry *gateway.ProtocolIkev2
	if !o.Ikev2.IsUnknown() && !o.Ikev2.IsNull() {
		if *obj != nil && (*obj).Ikev2 != nil {
			ikev2_entry = (*obj).Ikev2
		} else {
			ikev2_entry = new(gateway.ProtocolIkev2)
		}
		var object *IkeGatewayDataSourceProtocolIkev2Object
		diags.Append(o.Ikev2.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ikev2_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	version_value := o.Version.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.Protocol)
	}
	(*obj).Ikev1 = ikev1_entry
	(*obj).Ikev2 = ikev2_entry
	(*obj).Version = version_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_entry *gateway.ProtocolIkev1Dpd
	if !o.Dpd.IsUnknown() && !o.Dpd.IsNull() {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev1Dpd)
		}
		var object *IkeGatewayDataSourceProtocolIkev1DpdObject
		diags.Append(o.Dpd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dpd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	exchangeMode_value := o.ExchangeMode.ValueStringPointer()
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1)
	}
	(*obj).Dpd = dpd_entry
	(*obj).ExchangeMode = exchangeMode_value
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev1DpdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev1Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	retry_value := o.Retry.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value
	(*obj).Retry = retry_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev2Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_entry *gateway.ProtocolIkev2Dpd
	if !o.Dpd.IsUnknown() && !o.Dpd.IsNull() {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev2Dpd)
		}
		var object *IkeGatewayDataSourceProtocolIkev2DpdObject
		diags.Append(o.Dpd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dpd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()
	requireCookie_value := o.RequireCookie.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2)
	}
	(*obj).Dpd = dpd_entry
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value
	(*obj).RequireCookie = requireCookie_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev2DpdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev2Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolCommonObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolCommon, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var fragmentation_entry *gateway.ProtocolCommonFragmentation
	if !o.Fragmentation.IsUnknown() && !o.Fragmentation.IsNull() {
		if *obj != nil && (*obj).Fragmentation != nil {
			fragmentation_entry = (*obj).Fragmentation
		} else {
			fragmentation_entry = new(gateway.ProtocolCommonFragmentation)
		}
		var object *IkeGatewayDataSourceProtocolCommonFragmentationObject
		diags.Append(o.Fragmentation.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &fragmentation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var natTraversal_entry *gateway.ProtocolCommonNatTraversal
	if !o.NatTraversal.IsUnknown() && !o.NatTraversal.IsNull() {
		if *obj != nil && (*obj).NatTraversal != nil {
			natTraversal_entry = (*obj).NatTraversal
		} else {
			natTraversal_entry = new(gateway.ProtocolCommonNatTraversal)
		}
		var object *IkeGatewayDataSourceProtocolCommonNatTraversalObject
		diags.Append(o.NatTraversal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &natTraversal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	passiveMode_value := o.PassiveMode.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommon)
	}
	(*obj).Fragmentation = fragmentation_entry
	(*obj).NatTraversal = natTraversal_entry
	(*obj).PassiveMode = passiveMode_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolCommonFragmentationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolCommonFragmentation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonFragmentation)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolCommonNatTraversalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolCommonNatTraversal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	keepAliveInterval_value := o.KeepAliveInterval.ValueInt64Pointer()
	udpChecksumEnable_value := o.UdpChecksumEnable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonNatTraversal)
	}
	(*obj).Enable = enable_value
	(*obj).KeepAliveInterval = keepAliveInterval_value
	(*obj).UdpChecksumEnable = udpChecksumEnable_value

	return diags
}

func (o *IkeGatewayDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authentication_obj *IkeGatewayDataSourceAuthenticationObject
	if o.Authentication.IsNull() {
		authentication_obj = new(IkeGatewayDataSourceAuthenticationObject)
	} else {
		diags.Append(o.Authentication.As(ctx, &authentication_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authentication_object := types.ObjectNull(authentication_obj.AttributeTypes())
	if obj.Authentication != nil {
		diags.Append(authentication_obj.CopyFromPango(ctx, client, ancestors, obj.Authentication, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authentication_object, diags_tmp = types.ObjectValueFrom(ctx, authentication_obj.AttributeTypes(), authentication_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *IkeGatewayDataSourceLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(IkeGatewayDataSourceLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, ancestors, obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localId_obj *IkeGatewayDataSourceLocalIdObject
	if o.LocalId.IsNull() {
		localId_obj = new(IkeGatewayDataSourceLocalIdObject)
	} else {
		diags.Append(o.LocalId.As(ctx, &localId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localId_object := types.ObjectNull(localId_obj.AttributeTypes())
	if obj.LocalId != nil {
		diags.Append(localId_obj.CopyFromPango(ctx, client, ancestors, obj.LocalId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localId_object, diags_tmp = types.ObjectValueFrom(ctx, localId_obj.AttributeTypes(), localId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *IkeGatewayDataSourcePeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(IkeGatewayDataSourcePeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, ancestors, obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerId_obj *IkeGatewayDataSourcePeerIdObject
	if o.PeerId.IsNull() {
		peerId_obj = new(IkeGatewayDataSourcePeerIdObject)
	} else {
		diags.Append(o.PeerId.As(ctx, &peerId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerId_object := types.ObjectNull(peerId_obj.AttributeTypes())
	if obj.PeerId != nil {
		diags.Append(peerId_obj.CopyFromPango(ctx, client, ancestors, obj.PeerId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerId_object, diags_tmp = types.ObjectValueFrom(ctx, peerId_obj.AttributeTypes(), peerId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var protocol_obj *IkeGatewayDataSourceProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(IkeGatewayDataSourceProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, ancestors, obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var protocolCommon_obj *IkeGatewayDataSourceProtocolCommonObject
	if o.ProtocolCommon.IsNull() {
		protocolCommon_obj = new(IkeGatewayDataSourceProtocolCommonObject)
	} else {
		diags.Append(o.ProtocolCommon.As(ctx, &protocolCommon_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocolCommon_object := types.ObjectNull(protocolCommon_obj.AttributeTypes())
	if obj.ProtocolCommon != nil {
		diags.Append(protocolCommon_obj.CopyFromPango(ctx, client, ancestors, obj.ProtocolCommon, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocolCommon_object, diags_tmp = types.ObjectValueFrom(ctx, protocolCommon_obj.AttributeTypes(), protocolCommon_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_object
	o.Comment = comment_value
	o.Disabled = disabled_value
	o.Ipv6 = ipv6_value
	o.LocalAddress = localAddress_object
	o.LocalId = localId_object
	o.PeerAddress = peerAddress_object
	o.PeerId = peerId_object
	o.Protocol = protocol_object
	o.ProtocolCommon = protocolCommon_object

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Authentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificate_obj *IkeGatewayDataSourceAuthenticationCertificateObject
	if o.Certificate.IsNull() {
		certificate_obj = new(IkeGatewayDataSourceAuthenticationCertificateObject)
	} else {
		diags.Append(o.Certificate.As(ctx, &certificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	certificate_object := types.ObjectNull(certificate_obj.AttributeTypes())
	if obj.Certificate != nil {
		diags.Append(certificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Certificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		certificate_object, diags_tmp = types.ObjectValueFrom(ctx, certificate_obj.AttributeTypes(), certificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var preSharedKey_obj *IkeGatewayDataSourceAuthenticationPreSharedKeyObject
	if o.PreSharedKey.IsNull() {
		preSharedKey_obj = new(IkeGatewayDataSourceAuthenticationPreSharedKeyObject)
	} else {
		diags.Append(o.PreSharedKey.As(ctx, &preSharedKey_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	preSharedKey_object := types.ObjectNull(preSharedKey_obj.AttributeTypes())
	if obj.PreSharedKey != nil {
		diags.Append(preSharedKey_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PreSharedKey, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		preSharedKey_object, diags_tmp = types.ObjectValueFrom(ctx, preSharedKey_obj.AttributeTypes(), preSharedKey_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Certificate = certificate_object
	o.PreSharedKey = preSharedKey_object

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localCertificate_obj *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject
	if o.LocalCertificate.IsNull() {
		localCertificate_obj = new(IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject)
	} else {
		diags.Append(o.LocalCertificate.As(ctx, &localCertificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localCertificate_object := types.ObjectNull(localCertificate_obj.AttributeTypes())
	if obj.LocalCertificate != nil {
		diags.Append(localCertificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalCertificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localCertificate_object, diags_tmp = types.ObjectValueFrom(ctx, localCertificate_obj.AttributeTypes(), localCertificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowIdPayloadMismatch_value types.Bool
	if obj.AllowIdPayloadMismatch != nil {
		allowIdPayloadMismatch_value = types.BoolValue(*obj.AllowIdPayloadMismatch)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var strictValidationRevocation_value types.Bool
	if obj.StrictValidationRevocation != nil {
		strictValidationRevocation_value = types.BoolValue(*obj.StrictValidationRevocation)
	}
	var useManagementAsSource_value types.Bool
	if obj.UseManagementAsSource != nil {
		useManagementAsSource_value = types.BoolValue(*obj.UseManagementAsSource)
	}
	o.AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_object
	o.StrictValidationRevocation = strictValidationRevocation_value
	o.UseManagementAsSource = useManagementAsSource_value

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationCertificateLocalCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hashAndUrl_obj *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject
	if o.HashAndUrl.IsNull() {
		hashAndUrl_obj = new(IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject)
	} else {
		diags.Append(o.HashAndUrl.As(ctx, &hashAndUrl_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hashAndUrl_object := types.ObjectNull(hashAndUrl_obj.AttributeTypes())
	if obj.HashAndUrl != nil {
		diags.Append(hashAndUrl_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HashAndUrl, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hashAndUrl_object, diags_tmp = types.ObjectValueFrom(ctx, hashAndUrl_obj.AttributeTypes(), hashAndUrl_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var name_value types.String
	if obj.Name != nil {
		name_value = types.StringValue(*obj.Name)
	}
	o.HashAndUrl = hashAndUrl_object
	o.Name = name_value

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationCertificateLocalCertificateHashAndUrl, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var baseUrl_value types.String
	if obj.BaseUrl != nil {
		baseUrl_value = types.StringValue(*obj.BaseUrl)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.BaseUrl = baseUrl_value
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationPreSharedKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationPreSharedKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.Key != evFromState {
			key_value = types.StringPointerValue(obj.Key)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			key_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.Key)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	o.Key = key_value

	return diags
}

func (o *IkeGatewayDataSourceLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *IkeGatewayDataSourceLocalIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Id = id_value
	o.Type = type_value

	return diags
}

func (o *IkeGatewayDataSourcePeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.PeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dynamic_obj *IkeGatewayDataSourcePeerAddressDynamicObject
	if o.Dynamic.IsNull() {
		dynamic_obj = new(IkeGatewayDataSourcePeerAddressDynamicObject)
	} else {
		diags.Append(o.Dynamic.As(ctx, &dynamic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamic_object := types.ObjectNull(dynamic_obj.AttributeTypes())
	if obj.Dynamic != nil {
		diags.Append(dynamic_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamic_object, diags_tmp = types.ObjectValueFrom(ctx, dynamic_obj.AttributeTypes(), dynamic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Dynamic = dynamic_object
	o.Fqdn = fqdn_value
	o.Ip = ip_value

	return diags
}

func (o *IkeGatewayDataSourcePeerAddressDynamicObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.PeerAddressDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IkeGatewayDataSourcePeerIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.PeerId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	var matching_value types.String
	if obj.Matching != nil {
		matching_value = types.StringValue(*obj.Matching)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Id = id_value
	o.Matching = matching_value
	o.Type = type_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ikev1_obj *IkeGatewayDataSourceProtocolIkev1Object
	if o.Ikev1.IsNull() {
		ikev1_obj = new(IkeGatewayDataSourceProtocolIkev1Object)
	} else {
		diags.Append(o.Ikev1.As(ctx, &ikev1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ikev1_object := types.ObjectNull(ikev1_obj.AttributeTypes())
	if obj.Ikev1 != nil {
		diags.Append(ikev1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ikev1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ikev1_object, diags_tmp = types.ObjectValueFrom(ctx, ikev1_obj.AttributeTypes(), ikev1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ikev2_obj *IkeGatewayDataSourceProtocolIkev2Object
	if o.Ikev2.IsNull() {
		ikev2_obj = new(IkeGatewayDataSourceProtocolIkev2Object)
	} else {
		diags.Append(o.Ikev2.As(ctx, &ikev2_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ikev2_object := types.ObjectNull(ikev2_obj.AttributeTypes())
	if obj.Ikev2 != nil {
		diags.Append(ikev2_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ikev2, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ikev2_object, diags_tmp = types.ObjectValueFrom(ctx, ikev2_obj.AttributeTypes(), ikev2_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	o.Ikev1 = ikev1_object
	o.Ikev2 = ikev2_object
	o.Version = version_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dpd_obj *IkeGatewayDataSourceProtocolIkev1DpdObject
	if o.Dpd.IsNull() {
		dpd_obj = new(IkeGatewayDataSourceProtocolIkev1DpdObject)
	} else {
		diags.Append(o.Dpd.As(ctx, &dpd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dpd_object := types.ObjectNull(dpd_obj.AttributeTypes())
	if obj.Dpd != nil {
		diags.Append(dpd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dpd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dpd_object, diags_tmp = types.ObjectValueFrom(ctx, dpd_obj.AttributeTypes(), dpd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var exchangeMode_value types.String
	if obj.ExchangeMode != nil {
		exchangeMode_value = types.StringValue(*obj.ExchangeMode)
	}
	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	o.Dpd = dpd_object
	o.ExchangeMode = exchangeMode_value
	o.IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev1DpdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev1Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var retry_value types.Int64
	if obj.Retry != nil {
		retry_value = types.Int64Value(*obj.Retry)
	}
	o.Enable = enable_value
	o.Interval = interval_value
	o.Retry = retry_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev2Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dpd_obj *IkeGatewayDataSourceProtocolIkev2DpdObject
	if o.Dpd.IsNull() {
		dpd_obj = new(IkeGatewayDataSourceProtocolIkev2DpdObject)
	} else {
		diags.Append(o.Dpd.As(ctx, &dpd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dpd_object := types.ObjectNull(dpd_obj.AttributeTypes())
	if obj.Dpd != nil {
		diags.Append(dpd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dpd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dpd_object, diags_tmp = types.ObjectValueFrom(ctx, dpd_obj.AttributeTypes(), dpd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	var requireCookie_value types.Bool
	if obj.RequireCookie != nil {
		requireCookie_value = types.BoolValue(*obj.RequireCookie)
	}
	o.Dpd = dpd_object
	o.IkeCryptoProfile = ikeCryptoProfile_value
	o.RequireCookie = requireCookie_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev2DpdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev2Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Enable = enable_value
	o.Interval = interval_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolCommonObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolCommon, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var fragmentation_obj *IkeGatewayDataSourceProtocolCommonFragmentationObject
	if o.Fragmentation.IsNull() {
		fragmentation_obj = new(IkeGatewayDataSourceProtocolCommonFragmentationObject)
	} else {
		diags.Append(o.Fragmentation.As(ctx, &fragmentation_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	fragmentation_object := types.ObjectNull(fragmentation_obj.AttributeTypes())
	if obj.Fragmentation != nil {
		diags.Append(fragmentation_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Fragmentation, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		fragmentation_object, diags_tmp = types.ObjectValueFrom(ctx, fragmentation_obj.AttributeTypes(), fragmentation_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var natTraversal_obj *IkeGatewayDataSourceProtocolCommonNatTraversalObject
	if o.NatTraversal.IsNull() {
		natTraversal_obj = new(IkeGatewayDataSourceProtocolCommonNatTraversalObject)
	} else {
		diags.Append(o.NatTraversal.As(ctx, &natTraversal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	natTraversal_object := types.ObjectNull(natTraversal_obj.AttributeTypes())
	if obj.NatTraversal != nil {
		diags.Append(natTraversal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NatTraversal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		natTraversal_object, diags_tmp = types.ObjectValueFrom(ctx, natTraversal_obj.AttributeTypes(), natTraversal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var passiveMode_value types.Bool
	if obj.PassiveMode != nil {
		passiveMode_value = types.BoolValue(*obj.PassiveMode)
	}
	o.Fragmentation = fragmentation_object
	o.NatTraversal = natTraversal_object
	o.PassiveMode = passiveMode_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolCommonFragmentationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolCommonFragmentation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolCommonNatTraversalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolCommonNatTraversal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var keepAliveInterval_value types.Int64
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.Int64Value(*obj.KeepAliveInterval)
	}
	var udpChecksumEnable_value types.Bool
	if obj.UdpChecksumEnable != nil {
		udpChecksumEnable_value = types.BoolValue(*obj.UdpChecksumEnable)
	}
	o.Enable = enable_value
	o.KeepAliveInterval = keepAliveInterval_value
	o.UdpChecksumEnable = udpChecksumEnable_value

	return diags
}

func (o *IkeGatewayDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func IkeGatewayDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": IkeGatewayDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": IkeGatewayDataSourceAuthenticationSchema(),

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disabled": dsschema.BoolAttribute{
				Description: "Disable the IKE gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.BoolAttribute{
				Description: "use IPv6 for the IKE gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": IkeGatewayDataSourceLocalAddressSchema(),

			"local_id": IkeGatewayDataSourceLocalIdSchema(),

			"peer_address": IkeGatewayDataSourcePeerAddressSchema(),

			"peer_id": IkeGatewayDataSourcePeerIdSchema(),

			"protocol": IkeGatewayDataSourceProtocolSchema(),

			"protocol_common": IkeGatewayDataSourceProtocolCommonSchema(),
		},
	}
}

func (o *IkeGatewayDataSourceModel) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate": IkeGatewayDataSourceAuthenticationCertificateSchema(),

			"pre_shared_key": IkeGatewayDataSourceAuthenticationPreSharedKeySchema(),
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationCertificateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"allow_id_payload_mismatch": dsschema.BoolAttribute{
				Description: "Permit peer identification and certificate payload identification mismatch",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for certificate valdiation during IKE negotiation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": IkeGatewayDataSourceAuthenticationCertificateLocalCertificateSchema(),

			"strict_validation_revocation": dsschema.BoolAttribute{
				Description: "Enable strict validation of peer's extended key use",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_management_as_source": dsschema.BoolAttribute{
				Description: "Use management interface IP as source to retrieve http certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationCertificateLocalCertificateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"hash_and_url": IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlSchema(),

			"name": dsschema.StringAttribute{
				Description: "Local certificate name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationCertificateLocalCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"base_url": dsschema.StringAttribute{
				Description: "The host and directory part of URL for local certificates(http only)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Use hash-and-url for local certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationPreSharedKeySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "the string used as pre-shared key",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationPreSharedKeyObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationPreSharedKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceLocalIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"id": dsschema.StringAttribute{
				Description: "Local ID string",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceLocalIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceLocalIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourcePeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dynamic": IkeGatewayDataSourcePeerAddressDynamicSchema(),

			"fqdn": dsschema.StringAttribute{
				Description: "peer gateway FQDN name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "peer gateway has static IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourcePeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourcePeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourcePeerAddressDynamicSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IkeGatewayDataSourcePeerAddressDynamicObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourcePeerAddressDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourcePeerIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"id": dsschema.StringAttribute{
				Description: "Peer ID string",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"matching": dsschema.StringAttribute{
				Description: "Enable peer ID wildcard match for certificate authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourcePeerIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourcePeerIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ikev1": IkeGatewayDataSourceProtocolIkev1Schema(),

			"ikev2": IkeGatewayDataSourceProtocolIkev2Schema(),

			"version": dsschema.StringAttribute{
				Description: "IKE protocol version",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dpd": IkeGatewayDataSourceProtocolIkev1DpdSchema(),

			"exchange_mode": dsschema.StringAttribute{
				Description: "Exchange mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ike_crypto_profile": dsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev1Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev1DpdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable Dead-Peer-Detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "sending interval for probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retry": dsschema.Int64Attribute{
				Description: "number of retries before disconnection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev1DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev1DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev2Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dpd": IkeGatewayDataSourceProtocolIkev2DpdSchema(),

			"ike_crypto_profile": dsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"require_cookie": dsschema.BoolAttribute{
				Description: "Require cookie",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev2Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev2DpdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable sending empty information liveness check message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "delay interval before sending probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev2DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev2DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolCommonSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"fragmentation": IkeGatewayDataSourceProtocolCommonFragmentationSchema(),

			"nat_traversal": IkeGatewayDataSourceProtocolCommonNatTraversalSchema(),

			"passive_mode": dsschema.BoolAttribute{
				Description: "Enable passive mode (responder only)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolCommonObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolCommonSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolCommonFragmentationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable IKE fragmentation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolCommonFragmentationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolCommonFragmentationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolCommonNatTraversalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable NAT-Traversal",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keep_alive_interval": dsschema.Int64Attribute{
				Description: "sending interval for NAT keep-alive packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"udp_checksum_enable": dsschema.BoolAttribute{
				Description: "Enable UDP checksum",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolCommonNatTraversalObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolCommonNatTraversalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceLocationSchema() rsschema.Attribute {
	return IkeGatewayLocationSchema()
}

// Metadata returns the data source type name.
func (d *IkeGatewayDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ike_gateway"
}

// Schema defines the schema for this data source.
func (d *IkeGatewayDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = IkeGatewayDataSourceSchema()
}

// Configure prepares the struct.
func (d *IkeGatewayDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := gateway.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service](d.client, gateway.NewService(d.client), batchSize, specifier, gateway.SpecMatches)
}
func (o *IkeGatewayDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state IkeGatewayDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location gateway.Location

	{
		var terraformLocation IkeGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &gateway.NgfwLocation{}
			var innerLocation IkeGatewayNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation IkeGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation IkeGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &IkeGatewayResource{}
	_ resource.ResourceWithConfigure   = &IkeGatewayResource{}
	_ resource.ResourceWithImportState = &IkeGatewayResource{}
)

func NewIkeGatewayResource() resource.Resource {
	if _, found := resourceFuncMap["panos_ike_gateway"]; !found {
		resourceFuncMap["panos_ike_gateway"] = resourceFuncs{
			CreateImportId: IkeGatewayImportStateCreator,
		}
	}
	return &IkeGatewayResource{}
}

type IkeGatewayResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service]
}

func IkeGatewayResourceLocationSchema() rsschema.Attribute {
	return IkeGatewayLocationSchema()
}

type IkeGatewayResourceModel struct {
	Location       types.Object `tfsdk:"location"`
	Name           types.String `tfsdk:"name"`
	Authentication types.Object `tfsdk:"authentication"`
	Comment        types.String `tfsdk:"comment"`
	Disabled       types.Bool   `tfsdk:"disabled"`
	Ipv6           types.Bool   `tfsdk:"ipv6"`
	LocalAddress   types.Object `tfsdk:"local_address"`
	LocalId        types.Object `tfsdk:"local_id"`
	PeerAddress    types.Object `tfsdk:"peer_address"`
	PeerId         types.Object `tfsdk:"peer_id"`
	Protocol       types.Object `tfsdk:"protocol"`
	ProtocolCommon types.Object `tfsdk:"protocol_common"`
}
type IkeGatewayResourceAuthenticationObject struct {
	Certificate  types.Object `tfsdk:"certificate"`
	PreSharedKey types.Object `tfsdk:"pre_shared_key"`
}
type IkeGatewayResourceAuthenticationCertificateObject struct {
	AllowIdPayloadMismatch     types.Bool   `tfsdk:"allow_id_payload_mismatch"`
	CertificateProfile         types.String `tfsdk:"certificate_profile"`
	LocalCertificate           types.Object `tfsdk:"local_certificate"`
	StrictValidationRevocation types.Bool   `tfsdk:"strict_validation_revocation"`
	UseManagementAsSource      types.Bool   `tfsdk:"use_management_as_source"`
}
type IkeGatewayResourceAuthenticationCertificateLocalCertificateObject struct {
	HashAndUrl types.Object `tfsdk:"hash_and_url"`
	Name       types.String `tfsdk:"name"`
}
type IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject struct {
	BaseUrl types.String `tfsdk:"base_url"`
	Enable  types.Bool   `tfsdk:"enable"`
}
type IkeGatewayResourceAuthenticationPreSharedKeyObject struct {
	Key types.String `tfsdk:"key"`
}
type IkeGatewayResourceLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type IkeGatewayResourceLocalIdObject struct {
	Id   types.String `tfsdk:"id"`
	Type types.String `tfsdk:"type"`
}
type IkeGatewayResourcePeerAddressObject struct {
	Dynamic types.Object `tfsdk:"dynamic"`
	Fqdn    types.String `tfsdk:"fqdn"`
	Ip      types.String `tfsdk:"ip"`
}
type IkeGatewayResourcePeerAddressDynamicObject struct {
}
type IkeGatewayResourcePeerIdObject struct {
	Id       types.String `tfsdk:"id"`
	Matching types.String `tfsdk:"matching"`
	Type     types.String `tfsdk:"type"`
}
type IkeGatewayResourceProtocolObject struct {
	Ikev1   types.Object `tfsdk:"ikev1"`
	Ikev2   types.Object `tfsdk:"ikev2"`
	Version types.String `tfsdk:"version"`
}
type IkeGatewayResourceProtocolIkev1Object struct {
	Dpd              types.Object `tfsdk:"dpd"`
	ExchangeMode     types.String `tfsdk:"exchange_mode"`
	IkeCryptoProfile types.String `tfsdk:"ike_crypto_profile"`
}
type IkeGatewayResourceProtocolIkev1DpdObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	Interval types.Int64 `tfsdk:"interval"`
	Retry    types.Int64 `tfsdk:"retry"`
}
type IkeGatewayResourceProtocolIkev2Object struct {
	Dpd              types.Object `tfsdk:"dpd"`
	IkeCryptoProfile types.String `tfsdk:"ike_crypto_profile"`
	RequireCookie    types.Bool   `tfsdk:"require_cookie"`
}
type IkeGatewayResourceProtocolIkev2DpdObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	Interval types.Int64 `tfsdk:"interval"`
}
type IkeGatewayResourceProtocolCommonObject struct {
	Fragmentation types.Object `tfsdk:"fragmentation"`
	NatTraversal  types.Object `tfsdk:"nat_traversal"`
	PassiveMode   types.Bool   `tfsdk:"passive_mode"`
}
type IkeGatewayResourceProtocolCommonFragmentationObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IkeGatewayResourceProtocolCommonNatTraversalObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	KeepAliveInterval types.Int64 `tfsdk:"keep_alive_interval"`
	UdpChecksumEnable types.Bool  `tfsdk:"udp_checksum_enable"`
}

func (o *IkeGatewayResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func IkeGatewayResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": IkeGatewayResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": IkeGatewayResourceAuthenticationSchema(),

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disabled": rsschema.BoolAttribute{
				Description: "Disable the IKE gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.BoolAttribute{
				Description: "use IPv6 for the IKE gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": IkeGatewayResourceLocalAddressSchema(),

			"local_id": IkeGatewayResourceLocalIdSchema(),

			"peer_address": IkeGatewayResourcePeerAddressSchema(),

			"peer_id": IkeGatewayResourcePeerIdSchema(),

			"protocol": IkeGatewayResourceProtocolSchema(),

			"protocol_common": IkeGatewayResourceProtocolCommonSchema(),
		},
	}
}

func (o *IkeGatewayResourceModel) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate": IkeGatewayResourceAuthenticationCertificateSchema(),

			"pre_shared_key": IkeGatewayResourceAuthenticationPreSharedKeySchema(),
		},
	}
}

func (o *IkeGatewayResourceAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationCertificateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"allow_id_payload_mismatch": rsschema.BoolAttribute{
				Description: "Permit peer identification and certificate payload identification mismatch",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for certificate valdiation during IKE negotiation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": IkeGatewayResourceAuthenticationCertificateLocalCertificateSchema(),

			"strict_validation_revocation": rsschema.BoolAttribute{
				Description: "Enable strict validation of peer's extended key use",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_management_as_source": rsschema.BoolAttribute{
				Description: "Use management interface IP as source to retrieve http certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationCertificateLocalCertificateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hash_and_url": IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlSchema(),

			"name": rsschema.StringAttribute{
				Description: "Local certificate name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationCertificateLocalCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"base_url": rsschema.StringAttribute{
				Description: "The host and directory part of URL for local certificates(http only)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Use hash-and-url for local certificate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationPreSharedKeySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "the string used as pre-shared key",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationPreSharedKeyObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationPreSharedKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceLocalIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"id": rsschema.StringAttribute{
				Description: "Local ID string",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceLocalIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceLocalIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourcePeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dynamic": IkeGatewayResourcePeerAddressDynamicSchema(),

			"fqdn": rsschema.StringAttribute{
				Description: "peer gateway FQDN name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "peer gateway has static IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourcePeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourcePeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourcePeerAddressDynamicSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IkeGatewayResourcePeerAddressDynamicObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourcePeerAddressDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourcePeerIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"id": rsschema.StringAttribute{
				Description: "Peer ID string",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"matching": rsschema.StringAttribute{
				Description: "Enable peer ID wildcard match for certificate authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("exact"),
			},

			"type": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourcePeerIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourcePeerIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ikev1": IkeGatewayResourceProtocolIkev1Schema(),

			"ikev2": IkeGatewayResourceProtocolIkev2Schema(),

			"version": rsschema.StringAttribute{
				Description: "IKE protocol version",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ikev1"),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dpd": IkeGatewayResourceProtocolIkev1DpdSchema(),

			"exchange_mode": rsschema.StringAttribute{
				Description: "Exchange mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("auto"),
			},

			"ike_crypto_profile": rsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("default"),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev1Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev1DpdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable Dead-Peer-Detection",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "sending interval for probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"retry": rsschema.Int64Attribute{
				Description: "number of retries before disconnection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev1DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev1DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev2Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dpd": IkeGatewayResourceProtocolIkev2DpdSchema(),

			"ike_crypto_profile": rsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("default"),
			},

			"require_cookie": rsschema.BoolAttribute{
				Description: "Require cookie",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev2Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev2DpdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable sending empty information liveness check message",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "delay interval before sending probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev2DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev2DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolCommonSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"fragmentation": IkeGatewayResourceProtocolCommonFragmentationSchema(),

			"nat_traversal": IkeGatewayResourceProtocolCommonNatTraversalSchema(),

			"passive_mode": rsschema.BoolAttribute{
				Description: "Enable passive mode (responder only)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolCommonObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolCommonSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolCommonFragmentationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable IKE fragmentation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolCommonFragmentationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolCommonFragmentationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolCommonNatTraversalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable NAT-Traversal",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keep_alive_interval": rsschema.Int64Attribute{
				Description: "sending interval for NAT keep-alive packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"udp_checksum_enable": rsschema.BoolAttribute{
				Description: "Enable UDP checksum",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolCommonNatTraversalObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolCommonNatTraversalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *IkeGatewayResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ike_gateway"
}

func (o *IkeGatewayResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = IkeGatewayResourceSchema()
}

// </ResourceSchema>

func (o *IkeGatewayResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := gateway.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service](o.client, gateway.NewService(o.client), batchSize, specifier, gateway.SpecMatches)
}

func (o *IkeGatewayResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj IkeGatewayLocation

	var authenticationObj *IkeGatewayResourceAuthenticationObject

	var localAddressObj *IkeGatewayResourceLocalAddressObject

	var localIdObj *IkeGatewayResourceLocalIdObject

	var peerAddressObj *IkeGatewayResourcePeerAddressObject

	var peerIdObj *IkeGatewayResourcePeerIdObject

	var protocolObj *IkeGatewayResourceProtocolObject

	var protocolCommonObj *IkeGatewayResourceProtocolCommonObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"authentication": types.ObjectType{
			AttrTypes: authenticationObj.AttributeTypes(),
		},
		"comment":  types.StringType,
		"disabled": types.BoolType,
		"ipv6":     types.BoolType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"local_id": types.ObjectType{
			AttrTypes: localIdObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"peer_id": types.ObjectType{
			AttrTypes: peerIdObj.AttributeTypes(),
		},
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
		"protocol_common": types.ObjectType{
			AttrTypes: protocolCommonObj.AttributeTypes(),
		},
	}
}

func (o IkeGatewayResourceModel) AncestorName() string {
	return ""
}

func (o IkeGatewayResourceModel) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceAuthenticationObject) AttributeTypes() map[string]attr.Type {

	var certificateObj *IkeGatewayResourceAuthenticationCertificateObject

	var preSharedKeyObj *IkeGatewayResourceAuthenticationPreSharedKeyObject
	return map[string]attr.Type{
		"certificate": types.ObjectType{
			AttrTypes: certificateObj.AttributeTypes(),
		},
		"pre_shared_key": types.ObjectType{
			AttrTypes: preSharedKeyObj.AttributeTypes(),
		},
	}
}

func (o IkeGatewayResourceAuthenticationObject) AncestorName() string {
	return "authentication"
}

func (o IkeGatewayResourceAuthenticationObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceAuthenticationCertificateObject) AttributeTypes() map[string]attr.Type {

	var localCertificateObj *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject

	return map[string]attr.Type{
		"allow_id_payload_mismatch": types.BoolType,
		"certificate_profile":       types.StringType,
		"local_certificate": types.ObjectType{
			AttrTypes: localCertificateObj.AttributeTypes(),
		},
		"strict_validation_revocation": types.BoolType,
		"use_management_as_source":     types.BoolType,
	}
}

func (o IkeGatewayResourceAuthenticationCertificateObject) AncestorName() string {
	return "certificate"
}

func (o IkeGatewayResourceAuthenticationCertificateObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) AttributeTypes() map[string]attr.Type {

	var hashAndUrlObj *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject

	return map[string]attr.Type{
		"hash_and_url": types.ObjectType{
			AttrTypes: hashAndUrlObj.AttributeTypes(),
		},
		"name": types.StringType,
	}
}

func (o IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) AncestorName() string {
	return "local-certificate"
}

func (o IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"base_url": types.StringType,
		"enable":   types.BoolType,
	}
}

func (o IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) AncestorName() string {
	return "hash-and-url"
}

func (o IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceAuthenticationPreSharedKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IkeGatewayResourceAuthenticationPreSharedKeyObject) AncestorName() string {
	return "pre-shared-key"
}

func (o IkeGatewayResourceAuthenticationPreSharedKeyObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}

func (o IkeGatewayResourceLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o IkeGatewayResourceLocalAddressObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceLocalIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"id":   types.StringType,
		"type": types.StringType,
	}
}

func (o IkeGatewayResourceLocalIdObject) AncestorName() string {
	return "local-id"
}

func (o IkeGatewayResourceLocalIdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourcePeerAddressObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *IkeGatewayResourcePeerAddressDynamicObject

	return map[string]attr.Type{
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"fqdn": types.StringType,
		"ip":   types.StringType,
	}
}

func (o IkeGatewayResourcePeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o IkeGatewayResourcePeerAddressObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourcePeerAddressDynamicObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IkeGatewayResourcePeerAddressDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o IkeGatewayResourcePeerAddressDynamicObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourcePeerIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"id":       types.StringType,
		"matching": types.StringType,
		"type":     types.StringType,
	}
}

func (o IkeGatewayResourcePeerIdObject) AncestorName() string {
	return "peer-id"
}

func (o IkeGatewayResourcePeerIdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolObject) AttributeTypes() map[string]attr.Type {

	var ikev1Obj *IkeGatewayResourceProtocolIkev1Object

	var ikev2Obj *IkeGatewayResourceProtocolIkev2Object

	return map[string]attr.Type{
		"ikev1": types.ObjectType{
			AttrTypes: ikev1Obj.AttributeTypes(),
		},
		"ikev2": types.ObjectType{
			AttrTypes: ikev2Obj.AttributeTypes(),
		},
		"version": types.StringType,
	}
}

func (o IkeGatewayResourceProtocolObject) AncestorName() string {
	return "protocol"
}

func (o IkeGatewayResourceProtocolObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolIkev1Object) AttributeTypes() map[string]attr.Type {

	var dpdObj *IkeGatewayResourceProtocolIkev1DpdObject

	return map[string]attr.Type{
		"dpd": types.ObjectType{
			AttrTypes: dpdObj.AttributeTypes(),
		},
		"exchange_mode":      types.StringType,
		"ike_crypto_profile": types.StringType,
	}
}

func (o IkeGatewayResourceProtocolIkev1Object) AncestorName() string {
	return "ikev1"
}

func (o IkeGatewayResourceProtocolIkev1Object) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolIkev1DpdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":   types.BoolType,
		"interval": types.Int64Type,
		"retry":    types.Int64Type,
	}
}

func (o IkeGatewayResourceProtocolIkev1DpdObject) AncestorName() string {
	return "dpd"
}

func (o IkeGatewayResourceProtocolIkev1DpdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolIkev2Object) AttributeTypes() map[string]attr.Type {

	var dpdObj *IkeGatewayResourceProtocolIkev2DpdObject

	return map[string]attr.Type{
		"dpd": types.ObjectType{
			AttrTypes: dpdObj.AttributeTypes(),
		},
		"ike_crypto_profile": types.StringType,
		"require_cookie":     types.BoolType,
	}
}

func (o IkeGatewayResourceProtocolIkev2Object) AncestorName() string {
	return "ikev2"
}

func (o IkeGatewayResourceProtocolIkev2Object) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolIkev2DpdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":   types.BoolType,
		"interval": types.Int64Type,
	}
}

func (o IkeGatewayResourceProtocolIkev2DpdObject) AncestorName() string {
	return "dpd"
}

func (o IkeGatewayResourceProtocolIkev2DpdObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolCommonObject) AttributeTypes() map[string]attr.Type {

	var fragmentationObj *IkeGatewayResourceProtocolCommonFragmentationObject

	var natTraversalObj *IkeGatewayResourceProtocolCommonNatTraversalObject

	return map[string]attr.Type{
		"fragmentation": types.ObjectType{
			AttrTypes: fragmentationObj.AttributeTypes(),
		},
		"nat_traversal": types.ObjectType{
			AttrTypes: natTraversalObj.AttributeTypes(),
		},
		"passive_mode": types.BoolType,
	}
}

func (o IkeGatewayResourceProtocolCommonObject) AncestorName() string {
	return "protocol-common"
}

func (o IkeGatewayResourceProtocolCommonObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolCommonFragmentationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable": types.BoolType,
	}
}

func (o IkeGatewayResourceProtocolCommonFragmentationObject) AncestorName() string {
	return "fragmentation"
}

func (o IkeGatewayResourceProtocolCommonFragmentationObject) EntryName() *string {
	return nil
}
func (o *IkeGatewayResourceProtocolCommonNatTraversalObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":              types.BoolType,
		"keep_alive_interval": types.Int64Type,
		"udp_checksum_enable": types.BoolType,
	}
}

func (o IkeGatewayResourceProtocolCommonNatTraversalObject) AncestorName() string {
	return "nat-traversal"
}

func (o IkeGatewayResourceProtocolCommonNatTraversalObject) EntryName() *string {
	return nil
}

func (o *IkeGatewayResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *gateway.Authentication
	if !o.Authentication.IsUnknown() && !o.Authentication.IsNull() {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(gateway.Authentication)
		}
		var object *IkeGatewayResourceAuthenticationObject
		diags.Append(o.Authentication.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &authentication_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	var localAddress_entry *gateway.LocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(gateway.LocalAddress)
		}
		var object *IkeGatewayResourceLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localId_entry *gateway.LocalId
	if !o.LocalId.IsUnknown() && !o.LocalId.IsNull() {
		if *obj != nil && (*obj).LocalId != nil {
			localId_entry = (*obj).LocalId
		} else {
			localId_entry = new(gateway.LocalId)
		}
		var object *IkeGatewayResourceLocalIdObject
		diags.Append(o.LocalId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &localId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *gateway.PeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(gateway.PeerAddress)
		}
		var object *IkeGatewayResourcePeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerId_entry *gateway.PeerId
	if !o.PeerId.IsUnknown() && !o.PeerId.IsNull() {
		if *obj != nil && (*obj).PeerId != nil {
			peerId_entry = (*obj).PeerId
		} else {
			peerId_entry = new(gateway.PeerId)
		}
		var object *IkeGatewayResourcePeerIdObject
		diags.Append(o.PeerId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &peerId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *gateway.Protocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(gateway.Protocol)
		}
		var object *IkeGatewayResourceProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocolCommon_entry *gateway.ProtocolCommon
	if !o.ProtocolCommon.IsUnknown() && !o.ProtocolCommon.IsNull() {
		if *obj != nil && (*obj).ProtocolCommon != nil {
			protocolCommon_entry = (*obj).ProtocolCommon
		} else {
			protocolCommon_entry = new(gateway.ProtocolCommon)
		}
		var object *IkeGatewayResourceProtocolCommonObject
		diags.Append(o.ProtocolCommon.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &protocolCommon_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_entry
	(*obj).Comment = comment_value
	(*obj).Disabled = disabled_value
	(*obj).Ipv6 = ipv6_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).LocalId = localId_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).PeerId = peerId_entry
	(*obj).Protocol = protocol_entry
	(*obj).ProtocolCommon = protocolCommon_entry

	return diags
}
func (o *IkeGatewayResourceAuthenticationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Authentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var certificate_entry *gateway.AuthenticationCertificate
	if !o.Certificate.IsUnknown() && !o.Certificate.IsNull() {
		if *obj != nil && (*obj).Certificate != nil {
			certificate_entry = (*obj).Certificate
		} else {
			certificate_entry = new(gateway.AuthenticationCertificate)
		}
		var object *IkeGatewayResourceAuthenticationCertificateObject
		diags.Append(o.Certificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &certificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var preSharedKey_entry *gateway.AuthenticationPreSharedKey
	if !o.PreSharedKey.IsUnknown() && !o.PreSharedKey.IsNull() {
		if *obj != nil && (*obj).PreSharedKey != nil {
			preSharedKey_entry = (*obj).PreSharedKey
		} else {
			preSharedKey_entry = new(gateway.AuthenticationPreSharedKey)
		}
		var object *IkeGatewayResourceAuthenticationPreSharedKeyObject
		diags.Append(o.PreSharedKey.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &preSharedKey_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Authentication)
	}
	(*obj).Certificate = certificate_entry
	(*obj).PreSharedKey = preSharedKey_entry

	return diags
}
func (o *IkeGatewayResourceAuthenticationCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowIdPayloadMismatch_value := o.AllowIdPayloadMismatch.ValueBoolPointer()
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var localCertificate_entry *gateway.AuthenticationCertificateLocalCertificate
	if !o.LocalCertificate.IsUnknown() && !o.LocalCertificate.IsNull() {
		if *obj != nil && (*obj).LocalCertificate != nil {
			localCertificate_entry = (*obj).LocalCertificate
		} else {
			localCertificate_entry = new(gateway.AuthenticationCertificateLocalCertificate)
		}
		var object *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject
		diags.Append(o.LocalCertificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localCertificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	strictValidationRevocation_value := o.StrictValidationRevocation.ValueBoolPointer()
	useManagementAsSource_value := o.UseManagementAsSource.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificate)
	}
	(*obj).AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_entry
	(*obj).StrictValidationRevocation = strictValidationRevocation_value
	(*obj).UseManagementAsSource = useManagementAsSource_value

	return diags
}
func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationCertificateLocalCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var hashAndUrl_entry *gateway.AuthenticationCertificateLocalCertificateHashAndUrl
	if !o.HashAndUrl.IsUnknown() && !o.HashAndUrl.IsNull() {
		if *obj != nil && (*obj).HashAndUrl != nil {
			hashAndUrl_entry = (*obj).HashAndUrl
		} else {
			hashAndUrl_entry = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
		}
		var object *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject
		diags.Append(o.HashAndUrl.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hashAndUrl_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	name_value := o.Name.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificate)
	}
	(*obj).HashAndUrl = hashAndUrl_entry
	(*obj).Name = name_value

	return diags
}
func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationCertificateLocalCertificateHashAndUrl, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	baseUrl_value := o.BaseUrl.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
	}
	(*obj).BaseUrl = baseUrl_value
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayResourceAuthenticationPreSharedKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.AuthenticationPreSharedKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.Key.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		key_value = o.Key.ValueStringPointer()
	}

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationPreSharedKey)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IkeGatewayResourceLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayResourceLocalIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalId)
	}
	(*obj).Id = id_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayResourcePeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.PeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *gateway.PeerAddressDynamic
	if !o.Dynamic.IsUnknown() && !o.Dynamic.IsNull() {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(gateway.PeerAddressDynamic)
		}
		var object *IkeGatewayResourcePeerAddressDynamicObject
		diags.Append(o.Dynamic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	fqdn_value := o.Fqdn.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerAddress)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayResourcePeerAddressDynamicObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.PeerAddressDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(gateway.PeerAddressDynamic)
	}

	return diags
}
func (o *IkeGatewayResourcePeerIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.PeerId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	matching_value := o.Matching.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerId)
	}
	(*obj).Id = id_value
	(*obj).Matching = matching_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayResourceProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikev1_entry *gateway.ProtocolIkev1
	if !o.Ikev1.IsUnknown() && !o.Ikev1.IsNull() {
		if *obj != nil && (*obj).Ikev1 != nil {
			ikev1_entry = (*obj).Ikev1
		} else {
			ikev1_entry = new(gateway.ProtocolIkev1)
		}
		var object *IkeGatewayResourceProtocolIkev1Object
		diags.Append(o.Ikev1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ikev1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ikev2_entry *gateway.ProtocolIkev2
	if !o.Ikev2.IsUnknown() && !o.Ikev2.IsNull() {
		if *obj != nil && (*obj).Ikev2 != nil {
			ikev2_entry = (*obj).Ikev2
		} else {
			ikev2_entry = new(gateway.ProtocolIkev2)
		}
		var object *IkeGatewayResourceProtocolIkev2Object
		diags.Append(o.Ikev2.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ikev2_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	version_value := o.Version.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.Protocol)
	}
	(*obj).Ikev1 = ikev1_entry
	(*obj).Ikev2 = ikev2_entry
	(*obj).Version = version_value

	return diags
}
func (o *IkeGatewayResourceProtocolIkev1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_entry *gateway.ProtocolIkev1Dpd
	if !o.Dpd.IsUnknown() && !o.Dpd.IsNull() {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev1Dpd)
		}
		var object *IkeGatewayResourceProtocolIkev1DpdObject
		diags.Append(o.Dpd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dpd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	exchangeMode_value := o.ExchangeMode.ValueStringPointer()
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1)
	}
	(*obj).Dpd = dpd_entry
	(*obj).ExchangeMode = exchangeMode_value
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}
func (o *IkeGatewayResourceProtocolIkev1DpdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev1Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	retry_value := o.Retry.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value
	(*obj).Retry = retry_value

	return diags
}
func (o *IkeGatewayResourceProtocolIkev2Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_entry *gateway.ProtocolIkev2Dpd
	if !o.Dpd.IsUnknown() && !o.Dpd.IsNull() {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev2Dpd)
		}
		var object *IkeGatewayResourceProtocolIkev2DpdObject
		diags.Append(o.Dpd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dpd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()
	requireCookie_value := o.RequireCookie.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2)
	}
	(*obj).Dpd = dpd_entry
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value
	(*obj).RequireCookie = requireCookie_value

	return diags
}
func (o *IkeGatewayResourceProtocolIkev2DpdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolIkev2Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value

	return diags
}
func (o *IkeGatewayResourceProtocolCommonObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolCommon, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var fragmentation_entry *gateway.ProtocolCommonFragmentation
	if !o.Fragmentation.IsUnknown() && !o.Fragmentation.IsNull() {
		if *obj != nil && (*obj).Fragmentation != nil {
			fragmentation_entry = (*obj).Fragmentation
		} else {
			fragmentation_entry = new(gateway.ProtocolCommonFragmentation)
		}
		var object *IkeGatewayResourceProtocolCommonFragmentationObject
		diags.Append(o.Fragmentation.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &fragmentation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var natTraversal_entry *gateway.ProtocolCommonNatTraversal
	if !o.NatTraversal.IsUnknown() && !o.NatTraversal.IsNull() {
		if *obj != nil && (*obj).NatTraversal != nil {
			natTraversal_entry = (*obj).NatTraversal
		} else {
			natTraversal_entry = new(gateway.ProtocolCommonNatTraversal)
		}
		var object *IkeGatewayResourceProtocolCommonNatTraversalObject
		diags.Append(o.NatTraversal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &natTraversal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	passiveMode_value := o.PassiveMode.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommon)
	}
	(*obj).Fragmentation = fragmentation_entry
	(*obj).NatTraversal = natTraversal_entry
	(*obj).PassiveMode = passiveMode_value

	return diags
}
func (o *IkeGatewayResourceProtocolCommonFragmentationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolCommonFragmentation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonFragmentation)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayResourceProtocolCommonNatTraversalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ProtocolCommonNatTraversal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	keepAliveInterval_value := o.KeepAliveInterval.ValueInt64Pointer()
	udpChecksumEnable_value := o.UdpChecksumEnable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonNatTraversal)
	}
	(*obj).Enable = enable_value
	(*obj).KeepAliveInterval = keepAliveInterval_value
	(*obj).UdpChecksumEnable = udpChecksumEnable_value

	return diags
}

func (o *IkeGatewayResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authentication_obj *IkeGatewayResourceAuthenticationObject
	if o.Authentication.IsNull() {
		authentication_obj = new(IkeGatewayResourceAuthenticationObject)
	} else {
		diags.Append(o.Authentication.As(ctx, &authentication_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authentication_object := types.ObjectNull(authentication_obj.AttributeTypes())
	if obj.Authentication != nil {
		diags.Append(authentication_obj.CopyFromPango(ctx, client, ancestors, obj.Authentication, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authentication_object, diags_tmp = types.ObjectValueFrom(ctx, authentication_obj.AttributeTypes(), authentication_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *IkeGatewayResourceLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(IkeGatewayResourceLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, ancestors, obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localId_obj *IkeGatewayResourceLocalIdObject
	if o.LocalId.IsNull() {
		localId_obj = new(IkeGatewayResourceLocalIdObject)
	} else {
		diags.Append(o.LocalId.As(ctx, &localId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localId_object := types.ObjectNull(localId_obj.AttributeTypes())
	if obj.LocalId != nil {
		diags.Append(localId_obj.CopyFromPango(ctx, client, ancestors, obj.LocalId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localId_object, diags_tmp = types.ObjectValueFrom(ctx, localId_obj.AttributeTypes(), localId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *IkeGatewayResourcePeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(IkeGatewayResourcePeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, ancestors, obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerId_obj *IkeGatewayResourcePeerIdObject
	if o.PeerId.IsNull() {
		peerId_obj = new(IkeGatewayResourcePeerIdObject)
	} else {
		diags.Append(o.PeerId.As(ctx, &peerId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerId_object := types.ObjectNull(peerId_obj.AttributeTypes())
	if obj.PeerId != nil {
		diags.Append(peerId_obj.CopyFromPango(ctx, client, ancestors, obj.PeerId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerId_object, diags_tmp = types.ObjectValueFrom(ctx, peerId_obj.AttributeTypes(), peerId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var protocol_obj *IkeGatewayResourceProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(IkeGatewayResourceProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, ancestors, obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var protocolCommon_obj *IkeGatewayResourceProtocolCommonObject
	if o.ProtocolCommon.IsNull() {
		protocolCommon_obj = new(IkeGatewayResourceProtocolCommonObject)
	} else {
		diags.Append(o.ProtocolCommon.As(ctx, &protocolCommon_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocolCommon_object := types.ObjectNull(protocolCommon_obj.AttributeTypes())
	if obj.ProtocolCommon != nil {
		diags.Append(protocolCommon_obj.CopyFromPango(ctx, client, ancestors, obj.ProtocolCommon, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocolCommon_object, diags_tmp = types.ObjectValueFrom(ctx, protocolCommon_obj.AttributeTypes(), protocolCommon_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_object
	o.Comment = comment_value
	o.Disabled = disabled_value
	o.Ipv6 = ipv6_value
	o.LocalAddress = localAddress_object
	o.LocalId = localId_object
	o.PeerAddress = peerAddress_object
	o.PeerId = peerId_object
	o.Protocol = protocol_object
	o.ProtocolCommon = protocolCommon_object

	return diags
}

func (o *IkeGatewayResourceAuthenticationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Authentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificate_obj *IkeGatewayResourceAuthenticationCertificateObject
	if o.Certificate.IsNull() {
		certificate_obj = new(IkeGatewayResourceAuthenticationCertificateObject)
	} else {
		diags.Append(o.Certificate.As(ctx, &certificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	certificate_object := types.ObjectNull(certificate_obj.AttributeTypes())
	if obj.Certificate != nil {
		diags.Append(certificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Certificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		certificate_object, diags_tmp = types.ObjectValueFrom(ctx, certificate_obj.AttributeTypes(), certificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var preSharedKey_obj *IkeGatewayResourceAuthenticationPreSharedKeyObject
	if o.PreSharedKey.IsNull() {
		preSharedKey_obj = new(IkeGatewayResourceAuthenticationPreSharedKeyObject)
	} else {
		diags.Append(o.PreSharedKey.As(ctx, &preSharedKey_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	preSharedKey_object := types.ObjectNull(preSharedKey_obj.AttributeTypes())
	if obj.PreSharedKey != nil {
		diags.Append(preSharedKey_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PreSharedKey, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		preSharedKey_object, diags_tmp = types.ObjectValueFrom(ctx, preSharedKey_obj.AttributeTypes(), preSharedKey_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Certificate = certificate_object
	o.PreSharedKey = preSharedKey_object

	return diags
}

func (o *IkeGatewayResourceAuthenticationCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localCertificate_obj *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject
	if o.LocalCertificate.IsNull() {
		localCertificate_obj = new(IkeGatewayResourceAuthenticationCertificateLocalCertificateObject)
	} else {
		diags.Append(o.LocalCertificate.As(ctx, &localCertificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localCertificate_object := types.ObjectNull(localCertificate_obj.AttributeTypes())
	if obj.LocalCertificate != nil {
		diags.Append(localCertificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalCertificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localCertificate_object, diags_tmp = types.ObjectValueFrom(ctx, localCertificate_obj.AttributeTypes(), localCertificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowIdPayloadMismatch_value types.Bool
	if obj.AllowIdPayloadMismatch != nil {
		allowIdPayloadMismatch_value = types.BoolValue(*obj.AllowIdPayloadMismatch)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var strictValidationRevocation_value types.Bool
	if obj.StrictValidationRevocation != nil {
		strictValidationRevocation_value = types.BoolValue(*obj.StrictValidationRevocation)
	}
	var useManagementAsSource_value types.Bool
	if obj.UseManagementAsSource != nil {
		useManagementAsSource_value = types.BoolValue(*obj.UseManagementAsSource)
	}
	o.AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_object
	o.StrictValidationRevocation = strictValidationRevocation_value
	o.UseManagementAsSource = useManagementAsSource_value

	return diags
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationCertificateLocalCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hashAndUrl_obj *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject
	if o.HashAndUrl.IsNull() {
		hashAndUrl_obj = new(IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject)
	} else {
		diags.Append(o.HashAndUrl.As(ctx, &hashAndUrl_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hashAndUrl_object := types.ObjectNull(hashAndUrl_obj.AttributeTypes())
	if obj.HashAndUrl != nil {
		diags.Append(hashAndUrl_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HashAndUrl, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hashAndUrl_object, diags_tmp = types.ObjectValueFrom(ctx, hashAndUrl_obj.AttributeTypes(), hashAndUrl_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var name_value types.String
	if obj.Name != nil {
		name_value = types.StringValue(*obj.Name)
	}
	o.HashAndUrl = hashAndUrl_object
	o.Name = name_value

	return diags
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationCertificateLocalCertificateHashAndUrl, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var baseUrl_value types.String
	if obj.BaseUrl != nil {
		baseUrl_value = types.StringValue(*obj.BaseUrl)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.BaseUrl = baseUrl_value
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayResourceAuthenticationPreSharedKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.AuthenticationPreSharedKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.Key != evFromState {
			key_value = types.StringPointerValue(obj.Key)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			key_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.Key)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	o.Key = key_value

	return diags
}

func (o *IkeGatewayResourceLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *IkeGatewayResourceLocalIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Id = id_value
	o.Type = type_value

	return diags
}

func (o *IkeGatewayResourcePeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.PeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dynamic_obj *IkeGatewayResourcePeerAddressDynamicObject
	if o.Dynamic.IsNull() {
		dynamic_obj = new(IkeGatewayResourcePeerAddressDynamicObject)
	} else {
		diags.Append(o.Dynamic.As(ctx, &dynamic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamic_object := types.ObjectNull(dynamic_obj.AttributeTypes())
	if obj.Dynamic != nil {
		diags.Append(dynamic_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamic_object, diags_tmp = types.ObjectValueFrom(ctx, dynamic_obj.AttributeTypes(), dynamic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Dynamic = dynamic_object
	o.Fqdn = fqdn_value
	o.Ip = ip_value

	return diags
}

func (o *IkeGatewayResourcePeerAddressDynamicObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.PeerAddressDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IkeGatewayResourcePeerIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.PeerId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	var matching_value types.String
	if obj.Matching != nil {
		matching_value = types.StringValue(*obj.Matching)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Id = id_value
	o.Matching = matching_value
	o.Type = type_value

	return diags
}

func (o *IkeGatewayResourceProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ikev1_obj *IkeGatewayResourceProtocolIkev1Object
	if o.Ikev1.IsNull() {
		ikev1_obj = new(IkeGatewayResourceProtocolIkev1Object)
	} else {
		diags.Append(o.Ikev1.As(ctx, &ikev1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ikev1_object := types.ObjectNull(ikev1_obj.AttributeTypes())
	if obj.Ikev1 != nil {
		diags.Append(ikev1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ikev1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ikev1_object, diags_tmp = types.ObjectValueFrom(ctx, ikev1_obj.AttributeTypes(), ikev1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ikev2_obj *IkeGatewayResourceProtocolIkev2Object
	if o.Ikev2.IsNull() {
		ikev2_obj = new(IkeGatewayResourceProtocolIkev2Object)
	} else {
		diags.Append(o.Ikev2.As(ctx, &ikev2_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ikev2_object := types.ObjectNull(ikev2_obj.AttributeTypes())
	if obj.Ikev2 != nil {
		diags.Append(ikev2_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ikev2, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ikev2_object, diags_tmp = types.ObjectValueFrom(ctx, ikev2_obj.AttributeTypes(), ikev2_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	o.Ikev1 = ikev1_object
	o.Ikev2 = ikev2_object
	o.Version = version_value

	return diags
}

func (o *IkeGatewayResourceProtocolIkev1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dpd_obj *IkeGatewayResourceProtocolIkev1DpdObject
	if o.Dpd.IsNull() {
		dpd_obj = new(IkeGatewayResourceProtocolIkev1DpdObject)
	} else {
		diags.Append(o.Dpd.As(ctx, &dpd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dpd_object := types.ObjectNull(dpd_obj.AttributeTypes())
	if obj.Dpd != nil {
		diags.Append(dpd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dpd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dpd_object, diags_tmp = types.ObjectValueFrom(ctx, dpd_obj.AttributeTypes(), dpd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var exchangeMode_value types.String
	if obj.ExchangeMode != nil {
		exchangeMode_value = types.StringValue(*obj.ExchangeMode)
	}
	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	o.Dpd = dpd_object
	o.ExchangeMode = exchangeMode_value
	o.IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}

func (o *IkeGatewayResourceProtocolIkev1DpdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev1Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var retry_value types.Int64
	if obj.Retry != nil {
		retry_value = types.Int64Value(*obj.Retry)
	}
	o.Enable = enable_value
	o.Interval = interval_value
	o.Retry = retry_value

	return diags
}

func (o *IkeGatewayResourceProtocolIkev2Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dpd_obj *IkeGatewayResourceProtocolIkev2DpdObject
	if o.Dpd.IsNull() {
		dpd_obj = new(IkeGatewayResourceProtocolIkev2DpdObject)
	} else {
		diags.Append(o.Dpd.As(ctx, &dpd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dpd_object := types.ObjectNull(dpd_obj.AttributeTypes())
	if obj.Dpd != nil {
		diags.Append(dpd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dpd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dpd_object, diags_tmp = types.ObjectValueFrom(ctx, dpd_obj.AttributeTypes(), dpd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	var requireCookie_value types.Bool
	if obj.RequireCookie != nil {
		requireCookie_value = types.BoolValue(*obj.RequireCookie)
	}
	o.Dpd = dpd_object
	o.IkeCryptoProfile = ikeCryptoProfile_value
	o.RequireCookie = requireCookie_value

	return diags
}

func (o *IkeGatewayResourceProtocolIkev2DpdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolIkev2Dpd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Enable = enable_value
	o.Interval = interval_value

	return diags
}

func (o *IkeGatewayResourceProtocolCommonObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolCommon, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var fragmentation_obj *IkeGatewayResourceProtocolCommonFragmentationObject
	if o.Fragmentation.IsNull() {
		fragmentation_obj = new(IkeGatewayResourceProtocolCommonFragmentationObject)
	} else {
		diags.Append(o.Fragmentation.As(ctx, &fragmentation_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	fragmentation_object := types.ObjectNull(fragmentation_obj.AttributeTypes())
	if obj.Fragmentation != nil {
		diags.Append(fragmentation_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Fragmentation, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		fragmentation_object, diags_tmp = types.ObjectValueFrom(ctx, fragmentation_obj.AttributeTypes(), fragmentation_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var natTraversal_obj *IkeGatewayResourceProtocolCommonNatTraversalObject
	if o.NatTraversal.IsNull() {
		natTraversal_obj = new(IkeGatewayResourceProtocolCommonNatTraversalObject)
	} else {
		diags.Append(o.NatTraversal.As(ctx, &natTraversal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	natTraversal_object := types.ObjectNull(natTraversal_obj.AttributeTypes())
	if obj.NatTraversal != nil {
		diags.Append(natTraversal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NatTraversal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		natTraversal_object, diags_tmp = types.ObjectValueFrom(ctx, natTraversal_obj.AttributeTypes(), natTraversal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var passiveMode_value types.Bool
	if obj.PassiveMode != nil {
		passiveMode_value = types.BoolValue(*obj.PassiveMode)
	}
	o.Fragmentation = fragmentation_object
	o.NatTraversal = natTraversal_object
	o.PassiveMode = passiveMode_value

	return diags
}

func (o *IkeGatewayResourceProtocolCommonFragmentationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolCommonFragmentation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayResourceProtocolCommonNatTraversalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ProtocolCommonNatTraversal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var keepAliveInterval_value types.Int64
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.Int64Value(*obj.KeepAliveInterval)
	}
	var udpChecksumEnable_value types.Bool
	if obj.UdpChecksumEnable != nil {
		udpChecksumEnable_value = types.BoolValue(*obj.UdpChecksumEnable)
	}
	o.Enable = enable_value
	o.KeepAliveInterval = keepAliveInterval_value
	o.UdpChecksumEnable = udpChecksumEnable_value

	return diags
}

func (o *IkeGatewayResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *IkeGatewayResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location gateway.Location

	{
		var terraformLocation IkeGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &gateway.NgfwLocation{}
			var innerLocation IkeGatewayNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation IkeGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation IkeGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *gateway.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *IkeGatewayResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location gateway.Location

	{
		var terraformLocation IkeGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &gateway.NgfwLocation{}
			var innerLocation IkeGatewayNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation IkeGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation IkeGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *IkeGatewayResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location gateway.Location

	{
		var terraformLocation IkeGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &gateway.NgfwLocation{}
			var innerLocation IkeGatewayNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation IkeGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation IkeGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := o.manager.Read(ctx, location, components, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := o.manager.Update(ctx, location, components, obj, obj.Name)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *IkeGatewayResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location gateway.Location

	{
		var terraformLocation IkeGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &gateway.NgfwLocation{}
			var innerLocation IkeGatewayNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation IkeGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation IkeGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type IkeGatewayImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o IkeGatewayImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *IkeGatewayLocation `json:"location"`
		Name     *string             `json:"name"`
	}
	var location_object *IkeGatewayLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *IkeGatewayLocation `json:"location"`
		Name     *string             `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func IkeGatewayImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := IkeGatewayImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *IkeGatewayResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj IkeGatewayImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type IkeGatewayNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type IkeGatewayTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type IkeGatewayTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type IkeGatewayLocation struct {
	Ngfw          types.Object `tfsdk:"ngfw"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func IkeGatewayLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o IkeGatewayNgfwLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IkeGatewayTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IkeGatewayTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IkeGatewayLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Ngfw          *IkeGatewayNgfwLocation          `json:"ngfw,omitempty"`
		Template      *IkeGatewayTemplateLocation      `json:"template,omitempty"`
		TemplateStack *IkeGatewayTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var ngfw_object *IkeGatewayNgfwLocation
	{
		diags := o.Ngfw.As(context.TODO(), &ngfw_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal ngfw into JSON document", diags.Errors())
		}
	}
	var template_object *IkeGatewayTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *IkeGatewayTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Ngfw:          ngfw_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Ngfw          *IkeGatewayNgfwLocation          `json:"ngfw,omitempty"`
		Template      *IkeGatewayTemplateLocation      `json:"template,omitempty"`
		TemplateStack *IkeGatewayTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var ngfw_object types.Object
	{
		var diags_tmp diag.Diagnostics
		ngfw_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Ngfw.AttributeTypes(), shadow.Ngfw)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into ngfw", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.Ngfw = ngfw_object
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *IkeGatewayNgfwLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *IkeGatewayTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *IkeGatewayTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *IkeGatewayLocation) AttributeTypes() map[string]attr.Type {
	var ngfwObj IkeGatewayNgfwLocation
	var templateObj IkeGatewayTemplateLocation
	var templateStackObj IkeGatewayTemplateStackLocation
	return map[string]attr.Type{
		"ngfw": types.ObjectType{
			AttrTypes: ngfwObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
