package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/crypto/ike/gateway"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &IkeGatewayDataSource{}
	_ datasource.DataSourceWithConfigure = &IkeGatewayDataSource{}
)

func NewIkeGatewayDataSource() datasource.DataSource {
	return &IkeGatewayDataSource{}
}

type IkeGatewayDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service]
}

type IkeGatewayDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type IkeGatewayDataSourceModel struct {
	Location       IkeGatewayLocation                        `tfsdk:"location"`
	Name           types.String                              `tfsdk:"name"`
	Authentication *IkeGatewayDataSourceAuthenticationObject `tfsdk:"authentication"`
	Comment        types.String                              `tfsdk:"comment"`
	Disabled       types.Bool                                `tfsdk:"disabled"`
	Ipv6           types.Bool                                `tfsdk:"ipv6"`
	LocalId        *IkeGatewayDataSourceLocalIdObject        `tfsdk:"local_id"`
	PeerAddress    *IkeGatewayDataSourcePeerAddressObject    `tfsdk:"peer_address"`
	LocalAddress   *IkeGatewayDataSourceLocalAddressObject   `tfsdk:"local_address"`
	PeerId         *IkeGatewayDataSourcePeerIdObject         `tfsdk:"peer_id"`
	Protocol       *IkeGatewayDataSourceProtocolObject       `tfsdk:"protocol"`
	ProtocolCommon *IkeGatewayDataSourceProtocolCommonObject `tfsdk:"protocol_common"`
}
type IkeGatewayDataSourceAuthenticationObject struct {
	Certificate  *IkeGatewayDataSourceAuthenticationCertificateObject  `tfsdk:"certificate"`
	PreSharedKey *IkeGatewayDataSourceAuthenticationPreSharedKeyObject `tfsdk:"pre_shared_key"`
}
type IkeGatewayDataSourceAuthenticationCertificateObject struct {
	UseManagementAsSource      types.Bool                                                           `tfsdk:"use_management_as_source"`
	AllowIdPayloadMismatch     types.Bool                                                           `tfsdk:"allow_id_payload_mismatch"`
	CertificateProfile         types.String                                                         `tfsdk:"certificate_profile"`
	LocalCertificate           *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject `tfsdk:"local_certificate"`
	StrictValidationRevocation types.Bool                                                           `tfsdk:"strict_validation_revocation"`
}
type IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject struct {
	HashAndUrl *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject `tfsdk:"hash_and_url"`
	Name       types.String                                                                   `tfsdk:"name"`
}
type IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject struct {
	BaseUrl types.String `tfsdk:"base_url"`
	Enable  types.Bool   `tfsdk:"enable"`
}
type IkeGatewayDataSourceAuthenticationPreSharedKeyObject struct {
	Key types.String `tfsdk:"key"`
}
type IkeGatewayDataSourceLocalIdObject struct {
	Id   types.String `tfsdk:"id"`
	Type types.String `tfsdk:"type"`
}
type IkeGatewayDataSourcePeerAddressObject struct {
	Dynamic *IkeGatewayDataSourcePeerAddressDynamicObject `tfsdk:"dynamic"`
	Fqdn    types.String                                  `tfsdk:"fqdn"`
	Ip      types.String                                  `tfsdk:"ip"`
}
type IkeGatewayDataSourcePeerAddressDynamicObject struct {
}
type IkeGatewayDataSourceLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type IkeGatewayDataSourcePeerIdObject struct {
	Id       types.String `tfsdk:"id"`
	Matching types.String `tfsdk:"matching"`
	Type     types.String `tfsdk:"type"`
}
type IkeGatewayDataSourceProtocolObject struct {
	Ikev1   *IkeGatewayDataSourceProtocolIkev1Object `tfsdk:"ikev1"`
	Ikev2   *IkeGatewayDataSourceProtocolIkev2Object `tfsdk:"ikev2"`
	Version types.String                             `tfsdk:"version"`
}
type IkeGatewayDataSourceProtocolIkev2Object struct {
	Dpd              *IkeGatewayDataSourceProtocolIkev2DpdObject `tfsdk:"dpd"`
	IkeCryptoProfile types.String                                `tfsdk:"ike_crypto_profile"`
	RequireCookie    types.Bool                                  `tfsdk:"require_cookie"`
}
type IkeGatewayDataSourceProtocolIkev2DpdObject struct {
	Interval types.Int64 `tfsdk:"interval"`
	Enable   types.Bool  `tfsdk:"enable"`
}
type IkeGatewayDataSourceProtocolIkev1Object struct {
	Dpd              *IkeGatewayDataSourceProtocolIkev1DpdObject `tfsdk:"dpd"`
	ExchangeMode     types.String                                `tfsdk:"exchange_mode"`
	IkeCryptoProfile types.String                                `tfsdk:"ike_crypto_profile"`
}
type IkeGatewayDataSourceProtocolIkev1DpdObject struct {
	Interval types.Int64 `tfsdk:"interval"`
	Retry    types.Int64 `tfsdk:"retry"`
	Enable   types.Bool  `tfsdk:"enable"`
}
type IkeGatewayDataSourceProtocolCommonObject struct {
	Fragmentation *IkeGatewayDataSourceProtocolCommonFragmentationObject `tfsdk:"fragmentation"`
	NatTraversal  *IkeGatewayDataSourceProtocolCommonNatTraversalObject  `tfsdk:"nat_traversal"`
	PassiveMode   types.Bool                                             `tfsdk:"passive_mode"`
}
type IkeGatewayDataSourceProtocolCommonFragmentationObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IkeGatewayDataSourceProtocolCommonNatTraversalObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	KeepAliveInterval types.Int64 `tfsdk:"keep_alive_interval"`
	UdpChecksumEnable types.Bool  `tfsdk:"udp_checksum_enable"`
}

func (o *IkeGatewayDataSourceModel) CopyToPango(ctx context.Context, obj **gateway.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *gateway.Authentication
	if o.Authentication != nil {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(gateway.Authentication)
		}

		diags.Append(o.Authentication.CopyToPango(ctx, &authentication_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	var localId_entry *gateway.LocalId
	if o.LocalId != nil {
		if *obj != nil && (*obj).LocalId != nil {
			localId_entry = (*obj).LocalId
		} else {
			localId_entry = new(gateway.LocalId)
		}

		diags.Append(o.LocalId.CopyToPango(ctx, &localId_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *gateway.PeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(gateway.PeerAddress)
		}

		diags.Append(o.PeerAddress.CopyToPango(ctx, &peerAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *gateway.LocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(gateway.LocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerId_entry *gateway.PeerId
	if o.PeerId != nil {
		if *obj != nil && (*obj).PeerId != nil {
			peerId_entry = (*obj).PeerId
		} else {
			peerId_entry = new(gateway.PeerId)
		}

		diags.Append(o.PeerId.CopyToPango(ctx, &peerId_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *gateway.Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(gateway.Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocolCommon_entry *gateway.ProtocolCommon
	if o.ProtocolCommon != nil {
		if *obj != nil && (*obj).ProtocolCommon != nil {
			protocolCommon_entry = (*obj).ProtocolCommon
		} else {
			protocolCommon_entry = new(gateway.ProtocolCommon)
		}

		diags.Append(o.ProtocolCommon.CopyToPango(ctx, &protocolCommon_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_entry
	(*obj).Comment = comment_value
	(*obj).Disabled = disabled_value
	(*obj).Ipv6 = ipv6_value
	(*obj).LocalId = localId_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerId = peerId_entry
	(*obj).Protocol = protocol_entry
	(*obj).ProtocolCommon = protocolCommon_entry

	return diags
}
func (o *IkeGatewayDataSourceLocalAddressObject) CopyToPango(ctx context.Context, obj **gateway.LocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayDataSourcePeerIdObject) CopyToPango(ctx context.Context, obj **gateway.PeerId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	matching_value := o.Matching.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerId)
	}
	(*obj).Id = id_value
	(*obj).Matching = matching_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolObject) CopyToPango(ctx context.Context, obj **gateway.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikev1_entry *gateway.ProtocolIkev1
	if o.Ikev1 != nil {
		if *obj != nil && (*obj).Ikev1 != nil {
			ikev1_entry = (*obj).Ikev1
		} else {
			ikev1_entry = new(gateway.ProtocolIkev1)
		}

		diags.Append(o.Ikev1.CopyToPango(ctx, &ikev1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ikev2_entry *gateway.ProtocolIkev2
	if o.Ikev2 != nil {
		if *obj != nil && (*obj).Ikev2 != nil {
			ikev2_entry = (*obj).Ikev2
		} else {
			ikev2_entry = new(gateway.ProtocolIkev2)
		}

		diags.Append(o.Ikev2.CopyToPango(ctx, &ikev2_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	version_value := o.Version.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.Protocol)
	}
	(*obj).Ikev1 = ikev1_entry
	(*obj).Ikev2 = ikev2_entry
	(*obj).Version = version_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev1Object) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_entry *gateway.ProtocolIkev1Dpd
	if o.Dpd != nil {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev1Dpd)
		}

		diags.Append(o.Dpd.CopyToPango(ctx, &dpd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	exchangeMode_value := o.ExchangeMode.ValueStringPointer()
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1)
	}
	(*obj).Dpd = dpd_entry
	(*obj).ExchangeMode = exchangeMode_value
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev1DpdObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev1Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	retry_value := o.Retry.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value
	(*obj).Retry = retry_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev2Object) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	requireCookie_value := o.RequireCookie.ValueBoolPointer()
	var dpd_entry *gateway.ProtocolIkev2Dpd
	if o.Dpd != nil {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev2Dpd)
		}

		diags.Append(o.Dpd.CopyToPango(ctx, &dpd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2)
	}
	(*obj).RequireCookie = requireCookie_value
	(*obj).Dpd = dpd_entry
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolIkev2DpdObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev2Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolCommonObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolCommon, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fragmentation_entry *gateway.ProtocolCommonFragmentation
	if o.Fragmentation != nil {
		if *obj != nil && (*obj).Fragmentation != nil {
			fragmentation_entry = (*obj).Fragmentation
		} else {
			fragmentation_entry = new(gateway.ProtocolCommonFragmentation)
		}

		diags.Append(o.Fragmentation.CopyToPango(ctx, &fragmentation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var natTraversal_entry *gateway.ProtocolCommonNatTraversal
	if o.NatTraversal != nil {
		if *obj != nil && (*obj).NatTraversal != nil {
			natTraversal_entry = (*obj).NatTraversal
		} else {
			natTraversal_entry = new(gateway.ProtocolCommonNatTraversal)
		}

		diags.Append(o.NatTraversal.CopyToPango(ctx, &natTraversal_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	passiveMode_value := o.PassiveMode.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommon)
	}
	(*obj).Fragmentation = fragmentation_entry
	(*obj).NatTraversal = natTraversal_entry
	(*obj).PassiveMode = passiveMode_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolCommonFragmentationObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolCommonFragmentation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonFragmentation)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayDataSourceProtocolCommonNatTraversalObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolCommonNatTraversal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	keepAliveInterval_value := o.KeepAliveInterval.ValueInt64Pointer()
	udpChecksumEnable_value := o.UdpChecksumEnable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonNatTraversal)
	}
	(*obj).Enable = enable_value
	(*obj).KeepAliveInterval = keepAliveInterval_value
	(*obj).UdpChecksumEnable = udpChecksumEnable_value

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationObject) CopyToPango(ctx context.Context, obj **gateway.Authentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var certificate_entry *gateway.AuthenticationCertificate
	if o.Certificate != nil {
		if *obj != nil && (*obj).Certificate != nil {
			certificate_entry = (*obj).Certificate
		} else {
			certificate_entry = new(gateway.AuthenticationCertificate)
		}

		diags.Append(o.Certificate.CopyToPango(ctx, &certificate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var preSharedKey_entry *gateway.AuthenticationPreSharedKey
	if o.PreSharedKey != nil {
		if *obj != nil && (*obj).PreSharedKey != nil {
			preSharedKey_entry = (*obj).PreSharedKey
		} else {
			preSharedKey_entry = new(gateway.AuthenticationPreSharedKey)
		}

		diags.Append(o.PreSharedKey.CopyToPango(ctx, &preSharedKey_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Authentication)
	}
	(*obj).Certificate = certificate_entry
	(*obj).PreSharedKey = preSharedKey_entry

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationCertificateObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	allowIdPayloadMismatch_value := o.AllowIdPayloadMismatch.ValueBoolPointer()
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var localCertificate_entry *gateway.AuthenticationCertificateLocalCertificate
	if o.LocalCertificate != nil {
		if *obj != nil && (*obj).LocalCertificate != nil {
			localCertificate_entry = (*obj).LocalCertificate
		} else {
			localCertificate_entry = new(gateway.AuthenticationCertificateLocalCertificate)
		}

		diags.Append(o.LocalCertificate.CopyToPango(ctx, &localCertificate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	strictValidationRevocation_value := o.StrictValidationRevocation.ValueBoolPointer()
	useManagementAsSource_value := o.UseManagementAsSource.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificate)
	}
	(*obj).AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_entry
	(*obj).StrictValidationRevocation = strictValidationRevocation_value
	(*obj).UseManagementAsSource = useManagementAsSource_value

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationCertificateLocalCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hashAndUrl_entry *gateway.AuthenticationCertificateLocalCertificateHashAndUrl
	if o.HashAndUrl != nil {
		if *obj != nil && (*obj).HashAndUrl != nil {
			hashAndUrl_entry = (*obj).HashAndUrl
		} else {
			hashAndUrl_entry = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
		}

		diags.Append(o.HashAndUrl.CopyToPango(ctx, &hashAndUrl_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	name_value := o.Name.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificate)
	}
	(*obj).HashAndUrl = hashAndUrl_entry
	(*obj).Name = name_value

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationCertificateLocalCertificateHashAndUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	baseUrl_value := o.BaseUrl.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
	}
	(*obj).BaseUrl = baseUrl_value
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayDataSourceAuthenticationPreSharedKeyObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationPreSharedKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationPreSharedKey)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IkeGatewayDataSourceLocalIdObject) CopyToPango(ctx context.Context, obj **gateway.LocalId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalId)
	}
	(*obj).Id = id_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayDataSourcePeerAddressObject) CopyToPango(ctx context.Context, obj **gateway.PeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *gateway.PeerAddressDynamic
	if o.Dynamic != nil {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(gateway.PeerAddressDynamic)
		}

		diags.Append(o.Dynamic.CopyToPango(ctx, &dynamic_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	fqdn_value := o.Fqdn.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerAddress)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayDataSourcePeerAddressDynamicObject) CopyToPango(ctx context.Context, obj **gateway.PeerAddressDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(gateway.PeerAddressDynamic)
	}

	return diags
}

func (o *IkeGatewayDataSourceModel) CopyFromPango(ctx context.Context, obj *gateway.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_object *IkeGatewayDataSourceLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(IkeGatewayDataSourceLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerId_object *IkeGatewayDataSourcePeerIdObject
	if obj.PeerId != nil {
		peerId_object = new(IkeGatewayDataSourcePeerIdObject)

		diags.Append(peerId_object.CopyFromPango(ctx, obj.PeerId, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_object *IkeGatewayDataSourceProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(IkeGatewayDataSourceProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocolCommon_object *IkeGatewayDataSourceProtocolCommonObject
	if obj.ProtocolCommon != nil {
		protocolCommon_object = new(IkeGatewayDataSourceProtocolCommonObject)

		diags.Append(protocolCommon_object.CopyFromPango(ctx, obj.ProtocolCommon, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localId_object *IkeGatewayDataSourceLocalIdObject
	if obj.LocalId != nil {
		localId_object = new(IkeGatewayDataSourceLocalIdObject)

		diags.Append(localId_object.CopyFromPango(ctx, obj.LocalId, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *IkeGatewayDataSourcePeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(IkeGatewayDataSourcePeerAddressObject)

		diags.Append(peerAddress_object.CopyFromPango(ctx, obj.PeerAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var authentication_object *IkeGatewayDataSourceAuthenticationObject
	if obj.Authentication != nil {
		authentication_object = new(IkeGatewayDataSourceAuthenticationObject)

		diags.Append(authentication_object.CopyFromPango(ctx, obj.Authentication, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	o.Name = types.StringValue(obj.Name)
	o.LocalAddress = localAddress_object
	o.PeerId = peerId_object
	o.Protocol = protocol_object
	o.ProtocolCommon = protocolCommon_object
	o.LocalId = localId_object
	o.PeerAddress = peerAddress_object
	o.Authentication = authentication_object
	o.Comment = comment_value
	o.Disabled = disabled_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationObject) CopyFromPango(ctx context.Context, obj *gateway.Authentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var certificate_object *IkeGatewayDataSourceAuthenticationCertificateObject
	if obj.Certificate != nil {
		certificate_object = new(IkeGatewayDataSourceAuthenticationCertificateObject)

		diags.Append(certificate_object.CopyFromPango(ctx, obj.Certificate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var preSharedKey_object *IkeGatewayDataSourceAuthenticationPreSharedKeyObject
	if obj.PreSharedKey != nil {
		preSharedKey_object = new(IkeGatewayDataSourceAuthenticationPreSharedKeyObject)

		diags.Append(preSharedKey_object.CopyFromPango(ctx, obj.PreSharedKey, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Certificate = certificate_object
	o.PreSharedKey = preSharedKey_object

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationCertificateObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var localCertificate_object *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject
	if obj.LocalCertificate != nil {
		localCertificate_object = new(IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject)

		diags.Append(localCertificate_object.CopyFromPango(ctx, obj.LocalCertificate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var allowIdPayloadMismatch_value types.Bool
	if obj.AllowIdPayloadMismatch != nil {
		allowIdPayloadMismatch_value = types.BoolValue(*obj.AllowIdPayloadMismatch)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var strictValidationRevocation_value types.Bool
	if obj.StrictValidationRevocation != nil {
		strictValidationRevocation_value = types.BoolValue(*obj.StrictValidationRevocation)
	}
	var useManagementAsSource_value types.Bool
	if obj.UseManagementAsSource != nil {
		useManagementAsSource_value = types.BoolValue(*obj.UseManagementAsSource)
	}
	o.AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_object
	o.StrictValidationRevocation = strictValidationRevocation_value
	o.UseManagementAsSource = useManagementAsSource_value

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationCertificateLocalCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hashAndUrl_object *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject
	if obj.HashAndUrl != nil {
		hashAndUrl_object = new(IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject)

		diags.Append(hashAndUrl_object.CopyFromPango(ctx, obj.HashAndUrl, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var name_value types.String
	if obj.Name != nil {
		name_value = types.StringValue(*obj.Name)
	}
	o.HashAndUrl = hashAndUrl_object
	o.Name = name_value

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationCertificateLocalCertificateHashAndUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var baseUrl_value types.String
	if obj.BaseUrl != nil {
		baseUrl_value = types.StringValue(*obj.BaseUrl)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.BaseUrl = baseUrl_value
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayDataSourceAuthenticationPreSharedKeyObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationPreSharedKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IkeGatewayDataSourceLocalIdObject) CopyFromPango(ctx context.Context, obj *gateway.LocalId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Id = id_value
	o.Type = type_value

	return diags
}

func (o *IkeGatewayDataSourcePeerAddressObject) CopyFromPango(ctx context.Context, obj *gateway.PeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_object *IkeGatewayDataSourcePeerAddressDynamicObject
	if obj.Dynamic != nil {
		dynamic_object = new(IkeGatewayDataSourcePeerAddressDynamicObject)

		diags.Append(dynamic_object.CopyFromPango(ctx, obj.Dynamic, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Dynamic = dynamic_object
	o.Fqdn = fqdn_value
	o.Ip = ip_value

	return diags
}

func (o *IkeGatewayDataSourcePeerAddressDynamicObject) CopyFromPango(ctx context.Context, obj *gateway.PeerAddressDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IkeGatewayDataSourceLocalAddressObject) CopyFromPango(ctx context.Context, obj *gateway.LocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *IkeGatewayDataSourcePeerIdObject) CopyFromPango(ctx context.Context, obj *gateway.PeerId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	var matching_value types.String
	if obj.Matching != nil {
		matching_value = types.StringValue(*obj.Matching)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Id = id_value
	o.Matching = matching_value
	o.Type = type_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolObject) CopyFromPango(ctx context.Context, obj *gateway.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikev1_object *IkeGatewayDataSourceProtocolIkev1Object
	if obj.Ikev1 != nil {
		ikev1_object = new(IkeGatewayDataSourceProtocolIkev1Object)

		diags.Append(ikev1_object.CopyFromPango(ctx, obj.Ikev1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ikev2_object *IkeGatewayDataSourceProtocolIkev2Object
	if obj.Ikev2 != nil {
		ikev2_object = new(IkeGatewayDataSourceProtocolIkev2Object)

		diags.Append(ikev2_object.CopyFromPango(ctx, obj.Ikev2, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	o.Ikev1 = ikev1_object
	o.Ikev2 = ikev2_object
	o.Version = version_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev1Object) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_object *IkeGatewayDataSourceProtocolIkev1DpdObject
	if obj.Dpd != nil {
		dpd_object = new(IkeGatewayDataSourceProtocolIkev1DpdObject)

		diags.Append(dpd_object.CopyFromPango(ctx, obj.Dpd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var exchangeMode_value types.String
	if obj.ExchangeMode != nil {
		exchangeMode_value = types.StringValue(*obj.ExchangeMode)
	}
	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	o.Dpd = dpd_object
	o.ExchangeMode = exchangeMode_value
	o.IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev1DpdObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev1Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var retry_value types.Int64
	if obj.Retry != nil {
		retry_value = types.Int64Value(*obj.Retry)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Interval = interval_value
	o.Retry = retry_value
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev2Object) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_object *IkeGatewayDataSourceProtocolIkev2DpdObject
	if obj.Dpd != nil {
		dpd_object = new(IkeGatewayDataSourceProtocolIkev2DpdObject)

		diags.Append(dpd_object.CopyFromPango(ctx, obj.Dpd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	var requireCookie_value types.Bool
	if obj.RequireCookie != nil {
		requireCookie_value = types.BoolValue(*obj.RequireCookie)
	}
	o.Dpd = dpd_object
	o.IkeCryptoProfile = ikeCryptoProfile_value
	o.RequireCookie = requireCookie_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolIkev2DpdObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev2Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Enable = enable_value
	o.Interval = interval_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolCommonObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolCommon, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fragmentation_object *IkeGatewayDataSourceProtocolCommonFragmentationObject
	if obj.Fragmentation != nil {
		fragmentation_object = new(IkeGatewayDataSourceProtocolCommonFragmentationObject)

		diags.Append(fragmentation_object.CopyFromPango(ctx, obj.Fragmentation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var natTraversal_object *IkeGatewayDataSourceProtocolCommonNatTraversalObject
	if obj.NatTraversal != nil {
		natTraversal_object = new(IkeGatewayDataSourceProtocolCommonNatTraversalObject)

		diags.Append(natTraversal_object.CopyFromPango(ctx, obj.NatTraversal, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var passiveMode_value types.Bool
	if obj.PassiveMode != nil {
		passiveMode_value = types.BoolValue(*obj.PassiveMode)
	}
	o.Fragmentation = fragmentation_object
	o.NatTraversal = natTraversal_object
	o.PassiveMode = passiveMode_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolCommonFragmentationObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolCommonFragmentation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayDataSourceProtocolCommonNatTraversalObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolCommonNatTraversal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var udpChecksumEnable_value types.Bool
	if obj.UdpChecksumEnable != nil {
		udpChecksumEnable_value = types.BoolValue(*obj.UdpChecksumEnable)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var keepAliveInterval_value types.Int64
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.Int64Value(*obj.KeepAliveInterval)
	}
	o.UdpChecksumEnable = udpChecksumEnable_value
	o.Enable = enable_value
	o.KeepAliveInterval = keepAliveInterval_value

	return diags
}

func IkeGatewayDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": IkeGatewayDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local_address": IkeGatewayDataSourceLocalAddressSchema(),

			"peer_id": IkeGatewayDataSourcePeerIdSchema(),

			"protocol": IkeGatewayDataSourceProtocolSchema(),

			"protocol_common": IkeGatewayDataSourceProtocolCommonSchema(),

			"authentication": IkeGatewayDataSourceAuthenticationSchema(),

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disabled": dsschema.BoolAttribute{
				Description: "Disable the IKE gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.BoolAttribute{
				Description: "use IPv6 for the IKE gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_id": IkeGatewayDataSourceLocalIdSchema(),

			"peer_address": IkeGatewayDataSourcePeerAddressSchema(),
		},
	}
}

func (o *IkeGatewayDataSourceModel) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourcePeerIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"type": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"id": dsschema.StringAttribute{
				Description: "Peer ID string",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"matching": dsschema.StringAttribute{
				Description: "Enable peer ID wildcard match for certificate authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourcePeerIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourcePeerIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"version": dsschema.StringAttribute{
				Description: "IKE protocol version",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ikev1": IkeGatewayDataSourceProtocolIkev1Schema(),

			"ikev2": IkeGatewayDataSourceProtocolIkev2Schema(),
		},
	}
}

func (o *IkeGatewayDataSourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev2Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ike_crypto_profile": dsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"require_cookie": dsschema.BoolAttribute{
				Description: "Require cookie",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dpd": IkeGatewayDataSourceProtocolIkev2DpdSchema(),
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev2Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev2DpdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable sending empty information liveness check message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "delay interval before sending probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev2DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev2DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"exchange_mode": dsschema.StringAttribute{
				Description: "Exchange mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ike_crypto_profile": dsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dpd": IkeGatewayDataSourceProtocolIkev1DpdSchema(),
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev1Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolIkev1DpdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interval": dsschema.Int64Attribute{
				Description: "sending interval for probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retry": dsschema.Int64Attribute{
				Description: "number of retries before disconnection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable Dead-Peer-Detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolIkev1DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolIkev1DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolCommonSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"fragmentation": IkeGatewayDataSourceProtocolCommonFragmentationSchema(),

			"nat_traversal": IkeGatewayDataSourceProtocolCommonNatTraversalSchema(),

			"passive_mode": dsschema.BoolAttribute{
				Description: "Enable passive mode (responder only)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolCommonObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolCommonSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolCommonFragmentationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable IKE fragmentation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolCommonFragmentationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolCommonFragmentationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceProtocolCommonNatTraversalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable NAT-Traversal",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keep_alive_interval": dsschema.Int64Attribute{
				Description: "sending interval for NAT keep-alive packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"udp_checksum_enable": dsschema.BoolAttribute{
				Description: "Enable UDP checksum",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceProtocolCommonNatTraversalObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceProtocolCommonNatTraversalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate": IkeGatewayDataSourceAuthenticationCertificateSchema(),

			"pre_shared_key": IkeGatewayDataSourceAuthenticationPreSharedKeySchema(),
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationCertificateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"strict_validation_revocation": dsschema.BoolAttribute{
				Description: "Enable strict validation of peer's extended key use",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_management_as_source": dsschema.BoolAttribute{
				Description: "Use management interface IP as source to retrieve http certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allow_id_payload_mismatch": dsschema.BoolAttribute{
				Description: "Permit peer identification and certificate payload identification mismatch",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for certificate valdiation during IKE negotiation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": IkeGatewayDataSourceAuthenticationCertificateLocalCertificateSchema(),
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationCertificateLocalCertificateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"hash_and_url": IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlSchema(),

			"name": dsschema.StringAttribute{
				Description: "Local certificate name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationCertificateLocalCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"base_url": dsschema.StringAttribute{
				Description: "The host and directory part of URL for local certificates(http only)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Use hash-and-url for local certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationCertificateLocalCertificateHashAndUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceAuthenticationPreSharedKeySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "the string used as pre-shared key",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceAuthenticationPreSharedKeyObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceAuthenticationPreSharedKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceLocalIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"id": dsschema.StringAttribute{
				Description: "Local ID string",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourceLocalIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourceLocalIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourcePeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dynamic": IkeGatewayDataSourcePeerAddressDynamicSchema(),

			"fqdn": dsschema.StringAttribute{
				Description: "peer gateway FQDN name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "peer gateway has static IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayDataSourcePeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourcePeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourcePeerAddressDynamicSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IkeGatewayDataSourcePeerAddressDynamicObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayDataSourcePeerAddressDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayDataSourceLocationSchema() rsschema.Attribute {
	return IkeGatewayLocationSchema()
}

// Metadata returns the data source type name.
func (d *IkeGatewayDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ike_gateway"
}

// Schema defines the schema for this data source.
func (d *IkeGatewayDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = IkeGatewayDataSourceSchema()
}

// Configure prepares the struct.
func (d *IkeGatewayDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := gateway.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewEntryObjectManager(d.client, gateway.NewService(d.client), specifier, gateway.SpecMatches)
}

func (o *IkeGatewayDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state IkeGatewayDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location gateway.Location

	if savestate.Location.Ngfw != nil {
		location.Ngfw = &gateway.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Template != nil {
		location.Template = &gateway.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &gateway.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &IkeGatewayResource{}
	_ resource.ResourceWithConfigure   = &IkeGatewayResource{}
	_ resource.ResourceWithImportState = &IkeGatewayResource{}
)

func NewIkeGatewayResource() resource.Resource {
	if _, found := resourceFuncMap["panos_ike_gateway"]; !found {
		resourceFuncMap["panos_ike_gateway"] = resourceFuncs{
			CreateImportId: IkeGatewayImportStateCreator,
		}
	}
	return &IkeGatewayResource{}
}

type IkeGatewayResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service]
}

func IkeGatewayResourceLocationSchema() rsschema.Attribute {
	return IkeGatewayLocationSchema()
}

type IkeGatewayResourceModel struct {
	Location       IkeGatewayLocation                      `tfsdk:"location"`
	Name           types.String                            `tfsdk:"name"`
	LocalId        *IkeGatewayResourceLocalIdObject        `tfsdk:"local_id"`
	PeerAddress    *IkeGatewayResourcePeerAddressObject    `tfsdk:"peer_address"`
	Authentication *IkeGatewayResourceAuthenticationObject `tfsdk:"authentication"`
	Comment        types.String                            `tfsdk:"comment"`
	Disabled       types.Bool                              `tfsdk:"disabled"`
	Ipv6           types.Bool                              `tfsdk:"ipv6"`
	LocalAddress   *IkeGatewayResourceLocalAddressObject   `tfsdk:"local_address"`
	PeerId         *IkeGatewayResourcePeerIdObject         `tfsdk:"peer_id"`
	Protocol       *IkeGatewayResourceProtocolObject       `tfsdk:"protocol"`
	ProtocolCommon *IkeGatewayResourceProtocolCommonObject `tfsdk:"protocol_common"`
}
type IkeGatewayResourceLocalIdObject struct {
	Id   types.String `tfsdk:"id"`
	Type types.String `tfsdk:"type"`
}
type IkeGatewayResourcePeerAddressObject struct {
	Dynamic *IkeGatewayResourcePeerAddressDynamicObject `tfsdk:"dynamic"`
	Fqdn    types.String                                `tfsdk:"fqdn"`
	Ip      types.String                                `tfsdk:"ip"`
}
type IkeGatewayResourcePeerAddressDynamicObject struct {
}
type IkeGatewayResourceAuthenticationObject struct {
	PreSharedKey *IkeGatewayResourceAuthenticationPreSharedKeyObject `tfsdk:"pre_shared_key"`
	Certificate  *IkeGatewayResourceAuthenticationCertificateObject  `tfsdk:"certificate"`
}
type IkeGatewayResourceAuthenticationCertificateObject struct {
	AllowIdPayloadMismatch     types.Bool                                                         `tfsdk:"allow_id_payload_mismatch"`
	CertificateProfile         types.String                                                       `tfsdk:"certificate_profile"`
	LocalCertificate           *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject `tfsdk:"local_certificate"`
	StrictValidationRevocation types.Bool                                                         `tfsdk:"strict_validation_revocation"`
	UseManagementAsSource      types.Bool                                                         `tfsdk:"use_management_as_source"`
}
type IkeGatewayResourceAuthenticationCertificateLocalCertificateObject struct {
	HashAndUrl *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject `tfsdk:"hash_and_url"`
	Name       types.String                                                                 `tfsdk:"name"`
}
type IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject struct {
	BaseUrl types.String `tfsdk:"base_url"`
	Enable  types.Bool   `tfsdk:"enable"`
}
type IkeGatewayResourceAuthenticationPreSharedKeyObject struct {
	Key types.String `tfsdk:"key"`
}
type IkeGatewayResourceLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	Ip         types.String `tfsdk:"ip"`
	FloatingIp types.String `tfsdk:"floating_ip"`
}
type IkeGatewayResourcePeerIdObject struct {
	Id       types.String `tfsdk:"id"`
	Matching types.String `tfsdk:"matching"`
	Type     types.String `tfsdk:"type"`
}
type IkeGatewayResourceProtocolObject struct {
	Ikev1   *IkeGatewayResourceProtocolIkev1Object `tfsdk:"ikev1"`
	Ikev2   *IkeGatewayResourceProtocolIkev2Object `tfsdk:"ikev2"`
	Version types.String                           `tfsdk:"version"`
}
type IkeGatewayResourceProtocolIkev1Object struct {
	Dpd              *IkeGatewayResourceProtocolIkev1DpdObject `tfsdk:"dpd"`
	ExchangeMode     types.String                              `tfsdk:"exchange_mode"`
	IkeCryptoProfile types.String                              `tfsdk:"ike_crypto_profile"`
}
type IkeGatewayResourceProtocolIkev1DpdObject struct {
	Retry    types.Int64 `tfsdk:"retry"`
	Enable   types.Bool  `tfsdk:"enable"`
	Interval types.Int64 `tfsdk:"interval"`
}
type IkeGatewayResourceProtocolIkev2Object struct {
	Dpd              *IkeGatewayResourceProtocolIkev2DpdObject `tfsdk:"dpd"`
	IkeCryptoProfile types.String                              `tfsdk:"ike_crypto_profile"`
	RequireCookie    types.Bool                                `tfsdk:"require_cookie"`
}
type IkeGatewayResourceProtocolIkev2DpdObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	Interval types.Int64 `tfsdk:"interval"`
}
type IkeGatewayResourceProtocolCommonObject struct {
	Fragmentation *IkeGatewayResourceProtocolCommonFragmentationObject `tfsdk:"fragmentation"`
	NatTraversal  *IkeGatewayResourceProtocolCommonNatTraversalObject  `tfsdk:"nat_traversal"`
	PassiveMode   types.Bool                                           `tfsdk:"passive_mode"`
}
type IkeGatewayResourceProtocolCommonFragmentationObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IkeGatewayResourceProtocolCommonNatTraversalObject struct {
	KeepAliveInterval types.Int64 `tfsdk:"keep_alive_interval"`
	UdpChecksumEnable types.Bool  `tfsdk:"udp_checksum_enable"`
	Enable            types.Bool  `tfsdk:"enable"`
}

func (r *IkeGatewayResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ike_gateway"
}

func (r *IkeGatewayResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func IkeGatewayResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": IkeGatewayResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local_address": IkeGatewayResourceLocalAddressSchema(),

			"peer_id": IkeGatewayResourcePeerIdSchema(),

			"protocol": IkeGatewayResourceProtocolSchema(),

			"protocol_common": IkeGatewayResourceProtocolCommonSchema(),

			"authentication": IkeGatewayResourceAuthenticationSchema(),

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disabled": rsschema.BoolAttribute{
				Description: "Disable the IKE gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.BoolAttribute{
				Description: "use IPv6 for the IKE gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_id": IkeGatewayResourceLocalIdSchema(),

			"peer_address": IkeGatewayResourcePeerAddressSchema(),
		},
	}
}

func (o *IkeGatewayResourceModel) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourcePeerIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"id": rsschema.StringAttribute{
				Description: "Peer ID string",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"matching": rsschema.StringAttribute{
				Description: "Enable peer ID wildcard match for certificate authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("exact"),
			},

			"type": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourcePeerIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourcePeerIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ikev1": IkeGatewayResourceProtocolIkev1Schema(),

			"ikev2": IkeGatewayResourceProtocolIkev2Schema(),

			"version": rsschema.StringAttribute{
				Description: "IKE protocol version",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ikev1"),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ike_crypto_profile": rsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("default"),
			},

			"dpd": IkeGatewayResourceProtocolIkev1DpdSchema(),

			"exchange_mode": rsschema.StringAttribute{
				Description: "Exchange mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("auto"),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev1Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev1DpdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"retry": rsschema.Int64Attribute{
				Description: "number of retries before disconnection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable Dead-Peer-Detection",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "sending interval for probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev1DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev1DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev2Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"require_cookie": rsschema.BoolAttribute{
				Description: "Require cookie",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dpd": IkeGatewayResourceProtocolIkev2DpdSchema(),

			"ike_crypto_profile": rsschema.StringAttribute{
				Description: "IKE SA crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("default"),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev2Object) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolIkev2DpdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable sending empty information liveness check message",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "delay interval before sending probing packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolIkev2DpdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolIkev2DpdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolCommonSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"fragmentation": IkeGatewayResourceProtocolCommonFragmentationSchema(),

			"nat_traversal": IkeGatewayResourceProtocolCommonNatTraversalSchema(),

			"passive_mode": rsschema.BoolAttribute{
				Description: "Enable passive mode (responder only)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolCommonObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolCommonSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolCommonFragmentationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable IKE fragmentation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolCommonFragmentationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolCommonFragmentationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceProtocolCommonNatTraversalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable NAT-Traversal",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keep_alive_interval": rsschema.Int64Attribute{
				Description: "sending interval for NAT keep-alive packets (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"udp_checksum_enable": rsschema.BoolAttribute{
				Description: "Enable UDP checksum",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceProtocolCommonNatTraversalObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceProtocolCommonNatTraversalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate": IkeGatewayResourceAuthenticationCertificateSchema(),

			"pre_shared_key": IkeGatewayResourceAuthenticationPreSharedKeySchema(),
		},
	}
}

func (o *IkeGatewayResourceAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationCertificateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"allow_id_payload_mismatch": rsschema.BoolAttribute{
				Description: "Permit peer identification and certificate payload identification mismatch",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for certificate valdiation during IKE negotiation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": IkeGatewayResourceAuthenticationCertificateLocalCertificateSchema(),

			"strict_validation_revocation": rsschema.BoolAttribute{
				Description: "Enable strict validation of peer's extended key use",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_management_as_source": rsschema.BoolAttribute{
				Description: "Use management interface IP as source to retrieve http certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationCertificateLocalCertificateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hash_and_url": IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlSchema(),

			"name": rsschema.StringAttribute{
				Description: "Local certificate name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationCertificateLocalCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"base_url": rsschema.StringAttribute{
				Description: "The host and directory part of URL for local certificates(http only)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Use hash-and-url for local certificate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceAuthenticationPreSharedKeySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("certificate"),
				path.MatchRelative().AtParent().AtName("pre_shared_key"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "the string used as pre-shared key",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceAuthenticationPreSharedKeyObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceAuthenticationPreSharedKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourceLocalIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"type": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"id": rsschema.StringAttribute{
				Description: "Local ID string",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourceLocalIdObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourceLocalIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourcePeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "peer gateway has static IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("dynamic"),
						path.MatchRelative().AtParent().AtName("fqdn"),
					}...),
				},
			},

			"dynamic": IkeGatewayResourcePeerAddressDynamicSchema(),

			"fqdn": rsschema.StringAttribute{
				Description: "peer gateway FQDN name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IkeGatewayResourcePeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourcePeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IkeGatewayResourcePeerAddressDynamicSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("fqdn"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IkeGatewayResourcePeerAddressDynamicObject) getTypeFor(name string) attr.Type {
	schema := IkeGatewayResourcePeerAddressDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *IkeGatewayResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = IkeGatewayResourceSchema()
}

// </ResourceSchema>

func (r *IkeGatewayResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := gateway.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewEntryObjectManager(r.client, gateway.NewService(r.client), specifier, gateway.SpecMatches)
}

func (o *IkeGatewayResourceModel) CopyToPango(ctx context.Context, obj **gateway.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_entry *gateway.LocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(gateway.LocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerId_entry *gateway.PeerId
	if o.PeerId != nil {
		if *obj != nil && (*obj).PeerId != nil {
			peerId_entry = (*obj).PeerId
		} else {
			peerId_entry = new(gateway.PeerId)
		}

		diags.Append(o.PeerId.CopyToPango(ctx, &peerId_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *gateway.Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(gateway.Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocolCommon_entry *gateway.ProtocolCommon
	if o.ProtocolCommon != nil {
		if *obj != nil && (*obj).ProtocolCommon != nil {
			protocolCommon_entry = (*obj).ProtocolCommon
		} else {
			protocolCommon_entry = new(gateway.ProtocolCommon)
		}

		diags.Append(o.ProtocolCommon.CopyToPango(ctx, &protocolCommon_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var authentication_entry *gateway.Authentication
	if o.Authentication != nil {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(gateway.Authentication)
		}

		diags.Append(o.Authentication.CopyToPango(ctx, &authentication_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	var localId_entry *gateway.LocalId
	if o.LocalId != nil {
		if *obj != nil && (*obj).LocalId != nil {
			localId_entry = (*obj).LocalId
		} else {
			localId_entry = new(gateway.LocalId)
		}

		diags.Append(o.LocalId.CopyToPango(ctx, &localId_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *gateway.PeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(gateway.PeerAddress)
		}

		diags.Append(o.PeerAddress.CopyToPango(ctx, &peerAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerId = peerId_entry
	(*obj).Protocol = protocol_entry
	(*obj).ProtocolCommon = protocolCommon_entry
	(*obj).Authentication = authentication_entry
	(*obj).Comment = comment_value
	(*obj).Disabled = disabled_value
	(*obj).Ipv6 = ipv6_value
	(*obj).LocalId = localId_entry
	(*obj).PeerAddress = peerAddress_entry

	return diags
}
func (o *IkeGatewayResourceLocalAddressObject) CopyToPango(ctx context.Context, obj **gateway.LocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayResourcePeerIdObject) CopyToPango(ctx context.Context, obj **gateway.PeerId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	matching_value := o.Matching.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerId)
	}
	(*obj).Id = id_value
	(*obj).Matching = matching_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayResourceProtocolObject) CopyToPango(ctx context.Context, obj **gateway.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikev1_entry *gateway.ProtocolIkev1
	if o.Ikev1 != nil {
		if *obj != nil && (*obj).Ikev1 != nil {
			ikev1_entry = (*obj).Ikev1
		} else {
			ikev1_entry = new(gateway.ProtocolIkev1)
		}

		diags.Append(o.Ikev1.CopyToPango(ctx, &ikev1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ikev2_entry *gateway.ProtocolIkev2
	if o.Ikev2 != nil {
		if *obj != nil && (*obj).Ikev2 != nil {
			ikev2_entry = (*obj).Ikev2
		} else {
			ikev2_entry = new(gateway.ProtocolIkev2)
		}

		diags.Append(o.Ikev2.CopyToPango(ctx, &ikev2_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	version_value := o.Version.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.Protocol)
	}
	(*obj).Ikev1 = ikev1_entry
	(*obj).Ikev2 = ikev2_entry
	(*obj).Version = version_value

	return diags
}
func (o *IkeGatewayResourceProtocolIkev1Object) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exchangeMode_value := o.ExchangeMode.ValueStringPointer()
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()
	var dpd_entry *gateway.ProtocolIkev1Dpd
	if o.Dpd != nil {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev1Dpd)
		}

		diags.Append(o.Dpd.CopyToPango(ctx, &dpd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1)
	}
	(*obj).ExchangeMode = exchangeMode_value
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value
	(*obj).Dpd = dpd_entry

	return diags
}
func (o *IkeGatewayResourceProtocolIkev1DpdObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev1Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	retry_value := o.Retry.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev1Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value
	(*obj).Retry = retry_value

	return diags
}
func (o *IkeGatewayResourceProtocolIkev2Object) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	requireCookie_value := o.RequireCookie.ValueBoolPointer()
	var dpd_entry *gateway.ProtocolIkev2Dpd
	if o.Dpd != nil {
		if *obj != nil && (*obj).Dpd != nil {
			dpd_entry = (*obj).Dpd
		} else {
			dpd_entry = new(gateway.ProtocolIkev2Dpd)
		}

		diags.Append(o.Dpd.CopyToPango(ctx, &dpd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ikeCryptoProfile_value := o.IkeCryptoProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2)
	}
	(*obj).RequireCookie = requireCookie_value
	(*obj).Dpd = dpd_entry
	(*obj).IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}
func (o *IkeGatewayResourceProtocolIkev2DpdObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolIkev2Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolIkev2Dpd)
	}
	(*obj).Enable = enable_value
	(*obj).Interval = interval_value

	return diags
}
func (o *IkeGatewayResourceProtocolCommonObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolCommon, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passiveMode_value := o.PassiveMode.ValueBoolPointer()
	var fragmentation_entry *gateway.ProtocolCommonFragmentation
	if o.Fragmentation != nil {
		if *obj != nil && (*obj).Fragmentation != nil {
			fragmentation_entry = (*obj).Fragmentation
		} else {
			fragmentation_entry = new(gateway.ProtocolCommonFragmentation)
		}

		diags.Append(o.Fragmentation.CopyToPango(ctx, &fragmentation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var natTraversal_entry *gateway.ProtocolCommonNatTraversal
	if o.NatTraversal != nil {
		if *obj != nil && (*obj).NatTraversal != nil {
			natTraversal_entry = (*obj).NatTraversal
		} else {
			natTraversal_entry = new(gateway.ProtocolCommonNatTraversal)
		}

		diags.Append(o.NatTraversal.CopyToPango(ctx, &natTraversal_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommon)
	}
	(*obj).PassiveMode = passiveMode_value
	(*obj).Fragmentation = fragmentation_entry
	(*obj).NatTraversal = natTraversal_entry

	return diags
}
func (o *IkeGatewayResourceProtocolCommonFragmentationObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolCommonFragmentation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonFragmentation)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayResourceProtocolCommonNatTraversalObject) CopyToPango(ctx context.Context, obj **gateway.ProtocolCommonNatTraversal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	udpChecksumEnable_value := o.UdpChecksumEnable.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	keepAliveInterval_value := o.KeepAliveInterval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.ProtocolCommonNatTraversal)
	}
	(*obj).UdpChecksumEnable = udpChecksumEnable_value
	(*obj).Enable = enable_value
	(*obj).KeepAliveInterval = keepAliveInterval_value

	return diags
}
func (o *IkeGatewayResourceAuthenticationObject) CopyToPango(ctx context.Context, obj **gateway.Authentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var certificate_entry *gateway.AuthenticationCertificate
	if o.Certificate != nil {
		if *obj != nil && (*obj).Certificate != nil {
			certificate_entry = (*obj).Certificate
		} else {
			certificate_entry = new(gateway.AuthenticationCertificate)
		}

		diags.Append(o.Certificate.CopyToPango(ctx, &certificate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var preSharedKey_entry *gateway.AuthenticationPreSharedKey
	if o.PreSharedKey != nil {
		if *obj != nil && (*obj).PreSharedKey != nil {
			preSharedKey_entry = (*obj).PreSharedKey
		} else {
			preSharedKey_entry = new(gateway.AuthenticationPreSharedKey)
		}

		diags.Append(o.PreSharedKey.CopyToPango(ctx, &preSharedKey_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.Authentication)
	}
	(*obj).Certificate = certificate_entry
	(*obj).PreSharedKey = preSharedKey_entry

	return diags
}
func (o *IkeGatewayResourceAuthenticationPreSharedKeyObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationPreSharedKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationPreSharedKey)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IkeGatewayResourceAuthenticationCertificateObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	allowIdPayloadMismatch_value := o.AllowIdPayloadMismatch.ValueBoolPointer()
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var localCertificate_entry *gateway.AuthenticationCertificateLocalCertificate
	if o.LocalCertificate != nil {
		if *obj != nil && (*obj).LocalCertificate != nil {
			localCertificate_entry = (*obj).LocalCertificate
		} else {
			localCertificate_entry = new(gateway.AuthenticationCertificateLocalCertificate)
		}

		diags.Append(o.LocalCertificate.CopyToPango(ctx, &localCertificate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	strictValidationRevocation_value := o.StrictValidationRevocation.ValueBoolPointer()
	useManagementAsSource_value := o.UseManagementAsSource.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificate)
	}
	(*obj).AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_entry
	(*obj).StrictValidationRevocation = strictValidationRevocation_value
	(*obj).UseManagementAsSource = useManagementAsSource_value

	return diags
}
func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationCertificateLocalCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	name_value := o.Name.ValueStringPointer()
	var hashAndUrl_entry *gateway.AuthenticationCertificateLocalCertificateHashAndUrl
	if o.HashAndUrl != nil {
		if *obj != nil && (*obj).HashAndUrl != nil {
			hashAndUrl_entry = (*obj).HashAndUrl
		} else {
			hashAndUrl_entry = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
		}

		diags.Append(o.HashAndUrl.CopyToPango(ctx, &hashAndUrl_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificate)
	}
	(*obj).Name = name_value
	(*obj).HashAndUrl = hashAndUrl_entry

	return diags
}
func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyToPango(ctx context.Context, obj **gateway.AuthenticationCertificateLocalCertificateHashAndUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	baseUrl_value := o.BaseUrl.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.AuthenticationCertificateLocalCertificateHashAndUrl)
	}
	(*obj).BaseUrl = baseUrl_value
	(*obj).Enable = enable_value

	return diags
}
func (o *IkeGatewayResourceLocalIdObject) CopyToPango(ctx context.Context, obj **gateway.LocalId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	id_value := o.Id.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalId)
	}
	(*obj).Id = id_value
	(*obj).Type = type_value

	return diags
}
func (o *IkeGatewayResourcePeerAddressObject) CopyToPango(ctx context.Context, obj **gateway.PeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *gateway.PeerAddressDynamic
	if o.Dynamic != nil {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(gateway.PeerAddressDynamic)
		}

		diags.Append(o.Dynamic.CopyToPango(ctx, &dynamic_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	fqdn_value := o.Fqdn.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.PeerAddress)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IkeGatewayResourcePeerAddressDynamicObject) CopyToPango(ctx context.Context, obj **gateway.PeerAddressDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(gateway.PeerAddressDynamic)
	}

	return diags
}

func (o *IkeGatewayResourceModel) CopyFromPango(ctx context.Context, obj *gateway.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_object *IkeGatewayResourceAuthenticationObject
	if obj.Authentication != nil {
		authentication_object = new(IkeGatewayResourceAuthenticationObject)

		diags.Append(authentication_object.CopyFromPango(ctx, obj.Authentication, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localId_object *IkeGatewayResourceLocalIdObject
	if obj.LocalId != nil {
		localId_object = new(IkeGatewayResourceLocalIdObject)

		diags.Append(localId_object.CopyFromPango(ctx, obj.LocalId, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *IkeGatewayResourcePeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(IkeGatewayResourcePeerAddressObject)

		diags.Append(peerAddress_object.CopyFromPango(ctx, obj.PeerAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_object *IkeGatewayResourceLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(IkeGatewayResourceLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerId_object *IkeGatewayResourcePeerIdObject
	if obj.PeerId != nil {
		peerId_object = new(IkeGatewayResourcePeerIdObject)

		diags.Append(peerId_object.CopyFromPango(ctx, obj.PeerId, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_object *IkeGatewayResourceProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(IkeGatewayResourceProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocolCommon_object *IkeGatewayResourceProtocolCommonObject
	if obj.ProtocolCommon != nil {
		protocolCommon_object = new(IkeGatewayResourceProtocolCommonObject)

		diags.Append(protocolCommon_object.CopyFromPango(ctx, obj.ProtocolCommon, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_object
	o.Comment = comment_value
	o.Disabled = disabled_value
	o.Ipv6 = ipv6_value
	o.LocalId = localId_object
	o.PeerAddress = peerAddress_object
	o.LocalAddress = localAddress_object
	o.PeerId = peerId_object
	o.Protocol = protocol_object
	o.ProtocolCommon = protocolCommon_object

	return diags
}

func (o *IkeGatewayResourceLocalIdObject) CopyFromPango(ctx context.Context, obj *gateway.LocalId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Id = id_value
	o.Type = type_value

	return diags
}

func (o *IkeGatewayResourcePeerAddressObject) CopyFromPango(ctx context.Context, obj *gateway.PeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_object *IkeGatewayResourcePeerAddressDynamicObject
	if obj.Dynamic != nil {
		dynamic_object = new(IkeGatewayResourcePeerAddressDynamicObject)

		diags.Append(dynamic_object.CopyFromPango(ctx, obj.Dynamic, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Dynamic = dynamic_object
	o.Fqdn = fqdn_value
	o.Ip = ip_value

	return diags
}

func (o *IkeGatewayResourcePeerAddressDynamicObject) CopyFromPango(ctx context.Context, obj *gateway.PeerAddressDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IkeGatewayResourceAuthenticationObject) CopyFromPango(ctx context.Context, obj *gateway.Authentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var certificate_object *IkeGatewayResourceAuthenticationCertificateObject
	if obj.Certificate != nil {
		certificate_object = new(IkeGatewayResourceAuthenticationCertificateObject)

		diags.Append(certificate_object.CopyFromPango(ctx, obj.Certificate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var preSharedKey_object *IkeGatewayResourceAuthenticationPreSharedKeyObject
	if obj.PreSharedKey != nil {
		preSharedKey_object = new(IkeGatewayResourceAuthenticationPreSharedKeyObject)

		diags.Append(preSharedKey_object.CopyFromPango(ctx, obj.PreSharedKey, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Certificate = certificate_object
	o.PreSharedKey = preSharedKey_object

	return diags
}

func (o *IkeGatewayResourceAuthenticationCertificateObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var localCertificate_object *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject
	if obj.LocalCertificate != nil {
		localCertificate_object = new(IkeGatewayResourceAuthenticationCertificateLocalCertificateObject)

		diags.Append(localCertificate_object.CopyFromPango(ctx, obj.LocalCertificate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var allowIdPayloadMismatch_value types.Bool
	if obj.AllowIdPayloadMismatch != nil {
		allowIdPayloadMismatch_value = types.BoolValue(*obj.AllowIdPayloadMismatch)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var strictValidationRevocation_value types.Bool
	if obj.StrictValidationRevocation != nil {
		strictValidationRevocation_value = types.BoolValue(*obj.StrictValidationRevocation)
	}
	var useManagementAsSource_value types.Bool
	if obj.UseManagementAsSource != nil {
		useManagementAsSource_value = types.BoolValue(*obj.UseManagementAsSource)
	}
	o.AllowIdPayloadMismatch = allowIdPayloadMismatch_value
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_object
	o.StrictValidationRevocation = strictValidationRevocation_value
	o.UseManagementAsSource = useManagementAsSource_value

	return diags
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationCertificateLocalCertificate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hashAndUrl_object *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject
	if obj.HashAndUrl != nil {
		hashAndUrl_object = new(IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject)

		diags.Append(hashAndUrl_object.CopyFromPango(ctx, obj.HashAndUrl, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var name_value types.String
	if obj.Name != nil {
		name_value = types.StringValue(*obj.Name)
	}
	o.HashAndUrl = hashAndUrl_object
	o.Name = name_value

	return diags
}

func (o *IkeGatewayResourceAuthenticationCertificateLocalCertificateHashAndUrlObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationCertificateLocalCertificateHashAndUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var baseUrl_value types.String
	if obj.BaseUrl != nil {
		baseUrl_value = types.StringValue(*obj.BaseUrl)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.BaseUrl = baseUrl_value
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayResourceAuthenticationPreSharedKeyObject) CopyFromPango(ctx context.Context, obj *gateway.AuthenticationPreSharedKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IkeGatewayResourcePeerIdObject) CopyFromPango(ctx context.Context, obj *gateway.PeerId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var matching_value types.String
	if obj.Matching != nil {
		matching_value = types.StringValue(*obj.Matching)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	var id_value types.String
	if obj.Id != nil {
		id_value = types.StringValue(*obj.Id)
	}
	o.Matching = matching_value
	o.Type = type_value
	o.Id = id_value

	return diags
}

func (o *IkeGatewayResourceProtocolObject) CopyFromPango(ctx context.Context, obj *gateway.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikev2_object *IkeGatewayResourceProtocolIkev2Object
	if obj.Ikev2 != nil {
		ikev2_object = new(IkeGatewayResourceProtocolIkev2Object)

		diags.Append(ikev2_object.CopyFromPango(ctx, obj.Ikev2, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ikev1_object *IkeGatewayResourceProtocolIkev1Object
	if obj.Ikev1 != nil {
		ikev1_object = new(IkeGatewayResourceProtocolIkev1Object)

		diags.Append(ikev1_object.CopyFromPango(ctx, obj.Ikev1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	o.Ikev2 = ikev2_object
	o.Version = version_value
	o.Ikev1 = ikev1_object

	return diags
}

func (o *IkeGatewayResourceProtocolIkev1Object) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_object *IkeGatewayResourceProtocolIkev1DpdObject
	if obj.Dpd != nil {
		dpd_object = new(IkeGatewayResourceProtocolIkev1DpdObject)

		diags.Append(dpd_object.CopyFromPango(ctx, obj.Dpd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var exchangeMode_value types.String
	if obj.ExchangeMode != nil {
		exchangeMode_value = types.StringValue(*obj.ExchangeMode)
	}
	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	o.Dpd = dpd_object
	o.ExchangeMode = exchangeMode_value
	o.IkeCryptoProfile = ikeCryptoProfile_value

	return diags
}

func (o *IkeGatewayResourceProtocolIkev1DpdObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev1Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var retry_value types.Int64
	if obj.Retry != nil {
		retry_value = types.Int64Value(*obj.Retry)
	}
	o.Enable = enable_value
	o.Interval = interval_value
	o.Retry = retry_value

	return diags
}

func (o *IkeGatewayResourceProtocolIkev2Object) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dpd_object *IkeGatewayResourceProtocolIkev2DpdObject
	if obj.Dpd != nil {
		dpd_object = new(IkeGatewayResourceProtocolIkev2DpdObject)

		diags.Append(dpd_object.CopyFromPango(ctx, obj.Dpd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ikeCryptoProfile_value types.String
	if obj.IkeCryptoProfile != nil {
		ikeCryptoProfile_value = types.StringValue(*obj.IkeCryptoProfile)
	}
	var requireCookie_value types.Bool
	if obj.RequireCookie != nil {
		requireCookie_value = types.BoolValue(*obj.RequireCookie)
	}
	o.Dpd = dpd_object
	o.IkeCryptoProfile = ikeCryptoProfile_value
	o.RequireCookie = requireCookie_value

	return diags
}

func (o *IkeGatewayResourceProtocolIkev2DpdObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolIkev2Dpd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Enable = enable_value
	o.Interval = interval_value

	return diags
}

func (o *IkeGatewayResourceProtocolCommonObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolCommon, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fragmentation_object *IkeGatewayResourceProtocolCommonFragmentationObject
	if obj.Fragmentation != nil {
		fragmentation_object = new(IkeGatewayResourceProtocolCommonFragmentationObject)

		diags.Append(fragmentation_object.CopyFromPango(ctx, obj.Fragmentation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var natTraversal_object *IkeGatewayResourceProtocolCommonNatTraversalObject
	if obj.NatTraversal != nil {
		natTraversal_object = new(IkeGatewayResourceProtocolCommonNatTraversalObject)

		diags.Append(natTraversal_object.CopyFromPango(ctx, obj.NatTraversal, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var passiveMode_value types.Bool
	if obj.PassiveMode != nil {
		passiveMode_value = types.BoolValue(*obj.PassiveMode)
	}
	o.Fragmentation = fragmentation_object
	o.NatTraversal = natTraversal_object
	o.PassiveMode = passiveMode_value

	return diags
}

func (o *IkeGatewayResourceProtocolCommonFragmentationObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolCommonFragmentation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IkeGatewayResourceProtocolCommonNatTraversalObject) CopyFromPango(ctx context.Context, obj *gateway.ProtocolCommonNatTraversal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var udpChecksumEnable_value types.Bool
	if obj.UdpChecksumEnable != nil {
		udpChecksumEnable_value = types.BoolValue(*obj.UdpChecksumEnable)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var keepAliveInterval_value types.Int64
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.Int64Value(*obj.KeepAliveInterval)
	}
	o.UdpChecksumEnable = udpChecksumEnable_value
	o.Enable = enable_value
	o.KeepAliveInterval = keepAliveInterval_value

	return diags
}

func (o *IkeGatewayResourceLocalAddressObject) CopyFromPango(ctx context.Context, obj *gateway.LocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (r *IkeGatewayResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location gateway.Location

	if state.Location.Ngfw != nil {
		location.Ngfw = &gateway.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &gateway.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &gateway.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *gateway.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (o *IkeGatewayResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location gateway.Location

	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &gateway.TemplateStackLocation{

			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
		}
	}
	if savestate.Location.Ngfw != nil {
		location.Ngfw = &gateway.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Template != nil {
		location.Template = &gateway.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *IkeGatewayResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location gateway.Location

	if state.Location.Ngfw != nil {
		location.Ngfw = &gateway.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &gateway.TemplateLocation{

			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &gateway.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj, obj.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *IkeGatewayResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state IkeGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_ike_gateway_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location gateway.Location

	if state.Location.Ngfw != nil {
		location.Ngfw = &gateway.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &gateway.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &gateway.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	err := r.manager.Delete(ctx, location, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

type IkeGatewayImportState struct {
	Location IkeGatewayLocation `json:"location"`
	Name     string             `json:"name"`
}

func IkeGatewayImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location IkeGatewayLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}

	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name string
	switch value := nameAttr.(type) {
	case types.String:
		name = value.ValueString()
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := IkeGatewayImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *IkeGatewayResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj IkeGatewayImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)

}

type IkeGatewayTemplateLocation struct {
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
	PanoramaDevice types.String `tfsdk:"panorama_device"`
}
type IkeGatewayTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type IkeGatewayNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type IkeGatewayLocation struct {
	Template      *IkeGatewayTemplateLocation      `tfsdk:"template"`
	TemplateStack *IkeGatewayTemplateStackLocation `tfsdk:"template_stack"`
	Ngfw          *IkeGatewayNgfwLocation          `tfsdk:"ngfw"`
}

func IkeGatewayLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o IkeGatewayNgfwLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		NgfwDevice *string `json:"ngfw_device"`
	}{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IkeGatewayTemplateLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IkeGatewayTemplateStackLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IkeGatewayLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Ngfw          *IkeGatewayNgfwLocation          `json:"ngfw"`
		Template      *IkeGatewayTemplateLocation      `json:"template"`
		TemplateStack *IkeGatewayTemplateStackLocation `json:"template_stack"`
	}{
		Ngfw:          o.Ngfw,
		Template:      o.Template,
		TemplateStack: o.TemplateStack,
	}

	return json.Marshal(obj)
}

func (o *IkeGatewayLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Ngfw          *IkeGatewayNgfwLocation          `json:"ngfw"`
		Template      *IkeGatewayTemplateLocation      `json:"template"`
		TemplateStack *IkeGatewayTemplateStackLocation `json:"template_stack"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Ngfw = shadow.Ngfw
	o.Template = shadow.Template
	o.TemplateStack = shadow.TemplateStack

	return nil
}
