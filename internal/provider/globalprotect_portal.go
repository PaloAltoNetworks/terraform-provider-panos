package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/globalprotect/portal"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &GlobalprotectPortalDataSource{}
	_ datasource.DataSourceWithConfigure = &GlobalprotectPortalDataSource{}
)

func NewGlobalprotectPortalDataSource() datasource.DataSource {
	return &GlobalprotectPortalDataSource{}
}

type GlobalprotectPortalDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*portal.Entry, portal.Location, *portal.Service]
}

type GlobalprotectPortalDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type GlobalprotectPortalDataSourceModel struct {
	Location        types.Object `tfsdk:"location"`
	Name            types.String `tfsdk:"name"`
	ClientConfig    types.Object `tfsdk:"client_config"`
	ClientlessVpn   types.Object `tfsdk:"clientless_vpn"`
	PortalConfig    types.Object `tfsdk:"portal_config"`
	SatelliteConfig types.Object `tfsdk:"satellite_config"`
}
type GlobalprotectPortalDataSourceClientConfigObject struct {
	AgentUserOverrideKey types.String `tfsdk:"agent_user_override_key"`
	Configs              types.List   `tfsdk:"configs"`
	RootCa               types.List   `tfsdk:"root_ca"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsObject struct {
	Name                             types.String `tfsdk:"name"`
	SaveUserCredentials              types.String `tfsdk:"save_user_credentials"`
	Portal2fa                        types.Bool   `tfsdk:"portal_2fa"`
	InternalGateway2fa               types.Bool   `tfsdk:"internal_gateway_2fa"`
	AutoDiscoveryExternalGateway2fa  types.Bool   `tfsdk:"auto_discovery_external_gateway_2fa"`
	ManualOnlyGateway2fa             types.Bool   `tfsdk:"manual_only_gateway_2fa"`
	RefreshConfig                    types.Bool   `tfsdk:"refresh_config"`
	MdmAddress                       types.String `tfsdk:"mdm_address"`
	MdmEnrollmentPort                types.String `tfsdk:"mdm_enrollment_port"`
	SourceUser                       types.List   `tfsdk:"source_user"`
	ThirdPartyVpnClients             types.List   `tfsdk:"third_party_vpn_clients"`
	Os                               types.List   `tfsdk:"os"`
	Certificate                      types.Object `tfsdk:"certificate"`
	CustomChecks                     types.Object `tfsdk:"custom_checks"`
	Gateways                         types.Object `tfsdk:"gateways"`
	InternalHostDetection            types.Object `tfsdk:"internal_host_detection"`
	InternalHostDetectionV6          types.Object `tfsdk:"internal_host_detection_v6"`
	AgentUi                          types.Object `tfsdk:"agent_ui"`
	HipCollection                    types.Object `tfsdk:"hip_collection"`
	AgentConfig                      types.Object `tfsdk:"agent_config"`
	GpAppConfig                      types.Object `tfsdk:"gp_app_config"`
	AuthenticationOverride           types.Object `tfsdk:"authentication_override"`
	MachineAccountExistsWithSerialno types.Object `tfsdk:"machine_account_exists_with_serialno"`
	ClientCertificate                types.Object `tfsdk:"client_certificate"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject struct {
	Criteria types.Object `tfsdk:"criteria"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject struct {
	Criteria types.Object `tfsdk:"criteria"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject struct {
	RegistryKey types.List `tfsdk:"registry_key"`
	Plist       types.List `tfsdk:"plist"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject struct {
	Name             types.String `tfsdk:"name"`
	DefaultValueData types.String `tfsdk:"default_value_data"`
	Negate           types.Bool   `tfsdk:"negate"`
	RegistryValue    types.List   `tfsdk:"registry_value"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject struct {
	Name      types.String `tfsdk:"name"`
	ValueData types.String `tfsdk:"value_data"`
	Negate    types.Bool   `tfsdk:"negate"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
	Key    types.List   `tfsdk:"key"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject struct {
	Name   types.String `tfsdk:"name"`
	Value  types.String `tfsdk:"value"`
	Negate types.Bool   `tfsdk:"negate"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject struct {
	Internal types.Object `tfsdk:"internal"`
	External types.Object `tfsdk:"external"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject struct {
	List           types.List `tfsdk:"list"`
	DhcpOptionCode types.List `tfsdk:"dhcp_option_code"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject struct {
	Name     types.String `tfsdk:"name"`
	SourceIp types.List   `tfsdk:"source_ip"`
	Fqdn     types.String `tfsdk:"fqdn"`
	Ip       types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject struct {
	CutoffTime types.Int64 `tfsdk:"cutoff_time"`
	List       types.List  `tfsdk:"list"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject struct {
	Name         types.String `tfsdk:"name"`
	PriorityRule types.List   `tfsdk:"priority_rule"`
	Manual       types.Bool   `tfsdk:"manual"`
	Fqdn         types.String `tfsdk:"fqdn"`
	Ip           types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.String `tfsdk:"priority"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Hostname  types.String `tfsdk:"hostname"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Hostname  types.String `tfsdk:"hostname"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject struct {
	Passcode                 types.String `tfsdk:"passcode"`
	UninstallPassword        types.String `tfsdk:"uninstall_password"`
	AgentUserOverrideTimeout types.Int64  `tfsdk:"agent_user_override_timeout"`
	MaxAgentUserOverrides    types.Int64  `tfsdk:"max_agent_user_overrides"`
	WelcomePage              types.Object `tfsdk:"welcome_page"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject struct {
	Page types.String `tfsdk:"page"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	MaxWaitTime        types.Int64  `tfsdk:"max_wait_time"`
	CollectHipData     types.Bool   `tfsdk:"collect_hip_data"`
	Exclusion          types.Object `tfsdk:"exclusion"`
	CustomChecks       types.Object `tfsdk:"custom_checks"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject struct {
	Category types.List `tfsdk:"category"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject struct {
	Name   types.String `tfsdk:"name"`
	Vendor types.List   `tfsdk:"vendor"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject struct {
	Name    types.String `tfsdk:"name"`
	Product types.List   `tfsdk:"product"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject struct {
	Windows types.Object `tfsdk:"windows"`
	MacOs   types.Object `tfsdk:"mac_os"`
	Linux   types.Object `tfsdk:"linux"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject struct {
	RegistryKey types.List `tfsdk:"registry_key"`
	ProcessList types.List `tfsdk:"process_list"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject struct {
	Name          types.String `tfsdk:"name"`
	RegistryValue types.List   `tfsdk:"registry_value"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject struct {
	Plist       types.List `tfsdk:"plist"`
	ProcessList types.List `tfsdk:"process_list"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject struct {
	Name types.String `tfsdk:"name"`
	Key  types.List   `tfsdk:"key"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject struct {
	ProcessList types.List `tfsdk:"process_list"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject struct {
}
type GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject struct {
	Config types.List `tfsdk:"config"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.List   `tfsdk:"value"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject struct {
	GenerateCookie           types.Bool   `tfsdk:"generate_cookie"`
	CookieEncryptDecryptCert types.String `tfsdk:"cookie_encrypt_decrypt_cert"`
	AcceptCookie             types.Object `tfsdk:"accept_cookie"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject struct {
	CookieLifetime types.Object `tfsdk:"cookie_lifetime"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject struct {
	LifetimeInDays    types.Int64 `tfsdk:"lifetime_in_days"`
	LifetimeInHours   types.Int64 `tfsdk:"lifetime_in_hours"`
	LifetimeInMinutes types.Int64 `tfsdk:"lifetime_in_minutes"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject struct {
	No  types.Object `tfsdk:"no"`
	Yes types.Object `tfsdk:"yes"`
}
type GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject struct {
}
type GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject struct {
}
type GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject struct {
	Local types.String `tfsdk:"local"`
	Scep  types.String `tfsdk:"scep"`
}
type GlobalprotectPortalDataSourceClientConfigRootCaObject struct {
	Name               types.String `tfsdk:"name"`
	InstallInCertStore types.Bool   `tfsdk:"install_in_cert_store"`
}
type GlobalprotectPortalDataSourceClientlessVpnObject struct {
	AppsToUserMapping        types.List   `tfsdk:"apps_to_user_mapping"`
	CryptoSettings           types.Object `tfsdk:"crypto_settings"`
	DnsProxy                 types.String `tfsdk:"dns_proxy"`
	Hostname                 types.String `tfsdk:"hostname"`
	InactivityLogout         types.Object `tfsdk:"inactivity_logout"`
	LoginLifetime            types.Object `tfsdk:"login_lifetime"`
	MaxUser                  types.Int64  `tfsdk:"max_user"`
	ProxyServerSetting       types.List   `tfsdk:"proxy_server_setting"`
	RewriteExcludeDomainList types.List   `tfsdk:"rewrite_exclude_domain_list"`
	SecurityZone             types.String `tfsdk:"security_zone"`
}
type GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject struct {
	Name                                  types.String `tfsdk:"name"`
	SourceUser                            types.List   `tfsdk:"source_user"`
	Applications                          types.List   `tfsdk:"applications"`
	EnableCustomAppURLAddressBar          types.Bool   `tfsdk:"enable_custom_app_u_r_l_address_bar"`
	DisplayGlobalProtectAgentDownloadLink types.Bool   `tfsdk:"display_global_protect_agent_download_link"`
}
type GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject struct {
	ServerCertVerification types.Object `tfsdk:"server_cert_verification"`
	SslProtocol            types.Object `tfsdk:"ssl_protocol"`
}
type GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject struct {
	BlockExpiredCertificate types.Bool `tfsdk:"block_expired_certificate"`
	BlockTimeoutCert        types.Bool `tfsdk:"block_timeout_cert"`
	BlockUnknownCert        types.Bool `tfsdk:"block_unknown_cert"`
	BlockUntrustedIssuer    types.Bool `tfsdk:"block_untrusted_issuer"`
}
type GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject struct {
	AuthAlgoMd5      types.Bool   `tfsdk:"auth_algo_md5"`
	AuthAlgoSha1     types.Bool   `tfsdk:"auth_algo_sha1"`
	AuthAlgoSha256   types.Bool   `tfsdk:"auth_algo_sha256"`
	AuthAlgoSha384   types.Bool   `tfsdk:"auth_algo_sha384"`
	EncAlgo3des      types.Bool   `tfsdk:"enc_algo_3des"`
	EncAlgoAes128Cbc types.Bool   `tfsdk:"enc_algo_aes_128_cbc"`
	EncAlgoAes128Gcm types.Bool   `tfsdk:"enc_algo_aes_128_gcm"`
	EncAlgoAes256Cbc types.Bool   `tfsdk:"enc_algo_aes_256_cbc"`
	EncAlgoAes256Gcm types.Bool   `tfsdk:"enc_algo_aes_256_gcm"`
	EncAlgoRc4       types.Bool   `tfsdk:"enc_algo_rc4"`
	KeyxchgAlgoDhe   types.Bool   `tfsdk:"keyxchg_algo_dhe"`
	KeyxchgAlgoEcdhe types.Bool   `tfsdk:"keyxchg_algo_ecdhe"`
	KeyxchgAlgoRsa   types.Bool   `tfsdk:"keyxchg_algo_rsa"`
	MaxVersion       types.String `tfsdk:"max_version"`
	MinVersion       types.String `tfsdk:"min_version"`
}
type GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject struct {
	Hours   types.Int64 `tfsdk:"hours"`
	Minutes types.Int64 `tfsdk:"minutes"`
}
type GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject struct {
	Hours   types.Int64 `tfsdk:"hours"`
	Minutes types.Int64 `tfsdk:"minutes"`
}
type GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject struct {
	Name        types.String `tfsdk:"name"`
	Domains     types.List   `tfsdk:"domains"`
	UseProxy    types.Bool   `tfsdk:"use_proxy"`
	ProxyServer types.Object `tfsdk:"proxy_server"`
}
type GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject struct {
	Server   types.String `tfsdk:"server"`
	Port     types.Int64  `tfsdk:"port"`
	User     types.String `tfsdk:"user"`
	Password types.String `tfsdk:"password"`
}
type GlobalprotectPortalDataSourcePortalConfigObject struct {
	CertificateProfile   types.String `tfsdk:"certificate_profile"`
	ClientAuth           types.List   `tfsdk:"client_auth"`
	ConfigSelection      types.Object `tfsdk:"config_selection"`
	CustomHelpPage       types.String `tfsdk:"custom_help_page"`
	CustomHomePage       types.String `tfsdk:"custom_home_page"`
	CustomLoginPage      types.String `tfsdk:"custom_login_page"`
	LocalAddress         types.Object `tfsdk:"local_address"`
	LogFail              types.Bool   `tfsdk:"log_fail"`
	LogSetting           types.String `tfsdk:"log_setting"`
	LogSuccess           types.Bool   `tfsdk:"log_success"`
	SslTlsServiceProfile types.String `tfsdk:"ssl_tls_service_profile"`
}
type GlobalprotectPortalDataSourcePortalConfigClientAuthObject struct {
	Name                               types.String `tfsdk:"name"`
	Os                                 types.String `tfsdk:"os"`
	AuthenticationProfile              types.String `tfsdk:"authentication_profile"`
	AutoRetrievePasscode               types.Bool   `tfsdk:"auto_retrieve_passcode"`
	UsernameLabel                      types.String `tfsdk:"username_label"`
	PasswordLabel                      types.String `tfsdk:"password_label"`
	AuthenticationMessage              types.String `tfsdk:"authentication_message"`
	UserCredentialOrClientCertRequired types.String `tfsdk:"user_credential_or_client_cert_required"`
}
type GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	CustomChecks       types.Object `tfsdk:"custom_checks"`
}
type GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject struct {
	MacOs   types.Object `tfsdk:"mac_os"`
	Windows types.Object `tfsdk:"windows"`
}
type GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject struct {
	Plist types.List `tfsdk:"plist"`
}
type GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject struct {
	Name types.String `tfsdk:"name"`
	Key  types.List   `tfsdk:"key"`
}
type GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject struct {
	RegistryKey types.List `tfsdk:"registry_key"`
}
type GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject struct {
	Name          types.String `tfsdk:"name"`
	RegistryValue types.List   `tfsdk:"registry_value"`
}
type GlobalprotectPortalDataSourcePortalConfigLocalAddressObject struct {
	Interface       types.String `tfsdk:"interface"`
	IpAddressFamily types.String `tfsdk:"ip_address_family"`
	FloatingIp      types.Object `tfsdk:"floating_ip"`
	Ip              types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalDataSourceSatelliteConfigObject struct {
	ClientCertificate types.Object `tfsdk:"client_certificate"`
	Configs           types.List   `tfsdk:"configs"`
	RootCa            types.List   `tfsdk:"root_ca"`
}
type GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject struct {
	Local types.Object `tfsdk:"local"`
	Scep  types.Object `tfsdk:"scep"`
}
type GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject struct {
	CertificateLifeTime      types.Int64  `tfsdk:"certificate_life_time"`
	CertificateRenewalPeriod types.Int64  `tfsdk:"certificate_renewal_period"`
	IssuingCertificate       types.String `tfsdk:"issuing_certificate"`
	OcspResponder            types.String `tfsdk:"ocsp_responder"`
}
type GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject struct {
	CertificateRenewalPeriod types.Int64  `tfsdk:"certificate_renewal_period"`
	Scep                     types.String `tfsdk:"scep"`
}
type GlobalprotectPortalDataSourceSatelliteConfigConfigsObject struct {
	Name                  types.String `tfsdk:"name"`
	Devices               types.List   `tfsdk:"devices"`
	SourceUser            types.List   `tfsdk:"source_user"`
	Gateways              types.List   `tfsdk:"gateways"`
	ConfigRefreshInterval types.Int64  `tfsdk:"config_refresh_interval"`
}
type GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject struct {
	Name          types.String `tfsdk:"name"`
	Ipv6Preferred types.Bool   `tfsdk:"ipv6_preferred"`
	Priority      types.Int64  `tfsdk:"priority"`
	Fqdn          types.String `tfsdk:"fqdn"`
	Ip            types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}

func (o *GlobalprotectPortalDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj GlobalprotectPortalLocation

	var clientConfigObj *GlobalprotectPortalDataSourceClientConfigObject

	var clientlessVpnObj *GlobalprotectPortalDataSourceClientlessVpnObject

	var portalConfigObj *GlobalprotectPortalDataSourcePortalConfigObject

	var satelliteConfigObj *GlobalprotectPortalDataSourceSatelliteConfigObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"client_config": types.ObjectType{
			AttrTypes: clientConfigObj.AttributeTypes(),
		},
		"clientless_vpn": types.ObjectType{
			AttrTypes: clientlessVpnObj.AttributeTypes(),
		},
		"portal_config": types.ObjectType{
			AttrTypes: portalConfigObj.AttributeTypes(),
		},
		"satellite_config": types.ObjectType{
			AttrTypes: satelliteConfigObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceModel) AncestorName() string {
	return ""
}

func (o GlobalprotectPortalDataSourceModel) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigObject) AttributeTypes() map[string]attr.Type {

	var configsObj *GlobalprotectPortalDataSourceClientConfigConfigsObject

	var rootCaObj *GlobalprotectPortalDataSourceClientConfigRootCaObject
	return map[string]attr.Type{
		"agent_user_override_key": types.StringType,
		"configs": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: configsObj.AttributeTypes(),
			},
		},
		"root_ca": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rootCaObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigObject) AncestorName() string {
	return "client-config"
}

func (o GlobalprotectPortalDataSourceClientConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsObject) AttributeTypes() map[string]attr.Type {

	var certificateObj *GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject

	var customChecksObj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject

	var gatewaysObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject

	var internalHostDetectionObj *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject

	var internalHostDetectionV6Obj *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object

	var agentUiObj *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject

	var hipCollectionObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject

	var agentConfigObj *GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject

	var gpAppConfigObj *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject

	var authenticationOverrideObj *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject

	var machineAccountExistsWithSerialnoObj *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject

	var clientCertificateObj *GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject
	return map[string]attr.Type{
		"name":                                types.StringType,
		"save_user_credentials":               types.StringType,
		"portal_2fa":                          types.BoolType,
		"internal_gateway_2fa":                types.BoolType,
		"auto_discovery_external_gateway_2fa": types.BoolType,
		"manual_only_gateway_2fa":             types.BoolType,
		"refresh_config":                      types.BoolType,
		"mdm_address":                         types.StringType,
		"mdm_enrollment_port":                 types.StringType,
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"third_party_vpn_clients": types.ListType{
			ElemType: types.StringType,
		},
		"os": types.ListType{
			ElemType: types.StringType,
		},
		"certificate": types.ObjectType{
			AttrTypes: certificateObj.AttributeTypes(),
		},
		"custom_checks": types.ObjectType{
			AttrTypes: customChecksObj.AttributeTypes(),
		},
		"gateways": types.ObjectType{
			AttrTypes: gatewaysObj.AttributeTypes(),
		},
		"internal_host_detection": types.ObjectType{
			AttrTypes: internalHostDetectionObj.AttributeTypes(),
		},
		"internal_host_detection_v6": types.ObjectType{
			AttrTypes: internalHostDetectionV6Obj.AttributeTypes(),
		},
		"agent_ui": types.ObjectType{
			AttrTypes: agentUiObj.AttributeTypes(),
		},
		"hip_collection": types.ObjectType{
			AttrTypes: hipCollectionObj.AttributeTypes(),
		},
		"agent_config": types.ObjectType{
			AttrTypes: agentConfigObj.AttributeTypes(),
		},
		"gp_app_config": types.ObjectType{
			AttrTypes: gpAppConfigObj.AttributeTypes(),
		},
		"authentication_override": types.ObjectType{
			AttrTypes: authenticationOverrideObj.AttributeTypes(),
		},
		"machine_account_exists_with_serialno": types.ObjectType{
			AttrTypes: machineAccountExistsWithSerialnoObj.AttributeTypes(),
		},
		"client_certificate": types.ObjectType{
			AttrTypes: clientCertificateObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsObject) AncestorName() string {
	return "configs"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject) AttributeTypes() map[string]attr.Type {

	var criteriaObj *GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject
	return map[string]attr.Type{
		"criteria": types.ObjectType{
			AttrTypes: criteriaObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject) AncestorName() string {
	return "certificate"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_profile": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject) AncestorName() string {
	return "criteria"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject) AttributeTypes() map[string]attr.Type {

	var criteriaObj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject
	return map[string]attr.Type{
		"criteria": types.ObjectType{
			AttrTypes: criteriaObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject) AncestorName() string {
	return "custom-checks"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject) AttributeTypes() map[string]attr.Type {

	var registryKeyObj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject

	var plistObj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject
	return map[string]attr.Type{
		"registry_key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryKeyObj.AttributeTypes(),
			},
		},
		"plist": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: plistObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject) AncestorName() string {
	return "criteria"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) AttributeTypes() map[string]attr.Type {

	var registryValueObj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject
	return map[string]attr.Type{
		"name":               types.StringType,
		"default_value_data": types.StringType,
		"negate":             types.BoolType,
		"registry_value": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryValueObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) AncestorName() string {
	return "registry-key"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"value_data": types.StringType,
		"negate":     types.BoolType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) AncestorName() string {
	return "registry-value"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject) AttributeTypes() map[string]attr.Type {

	var keyObj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"negate": types.BoolType,
		"key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: keyObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject) AncestorName() string {
	return "plist"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"value":  types.StringType,
		"negate": types.BoolType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) AncestorName() string {
	return "key"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject) AttributeTypes() map[string]attr.Type {

	var internalObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject

	var externalObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject
	return map[string]attr.Type{
		"internal": types.ObjectType{
			AttrTypes: internalObj.AttributeTypes(),
		},
		"external": types.ObjectType{
			AttrTypes: externalObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject) AncestorName() string {
	return "gateways"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject

	return map[string]attr.Type{
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
		"dhcp_option_code": types.ListType{
			ElemType: types.Int64Type,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject) AncestorName() string {
	return "internal"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject) AttributeTypes() map[string]attr.Type {

	var ipObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject
	return map[string]attr.Type{
		"name": types.StringType,
		"source_ip": types.ListType{
			ElemType: types.StringType,
		},
		"fqdn": types.StringType,
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject
	return map[string]attr.Type{
		"cutoff_time": types.Int64Type,
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject) AncestorName() string {
	return "external"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject) AttributeTypes() map[string]attr.Type {

	var priorityRuleObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject

	var ipObj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject
	return map[string]attr.Type{
		"name": types.StringType,
		"priority_rule": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: priorityRuleObj.AttributeTypes(),
			},
		},
		"manual": types.BoolType,
		"fqdn":   types.StringType,
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) AncestorName() string {
	return "priority-rule"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
		"hostname":   types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject) AncestorName() string {
	return "internal-host-detection"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
		"hostname":   types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object) AncestorName() string {
	return "internal-host-detection-v6"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject) AttributeTypes() map[string]attr.Type {

	var welcomePageObj *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject
	return map[string]attr.Type{
		"passcode":                    types.StringType,
		"uninstall_password":          types.StringType,
		"agent_user_override_timeout": types.Int64Type,
		"max_agent_user_overrides":    types.Int64Type,
		"welcome_page": types.ObjectType{
			AttrTypes: welcomePageObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject) AncestorName() string {
	return "agent-ui"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"page": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject) AncestorName() string {
	return "welcome-page"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject) AttributeTypes() map[string]attr.Type {

	var exclusionObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject

	var customChecksObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject
	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"max_wait_time":       types.Int64Type,
		"collect_hip_data":    types.BoolType,
		"exclusion": types.ObjectType{
			AttrTypes: exclusionObj.AttributeTypes(),
		},
		"custom_checks": types.ObjectType{
			AttrTypes: customChecksObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject) AncestorName() string {
	return "hip-collection"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject) AttributeTypes() map[string]attr.Type {

	var categoryObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject
	return map[string]attr.Type{
		"category": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: categoryObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject) AncestorName() string {
	return "exclusion"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject) AttributeTypes() map[string]attr.Type {

	var vendorObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject
	return map[string]attr.Type{
		"name": types.StringType,
		"vendor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: vendorObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject) AncestorName() string {
	return "category"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"product": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) AncestorName() string {
	return "vendor"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject) AttributeTypes() map[string]attr.Type {

	var windowsObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject

	var macOsObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject

	var linuxObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject
	return map[string]attr.Type{
		"windows": types.ObjectType{
			AttrTypes: windowsObj.AttributeTypes(),
		},
		"mac_os": types.ObjectType{
			AttrTypes: macOsObj.AttributeTypes(),
		},
		"linux": types.ObjectType{
			AttrTypes: linuxObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject) AncestorName() string {
	return "custom-checks"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) AttributeTypes() map[string]attr.Type {

	var registryKeyObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject

	return map[string]attr.Type{
		"registry_key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryKeyObj.AttributeTypes(),
			},
		},
		"process_list": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) AncestorName() string {
	return "windows"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"registry_value": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) AncestorName() string {
	return "registry-key"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) AttributeTypes() map[string]attr.Type {

	var plistObj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject

	return map[string]attr.Type{
		"plist": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: plistObj.AttributeTypes(),
			},
		},
		"process_list": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) AncestorName() string {
	return "mac-os"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"key": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) AncestorName() string {
	return "plist"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"process_list": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) AncestorName() string {
	return "linux"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject) AncestorName() string {
	return "agent-config"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject) AttributeTypes() map[string]attr.Type {

	var configObj *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject
	return map[string]attr.Type{
		"config": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: configObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject) AncestorName() string {
	return "gp-app-config"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"value": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject) AncestorName() string {
	return "config"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject) AttributeTypes() map[string]attr.Type {

	var acceptCookieObj *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject
	return map[string]attr.Type{
		"generate_cookie":             types.BoolType,
		"cookie_encrypt_decrypt_cert": types.StringType,
		"accept_cookie": types.ObjectType{
			AttrTypes: acceptCookieObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject) AncestorName() string {
	return "authentication-override"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) AttributeTypes() map[string]attr.Type {

	var cookieLifetimeObj *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	return map[string]attr.Type{
		"cookie_lifetime": types.ObjectType{
			AttrTypes: cookieLifetimeObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) AncestorName() string {
	return "accept-cookie"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lifetime_in_days":    types.Int64Type,
		"lifetime_in_hours":   types.Int64Type,
		"lifetime_in_minutes": types.Int64Type,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AncestorName() string {
	return "cookie-lifetime"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) AttributeTypes() map[string]attr.Type {

	var noObj *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject

	var yesObj *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject
	return map[string]attr.Type{
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) AncestorName() string {
	return "machine-account-exists-with-serialno"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) AncestorName() string {
	return "no"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) AncestorName() string {
	return "yes"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local": types.StringType,
		"scep":  types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject) AncestorName() string {
	return "client-certificate"
}

func (o GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientConfigRootCaObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                  types.StringType,
		"install_in_cert_store": types.BoolType,
	}
}

func (o GlobalprotectPortalDataSourceClientConfigRootCaObject) AncestorName() string {
	return "root-ca"
}

func (o GlobalprotectPortalDataSourceClientConfigRootCaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientlessVpnObject) AttributeTypes() map[string]attr.Type {

	var appsToUserMappingObj *GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject

	var cryptoSettingsObj *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject

	var inactivityLogoutObj *GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject

	var loginLifetimeObj *GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject

	var proxyServerSettingObj *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject

	return map[string]attr.Type{
		"apps_to_user_mapping": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: appsToUserMappingObj.AttributeTypes(),
			},
		},
		"crypto_settings": types.ObjectType{
			AttrTypes: cryptoSettingsObj.AttributeTypes(),
		},
		"dns_proxy": types.StringType,
		"hostname":  types.StringType,
		"inactivity_logout": types.ObjectType{
			AttrTypes: inactivityLogoutObj.AttributeTypes(),
		},
		"login_lifetime": types.ObjectType{
			AttrTypes: loginLifetimeObj.AttributeTypes(),
		},
		"max_user": types.Int64Type,
		"proxy_server_setting": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: proxyServerSettingObj.AttributeTypes(),
			},
		},
		"rewrite_exclude_domain_list": types.ListType{
			ElemType: types.StringType,
		},
		"security_zone": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnObject) AncestorName() string {
	return "clientless-vpn"
}

func (o GlobalprotectPortalDataSourceClientlessVpnObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"applications": types.ListType{
			ElemType: types.StringType,
		},
		"enable_custom_app_u_r_l_address_bar":        types.BoolType,
		"display_global_protect_agent_download_link": types.BoolType,
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject) AncestorName() string {
	return "apps-to-user-mapping"
}

func (o GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject) AttributeTypes() map[string]attr.Type {

	var serverCertVerificationObj *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject

	var sslProtocolObj *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject
	return map[string]attr.Type{
		"server_cert_verification": types.ObjectType{
			AttrTypes: serverCertVerificationObj.AttributeTypes(),
		},
		"ssl_protocol": types.ObjectType{
			AttrTypes: sslProtocolObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject) AncestorName() string {
	return "crypto-settings"
}

func (o GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"block_expired_certificate": types.BoolType,
		"block_timeout_cert":        types.BoolType,
		"block_unknown_cert":        types.BoolType,
		"block_untrusted_issuer":    types.BoolType,
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject) AncestorName() string {
	return "server-cert-verification"
}

func (o GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"auth_algo_md5":        types.BoolType,
		"auth_algo_sha1":       types.BoolType,
		"auth_algo_sha256":     types.BoolType,
		"auth_algo_sha384":     types.BoolType,
		"enc_algo_3des":        types.BoolType,
		"enc_algo_aes_128_cbc": types.BoolType,
		"enc_algo_aes_128_gcm": types.BoolType,
		"enc_algo_aes_256_cbc": types.BoolType,
		"enc_algo_aes_256_gcm": types.BoolType,
		"enc_algo_rc4":         types.BoolType,
		"keyxchg_algo_dhe":     types.BoolType,
		"keyxchg_algo_ecdhe":   types.BoolType,
		"keyxchg_algo_rsa":     types.BoolType,
		"max_version":          types.StringType,
		"min_version":          types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject) AncestorName() string {
	return "ssl-protocol"
}

func (o GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"hours":   types.Int64Type,
		"minutes": types.Int64Type,
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject) AncestorName() string {
	return "inactivity-logout"
}

func (o GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"hours":   types.Int64Type,
		"minutes": types.Int64Type,
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject) AncestorName() string {
	return "login-lifetime"
}

func (o GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject) AttributeTypes() map[string]attr.Type {

	var proxyServerObj *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject
	return map[string]attr.Type{
		"name": types.StringType,
		"domains": types.ListType{
			ElemType: types.StringType,
		},
		"use_proxy": types.BoolType,
		"proxy_server": types.ObjectType{
			AttrTypes: proxyServerObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject) AncestorName() string {
	return "proxy-server-setting"
}

func (o GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"server":   types.StringType,
		"port":     types.Int64Type,
		"user":     types.StringType,
		"password": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject) AncestorName() string {
	return "proxy-server"
}

func (o GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigObject) AttributeTypes() map[string]attr.Type {

	var clientAuthObj *GlobalprotectPortalDataSourcePortalConfigClientAuthObject

	var configSelectionObj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject

	var localAddressObj *GlobalprotectPortalDataSourcePortalConfigLocalAddressObject

	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"client_auth": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: clientAuthObj.AttributeTypes(),
			},
		},
		"config_selection": types.ObjectType{
			AttrTypes: configSelectionObj.AttributeTypes(),
		},
		"custom_help_page":  types.StringType,
		"custom_home_page":  types.StringType,
		"custom_login_page": types.StringType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"log_fail":                types.BoolType,
		"log_setting":             types.StringType,
		"log_success":             types.BoolType,
		"ssl_tls_service_profile": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigObject) AncestorName() string {
	return "portal-config"
}

func (o GlobalprotectPortalDataSourcePortalConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigClientAuthObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                   types.StringType,
		"os":                     types.StringType,
		"authentication_profile": types.StringType,
		"auto_retrieve_passcode": types.BoolType,
		"username_label":         types.StringType,
		"password_label":         types.StringType,
		"authentication_message": types.StringType,
		"user_credential_or_client_cert_required": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigClientAuthObject) AncestorName() string {
	return "client-auth"
}

func (o GlobalprotectPortalDataSourcePortalConfigClientAuthObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject) AttributeTypes() map[string]attr.Type {

	var customChecksObj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject
	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"custom_checks": types.ObjectType{
			AttrTypes: customChecksObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject) AncestorName() string {
	return "config-selection"
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject) AttributeTypes() map[string]attr.Type {

	var macOsObj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject

	var windowsObj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject
	return map[string]attr.Type{
		"mac_os": types.ObjectType{
			AttrTypes: macOsObj.AttributeTypes(),
		},
		"windows": types.ObjectType{
			AttrTypes: windowsObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject) AncestorName() string {
	return "custom-checks"
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject) AttributeTypes() map[string]attr.Type {

	var plistObj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject
	return map[string]attr.Type{
		"plist": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: plistObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject) AncestorName() string {
	return "mac-os"
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"key": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) AncestorName() string {
	return "plist"
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject) AttributeTypes() map[string]attr.Type {

	var registryKeyObj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject
	return map[string]attr.Type{
		"registry_key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryKeyObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject) AncestorName() string {
	return "windows"
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"registry_value": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) AncestorName() string {
	return "registry-key"
}

func (o GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressObject) AttributeTypes() map[string]attr.Type {

	var floatingIpObj *GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject

	var ipObj *GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject
	return map[string]attr.Type{
		"interface":         types.StringType,
		"ip_address_family": types.StringType,
		"floating_ip": types.ObjectType{
			AttrTypes: floatingIpObj.AttributeTypes(),
		},
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o GlobalprotectPortalDataSourcePortalConfigLocalAddressObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject) AncestorName() string {
	return "floating-ip"
}

func (o GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigObject) AttributeTypes() map[string]attr.Type {

	var clientCertificateObj *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject

	var configsObj *GlobalprotectPortalDataSourceSatelliteConfigConfigsObject

	return map[string]attr.Type{
		"client_certificate": types.ObjectType{
			AttrTypes: clientCertificateObj.AttributeTypes(),
		},
		"configs": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: configsObj.AttributeTypes(),
			},
		},
		"root_ca": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalDataSourceSatelliteConfigObject) AncestorName() string {
	return "satellite-config"
}

func (o GlobalprotectPortalDataSourceSatelliteConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject) AttributeTypes() map[string]attr.Type {

	var localObj *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject

	var scepObj *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject
	return map[string]attr.Type{
		"local": types.ObjectType{
			AttrTypes: localObj.AttributeTypes(),
		},
		"scep": types.ObjectType{
			AttrTypes: scepObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject) AncestorName() string {
	return "client-certificate"
}

func (o GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_life_time":      types.Int64Type,
		"certificate_renewal_period": types.Int64Type,
		"issuing_certificate":        types.StringType,
		"ocsp_responder":             types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject) AncestorName() string {
	return "local"
}

func (o GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_renewal_period": types.Int64Type,
		"scep":                       types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject) AncestorName() string {
	return "scep"
}

func (o GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsObject) AttributeTypes() map[string]attr.Type {

	var gatewaysObj *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject

	return map[string]attr.Type{
		"name": types.StringType,
		"devices": types.ListType{
			ElemType: types.StringType,
		},
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"gateways": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: gatewaysObj.AttributeTypes(),
			},
		},
		"config_refresh_interval": types.Int64Type,
	}
}

func (o GlobalprotectPortalDataSourceSatelliteConfigConfigsObject) AncestorName() string {
	return "configs"
}

func (o GlobalprotectPortalDataSourceSatelliteConfigConfigsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject) AttributeTypes() map[string]attr.Type {

	var ipObj *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"ipv6_preferred": types.BoolType,
		"priority":       types.Int64Type,
		"fqdn":           types.StringType,
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject) AncestorName() string {
	return "gateways"
}

func (o GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject) EntryName() *string {
	return nil
}

func (o *GlobalprotectPortalDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientConfig_entry *portal.ClientConfig
	if !o.ClientConfig.IsUnknown() && !o.ClientConfig.IsNull() {
		if *obj != nil && (*obj).ClientConfig != nil {
			clientConfig_entry = (*obj).ClientConfig
		} else {
			clientConfig_entry = new(portal.ClientConfig)
		}
		var object *GlobalprotectPortalDataSourceClientConfigObject
		diags.Append(o.ClientConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &clientConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var clientlessVpn_entry *portal.ClientlessVpn
	if !o.ClientlessVpn.IsUnknown() && !o.ClientlessVpn.IsNull() {
		if *obj != nil && (*obj).ClientlessVpn != nil {
			clientlessVpn_entry = (*obj).ClientlessVpn
		} else {
			clientlessVpn_entry = new(portal.ClientlessVpn)
		}
		var object *GlobalprotectPortalDataSourceClientlessVpnObject
		diags.Append(o.ClientlessVpn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &clientlessVpn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var portalConfig_entry *portal.PortalConfig
	if !o.PortalConfig.IsUnknown() && !o.PortalConfig.IsNull() {
		if *obj != nil && (*obj).PortalConfig != nil {
			portalConfig_entry = (*obj).PortalConfig
		} else {
			portalConfig_entry = new(portal.PortalConfig)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigObject
		diags.Append(o.PortalConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &portalConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var satelliteConfig_entry *portal.SatelliteConfig
	if !o.SatelliteConfig.IsUnknown() && !o.SatelliteConfig.IsNull() {
		if *obj != nil && (*obj).SatelliteConfig != nil {
			satelliteConfig_entry = (*obj).SatelliteConfig
		} else {
			satelliteConfig_entry = new(portal.SatelliteConfig)
		}
		var object *GlobalprotectPortalDataSourceSatelliteConfigObject
		diags.Append(o.SatelliteConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &satelliteConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ClientConfig = clientConfig_entry
	(*obj).ClientlessVpn = clientlessVpn_entry
	(*obj).PortalConfig = portalConfig_entry
	(*obj).SatelliteConfig = satelliteConfig_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var agentUserOverrideKey_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "agent-user-override-key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.AgentUserOverrideKey.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		agentUserOverrideKey_value = o.AgentUserOverrideKey.ValueStringPointer()
	}
	var configs_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsObject
	var configs_pango_entries []portal.ClientConfigConfigs
	{
		d := o.Configs.ElementsAs(ctx, &configs_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range configs_tf_entries {
			var entry *portal.ClientConfigConfigs
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			configs_pango_entries = append(configs_pango_entries, *entry)
		}
	}
	var rootCa_tf_entries []GlobalprotectPortalDataSourceClientConfigRootCaObject
	var rootCa_pango_entries []portal.ClientConfigRootCa
	{
		d := o.RootCa.ElementsAs(ctx, &rootCa_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rootCa_tf_entries {
			var entry *portal.ClientConfigRootCa
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rootCa_pango_entries = append(rootCa_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfig)
	}
	(*obj).AgentUserOverrideKey = agentUserOverrideKey_value
	(*obj).Configs = configs_pango_entries
	(*obj).RootCa = rootCa_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	saveUserCredentials_value := o.SaveUserCredentials.ValueStringPointer()
	portal2fa_value := o.Portal2fa.ValueBoolPointer()
	internalGateway2fa_value := o.InternalGateway2fa.ValueBoolPointer()
	autoDiscoveryExternalGateway2fa_value := o.AutoDiscoveryExternalGateway2fa.ValueBoolPointer()
	manualOnlyGateway2fa_value := o.ManualOnlyGateway2fa.ValueBoolPointer()
	refreshConfig_value := o.RefreshConfig.ValueBoolPointer()
	mdmAddress_value := o.MdmAddress.ValueStringPointer()
	mdmEnrollmentPort_value := o.MdmEnrollmentPort.ValueStringPointer()
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var thirdPartyVpnClients_pango_entries []string
	if !o.ThirdPartyVpnClients.IsUnknown() && !o.ThirdPartyVpnClients.IsNull() {
		object_entries := make([]types.String, 0, len(o.ThirdPartyVpnClients.Elements()))
		diags.Append(o.ThirdPartyVpnClients.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			thirdPartyVpnClients_pango_entries = append(thirdPartyVpnClients_pango_entries, elt.ValueString())
		}
	}
	var os_pango_entries []string
	if !o.Os.IsUnknown() && !o.Os.IsNull() {
		object_entries := make([]types.String, 0, len(o.Os.Elements()))
		diags.Append(o.Os.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			os_pango_entries = append(os_pango_entries, elt.ValueString())
		}
	}
	var certificate_entry *portal.ClientConfigConfigsCertificate
	if !o.Certificate.IsUnknown() && !o.Certificate.IsNull() {
		if *obj != nil && (*obj).Certificate != nil {
			certificate_entry = (*obj).Certificate
		} else {
			certificate_entry = new(portal.ClientConfigConfigsCertificate)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject
		diags.Append(o.Certificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &certificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var customChecks_entry *portal.ClientConfigConfigsCustomChecks
	if !o.CustomChecks.IsUnknown() && !o.CustomChecks.IsNull() {
		if *obj != nil && (*obj).CustomChecks != nil {
			customChecks_entry = (*obj).CustomChecks
		} else {
			customChecks_entry = new(portal.ClientConfigConfigsCustomChecks)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject
		diags.Append(o.CustomChecks.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &customChecks_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gateways_entry *portal.ClientConfigConfigsGateways
	if !o.Gateways.IsUnknown() && !o.Gateways.IsNull() {
		if *obj != nil && (*obj).Gateways != nil {
			gateways_entry = (*obj).Gateways
		} else {
			gateways_entry = new(portal.ClientConfigConfigsGateways)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject
		diags.Append(o.Gateways.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gateways_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var internalHostDetection_entry *portal.ClientConfigConfigsInternalHostDetection
	if !o.InternalHostDetection.IsUnknown() && !o.InternalHostDetection.IsNull() {
		if *obj != nil && (*obj).InternalHostDetection != nil {
			internalHostDetection_entry = (*obj).InternalHostDetection
		} else {
			internalHostDetection_entry = new(portal.ClientConfigConfigsInternalHostDetection)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject
		diags.Append(o.InternalHostDetection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &internalHostDetection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var internalHostDetectionV6_entry *portal.ClientConfigConfigsInternalHostDetectionV6
	if !o.InternalHostDetectionV6.IsUnknown() && !o.InternalHostDetectionV6.IsNull() {
		if *obj != nil && (*obj).InternalHostDetectionV6 != nil {
			internalHostDetectionV6_entry = (*obj).InternalHostDetectionV6
		} else {
			internalHostDetectionV6_entry = new(portal.ClientConfigConfigsInternalHostDetectionV6)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object
		diags.Append(o.InternalHostDetectionV6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &internalHostDetectionV6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var agentUi_entry *portal.ClientConfigConfigsAgentUi
	if !o.AgentUi.IsUnknown() && !o.AgentUi.IsNull() {
		if *obj != nil && (*obj).AgentUi != nil {
			agentUi_entry = (*obj).AgentUi
		} else {
			agentUi_entry = new(portal.ClientConfigConfigsAgentUi)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject
		diags.Append(o.AgentUi.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &agentUi_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hipCollection_entry *portal.ClientConfigConfigsHipCollection
	if !o.HipCollection.IsUnknown() && !o.HipCollection.IsNull() {
		if *obj != nil && (*obj).HipCollection != nil {
			hipCollection_entry = (*obj).HipCollection
		} else {
			hipCollection_entry = new(portal.ClientConfigConfigsHipCollection)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject
		diags.Append(o.HipCollection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hipCollection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var agentConfig_entry *portal.ClientConfigConfigsAgentConfig
	if !o.AgentConfig.IsUnknown() && !o.AgentConfig.IsNull() {
		if *obj != nil && (*obj).AgentConfig != nil {
			agentConfig_entry = (*obj).AgentConfig
		} else {
			agentConfig_entry = new(portal.ClientConfigConfigsAgentConfig)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject
		diags.Append(o.AgentConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &agentConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gpAppConfig_entry *portal.ClientConfigConfigsGpAppConfig
	if !o.GpAppConfig.IsUnknown() && !o.GpAppConfig.IsNull() {
		if *obj != nil && (*obj).GpAppConfig != nil {
			gpAppConfig_entry = (*obj).GpAppConfig
		} else {
			gpAppConfig_entry = new(portal.ClientConfigConfigsGpAppConfig)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject
		diags.Append(o.GpAppConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gpAppConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var authenticationOverride_entry *portal.ClientConfigConfigsAuthenticationOverride
	if !o.AuthenticationOverride.IsUnknown() && !o.AuthenticationOverride.IsNull() {
		if *obj != nil && (*obj).AuthenticationOverride != nil {
			authenticationOverride_entry = (*obj).AuthenticationOverride
		} else {
			authenticationOverride_entry = new(portal.ClientConfigConfigsAuthenticationOverride)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject
		diags.Append(o.AuthenticationOverride.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authenticationOverride_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var machineAccountExistsWithSerialno_entry *portal.ClientConfigConfigsMachineAccountExistsWithSerialno
	if !o.MachineAccountExistsWithSerialno.IsUnknown() && !o.MachineAccountExistsWithSerialno.IsNull() {
		if *obj != nil && (*obj).MachineAccountExistsWithSerialno != nil {
			machineAccountExistsWithSerialno_entry = (*obj).MachineAccountExistsWithSerialno
		} else {
			machineAccountExistsWithSerialno_entry = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialno)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject
		diags.Append(o.MachineAccountExistsWithSerialno.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &machineAccountExistsWithSerialno_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var clientCertificate_entry *portal.ClientConfigConfigsClientCertificate
	if !o.ClientCertificate.IsUnknown() && !o.ClientCertificate.IsNull() {
		if *obj != nil && (*obj).ClientCertificate != nil {
			clientCertificate_entry = (*obj).ClientCertificate
		} else {
			clientCertificate_entry = new(portal.ClientConfigConfigsClientCertificate)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject
		diags.Append(o.ClientCertificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &clientCertificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigs)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SaveUserCredentials = saveUserCredentials_value
	(*obj).Portal2fa = portal2fa_value
	(*obj).InternalGateway2fa = internalGateway2fa_value
	(*obj).AutoDiscoveryExternalGateway2fa = autoDiscoveryExternalGateway2fa_value
	(*obj).ManualOnlyGateway2fa = manualOnlyGateway2fa_value
	(*obj).RefreshConfig = refreshConfig_value
	(*obj).MdmAddress = mdmAddress_value
	(*obj).MdmEnrollmentPort = mdmEnrollmentPort_value
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).ThirdPartyVpnClients = thirdPartyVpnClients_pango_entries
	(*obj).Os = os_pango_entries
	(*obj).Certificate = certificate_entry
	(*obj).CustomChecks = customChecks_entry
	(*obj).Gateways = gateways_entry
	(*obj).InternalHostDetection = internalHostDetection_entry
	(*obj).InternalHostDetectionV6 = internalHostDetectionV6_entry
	(*obj).AgentUi = agentUi_entry
	(*obj).HipCollection = hipCollection_entry
	(*obj).AgentConfig = agentConfig_entry
	(*obj).GpAppConfig = gpAppConfig_entry
	(*obj).AuthenticationOverride = authenticationOverride_entry
	(*obj).MachineAccountExistsWithSerialno = machineAccountExistsWithSerialno_entry
	(*obj).ClientCertificate = clientCertificate_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var criteria_entry *portal.ClientConfigConfigsCertificateCriteria
	if !o.Criteria.IsUnknown() && !o.Criteria.IsNull() {
		if *obj != nil && (*obj).Criteria != nil {
			criteria_entry = (*obj).Criteria
		} else {
			criteria_entry = new(portal.ClientConfigConfigsCertificateCriteria)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject
		diags.Append(o.Criteria.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &criteria_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCertificate)
	}
	(*obj).Criteria = criteria_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCertificateCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCertificateCriteria)
	}
	(*obj).CertificateProfile = certificateProfile_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var criteria_entry *portal.ClientConfigConfigsCustomChecksCriteria
	if !o.Criteria.IsUnknown() && !o.Criteria.IsNull() {
		if *obj != nil && (*obj).Criteria != nil {
			criteria_entry = (*obj).Criteria
		} else {
			criteria_entry = new(portal.ClientConfigConfigsCustomChecksCriteria)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject
		diags.Append(o.Criteria.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &criteria_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecks)
	}
	(*obj).Criteria = criteria_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject
	var registryKey_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey
	{
		d := o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryKey_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryKey_pango_entries = append(registryKey_pango_entries, *entry)
		}
	}
	var plist_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject
	var plist_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaPlist
	{
		d := o.Plist.ElementsAs(ctx, &plist_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range plist_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaPlist
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			plist_pango_entries = append(plist_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteria)
	}
	(*obj).RegistryKey = registryKey_pango_entries
	(*obj).Plist = plist_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	defaultValueData_value := o.DefaultValueData.ValueStringPointer()
	negate_value := o.Negate.ValueBoolPointer()
	var registryValue_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject
	var registryValue_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue
	{
		d := o.RegistryValue.ElementsAs(ctx, &registryValue_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryValue_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryValue_pango_entries = append(registryValue_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).DefaultValueData = defaultValueData_value
	(*obj).Negate = negate_value
	(*obj).RegistryValue = registryValue_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	valueData_value := o.ValueData.ValueStringPointer()
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ValueData = valueData_value
	(*obj).Negate = negate_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	negate_value := o.Negate.ValueBoolPointer()
	var key_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject
	var key_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaPlistKey
	{
		d := o.Key.ElementsAs(ctx, &key_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range key_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaPlistKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			key_pango_entries = append(key_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaPlist)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Negate = negate_value
	(*obj).Key = key_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaPlistKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaPlistKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value
	(*obj).Negate = negate_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var internal_entry *portal.ClientConfigConfigsGatewaysInternal
	if !o.Internal.IsUnknown() && !o.Internal.IsNull() {
		if *obj != nil && (*obj).Internal != nil {
			internal_entry = (*obj).Internal
		} else {
			internal_entry = new(portal.ClientConfigConfigsGatewaysInternal)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject
		diags.Append(o.Internal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &internal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var external_entry *portal.ClientConfigConfigsGatewaysExternal
	if !o.External.IsUnknown() && !o.External.IsNull() {
		if *obj != nil && (*obj).External != nil {
			external_entry = (*obj).External
		} else {
			external_entry = new(portal.ClientConfigConfigsGatewaysExternal)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject
		diags.Append(o.External.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &external_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGateways)
	}
	(*obj).Internal = internal_entry
	(*obj).External = external_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysInternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject
	var list_pango_entries []portal.ClientConfigConfigsGatewaysInternalList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *portal.ClientConfigConfigsGatewaysInternalList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}
	var dhcpOptionCode_pango_entries []int64
	if !o.DhcpOptionCode.IsUnknown() && !o.DhcpOptionCode.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.DhcpOptionCode.Elements()))
		diags.Append(o.DhcpOptionCode.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			dhcpOptionCode_pango_entries = append(dhcpOptionCode_pango_entries, elt.ValueInt64())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysInternal)
	}
	(*obj).List = list_pango_entries
	(*obj).DhcpOptionCode = dhcpOptionCode_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysInternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceIp_pango_entries []string
	if !o.SourceIp.IsUnknown() && !o.SourceIp.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceIp.Elements()))
		diags.Append(o.SourceIp.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceIp_pango_entries = append(sourceIp_pango_entries, elt.ValueString())
		}
	}
	fqdn_value := o.Fqdn.ValueStringPointer()
	var ip_entry *portal.ClientConfigConfigsGatewaysInternalListIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.ClientConfigConfigsGatewaysInternalListIp)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysInternalList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SourceIp = sourceIp_pango_entries
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysInternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysInternalListIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	cutoffTime_value := o.CutoffTime.ValueInt64Pointer()
	var list_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject
	var list_pango_entries []portal.ClientConfigConfigsGatewaysExternalList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *portal.ClientConfigConfigsGatewaysExternalList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternal)
	}
	(*obj).CutoffTime = cutoffTime_value
	(*obj).List = list_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var priorityRule_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject
	var priorityRule_pango_entries []portal.ClientConfigConfigsGatewaysExternalListPriorityRule
	{
		d := o.PriorityRule.ElementsAs(ctx, &priorityRule_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range priorityRule_tf_entries {
			var entry *portal.ClientConfigConfigsGatewaysExternalListPriorityRule
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			priorityRule_pango_entries = append(priorityRule_pango_entries, *entry)
		}
	}
	manual_value := o.Manual.ValueBoolPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	var ip_entry *portal.ClientConfigConfigsGatewaysExternalListIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.ClientConfigConfigsGatewaysExternalListIp)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternalList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).PriorityRule = priorityRule_pango_entries
	(*obj).Manual = manual_value
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternalListPriorityRule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternalListPriorityRule)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternalListIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsInternalHostDetection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsInternalHostDetection)
	}
	(*obj).IpAddress = ipAddress_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsInternalHostDetectionV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsInternalHostDetectionV6)
	}
	(*obj).IpAddress = ipAddress_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAgentUi, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passcode_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "passcode")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.Passcode.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		passcode_value = o.Passcode.ValueStringPointer()
	}

	var uninstallPassword_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "uninstall-password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.UninstallPassword.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		uninstallPassword_value = o.UninstallPassword.ValueStringPointer()
	}
	agentUserOverrideTimeout_value := o.AgentUserOverrideTimeout.ValueInt64Pointer()
	maxAgentUserOverrides_value := o.MaxAgentUserOverrides.ValueInt64Pointer()
	var welcomePage_entry *portal.ClientConfigConfigsAgentUiWelcomePage
	if !o.WelcomePage.IsUnknown() && !o.WelcomePage.IsNull() {
		if *obj != nil && (*obj).WelcomePage != nil {
			welcomePage_entry = (*obj).WelcomePage
		} else {
			welcomePage_entry = new(portal.ClientConfigConfigsAgentUiWelcomePage)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject
		diags.Append(o.WelcomePage.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &welcomePage_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAgentUi)
	}
	(*obj).Passcode = passcode_value
	(*obj).UninstallPassword = uninstallPassword_value
	(*obj).AgentUserOverrideTimeout = agentUserOverrideTimeout_value
	(*obj).MaxAgentUserOverrides = maxAgentUserOverrides_value
	(*obj).WelcomePage = welcomePage_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAgentUiWelcomePage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	page_value := o.Page.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAgentUiWelcomePage)
	}
	(*obj).Page = page_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	maxWaitTime_value := o.MaxWaitTime.ValueInt64Pointer()
	collectHipData_value := o.CollectHipData.ValueBoolPointer()
	var exclusion_entry *portal.ClientConfigConfigsHipCollectionExclusion
	if !o.Exclusion.IsUnknown() && !o.Exclusion.IsNull() {
		if *obj != nil && (*obj).Exclusion != nil {
			exclusion_entry = (*obj).Exclusion
		} else {
			exclusion_entry = new(portal.ClientConfigConfigsHipCollectionExclusion)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject
		diags.Append(o.Exclusion.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &exclusion_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var customChecks_entry *portal.ClientConfigConfigsHipCollectionCustomChecks
	if !o.CustomChecks.IsUnknown() && !o.CustomChecks.IsNull() {
		if *obj != nil && (*obj).CustomChecks != nil {
			customChecks_entry = (*obj).CustomChecks
		} else {
			customChecks_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecks)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject
		diags.Append(o.CustomChecks.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &customChecks_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollection)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).MaxWaitTime = maxWaitTime_value
	(*obj).CollectHipData = collectHipData_value
	(*obj).Exclusion = exclusion_entry
	(*obj).CustomChecks = customChecks_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionExclusion, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var category_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject
	var category_pango_entries []portal.ClientConfigConfigsHipCollectionExclusionCategory
	{
		d := o.Category.ElementsAs(ctx, &category_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range category_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionExclusionCategory
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			category_pango_entries = append(category_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionExclusion)
	}
	(*obj).Category = category_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionExclusionCategory, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vendor_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject
	var vendor_pango_entries []portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor
	{
		d := o.Vendor.ElementsAs(ctx, &vendor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vendor_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			vendor_pango_entries = append(vendor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionExclusionCategory)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vendor = vendor_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var product_pango_entries []string
	if !o.Product.IsUnknown() && !o.Product.IsNull() {
		object_entries := make([]types.String, 0, len(o.Product.Elements()))
		diags.Append(o.Product.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			product_pango_entries = append(product_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Product = product_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var windows_entry *portal.ClientConfigConfigsHipCollectionCustomChecksWindows
	if !o.Windows.IsUnknown() && !o.Windows.IsNull() {
		if *obj != nil && (*obj).Windows != nil {
			windows_entry = (*obj).Windows
		} else {
			windows_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecksWindows)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject
		diags.Append(o.Windows.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &windows_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var macOs_entry *portal.ClientConfigConfigsHipCollectionCustomChecksMacOs
	if !o.MacOs.IsUnknown() && !o.MacOs.IsNull() {
		if *obj != nil && (*obj).MacOs != nil {
			macOs_entry = (*obj).MacOs
		} else {
			macOs_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecksMacOs)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject
		diags.Append(o.MacOs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &macOs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var linux_entry *portal.ClientConfigConfigsHipCollectionCustomChecksLinux
	if !o.Linux.IsUnknown() && !o.Linux.IsNull() {
		if *obj != nil && (*obj).Linux != nil {
			linux_entry = (*obj).Linux
		} else {
			linux_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecksLinux)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject
		diags.Append(o.Linux.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linux_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecks)
	}
	(*obj).Windows = windows_entry
	(*obj).MacOs = macOs_entry
	(*obj).Linux = linux_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject
	var registryKey_pango_entries []portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey
	{
		d := o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryKey_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryKey_pango_entries = append(registryKey_pango_entries, *entry)
		}
	}
	var processList_pango_entries []string
	if !o.ProcessList.IsUnknown() && !o.ProcessList.IsNull() {
		object_entries := make([]types.String, 0, len(o.ProcessList.Elements()))
		diags.Append(o.ProcessList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			processList_pango_entries = append(processList_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksWindows)
	}
	(*obj).RegistryKey = registryKey_pango_entries
	(*obj).ProcessList = processList_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_pango_entries []string
	if !o.RegistryValue.IsUnknown() && !o.RegistryValue.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegistryValue.Elements()))
		diags.Append(o.RegistryValue.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			registryValue_pango_entries = append(registryValue_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).RegistryValue = registryValue_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject
	var plist_pango_entries []portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist
	{
		d := o.Plist.ElementsAs(ctx, &plist_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range plist_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			plist_pango_entries = append(plist_pango_entries, *entry)
		}
	}
	var processList_pango_entries []string
	if !o.ProcessList.IsUnknown() && !o.ProcessList.IsNull() {
		object_entries := make([]types.String, 0, len(o.ProcessList.Elements()))
		diags.Append(o.ProcessList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			processList_pango_entries = append(processList_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksMacOs)
	}
	(*obj).Plist = plist_pango_entries
	(*obj).ProcessList = processList_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_pango_entries []string
	if !o.Key.IsUnknown() && !o.Key.IsNull() {
		object_entries := make([]types.String, 0, len(o.Key.Elements()))
		diags.Append(o.Key.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			key_pango_entries = append(key_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksLinux, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var processList_pango_entries []string
	if !o.ProcessList.IsUnknown() && !o.ProcessList.IsNull() {
		object_entries := make([]types.String, 0, len(o.ProcessList.Elements()))
		diags.Append(o.ProcessList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			processList_pango_entries = append(processList_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksLinux)
	}
	(*obj).ProcessList = processList_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAgentConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAgentConfig)
	}

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGpAppConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var config_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject
	var config_pango_entries []portal.ClientConfigConfigsGpAppConfigConfig
	{
		d := o.Config.ElementsAs(ctx, &config_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range config_tf_entries {
			var entry *portal.ClientConfigConfigsGpAppConfigConfig
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			config_pango_entries = append(config_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGpAppConfig)
	}
	(*obj).Config = config_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGpAppConfigConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var value_pango_entries []string
	if !o.Value.IsUnknown() && !o.Value.IsNull() {
		object_entries := make([]types.String, 0, len(o.Value.Elements()))
		diags.Append(o.Value.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			value_pango_entries = append(value_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGpAppConfigConfig)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	generateCookie_value := o.GenerateCookie.ValueBoolPointer()
	cookieEncryptDecryptCert_value := o.CookieEncryptDecryptCert.ValueStringPointer()
	var acceptCookie_entry *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie
	if !o.AcceptCookie.IsUnknown() && !o.AcceptCookie.IsNull() {
		if *obj != nil && (*obj).AcceptCookie != nil {
			acceptCookie_entry = (*obj).AcceptCookie
		} else {
			acceptCookie_entry = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject
		diags.Append(o.AcceptCookie.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &acceptCookie_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAuthenticationOverride)
	}
	(*obj).GenerateCookie = generateCookie_value
	(*obj).CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	(*obj).AcceptCookie = acceptCookie_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var cookieLifetime_entry *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime
	if !o.CookieLifetime.IsUnknown() && !o.CookieLifetime.IsNull() {
		if *obj != nil && (*obj).CookieLifetime != nil {
			cookieLifetime_entry = (*obj).CookieLifetime
		} else {
			cookieLifetime_entry = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
		diags.Append(o.CookieLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &cookieLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie)
	}
	(*obj).CookieLifetime = cookieLifetime_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetimeInDays_value := o.LifetimeInDays.ValueInt64Pointer()
	lifetimeInHours_value := o.LifetimeInHours.ValueInt64Pointer()
	lifetimeInMinutes_value := o.LifetimeInMinutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
	}
	(*obj).LifetimeInDays = lifetimeInDays_value
	(*obj).LifetimeInHours = lifetimeInHours_value
	(*obj).LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsMachineAccountExistsWithSerialno, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes)
		}
		var object *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialno)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo)
	}

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes)
	}

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	scep_value := o.Scep.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsClientCertificate)
	}
	(*obj).Local = local_value
	(*obj).Scep = scep_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientConfigRootCaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigRootCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	installInCertStore_value := o.InstallInCertStore.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigRootCa)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).InstallInCertStore = installInCertStore_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var appsToUserMapping_tf_entries []GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject
	var appsToUserMapping_pango_entries []portal.ClientlessVpnAppsToUserMapping
	{
		d := o.AppsToUserMapping.ElementsAs(ctx, &appsToUserMapping_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range appsToUserMapping_tf_entries {
			var entry *portal.ClientlessVpnAppsToUserMapping
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			appsToUserMapping_pango_entries = append(appsToUserMapping_pango_entries, *entry)
		}
	}
	var cryptoSettings_entry *portal.ClientlessVpnCryptoSettings
	if !o.CryptoSettings.IsUnknown() && !o.CryptoSettings.IsNull() {
		if *obj != nil && (*obj).CryptoSettings != nil {
			cryptoSettings_entry = (*obj).CryptoSettings
		} else {
			cryptoSettings_entry = new(portal.ClientlessVpnCryptoSettings)
		}
		var object *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject
		diags.Append(o.CryptoSettings.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &cryptoSettings_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	dnsProxy_value := o.DnsProxy.ValueStringPointer()
	hostname_value := o.Hostname.ValueStringPointer()
	var inactivityLogout_entry *portal.ClientlessVpnInactivityLogout
	if !o.InactivityLogout.IsUnknown() && !o.InactivityLogout.IsNull() {
		if *obj != nil && (*obj).InactivityLogout != nil {
			inactivityLogout_entry = (*obj).InactivityLogout
		} else {
			inactivityLogout_entry = new(portal.ClientlessVpnInactivityLogout)
		}
		var object *GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject
		diags.Append(o.InactivityLogout.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &inactivityLogout_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var loginLifetime_entry *portal.ClientlessVpnLoginLifetime
	if !o.LoginLifetime.IsUnknown() && !o.LoginLifetime.IsNull() {
		if *obj != nil && (*obj).LoginLifetime != nil {
			loginLifetime_entry = (*obj).LoginLifetime
		} else {
			loginLifetime_entry = new(portal.ClientlessVpnLoginLifetime)
		}
		var object *GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject
		diags.Append(o.LoginLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &loginLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxUser_value := o.MaxUser.ValueInt64Pointer()
	var proxyServerSetting_tf_entries []GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject
	var proxyServerSetting_pango_entries []portal.ClientlessVpnProxyServerSetting
	{
		d := o.ProxyServerSetting.ElementsAs(ctx, &proxyServerSetting_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyServerSetting_tf_entries {
			var entry *portal.ClientlessVpnProxyServerSetting
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			proxyServerSetting_pango_entries = append(proxyServerSetting_pango_entries, *entry)
		}
	}
	var rewriteExcludeDomainList_pango_entries []string
	if !o.RewriteExcludeDomainList.IsUnknown() && !o.RewriteExcludeDomainList.IsNull() {
		object_entries := make([]types.String, 0, len(o.RewriteExcludeDomainList.Elements()))
		diags.Append(o.RewriteExcludeDomainList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			rewriteExcludeDomainList_pango_entries = append(rewriteExcludeDomainList_pango_entries, elt.ValueString())
		}
	}
	securityZone_value := o.SecurityZone.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpn)
	}
	(*obj).AppsToUserMapping = appsToUserMapping_pango_entries
	(*obj).CryptoSettings = cryptoSettings_entry
	(*obj).DnsProxy = dnsProxy_value
	(*obj).Hostname = hostname_value
	(*obj).InactivityLogout = inactivityLogout_entry
	(*obj).LoginLifetime = loginLifetime_entry
	(*obj).MaxUser = maxUser_value
	(*obj).ProxyServerSetting = proxyServerSetting_pango_entries
	(*obj).RewriteExcludeDomainList = rewriteExcludeDomainList_pango_entries
	(*obj).SecurityZone = securityZone_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnAppsToUserMapping, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var applications_pango_entries []string
	if !o.Applications.IsUnknown() && !o.Applications.IsNull() {
		object_entries := make([]types.String, 0, len(o.Applications.Elements()))
		diags.Append(o.Applications.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			applications_pango_entries = append(applications_pango_entries, elt.ValueString())
		}
	}
	enableCustomAppURLAddressBar_value := o.EnableCustomAppURLAddressBar.ValueBoolPointer()
	displayGlobalProtectAgentDownloadLink_value := o.DisplayGlobalProtectAgentDownloadLink.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnAppsToUserMapping)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).Applications = applications_pango_entries
	(*obj).EnableCustomAppURLAddressBar = enableCustomAppURLAddressBar_value
	(*obj).DisplayGlobalProtectAgentDownloadLink = displayGlobalProtectAgentDownloadLink_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnCryptoSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var serverCertVerification_entry *portal.ClientlessVpnCryptoSettingsServerCertVerification
	if !o.ServerCertVerification.IsUnknown() && !o.ServerCertVerification.IsNull() {
		if *obj != nil && (*obj).ServerCertVerification != nil {
			serverCertVerification_entry = (*obj).ServerCertVerification
		} else {
			serverCertVerification_entry = new(portal.ClientlessVpnCryptoSettingsServerCertVerification)
		}
		var object *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject
		diags.Append(o.ServerCertVerification.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &serverCertVerification_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sslProtocol_entry *portal.ClientlessVpnCryptoSettingsSslProtocol
	if !o.SslProtocol.IsUnknown() && !o.SslProtocol.IsNull() {
		if *obj != nil && (*obj).SslProtocol != nil {
			sslProtocol_entry = (*obj).SslProtocol
		} else {
			sslProtocol_entry = new(portal.ClientlessVpnCryptoSettingsSslProtocol)
		}
		var object *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject
		diags.Append(o.SslProtocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sslProtocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnCryptoSettings)
	}
	(*obj).ServerCertVerification = serverCertVerification_entry
	(*obj).SslProtocol = sslProtocol_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnCryptoSettingsServerCertVerification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	blockExpiredCertificate_value := o.BlockExpiredCertificate.ValueBoolPointer()
	blockTimeoutCert_value := o.BlockTimeoutCert.ValueBoolPointer()
	blockUnknownCert_value := o.BlockUnknownCert.ValueBoolPointer()
	blockUntrustedIssuer_value := o.BlockUntrustedIssuer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnCryptoSettingsServerCertVerification)
	}
	(*obj).BlockExpiredCertificate = blockExpiredCertificate_value
	(*obj).BlockTimeoutCert = blockTimeoutCert_value
	(*obj).BlockUnknownCert = blockUnknownCert_value
	(*obj).BlockUntrustedIssuer = blockUntrustedIssuer_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnCryptoSettingsSslProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authAlgoMd5_value := o.AuthAlgoMd5.ValueBoolPointer()
	authAlgoSha1_value := o.AuthAlgoSha1.ValueBoolPointer()
	authAlgoSha256_value := o.AuthAlgoSha256.ValueBoolPointer()
	authAlgoSha384_value := o.AuthAlgoSha384.ValueBoolPointer()
	encAlgo3des_value := o.EncAlgo3des.ValueBoolPointer()
	encAlgoAes128Cbc_value := o.EncAlgoAes128Cbc.ValueBoolPointer()
	encAlgoAes128Gcm_value := o.EncAlgoAes128Gcm.ValueBoolPointer()
	encAlgoAes256Cbc_value := o.EncAlgoAes256Cbc.ValueBoolPointer()
	encAlgoAes256Gcm_value := o.EncAlgoAes256Gcm.ValueBoolPointer()
	encAlgoRc4_value := o.EncAlgoRc4.ValueBoolPointer()
	keyxchgAlgoDhe_value := o.KeyxchgAlgoDhe.ValueBoolPointer()
	keyxchgAlgoEcdhe_value := o.KeyxchgAlgoEcdhe.ValueBoolPointer()
	keyxchgAlgoRsa_value := o.KeyxchgAlgoRsa.ValueBoolPointer()
	maxVersion_value := o.MaxVersion.ValueStringPointer()
	minVersion_value := o.MinVersion.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnCryptoSettingsSslProtocol)
	}
	(*obj).AuthAlgoMd5 = authAlgoMd5_value
	(*obj).AuthAlgoSha1 = authAlgoSha1_value
	(*obj).AuthAlgoSha256 = authAlgoSha256_value
	(*obj).AuthAlgoSha384 = authAlgoSha384_value
	(*obj).EncAlgo3des = encAlgo3des_value
	(*obj).EncAlgoAes128Cbc = encAlgoAes128Cbc_value
	(*obj).EncAlgoAes128Gcm = encAlgoAes128Gcm_value
	(*obj).EncAlgoAes256Cbc = encAlgoAes256Cbc_value
	(*obj).EncAlgoAes256Gcm = encAlgoAes256Gcm_value
	(*obj).EncAlgoRc4 = encAlgoRc4_value
	(*obj).KeyxchgAlgoDhe = keyxchgAlgoDhe_value
	(*obj).KeyxchgAlgoEcdhe = keyxchgAlgoEcdhe_value
	(*obj).KeyxchgAlgoRsa = keyxchgAlgoRsa_value
	(*obj).MaxVersion = maxVersion_value
	(*obj).MinVersion = minVersion_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnInactivityLogout, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hours_value := o.Hours.ValueInt64Pointer()
	minutes_value := o.Minutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnInactivityLogout)
	}
	(*obj).Hours = hours_value
	(*obj).Minutes = minutes_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hours_value := o.Hours.ValueInt64Pointer()
	minutes_value := o.Minutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnLoginLifetime)
	}
	(*obj).Hours = hours_value
	(*obj).Minutes = minutes_value

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnProxyServerSetting, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var domains_pango_entries []string
	if !o.Domains.IsUnknown() && !o.Domains.IsNull() {
		object_entries := make([]types.String, 0, len(o.Domains.Elements()))
		diags.Append(o.Domains.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			domains_pango_entries = append(domains_pango_entries, elt.ValueString())
		}
	}
	useProxy_value := o.UseProxy.ValueBoolPointer()
	var proxyServer_entry *portal.ClientlessVpnProxyServerSettingProxyServer
	if !o.ProxyServer.IsUnknown() && !o.ProxyServer.IsNull() {
		if *obj != nil && (*obj).ProxyServer != nil {
			proxyServer_entry = (*obj).ProxyServer
		} else {
			proxyServer_entry = new(portal.ClientlessVpnProxyServerSettingProxyServer)
		}
		var object *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject
		diags.Append(o.ProxyServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &proxyServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnProxyServerSetting)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Domains = domains_pango_entries
	(*obj).UseProxy = useProxy_value
	(*obj).ProxyServer = proxyServer_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnProxyServerSettingProxyServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	server_value := o.Server.ValueStringPointer()
	port_value := o.Port.ValueInt64Pointer()
	user_value := o.User.ValueStringPointer()

	var password_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.Password.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		password_value = o.Password.ValueStringPointer()
	}

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnProxyServerSettingProxyServer)
	}
	(*obj).Server = server_value
	(*obj).Port = port_value
	(*obj).User = user_value
	(*obj).Password = password_value

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var clientAuth_tf_entries []GlobalprotectPortalDataSourcePortalConfigClientAuthObject
	var clientAuth_pango_entries []portal.PortalConfigClientAuth
	{
		d := o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range clientAuth_tf_entries {
			var entry *portal.PortalConfigClientAuth
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			clientAuth_pango_entries = append(clientAuth_pango_entries, *entry)
		}
	}
	var configSelection_entry *portal.PortalConfigConfigSelection
	if !o.ConfigSelection.IsUnknown() && !o.ConfigSelection.IsNull() {
		if *obj != nil && (*obj).ConfigSelection != nil {
			configSelection_entry = (*obj).ConfigSelection
		} else {
			configSelection_entry = new(portal.PortalConfigConfigSelection)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject
		diags.Append(o.ConfigSelection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &configSelection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	customHelpPage_value := o.CustomHelpPage.ValueStringPointer()
	customHomePage_value := o.CustomHomePage.ValueStringPointer()
	customLoginPage_value := o.CustomLoginPage.ValueStringPointer()
	var localAddress_entry *portal.PortalConfigLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(portal.PortalConfigLocalAddress)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	logFail_value := o.LogFail.ValueBoolPointer()
	logSetting_value := o.LogSetting.ValueStringPointer()
	logSuccess_value := o.LogSuccess.ValueBoolPointer()
	sslTlsServiceProfile_value := o.SslTlsServiceProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfig)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).ClientAuth = clientAuth_pango_entries
	(*obj).ConfigSelection = configSelection_entry
	(*obj).CustomHelpPage = customHelpPage_value
	(*obj).CustomHomePage = customHomePage_value
	(*obj).CustomLoginPage = customLoginPage_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).LogFail = logFail_value
	(*obj).LogSetting = logSetting_value
	(*obj).LogSuccess = logSuccess_value
	(*obj).SslTlsServiceProfile = sslTlsServiceProfile_value

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigClientAuthObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	os_value := o.Os.ValueStringPointer()
	authenticationProfile_value := o.AuthenticationProfile.ValueStringPointer()
	autoRetrievePasscode_value := o.AutoRetrievePasscode.ValueBoolPointer()
	usernameLabel_value := o.UsernameLabel.ValueStringPointer()
	passwordLabel_value := o.PasswordLabel.ValueStringPointer()
	authenticationMessage_value := o.AuthenticationMessage.ValueStringPointer()
	userCredentialOrClientCertRequired_value := o.UserCredentialOrClientCertRequired.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfigClientAuth)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Os = os_value
	(*obj).AuthenticationProfile = authenticationProfile_value
	(*obj).AutoRetrievePasscode = autoRetrievePasscode_value
	(*obj).UsernameLabel = usernameLabel_value
	(*obj).PasswordLabel = passwordLabel_value
	(*obj).AuthenticationMessage = authenticationMessage_value
	(*obj).UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var customChecks_entry *portal.PortalConfigConfigSelectionCustomChecks
	if !o.CustomChecks.IsUnknown() && !o.CustomChecks.IsNull() {
		if *obj != nil && (*obj).CustomChecks != nil {
			customChecks_entry = (*obj).CustomChecks
		} else {
			customChecks_entry = new(portal.PortalConfigConfigSelectionCustomChecks)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject
		diags.Append(o.CustomChecks.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &customChecks_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelection)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).CustomChecks = customChecks_entry

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var macOs_entry *portal.PortalConfigConfigSelectionCustomChecksMacOs
	if !o.MacOs.IsUnknown() && !o.MacOs.IsNull() {
		if *obj != nil && (*obj).MacOs != nil {
			macOs_entry = (*obj).MacOs
		} else {
			macOs_entry = new(portal.PortalConfigConfigSelectionCustomChecksMacOs)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject
		diags.Append(o.MacOs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &macOs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var windows_entry *portal.PortalConfigConfigSelectionCustomChecksWindows
	if !o.Windows.IsUnknown() && !o.Windows.IsNull() {
		if *obj != nil && (*obj).Windows != nil {
			windows_entry = (*obj).Windows
		} else {
			windows_entry = new(portal.PortalConfigConfigSelectionCustomChecksWindows)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject
		diags.Append(o.Windows.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &windows_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecks)
	}
	(*obj).MacOs = macOs_entry
	(*obj).Windows = windows_entry

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_tf_entries []GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject
	var plist_pango_entries []portal.PortalConfigConfigSelectionCustomChecksMacOsPlist
	{
		d := o.Plist.ElementsAs(ctx, &plist_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range plist_tf_entries {
			var entry *portal.PortalConfigConfigSelectionCustomChecksMacOsPlist
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			plist_pango_entries = append(plist_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksMacOs)
	}
	(*obj).Plist = plist_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_pango_entries []string
	if !o.Key.IsUnknown() && !o.Key.IsNull() {
		object_entries := make([]types.String, 0, len(o.Key.Elements()))
		diags.Append(o.Key.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			key_pango_entries = append(key_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksMacOsPlist)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_tf_entries []GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject
	var registryKey_pango_entries []portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey
	{
		d := o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryKey_tf_entries {
			var entry *portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryKey_pango_entries = append(registryKey_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksWindows)
	}
	(*obj).RegistryKey = registryKey_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_pango_entries []string
	if !o.RegistryValue.IsUnknown() && !o.RegistryValue.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegistryValue.Elements()))
		diags.Append(o.RegistryValue.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			registryValue_pango_entries = append(registryValue_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).RegistryValue = registryValue_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ipAddressFamily_value := o.IpAddressFamily.ValueStringPointer()
	var floatingIp_entry *portal.PortalConfigLocalAddressFloatingIp
	if !o.FloatingIp.IsUnknown() && !o.FloatingIp.IsNull() {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(portal.PortalConfigLocalAddressFloatingIp)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject
		diags.Append(o.FloatingIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &floatingIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *portal.PortalConfigLocalAddressIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.PortalConfigLocalAddressIp)
		}
		var object *GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).IpAddressFamily = ipAddressFamily_value
	(*obj).FloatingIp = floatingIp_entry
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfigLocalAddressFloatingIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfigLocalAddressIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientCertificate_entry *portal.SatelliteConfigClientCertificate
	if !o.ClientCertificate.IsUnknown() && !o.ClientCertificate.IsNull() {
		if *obj != nil && (*obj).ClientCertificate != nil {
			clientCertificate_entry = (*obj).ClientCertificate
		} else {
			clientCertificate_entry = new(portal.SatelliteConfigClientCertificate)
		}
		var object *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject
		diags.Append(o.ClientCertificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &clientCertificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var configs_tf_entries []GlobalprotectPortalDataSourceSatelliteConfigConfigsObject
	var configs_pango_entries []portal.SatelliteConfigConfigs
	{
		d := o.Configs.ElementsAs(ctx, &configs_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range configs_tf_entries {
			var entry *portal.SatelliteConfigConfigs
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			configs_pango_entries = append(configs_pango_entries, *entry)
		}
	}
	var rootCa_pango_entries []string
	if !o.RootCa.IsUnknown() && !o.RootCa.IsNull() {
		object_entries := make([]types.String, 0, len(o.RootCa.Elements()))
		diags.Append(o.RootCa.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			rootCa_pango_entries = append(rootCa_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfig)
	}
	(*obj).ClientCertificate = clientCertificate_entry
	(*obj).Configs = configs_pango_entries
	(*obj).RootCa = rootCa_pango_entries

	return diags
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var local_entry *portal.SatelliteConfigClientCertificateLocal
	if !o.Local.IsUnknown() && !o.Local.IsNull() {
		if *obj != nil && (*obj).Local != nil {
			local_entry = (*obj).Local
		} else {
			local_entry = new(portal.SatelliteConfigClientCertificateLocal)
		}
		var object *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject
		diags.Append(o.Local.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &local_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var scep_entry *portal.SatelliteConfigClientCertificateScep
	if !o.Scep.IsUnknown() && !o.Scep.IsNull() {
		if *obj != nil && (*obj).Scep != nil {
			scep_entry = (*obj).Scep
		} else {
			scep_entry = new(portal.SatelliteConfigClientCertificateScep)
		}
		var object *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject
		diags.Append(o.Scep.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &scep_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigClientCertificate)
	}
	(*obj).Local = local_entry
	(*obj).Scep = scep_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigClientCertificateLocal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateLifeTime_value := o.CertificateLifeTime.ValueInt64Pointer()
	certificateRenewalPeriod_value := o.CertificateRenewalPeriod.ValueInt64Pointer()
	issuingCertificate_value := o.IssuingCertificate.ValueStringPointer()
	ocspResponder_value := o.OcspResponder.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigClientCertificateLocal)
	}
	(*obj).CertificateLifeTime = certificateLifeTime_value
	(*obj).CertificateRenewalPeriod = certificateRenewalPeriod_value
	(*obj).IssuingCertificate = issuingCertificate_value
	(*obj).OcspResponder = ocspResponder_value

	return diags
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigClientCertificateScep, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateRenewalPeriod_value := o.CertificateRenewalPeriod.ValueInt64Pointer()
	scep_value := o.Scep.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigClientCertificateScep)
	}
	(*obj).CertificateRenewalPeriod = certificateRenewalPeriod_value
	(*obj).Scep = scep_value

	return diags
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_pango_entries []string
	if !o.Devices.IsUnknown() && !o.Devices.IsNull() {
		object_entries := make([]types.String, 0, len(o.Devices.Elements()))
		diags.Append(o.Devices.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			devices_pango_entries = append(devices_pango_entries, elt.ValueString())
		}
	}
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var gateways_tf_entries []GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject
	var gateways_pango_entries []portal.SatelliteConfigConfigsGateways
	{
		d := o.Gateways.ElementsAs(ctx, &gateways_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range gateways_tf_entries {
			var entry *portal.SatelliteConfigConfigsGateways
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			gateways_pango_entries = append(gateways_pango_entries, *entry)
		}
	}
	configRefreshInterval_value := o.ConfigRefreshInterval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigConfigs)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Devices = devices_pango_entries
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).Gateways = gateways_pango_entries
	(*obj).ConfigRefreshInterval = configRefreshInterval_value

	return diags
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv6Preferred_value := o.Ipv6Preferred.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	var ip_entry *portal.SatelliteConfigConfigsGatewaysIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.SatelliteConfigConfigsGatewaysIp)
		}
		var object *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigConfigsGateways)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ipv6Preferred = ipv6Preferred_value
	(*obj).Priority = priority_value
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigConfigsGatewaysIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigConfigsGatewaysIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var clientConfig_obj *GlobalprotectPortalDataSourceClientConfigObject
	if o.ClientConfig.IsNull() {
		clientConfig_obj = new(GlobalprotectPortalDataSourceClientConfigObject)
	} else {
		diags.Append(o.ClientConfig.As(ctx, &clientConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientConfig_object := types.ObjectNull(clientConfig_obj.AttributeTypes())
	if obj.ClientConfig != nil {
		diags.Append(clientConfig_obj.CopyFromPango(ctx, client, ancestors, obj.ClientConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientConfig_object, diags_tmp = types.ObjectValueFrom(ctx, clientConfig_obj.AttributeTypes(), clientConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var clientlessVpn_obj *GlobalprotectPortalDataSourceClientlessVpnObject
	if o.ClientlessVpn.IsNull() {
		clientlessVpn_obj = new(GlobalprotectPortalDataSourceClientlessVpnObject)
	} else {
		diags.Append(o.ClientlessVpn.As(ctx, &clientlessVpn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientlessVpn_object := types.ObjectNull(clientlessVpn_obj.AttributeTypes())
	if obj.ClientlessVpn != nil {
		diags.Append(clientlessVpn_obj.CopyFromPango(ctx, client, ancestors, obj.ClientlessVpn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientlessVpn_object, diags_tmp = types.ObjectValueFrom(ctx, clientlessVpn_obj.AttributeTypes(), clientlessVpn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var portalConfig_obj *GlobalprotectPortalDataSourcePortalConfigObject
	if o.PortalConfig.IsNull() {
		portalConfig_obj = new(GlobalprotectPortalDataSourcePortalConfigObject)
	} else {
		diags.Append(o.PortalConfig.As(ctx, &portalConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	portalConfig_object := types.ObjectNull(portalConfig_obj.AttributeTypes())
	if obj.PortalConfig != nil {
		diags.Append(portalConfig_obj.CopyFromPango(ctx, client, ancestors, obj.PortalConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		portalConfig_object, diags_tmp = types.ObjectValueFrom(ctx, portalConfig_obj.AttributeTypes(), portalConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var satelliteConfig_obj *GlobalprotectPortalDataSourceSatelliteConfigObject
	if o.SatelliteConfig.IsNull() {
		satelliteConfig_obj = new(GlobalprotectPortalDataSourceSatelliteConfigObject)
	} else {
		diags.Append(o.SatelliteConfig.As(ctx, &satelliteConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	satelliteConfig_object := types.ObjectNull(satelliteConfig_obj.AttributeTypes())
	if obj.SatelliteConfig != nil {
		diags.Append(satelliteConfig_obj.CopyFromPango(ctx, client, ancestors, obj.SatelliteConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		satelliteConfig_object, diags_tmp = types.ObjectValueFrom(ctx, satelliteConfig_obj.AttributeTypes(), satelliteConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.ClientConfig = clientConfig_object
	o.ClientlessVpn = clientlessVpn_object
	o.PortalConfig = portalConfig_object
	o.SatelliteConfig = satelliteConfig_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var configs_list types.List
	{
		var configs_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsObject
		if !o.Configs.IsNull() {
			diags.Append(o.Configs.ElementsAs(ctx, &configs_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Configs {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(configs_tf_entries) {
				entry = configs_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(configs_tf_entries) {
				configs_tf_entries[idx] = entry
			} else {
				configs_tf_entries = append(configs_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("configs")
		configs_list, list_diags = types.ListValueFrom(ctx, schemaType, configs_tf_entries)
		diags.Append(list_diags...)
	}
	var rootCa_list types.List
	{
		var rootCa_tf_entries []GlobalprotectPortalDataSourceClientConfigRootCaObject
		if !o.RootCa.IsNull() {
			diags.Append(o.RootCa.ElementsAs(ctx, &rootCa_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RootCa {
			entry := GlobalprotectPortalDataSourceClientConfigRootCaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rootCa_tf_entries) {
				entry = rootCa_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rootCa_tf_entries) {
				rootCa_tf_entries[idx] = entry
			} else {
				rootCa_tf_entries = append(rootCa_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("root_ca")
		rootCa_list, list_diags = types.ListValueFrom(ctx, schemaType, rootCa_tf_entries)
		diags.Append(list_diags...)
	}

	var agentUserOverrideKey_value types.String
	if obj.AgentUserOverrideKey != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "agent-user-override-key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.AgentUserOverrideKey != evFromState {
			agentUserOverrideKey_value = types.StringPointerValue(obj.AgentUserOverrideKey)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			agentUserOverrideKey_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.AgentUserOverrideKey)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	o.AgentUserOverrideKey = agentUserOverrideKey_value
	o.Configs = configs_list
	o.RootCa = rootCa_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var thirdPartyVpnClients_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ThirdPartyVpnClients.IsNull() || len(obj.ThirdPartyVpnClients) > 0 {
			entries = obj.ThirdPartyVpnClients
		}

		thirdPartyVpnClients_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var os_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Os.IsNull() || len(obj.Os) > 0 {
			entries = obj.Os
		}

		os_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var certificate_obj *GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject
	if o.Certificate.IsNull() {
		certificate_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject)
	} else {
		diags.Append(o.Certificate.As(ctx, &certificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	certificate_object := types.ObjectNull(certificate_obj.AttributeTypes())
	if obj.Certificate != nil {
		diags.Append(certificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Certificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		certificate_object, diags_tmp = types.ObjectValueFrom(ctx, certificate_obj.AttributeTypes(), certificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var customChecks_obj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject
	if o.CustomChecks.IsNull() {
		customChecks_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject)
	} else {
		diags.Append(o.CustomChecks.As(ctx, &customChecks_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	customChecks_object := types.ObjectNull(customChecks_obj.AttributeTypes())
	if obj.CustomChecks != nil {
		diags.Append(customChecks_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CustomChecks, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		customChecks_object, diags_tmp = types.ObjectValueFrom(ctx, customChecks_obj.AttributeTypes(), customChecks_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gateways_obj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject
	if o.Gateways.IsNull() {
		gateways_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject)
	} else {
		diags.Append(o.Gateways.As(ctx, &gateways_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gateways_object := types.ObjectNull(gateways_obj.AttributeTypes())
	if obj.Gateways != nil {
		diags.Append(gateways_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Gateways, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gateways_object, diags_tmp = types.ObjectValueFrom(ctx, gateways_obj.AttributeTypes(), gateways_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var internalHostDetection_obj *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject
	if o.InternalHostDetection.IsNull() {
		internalHostDetection_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject)
	} else {
		diags.Append(o.InternalHostDetection.As(ctx, &internalHostDetection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	internalHostDetection_object := types.ObjectNull(internalHostDetection_obj.AttributeTypes())
	if obj.InternalHostDetection != nil {
		diags.Append(internalHostDetection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InternalHostDetection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		internalHostDetection_object, diags_tmp = types.ObjectValueFrom(ctx, internalHostDetection_obj.AttributeTypes(), internalHostDetection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var internalHostDetectionV6_obj *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object
	if o.InternalHostDetectionV6.IsNull() {
		internalHostDetectionV6_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object)
	} else {
		diags.Append(o.InternalHostDetectionV6.As(ctx, &internalHostDetectionV6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	internalHostDetectionV6_object := types.ObjectNull(internalHostDetectionV6_obj.AttributeTypes())
	if obj.InternalHostDetectionV6 != nil {
		diags.Append(internalHostDetectionV6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InternalHostDetectionV6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		internalHostDetectionV6_object, diags_tmp = types.ObjectValueFrom(ctx, internalHostDetectionV6_obj.AttributeTypes(), internalHostDetectionV6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var agentUi_obj *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject
	if o.AgentUi.IsNull() {
		agentUi_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject)
	} else {
		diags.Append(o.AgentUi.As(ctx, &agentUi_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	agentUi_object := types.ObjectNull(agentUi_obj.AttributeTypes())
	if obj.AgentUi != nil {
		diags.Append(agentUi_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AgentUi, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		agentUi_object, diags_tmp = types.ObjectValueFrom(ctx, agentUi_obj.AttributeTypes(), agentUi_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hipCollection_obj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject
	if o.HipCollection.IsNull() {
		hipCollection_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject)
	} else {
		diags.Append(o.HipCollection.As(ctx, &hipCollection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hipCollection_object := types.ObjectNull(hipCollection_obj.AttributeTypes())
	if obj.HipCollection != nil {
		diags.Append(hipCollection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HipCollection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hipCollection_object, diags_tmp = types.ObjectValueFrom(ctx, hipCollection_obj.AttributeTypes(), hipCollection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var agentConfig_obj *GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject
	if o.AgentConfig.IsNull() {
		agentConfig_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject)
	} else {
		diags.Append(o.AgentConfig.As(ctx, &agentConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	agentConfig_object := types.ObjectNull(agentConfig_obj.AttributeTypes())
	if obj.AgentConfig != nil {
		diags.Append(agentConfig_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AgentConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		agentConfig_object, diags_tmp = types.ObjectValueFrom(ctx, agentConfig_obj.AttributeTypes(), agentConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gpAppConfig_obj *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject
	if o.GpAppConfig.IsNull() {
		gpAppConfig_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject)
	} else {
		diags.Append(o.GpAppConfig.As(ctx, &gpAppConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gpAppConfig_object := types.ObjectNull(gpAppConfig_obj.AttributeTypes())
	if obj.GpAppConfig != nil {
		diags.Append(gpAppConfig_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GpAppConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gpAppConfig_object, diags_tmp = types.ObjectValueFrom(ctx, gpAppConfig_obj.AttributeTypes(), gpAppConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authenticationOverride_obj *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject
	if o.AuthenticationOverride.IsNull() {
		authenticationOverride_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject)
	} else {
		diags.Append(o.AuthenticationOverride.As(ctx, &authenticationOverride_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authenticationOverride_object := types.ObjectNull(authenticationOverride_obj.AttributeTypes())
	if obj.AuthenticationOverride != nil {
		diags.Append(authenticationOverride_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AuthenticationOverride, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authenticationOverride_object, diags_tmp = types.ObjectValueFrom(ctx, authenticationOverride_obj.AttributeTypes(), authenticationOverride_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var machineAccountExistsWithSerialno_obj *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject
	if o.MachineAccountExistsWithSerialno.IsNull() {
		machineAccountExistsWithSerialno_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject)
	} else {
		diags.Append(o.MachineAccountExistsWithSerialno.As(ctx, &machineAccountExistsWithSerialno_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	machineAccountExistsWithSerialno_object := types.ObjectNull(machineAccountExistsWithSerialno_obj.AttributeTypes())
	if obj.MachineAccountExistsWithSerialno != nil {
		diags.Append(machineAccountExistsWithSerialno_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MachineAccountExistsWithSerialno, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		machineAccountExistsWithSerialno_object, diags_tmp = types.ObjectValueFrom(ctx, machineAccountExistsWithSerialno_obj.AttributeTypes(), machineAccountExistsWithSerialno_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var clientCertificate_obj *GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject
	if o.ClientCertificate.IsNull() {
		clientCertificate_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject)
	} else {
		diags.Append(o.ClientCertificate.As(ctx, &clientCertificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientCertificate_object := types.ObjectNull(clientCertificate_obj.AttributeTypes())
	if obj.ClientCertificate != nil {
		diags.Append(clientCertificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ClientCertificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientCertificate_object, diags_tmp = types.ObjectValueFrom(ctx, clientCertificate_obj.AttributeTypes(), clientCertificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var saveUserCredentials_value types.String
	if obj.SaveUserCredentials != nil {
		saveUserCredentials_value = types.StringValue(*obj.SaveUserCredentials)
	}
	var portal2fa_value types.Bool
	if obj.Portal2fa != nil {
		portal2fa_value = types.BoolValue(*obj.Portal2fa)
	}
	var internalGateway2fa_value types.Bool
	if obj.InternalGateway2fa != nil {
		internalGateway2fa_value = types.BoolValue(*obj.InternalGateway2fa)
	}
	var autoDiscoveryExternalGateway2fa_value types.Bool
	if obj.AutoDiscoveryExternalGateway2fa != nil {
		autoDiscoveryExternalGateway2fa_value = types.BoolValue(*obj.AutoDiscoveryExternalGateway2fa)
	}
	var manualOnlyGateway2fa_value types.Bool
	if obj.ManualOnlyGateway2fa != nil {
		manualOnlyGateway2fa_value = types.BoolValue(*obj.ManualOnlyGateway2fa)
	}
	var refreshConfig_value types.Bool
	if obj.RefreshConfig != nil {
		refreshConfig_value = types.BoolValue(*obj.RefreshConfig)
	}
	var mdmAddress_value types.String
	if obj.MdmAddress != nil {
		mdmAddress_value = types.StringValue(*obj.MdmAddress)
	}
	var mdmEnrollmentPort_value types.String
	if obj.MdmEnrollmentPort != nil {
		mdmEnrollmentPort_value = types.StringValue(*obj.MdmEnrollmentPort)
	}
	o.Name = types.StringValue(obj.Name)
	o.SaveUserCredentials = saveUserCredentials_value
	o.Portal2fa = portal2fa_value
	o.InternalGateway2fa = internalGateway2fa_value
	o.AutoDiscoveryExternalGateway2fa = autoDiscoveryExternalGateway2fa_value
	o.ManualOnlyGateway2fa = manualOnlyGateway2fa_value
	o.RefreshConfig = refreshConfig_value
	o.MdmAddress = mdmAddress_value
	o.MdmEnrollmentPort = mdmEnrollmentPort_value
	o.SourceUser = sourceUser_list
	o.ThirdPartyVpnClients = thirdPartyVpnClients_list
	o.Os = os_list
	o.Certificate = certificate_object
	o.CustomChecks = customChecks_object
	o.Gateways = gateways_object
	o.InternalHostDetection = internalHostDetection_object
	o.InternalHostDetectionV6 = internalHostDetectionV6_object
	o.AgentUi = agentUi_object
	o.HipCollection = hipCollection_object
	o.AgentConfig = agentConfig_object
	o.GpAppConfig = gpAppConfig_object
	o.AuthenticationOverride = authenticationOverride_object
	o.MachineAccountExistsWithSerialno = machineAccountExistsWithSerialno_object
	o.ClientCertificate = clientCertificate_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var criteria_obj *GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject
	if o.Criteria.IsNull() {
		criteria_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject)
	} else {
		diags.Append(o.Criteria.As(ctx, &criteria_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	criteria_object := types.ObjectNull(criteria_obj.AttributeTypes())
	if obj.Criteria != nil {
		diags.Append(criteria_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Criteria, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		criteria_object, diags_tmp = types.ObjectValueFrom(ctx, criteria_obj.AttributeTypes(), criteria_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Criteria = criteria_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCertificateCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	o.CertificateProfile = certificateProfile_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var criteria_obj *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject
	if o.Criteria.IsNull() {
		criteria_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject)
	} else {
		diags.Append(o.Criteria.As(ctx, &criteria_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	criteria_object := types.ObjectNull(criteria_obj.AttributeTypes())
	if obj.Criteria != nil {
		diags.Append(criteria_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Criteria, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		criteria_object, diags_tmp = types.ObjectValueFrom(ctx, criteria_obj.AttributeTypes(), criteria_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Criteria = criteria_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_list types.List
	{
		var registryKey_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject
		if !o.RegistryKey.IsNull() {
			diags.Append(o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryKey {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryKey_tf_entries) {
				entry = registryKey_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryKey_tf_entries) {
				registryKey_tf_entries[idx] = entry
			} else {
				registryKey_tf_entries = append(registryKey_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_key")
		registryKey_list, list_diags = types.ListValueFrom(ctx, schemaType, registryKey_tf_entries)
		diags.Append(list_diags...)
	}
	var plist_list types.List
	{
		var plist_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject
		if !o.Plist.IsNull() {
			diags.Append(o.Plist.ElementsAs(ctx, &plist_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Plist {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(plist_tf_entries) {
				entry = plist_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(plist_tf_entries) {
				plist_tf_entries[idx] = entry
			} else {
				plist_tf_entries = append(plist_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("plist")
		plist_list, list_diags = types.ListValueFrom(ctx, schemaType, plist_tf_entries)
		diags.Append(list_diags...)
	}

	o.RegistryKey = registryKey_list
	o.Plist = plist_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_list types.List
	{
		var registryValue_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject
		if !o.RegistryValue.IsNull() {
			diags.Append(o.RegistryValue.ElementsAs(ctx, &registryValue_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryValue {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryValue_tf_entries) {
				entry = registryValue_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryValue_tf_entries) {
				registryValue_tf_entries[idx] = entry
			} else {
				registryValue_tf_entries = append(registryValue_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_value")
		registryValue_list, list_diags = types.ListValueFrom(ctx, schemaType, registryValue_tf_entries)
		diags.Append(list_diags...)
	}

	var defaultValueData_value types.String
	if obj.DefaultValueData != nil {
		defaultValueData_value = types.StringValue(*obj.DefaultValueData)
	}
	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.DefaultValueData = defaultValueData_value
	o.Negate = negate_value
	o.RegistryValue = registryValue_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var valueData_value types.String
	if obj.ValueData != nil {
		valueData_value = types.StringValue(*obj.ValueData)
	}
	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.ValueData = valueData_value
	o.Negate = negate_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_list types.List
	{
		var key_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject
		if !o.Key.IsNull() {
			diags.Append(o.Key.ElementsAs(ctx, &key_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Key {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(key_tf_entries) {
				entry = key_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(key_tf_entries) {
				key_tf_entries[idx] = entry
			} else {
				key_tf_entries = append(key_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("key")
		key_list, list_diags = types.ListValueFrom(ctx, schemaType, key_tf_entries)
		diags.Append(list_diags...)
	}

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Negate = negate_value
	o.Key = key_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaPlistKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value
	o.Negate = negate_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var internal_obj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject
	if o.Internal.IsNull() {
		internal_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject)
	} else {
		diags.Append(o.Internal.As(ctx, &internal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	internal_object := types.ObjectNull(internal_obj.AttributeTypes())
	if obj.Internal != nil {
		diags.Append(internal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Internal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		internal_object, diags_tmp = types.ObjectValueFrom(ctx, internal_obj.AttributeTypes(), internal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var external_obj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject
	if o.External.IsNull() {
		external_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject)
	} else {
		diags.Append(o.External.As(ctx, &external_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	external_object := types.ObjectNull(external_obj.AttributeTypes())
	if obj.External != nil {
		diags.Append(external_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.External, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		external_object, diags_tmp = types.ObjectValueFrom(ctx, external_obj.AttributeTypes(), external_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Internal = internal_object
	o.External = external_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysInternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}
	var dhcpOptionCode_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.DhcpOptionCode.IsNull() || len(obj.DhcpOptionCode) > 0 {
			entries = obj.DhcpOptionCode
		}

		dhcpOptionCode_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.List = list_list
	o.DhcpOptionCode = dhcpOptionCode_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysInternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceIp_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceIp.IsNull() || len(obj.SourceIp) > 0 {
			entries = obj.SourceIp
		}

		sourceIp_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Name = types.StringValue(obj.Name)
	o.SourceIp = sourceIp_list
	o.Fqdn = fqdn_value
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysInternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}

	var cutoffTime_value types.Int64
	if obj.CutoffTime != nil {
		cutoffTime_value = types.Int64Value(*obj.CutoffTime)
	}
	o.CutoffTime = cutoffTime_value
	o.List = list_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var priorityRule_list types.List
	{
		var priorityRule_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject
		if !o.PriorityRule.IsNull() {
			diags.Append(o.PriorityRule.ElementsAs(ctx, &priorityRule_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.PriorityRule {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(priorityRule_tf_entries) {
				entry = priorityRule_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(priorityRule_tf_entries) {
				priorityRule_tf_entries[idx] = entry
			} else {
				priorityRule_tf_entries = append(priorityRule_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("priority_rule")
		priorityRule_list, list_diags = types.ListValueFrom(ctx, schemaType, priorityRule_tf_entries)
		diags.Append(list_diags...)
	}

	var ip_obj *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_value types.Bool
	if obj.Manual != nil {
		manual_value = types.BoolValue(*obj.Manual)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Name = types.StringValue(obj.Name)
	o.PriorityRule = priorityRule_list
	o.Manual = manual_value
	o.Fqdn = fqdn_value
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternalListPriorityRule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.String
	if obj.Priority != nil {
		priority_value = types.StringValue(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsInternalHostDetection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.IpAddress = ipAddress_value
	o.Hostname = hostname_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsInternalHostDetectionV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.IpAddress = ipAddress_value
	o.Hostname = hostname_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAgentUi, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var welcomePage_obj *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject
	if o.WelcomePage.IsNull() {
		welcomePage_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject)
	} else {
		diags.Append(o.WelcomePage.As(ctx, &welcomePage_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	welcomePage_object := types.ObjectNull(welcomePage_obj.AttributeTypes())
	if obj.WelcomePage != nil {
		diags.Append(welcomePage_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WelcomePage, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		welcomePage_object, diags_tmp = types.ObjectValueFrom(ctx, welcomePage_obj.AttributeTypes(), welcomePage_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var passcode_value types.String
	if obj.Passcode != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "passcode")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.Passcode != evFromState {
			passcode_value = types.StringPointerValue(obj.Passcode)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			passcode_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.Passcode)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	var uninstallPassword_value types.String
	if obj.UninstallPassword != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "uninstall-password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.UninstallPassword != evFromState {
			uninstallPassword_value = types.StringPointerValue(obj.UninstallPassword)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			uninstallPassword_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.UninstallPassword)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	var agentUserOverrideTimeout_value types.Int64
	if obj.AgentUserOverrideTimeout != nil {
		agentUserOverrideTimeout_value = types.Int64Value(*obj.AgentUserOverrideTimeout)
	}
	var maxAgentUserOverrides_value types.Int64
	if obj.MaxAgentUserOverrides != nil {
		maxAgentUserOverrides_value = types.Int64Value(*obj.MaxAgentUserOverrides)
	}
	o.Passcode = passcode_value
	o.UninstallPassword = uninstallPassword_value
	o.AgentUserOverrideTimeout = agentUserOverrideTimeout_value
	o.MaxAgentUserOverrides = maxAgentUserOverrides_value
	o.WelcomePage = welcomePage_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAgentUiWelcomePage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var page_value types.String
	if obj.Page != nil {
		page_value = types.StringValue(*obj.Page)
	}
	o.Page = page_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exclusion_obj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject
	if o.Exclusion.IsNull() {
		exclusion_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject)
	} else {
		diags.Append(o.Exclusion.As(ctx, &exclusion_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	exclusion_object := types.ObjectNull(exclusion_obj.AttributeTypes())
	if obj.Exclusion != nil {
		diags.Append(exclusion_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Exclusion, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		exclusion_object, diags_tmp = types.ObjectValueFrom(ctx, exclusion_obj.AttributeTypes(), exclusion_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var customChecks_obj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject
	if o.CustomChecks.IsNull() {
		customChecks_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject)
	} else {
		diags.Append(o.CustomChecks.As(ctx, &customChecks_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	customChecks_object := types.ObjectNull(customChecks_obj.AttributeTypes())
	if obj.CustomChecks != nil {
		diags.Append(customChecks_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CustomChecks, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		customChecks_object, diags_tmp = types.ObjectValueFrom(ctx, customChecks_obj.AttributeTypes(), customChecks_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var maxWaitTime_value types.Int64
	if obj.MaxWaitTime != nil {
		maxWaitTime_value = types.Int64Value(*obj.MaxWaitTime)
	}
	var collectHipData_value types.Bool
	if obj.CollectHipData != nil {
		collectHipData_value = types.BoolValue(*obj.CollectHipData)
	}
	o.CertificateProfile = certificateProfile_value
	o.MaxWaitTime = maxWaitTime_value
	o.CollectHipData = collectHipData_value
	o.Exclusion = exclusion_object
	o.CustomChecks = customChecks_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionExclusion, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var category_list types.List
	{
		var category_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject
		if !o.Category.IsNull() {
			diags.Append(o.Category.ElementsAs(ctx, &category_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Category {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(category_tf_entries) {
				entry = category_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(category_tf_entries) {
				category_tf_entries[idx] = entry
			} else {
				category_tf_entries = append(category_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("category")
		category_list, list_diags = types.ListValueFrom(ctx, schemaType, category_tf_entries)
		diags.Append(list_diags...)
	}

	o.Category = category_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionExclusionCategory, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vendor_list types.List
	{
		var vendor_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject
		if !o.Vendor.IsNull() {
			diags.Append(o.Vendor.ElementsAs(ctx, &vendor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Vendor {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(vendor_tf_entries) {
				entry = vendor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(vendor_tf_entries) {
				vendor_tf_entries[idx] = entry
			} else {
				vendor_tf_entries = append(vendor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vendor")
		vendor_list, list_diags = types.ListValueFrom(ctx, schemaType, vendor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vendor = vendor_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var product_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Product.IsNull() || len(obj.Product) > 0 {
			entries = obj.Product
		}

		product_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Product = product_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var windows_obj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject
	if o.Windows.IsNull() {
		windows_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject)
	} else {
		diags.Append(o.Windows.As(ctx, &windows_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	windows_object := types.ObjectNull(windows_obj.AttributeTypes())
	if obj.Windows != nil {
		diags.Append(windows_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Windows, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		windows_object, diags_tmp = types.ObjectValueFrom(ctx, windows_obj.AttributeTypes(), windows_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var macOs_obj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject
	if o.MacOs.IsNull() {
		macOs_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject)
	} else {
		diags.Append(o.MacOs.As(ctx, &macOs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	macOs_object := types.ObjectNull(macOs_obj.AttributeTypes())
	if obj.MacOs != nil {
		diags.Append(macOs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MacOs, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		macOs_object, diags_tmp = types.ObjectValueFrom(ctx, macOs_obj.AttributeTypes(), macOs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var linux_obj *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject
	if o.Linux.IsNull() {
		linux_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject)
	} else {
		diags.Append(o.Linux.As(ctx, &linux_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linux_object := types.ObjectNull(linux_obj.AttributeTypes())
	if obj.Linux != nil {
		diags.Append(linux_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Linux, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linux_object, diags_tmp = types.ObjectValueFrom(ctx, linux_obj.AttributeTypes(), linux_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Windows = windows_object
	o.MacOs = macOs_object
	o.Linux = linux_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_list types.List
	{
		var registryKey_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject
		if !o.RegistryKey.IsNull() {
			diags.Append(o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryKey {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryKey_tf_entries) {
				entry = registryKey_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryKey_tf_entries) {
				registryKey_tf_entries[idx] = entry
			} else {
				registryKey_tf_entries = append(registryKey_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_key")
		registryKey_list, list_diags = types.ListValueFrom(ctx, schemaType, registryKey_tf_entries)
		diags.Append(list_diags...)
	}
	var processList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ProcessList.IsNull() || len(obj.ProcessList) > 0 {
			entries = obj.ProcessList
		}

		processList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.RegistryKey = registryKey_list
	o.ProcessList = processList_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegistryValue.IsNull() || len(obj.RegistryValue) > 0 {
			entries = obj.RegistryValue
		}

		registryValue_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.RegistryValue = registryValue_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_list types.List
	{
		var plist_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject
		if !o.Plist.IsNull() {
			diags.Append(o.Plist.ElementsAs(ctx, &plist_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Plist {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(plist_tf_entries) {
				entry = plist_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(plist_tf_entries) {
				plist_tf_entries[idx] = entry
			} else {
				plist_tf_entries = append(plist_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("plist")
		plist_list, list_diags = types.ListValueFrom(ctx, schemaType, plist_tf_entries)
		diags.Append(list_diags...)
	}
	var processList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ProcessList.IsNull() || len(obj.ProcessList) > 0 {
			entries = obj.ProcessList
		}

		processList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Plist = plist_list
	o.ProcessList = processList_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Key.IsNull() || len(obj.Key) > 0 {
			entries = obj.Key
		}

		key_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Key = key_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksLinux, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var processList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ProcessList.IsNull() || len(obj.ProcessList) > 0 {
			entries = obj.ProcessList
		}

		processList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.ProcessList = processList_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAgentConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGpAppConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var config_list types.List
	{
		var config_tf_entries []GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject
		if !o.Config.IsNull() {
			diags.Append(o.Config.ElementsAs(ctx, &config_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Config {
			entry := GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(config_tf_entries) {
				entry = config_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(config_tf_entries) {
				config_tf_entries[idx] = entry
			} else {
				config_tf_entries = append(config_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("config")
		config_list, list_diags = types.ListValueFrom(ctx, schemaType, config_tf_entries)
		diags.Append(list_diags...)
	}

	o.Config = config_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGpAppConfigConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var value_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Value.IsNull() || len(obj.Value) > 0 {
			entries = obj.Value
		}

		value_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Value = value_list

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var acceptCookie_obj *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject
	if o.AcceptCookie.IsNull() {
		acceptCookie_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject)
	} else {
		diags.Append(o.AcceptCookie.As(ctx, &acceptCookie_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	acceptCookie_object := types.ObjectNull(acceptCookie_obj.AttributeTypes())
	if obj.AcceptCookie != nil {
		diags.Append(acceptCookie_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AcceptCookie, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		acceptCookie_object, diags_tmp = types.ObjectValueFrom(ctx, acceptCookie_obj.AttributeTypes(), acceptCookie_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var generateCookie_value types.Bool
	if obj.GenerateCookie != nil {
		generateCookie_value = types.BoolValue(*obj.GenerateCookie)
	}
	var cookieEncryptDecryptCert_value types.String
	if obj.CookieEncryptDecryptCert != nil {
		cookieEncryptDecryptCert_value = types.StringValue(*obj.CookieEncryptDecryptCert)
	}
	o.GenerateCookie = generateCookie_value
	o.CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	o.AcceptCookie = acceptCookie_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var cookieLifetime_obj *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	if o.CookieLifetime.IsNull() {
		cookieLifetime_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject)
	} else {
		diags.Append(o.CookieLifetime.As(ctx, &cookieLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	cookieLifetime_object := types.ObjectNull(cookieLifetime_obj.AttributeTypes())
	if obj.CookieLifetime != nil {
		diags.Append(cookieLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CookieLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		cookieLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, cookieLifetime_obj.AttributeTypes(), cookieLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.CookieLifetime = cookieLifetime_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetimeInDays_value types.Int64
	if obj.LifetimeInDays != nil {
		lifetimeInDays_value = types.Int64Value(*obj.LifetimeInDays)
	}
	var lifetimeInHours_value types.Int64
	if obj.LifetimeInHours != nil {
		lifetimeInHours_value = types.Int64Value(*obj.LifetimeInHours)
	}
	var lifetimeInMinutes_value types.Int64
	if obj.LifetimeInMinutes != nil {
		lifetimeInMinutes_value = types.Int64Value(*obj.LifetimeInMinutes)
	}
	o.LifetimeInDays = lifetimeInDays_value
	o.LifetimeInHours = lifetimeInHours_value
	o.LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsMachineAccountExistsWithSerialno, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var no_obj *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject
	if o.No.IsNull() {
		no_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var yes_obj *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject
	if o.Yes.IsNull() {
		yes_obj = new(GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var scep_value types.String
	if obj.Scep != nil {
		scep_value = types.StringValue(*obj.Scep)
	}
	o.Local = local_value
	o.Scep = scep_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientConfigRootCaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigRootCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var installInCertStore_value types.Bool
	if obj.InstallInCertStore != nil {
		installInCertStore_value = types.BoolValue(*obj.InstallInCertStore)
	}
	o.Name = types.StringValue(obj.Name)
	o.InstallInCertStore = installInCertStore_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var appsToUserMapping_list types.List
	{
		var appsToUserMapping_tf_entries []GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject
		if !o.AppsToUserMapping.IsNull() {
			diags.Append(o.AppsToUserMapping.ElementsAs(ctx, &appsToUserMapping_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AppsToUserMapping {
			entry := GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(appsToUserMapping_tf_entries) {
				entry = appsToUserMapping_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(appsToUserMapping_tf_entries) {
				appsToUserMapping_tf_entries[idx] = entry
			} else {
				appsToUserMapping_tf_entries = append(appsToUserMapping_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("apps_to_user_mapping")
		appsToUserMapping_list, list_diags = types.ListValueFrom(ctx, schemaType, appsToUserMapping_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyServerSetting_list types.List
	{
		var proxyServerSetting_tf_entries []GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject
		if !o.ProxyServerSetting.IsNull() {
			diags.Append(o.ProxyServerSetting.ElementsAs(ctx, &proxyServerSetting_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ProxyServerSetting {
			entry := GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(proxyServerSetting_tf_entries) {
				entry = proxyServerSetting_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(proxyServerSetting_tf_entries) {
				proxyServerSetting_tf_entries[idx] = entry
			} else {
				proxyServerSetting_tf_entries = append(proxyServerSetting_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_server_setting")
		proxyServerSetting_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyServerSetting_tf_entries)
		diags.Append(list_diags...)
	}
	var rewriteExcludeDomainList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RewriteExcludeDomainList.IsNull() || len(obj.RewriteExcludeDomainList) > 0 {
			entries = obj.RewriteExcludeDomainList
		}

		rewriteExcludeDomainList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var cryptoSettings_obj *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject
	if o.CryptoSettings.IsNull() {
		cryptoSettings_obj = new(GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject)
	} else {
		diags.Append(o.CryptoSettings.As(ctx, &cryptoSettings_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	cryptoSettings_object := types.ObjectNull(cryptoSettings_obj.AttributeTypes())
	if obj.CryptoSettings != nil {
		diags.Append(cryptoSettings_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CryptoSettings, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		cryptoSettings_object, diags_tmp = types.ObjectValueFrom(ctx, cryptoSettings_obj.AttributeTypes(), cryptoSettings_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var inactivityLogout_obj *GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject
	if o.InactivityLogout.IsNull() {
		inactivityLogout_obj = new(GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject)
	} else {
		diags.Append(o.InactivityLogout.As(ctx, &inactivityLogout_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	inactivityLogout_object := types.ObjectNull(inactivityLogout_obj.AttributeTypes())
	if obj.InactivityLogout != nil {
		diags.Append(inactivityLogout_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InactivityLogout, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		inactivityLogout_object, diags_tmp = types.ObjectValueFrom(ctx, inactivityLogout_obj.AttributeTypes(), inactivityLogout_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var loginLifetime_obj *GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject
	if o.LoginLifetime.IsNull() {
		loginLifetime_obj = new(GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject)
	} else {
		diags.Append(o.LoginLifetime.As(ctx, &loginLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	loginLifetime_object := types.ObjectNull(loginLifetime_obj.AttributeTypes())
	if obj.LoginLifetime != nil {
		diags.Append(loginLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LoginLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		loginLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, loginLifetime_obj.AttributeTypes(), loginLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsProxy_value types.String
	if obj.DnsProxy != nil {
		dnsProxy_value = types.StringValue(*obj.DnsProxy)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	var maxUser_value types.Int64
	if obj.MaxUser != nil {
		maxUser_value = types.Int64Value(*obj.MaxUser)
	}
	var securityZone_value types.String
	if obj.SecurityZone != nil {
		securityZone_value = types.StringValue(*obj.SecurityZone)
	}
	o.AppsToUserMapping = appsToUserMapping_list
	o.CryptoSettings = cryptoSettings_object
	o.DnsProxy = dnsProxy_value
	o.Hostname = hostname_value
	o.InactivityLogout = inactivityLogout_object
	o.LoginLifetime = loginLifetime_object
	o.MaxUser = maxUser_value
	o.ProxyServerSetting = proxyServerSetting_list
	o.RewriteExcludeDomainList = rewriteExcludeDomainList_list
	o.SecurityZone = securityZone_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnAppsToUserMapping, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var applications_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Applications.IsNull() || len(obj.Applications) > 0 {
			entries = obj.Applications
		}

		applications_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var enableCustomAppURLAddressBar_value types.Bool
	if obj.EnableCustomAppURLAddressBar != nil {
		enableCustomAppURLAddressBar_value = types.BoolValue(*obj.EnableCustomAppURLAddressBar)
	}
	var displayGlobalProtectAgentDownloadLink_value types.Bool
	if obj.DisplayGlobalProtectAgentDownloadLink != nil {
		displayGlobalProtectAgentDownloadLink_value = types.BoolValue(*obj.DisplayGlobalProtectAgentDownloadLink)
	}
	o.Name = types.StringValue(obj.Name)
	o.SourceUser = sourceUser_list
	o.Applications = applications_list
	o.EnableCustomAppURLAddressBar = enableCustomAppURLAddressBar_value
	o.DisplayGlobalProtectAgentDownloadLink = displayGlobalProtectAgentDownloadLink_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnCryptoSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var serverCertVerification_obj *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject
	if o.ServerCertVerification.IsNull() {
		serverCertVerification_obj = new(GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject)
	} else {
		diags.Append(o.ServerCertVerification.As(ctx, &serverCertVerification_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	serverCertVerification_object := types.ObjectNull(serverCertVerification_obj.AttributeTypes())
	if obj.ServerCertVerification != nil {
		diags.Append(serverCertVerification_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ServerCertVerification, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		serverCertVerification_object, diags_tmp = types.ObjectValueFrom(ctx, serverCertVerification_obj.AttributeTypes(), serverCertVerification_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sslProtocol_obj *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject
	if o.SslProtocol.IsNull() {
		sslProtocol_obj = new(GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject)
	} else {
		diags.Append(o.SslProtocol.As(ctx, &sslProtocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sslProtocol_object := types.ObjectNull(sslProtocol_obj.AttributeTypes())
	if obj.SslProtocol != nil {
		diags.Append(sslProtocol_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SslProtocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sslProtocol_object, diags_tmp = types.ObjectValueFrom(ctx, sslProtocol_obj.AttributeTypes(), sslProtocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.ServerCertVerification = serverCertVerification_object
	o.SslProtocol = sslProtocol_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnCryptoSettingsServerCertVerification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var blockExpiredCertificate_value types.Bool
	if obj.BlockExpiredCertificate != nil {
		blockExpiredCertificate_value = types.BoolValue(*obj.BlockExpiredCertificate)
	}
	var blockTimeoutCert_value types.Bool
	if obj.BlockTimeoutCert != nil {
		blockTimeoutCert_value = types.BoolValue(*obj.BlockTimeoutCert)
	}
	var blockUnknownCert_value types.Bool
	if obj.BlockUnknownCert != nil {
		blockUnknownCert_value = types.BoolValue(*obj.BlockUnknownCert)
	}
	var blockUntrustedIssuer_value types.Bool
	if obj.BlockUntrustedIssuer != nil {
		blockUntrustedIssuer_value = types.BoolValue(*obj.BlockUntrustedIssuer)
	}
	o.BlockExpiredCertificate = blockExpiredCertificate_value
	o.BlockTimeoutCert = blockTimeoutCert_value
	o.BlockUnknownCert = blockUnknownCert_value
	o.BlockUntrustedIssuer = blockUntrustedIssuer_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnCryptoSettingsSslProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authAlgoMd5_value types.Bool
	if obj.AuthAlgoMd5 != nil {
		authAlgoMd5_value = types.BoolValue(*obj.AuthAlgoMd5)
	}
	var authAlgoSha1_value types.Bool
	if obj.AuthAlgoSha1 != nil {
		authAlgoSha1_value = types.BoolValue(*obj.AuthAlgoSha1)
	}
	var authAlgoSha256_value types.Bool
	if obj.AuthAlgoSha256 != nil {
		authAlgoSha256_value = types.BoolValue(*obj.AuthAlgoSha256)
	}
	var authAlgoSha384_value types.Bool
	if obj.AuthAlgoSha384 != nil {
		authAlgoSha384_value = types.BoolValue(*obj.AuthAlgoSha384)
	}
	var encAlgo3des_value types.Bool
	if obj.EncAlgo3des != nil {
		encAlgo3des_value = types.BoolValue(*obj.EncAlgo3des)
	}
	var encAlgoAes128Cbc_value types.Bool
	if obj.EncAlgoAes128Cbc != nil {
		encAlgoAes128Cbc_value = types.BoolValue(*obj.EncAlgoAes128Cbc)
	}
	var encAlgoAes128Gcm_value types.Bool
	if obj.EncAlgoAes128Gcm != nil {
		encAlgoAes128Gcm_value = types.BoolValue(*obj.EncAlgoAes128Gcm)
	}
	var encAlgoAes256Cbc_value types.Bool
	if obj.EncAlgoAes256Cbc != nil {
		encAlgoAes256Cbc_value = types.BoolValue(*obj.EncAlgoAes256Cbc)
	}
	var encAlgoAes256Gcm_value types.Bool
	if obj.EncAlgoAes256Gcm != nil {
		encAlgoAes256Gcm_value = types.BoolValue(*obj.EncAlgoAes256Gcm)
	}
	var encAlgoRc4_value types.Bool
	if obj.EncAlgoRc4 != nil {
		encAlgoRc4_value = types.BoolValue(*obj.EncAlgoRc4)
	}
	var keyxchgAlgoDhe_value types.Bool
	if obj.KeyxchgAlgoDhe != nil {
		keyxchgAlgoDhe_value = types.BoolValue(*obj.KeyxchgAlgoDhe)
	}
	var keyxchgAlgoEcdhe_value types.Bool
	if obj.KeyxchgAlgoEcdhe != nil {
		keyxchgAlgoEcdhe_value = types.BoolValue(*obj.KeyxchgAlgoEcdhe)
	}
	var keyxchgAlgoRsa_value types.Bool
	if obj.KeyxchgAlgoRsa != nil {
		keyxchgAlgoRsa_value = types.BoolValue(*obj.KeyxchgAlgoRsa)
	}
	var maxVersion_value types.String
	if obj.MaxVersion != nil {
		maxVersion_value = types.StringValue(*obj.MaxVersion)
	}
	var minVersion_value types.String
	if obj.MinVersion != nil {
		minVersion_value = types.StringValue(*obj.MinVersion)
	}
	o.AuthAlgoMd5 = authAlgoMd5_value
	o.AuthAlgoSha1 = authAlgoSha1_value
	o.AuthAlgoSha256 = authAlgoSha256_value
	o.AuthAlgoSha384 = authAlgoSha384_value
	o.EncAlgo3des = encAlgo3des_value
	o.EncAlgoAes128Cbc = encAlgoAes128Cbc_value
	o.EncAlgoAes128Gcm = encAlgoAes128Gcm_value
	o.EncAlgoAes256Cbc = encAlgoAes256Cbc_value
	o.EncAlgoAes256Gcm = encAlgoAes256Gcm_value
	o.EncAlgoRc4 = encAlgoRc4_value
	o.KeyxchgAlgoDhe = keyxchgAlgoDhe_value
	o.KeyxchgAlgoEcdhe = keyxchgAlgoEcdhe_value
	o.KeyxchgAlgoRsa = keyxchgAlgoRsa_value
	o.MaxVersion = maxVersion_value
	o.MinVersion = minVersion_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnInactivityLogout, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hours_value types.Int64
	if obj.Hours != nil {
		hours_value = types.Int64Value(*obj.Hours)
	}
	var minutes_value types.Int64
	if obj.Minutes != nil {
		minutes_value = types.Int64Value(*obj.Minutes)
	}
	o.Hours = hours_value
	o.Minutes = minutes_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hours_value types.Int64
	if obj.Hours != nil {
		hours_value = types.Int64Value(*obj.Hours)
	}
	var minutes_value types.Int64
	if obj.Minutes != nil {
		minutes_value = types.Int64Value(*obj.Minutes)
	}
	o.Hours = hours_value
	o.Minutes = minutes_value

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnProxyServerSetting, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var domains_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Domains.IsNull() || len(obj.Domains) > 0 {
			entries = obj.Domains
		}

		domains_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var proxyServer_obj *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject
	if o.ProxyServer.IsNull() {
		proxyServer_obj = new(GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject)
	} else {
		diags.Append(o.ProxyServer.As(ctx, &proxyServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	proxyServer_object := types.ObjectNull(proxyServer_obj.AttributeTypes())
	if obj.ProxyServer != nil {
		diags.Append(proxyServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ProxyServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		proxyServer_object, diags_tmp = types.ObjectValueFrom(ctx, proxyServer_obj.AttributeTypes(), proxyServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var useProxy_value types.Bool
	if obj.UseProxy != nil {
		useProxy_value = types.BoolValue(*obj.UseProxy)
	}
	o.Name = types.StringValue(obj.Name)
	o.Domains = domains_list
	o.UseProxy = useProxy_value
	o.ProxyServer = proxyServer_object

	return diags
}

func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnProxyServerSettingProxyServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var server_value types.String
	if obj.Server != nil {
		server_value = types.StringValue(*obj.Server)
	}
	var port_value types.Int64
	if obj.Port != nil {
		port_value = types.Int64Value(*obj.Port)
	}
	var user_value types.String
	if obj.User != nil {
		user_value = types.StringValue(*obj.User)
	}
	var password_value types.String
	if obj.Password != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.Password != evFromState {
			password_value = types.StringPointerValue(obj.Password)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			password_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.Password)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	o.Server = server_value
	o.Port = port_value
	o.User = user_value
	o.Password = password_value

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientAuth_list types.List
	{
		var clientAuth_tf_entries []GlobalprotectPortalDataSourcePortalConfigClientAuthObject
		if !o.ClientAuth.IsNull() {
			diags.Append(o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ClientAuth {
			entry := GlobalprotectPortalDataSourcePortalConfigClientAuthObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(clientAuth_tf_entries) {
				entry = clientAuth_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(clientAuth_tf_entries) {
				clientAuth_tf_entries[idx] = entry
			} else {
				clientAuth_tf_entries = append(clientAuth_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("client_auth")
		clientAuth_list, list_diags = types.ListValueFrom(ctx, schemaType, clientAuth_tf_entries)
		diags.Append(list_diags...)
	}

	var configSelection_obj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject
	if o.ConfigSelection.IsNull() {
		configSelection_obj = new(GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject)
	} else {
		diags.Append(o.ConfigSelection.As(ctx, &configSelection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	configSelection_object := types.ObjectNull(configSelection_obj.AttributeTypes())
	if obj.ConfigSelection != nil {
		diags.Append(configSelection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConfigSelection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		configSelection_object, diags_tmp = types.ObjectValueFrom(ctx, configSelection_obj.AttributeTypes(), configSelection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *GlobalprotectPortalDataSourcePortalConfigLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(GlobalprotectPortalDataSourcePortalConfigLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var customHelpPage_value types.String
	if obj.CustomHelpPage != nil {
		customHelpPage_value = types.StringValue(*obj.CustomHelpPage)
	}
	var customHomePage_value types.String
	if obj.CustomHomePage != nil {
		customHomePage_value = types.StringValue(*obj.CustomHomePage)
	}
	var customLoginPage_value types.String
	if obj.CustomLoginPage != nil {
		customLoginPage_value = types.StringValue(*obj.CustomLoginPage)
	}
	var logFail_value types.Bool
	if obj.LogFail != nil {
		logFail_value = types.BoolValue(*obj.LogFail)
	}
	var logSetting_value types.String
	if obj.LogSetting != nil {
		logSetting_value = types.StringValue(*obj.LogSetting)
	}
	var logSuccess_value types.Bool
	if obj.LogSuccess != nil {
		logSuccess_value = types.BoolValue(*obj.LogSuccess)
	}
	var sslTlsServiceProfile_value types.String
	if obj.SslTlsServiceProfile != nil {
		sslTlsServiceProfile_value = types.StringValue(*obj.SslTlsServiceProfile)
	}
	o.CertificateProfile = certificateProfile_value
	o.ClientAuth = clientAuth_list
	o.ConfigSelection = configSelection_object
	o.CustomHelpPage = customHelpPage_value
	o.CustomHomePage = customHomePage_value
	o.CustomLoginPage = customLoginPage_value
	o.LocalAddress = localAddress_object
	o.LogFail = logFail_value
	o.LogSetting = logSetting_value
	o.LogSuccess = logSuccess_value
	o.SslTlsServiceProfile = sslTlsServiceProfile_value

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigClientAuthObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var os_value types.String
	if obj.Os != nil {
		os_value = types.StringValue(*obj.Os)
	}
	var authenticationProfile_value types.String
	if obj.AuthenticationProfile != nil {
		authenticationProfile_value = types.StringValue(*obj.AuthenticationProfile)
	}
	var autoRetrievePasscode_value types.Bool
	if obj.AutoRetrievePasscode != nil {
		autoRetrievePasscode_value = types.BoolValue(*obj.AutoRetrievePasscode)
	}
	var usernameLabel_value types.String
	if obj.UsernameLabel != nil {
		usernameLabel_value = types.StringValue(*obj.UsernameLabel)
	}
	var passwordLabel_value types.String
	if obj.PasswordLabel != nil {
		passwordLabel_value = types.StringValue(*obj.PasswordLabel)
	}
	var authenticationMessage_value types.String
	if obj.AuthenticationMessage != nil {
		authenticationMessage_value = types.StringValue(*obj.AuthenticationMessage)
	}
	var userCredentialOrClientCertRequired_value types.String
	if obj.UserCredentialOrClientCertRequired != nil {
		userCredentialOrClientCertRequired_value = types.StringValue(*obj.UserCredentialOrClientCertRequired)
	}
	o.Name = types.StringValue(obj.Name)
	o.Os = os_value
	o.AuthenticationProfile = authenticationProfile_value
	o.AutoRetrievePasscode = autoRetrievePasscode_value
	o.UsernameLabel = usernameLabel_value
	o.PasswordLabel = passwordLabel_value
	o.AuthenticationMessage = authenticationMessage_value
	o.UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var customChecks_obj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject
	if o.CustomChecks.IsNull() {
		customChecks_obj = new(GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject)
	} else {
		diags.Append(o.CustomChecks.As(ctx, &customChecks_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	customChecks_object := types.ObjectNull(customChecks_obj.AttributeTypes())
	if obj.CustomChecks != nil {
		diags.Append(customChecks_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CustomChecks, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		customChecks_object, diags_tmp = types.ObjectValueFrom(ctx, customChecks_obj.AttributeTypes(), customChecks_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	o.CertificateProfile = certificateProfile_value
	o.CustomChecks = customChecks_object

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var macOs_obj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject
	if o.MacOs.IsNull() {
		macOs_obj = new(GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject)
	} else {
		diags.Append(o.MacOs.As(ctx, &macOs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	macOs_object := types.ObjectNull(macOs_obj.AttributeTypes())
	if obj.MacOs != nil {
		diags.Append(macOs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MacOs, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		macOs_object, diags_tmp = types.ObjectValueFrom(ctx, macOs_obj.AttributeTypes(), macOs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var windows_obj *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject
	if o.Windows.IsNull() {
		windows_obj = new(GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject)
	} else {
		diags.Append(o.Windows.As(ctx, &windows_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	windows_object := types.ObjectNull(windows_obj.AttributeTypes())
	if obj.Windows != nil {
		diags.Append(windows_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Windows, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		windows_object, diags_tmp = types.ObjectValueFrom(ctx, windows_obj.AttributeTypes(), windows_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.MacOs = macOs_object
	o.Windows = windows_object

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_list types.List
	{
		var plist_tf_entries []GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject
		if !o.Plist.IsNull() {
			diags.Append(o.Plist.ElementsAs(ctx, &plist_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Plist {
			entry := GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(plist_tf_entries) {
				entry = plist_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(plist_tf_entries) {
				plist_tf_entries[idx] = entry
			} else {
				plist_tf_entries = append(plist_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("plist")
		plist_list, list_diags = types.ListValueFrom(ctx, schemaType, plist_tf_entries)
		diags.Append(list_diags...)
	}

	o.Plist = plist_list

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Key.IsNull() || len(obj.Key) > 0 {
			entries = obj.Key
		}

		key_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Key = key_list

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_list types.List
	{
		var registryKey_tf_entries []GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject
		if !o.RegistryKey.IsNull() {
			diags.Append(o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryKey {
			entry := GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryKey_tf_entries) {
				entry = registryKey_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryKey_tf_entries) {
				registryKey_tf_entries[idx] = entry
			} else {
				registryKey_tf_entries = append(registryKey_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_key")
		registryKey_list, list_diags = types.ListValueFrom(ctx, schemaType, registryKey_tf_entries)
		diags.Append(list_diags...)
	}

	o.RegistryKey = registryKey_list

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegistryValue.IsNull() || len(obj.RegistryValue) > 0 {
			entries = obj.RegistryValue
		}

		registryValue_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.RegistryValue = registryValue_list

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var floatingIp_obj *GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject
	if o.FloatingIp.IsNull() {
		floatingIp_obj = new(GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject)
	} else {
		diags.Append(o.FloatingIp.As(ctx, &floatingIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	floatingIp_object := types.ObjectNull(floatingIp_obj.AttributeTypes())
	if obj.FloatingIp != nil {
		diags.Append(floatingIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FloatingIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		floatingIp_object, diags_tmp = types.ObjectValueFrom(ctx, floatingIp_obj.AttributeTypes(), floatingIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ipAddressFamily_value types.String
	if obj.IpAddressFamily != nil {
		ipAddressFamily_value = types.StringValue(*obj.IpAddressFamily)
	}
	o.Interface = interface_value
	o.IpAddressFamily = ipAddressFamily_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var configs_list types.List
	{
		var configs_tf_entries []GlobalprotectPortalDataSourceSatelliteConfigConfigsObject
		if !o.Configs.IsNull() {
			diags.Append(o.Configs.ElementsAs(ctx, &configs_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Configs {
			entry := GlobalprotectPortalDataSourceSatelliteConfigConfigsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(configs_tf_entries) {
				entry = configs_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(configs_tf_entries) {
				configs_tf_entries[idx] = entry
			} else {
				configs_tf_entries = append(configs_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("configs")
		configs_list, list_diags = types.ListValueFrom(ctx, schemaType, configs_tf_entries)
		diags.Append(list_diags...)
	}
	var rootCa_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RootCa.IsNull() || len(obj.RootCa) > 0 {
			entries = obj.RootCa
		}

		rootCa_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var clientCertificate_obj *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject
	if o.ClientCertificate.IsNull() {
		clientCertificate_obj = new(GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject)
	} else {
		diags.Append(o.ClientCertificate.As(ctx, &clientCertificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientCertificate_object := types.ObjectNull(clientCertificate_obj.AttributeTypes())
	if obj.ClientCertificate != nil {
		diags.Append(clientCertificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ClientCertificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientCertificate_object, diags_tmp = types.ObjectValueFrom(ctx, clientCertificate_obj.AttributeTypes(), clientCertificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.ClientCertificate = clientCertificate_object
	o.Configs = configs_list
	o.RootCa = rootCa_list

	return diags
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var local_obj *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject
	if o.Local.IsNull() {
		local_obj = new(GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject)
	} else {
		diags.Append(o.Local.As(ctx, &local_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	local_object := types.ObjectNull(local_obj.AttributeTypes())
	if obj.Local != nil {
		diags.Append(local_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Local, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		local_object, diags_tmp = types.ObjectValueFrom(ctx, local_obj.AttributeTypes(), local_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var scep_obj *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject
	if o.Scep.IsNull() {
		scep_obj = new(GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject)
	} else {
		diags.Append(o.Scep.As(ctx, &scep_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	scep_object := types.ObjectNull(scep_obj.AttributeTypes())
	if obj.Scep != nil {
		diags.Append(scep_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Scep, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		scep_object, diags_tmp = types.ObjectValueFrom(ctx, scep_obj.AttributeTypes(), scep_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Local = local_object
	o.Scep = scep_object

	return diags
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigClientCertificateLocal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateLifeTime_value types.Int64
	if obj.CertificateLifeTime != nil {
		certificateLifeTime_value = types.Int64Value(*obj.CertificateLifeTime)
	}
	var certificateRenewalPeriod_value types.Int64
	if obj.CertificateRenewalPeriod != nil {
		certificateRenewalPeriod_value = types.Int64Value(*obj.CertificateRenewalPeriod)
	}
	var issuingCertificate_value types.String
	if obj.IssuingCertificate != nil {
		issuingCertificate_value = types.StringValue(*obj.IssuingCertificate)
	}
	var ocspResponder_value types.String
	if obj.OcspResponder != nil {
		ocspResponder_value = types.StringValue(*obj.OcspResponder)
	}
	o.CertificateLifeTime = certificateLifeTime_value
	o.CertificateRenewalPeriod = certificateRenewalPeriod_value
	o.IssuingCertificate = issuingCertificate_value
	o.OcspResponder = ocspResponder_value

	return diags
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigClientCertificateScep, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateRenewalPeriod_value types.Int64
	if obj.CertificateRenewalPeriod != nil {
		certificateRenewalPeriod_value = types.Int64Value(*obj.CertificateRenewalPeriod)
	}
	var scep_value types.String
	if obj.Scep != nil {
		scep_value = types.StringValue(*obj.Scep)
	}
	o.CertificateRenewalPeriod = certificateRenewalPeriod_value
	o.Scep = scep_value

	return diags
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Devices.IsNull() || len(obj.Devices) > 0 {
			entries = obj.Devices
		}

		devices_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var gateways_list types.List
	{
		var gateways_tf_entries []GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject
		if !o.Gateways.IsNull() {
			diags.Append(o.Gateways.ElementsAs(ctx, &gateways_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Gateways {
			entry := GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(gateways_tf_entries) {
				entry = gateways_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(gateways_tf_entries) {
				gateways_tf_entries[idx] = entry
			} else {
				gateways_tf_entries = append(gateways_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("gateways")
		gateways_list, list_diags = types.ListValueFrom(ctx, schemaType, gateways_tf_entries)
		diags.Append(list_diags...)
	}

	var configRefreshInterval_value types.Int64
	if obj.ConfigRefreshInterval != nil {
		configRefreshInterval_value = types.Int64Value(*obj.ConfigRefreshInterval)
	}
	o.Name = types.StringValue(obj.Name)
	o.Devices = devices_list
	o.SourceUser = sourceUser_list
	o.Gateways = gateways_list
	o.ConfigRefreshInterval = configRefreshInterval_value

	return diags
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_obj *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Preferred_value types.Bool
	if obj.Ipv6Preferred != nil {
		ipv6Preferred_value = types.BoolValue(*obj.Ipv6Preferred)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Name = types.StringValue(obj.Name)
	o.Ipv6Preferred = ipv6Preferred_value
	o.Priority = priority_value
	o.Fqdn = fqdn_value
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigConfigsGatewaysIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func GlobalprotectPortalDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": GlobalprotectPortalDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"client_config": GlobalprotectPortalDataSourceClientConfigSchema(),

			"clientless_vpn": GlobalprotectPortalDataSourceClientlessVpnSchema(),

			"portal_config": GlobalprotectPortalDataSourcePortalConfigSchema(),

			"satellite_config": GlobalprotectPortalDataSourceSatelliteConfigSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceModel) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"agent_user_override_key": dsschema.StringAttribute{
				Description: "Agent user override ticket key",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},

			"configs": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsSchema(),
			},

			"root_ca": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigRootCaSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"save_user_credentials": dsschema.StringAttribute{
				Description: "Save User Credentials",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"portal_2fa": dsschema.BoolAttribute{
				Description: "Portal Authentication OTP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"internal_gateway_2fa": dsschema.BoolAttribute{
				Description: "Internal Gateway Authentication OTP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_discovery_external_gateway_2fa": dsschema.BoolAttribute{
				Description: "Auto Discovery External Gateway Authentication OTP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"manual_only_gateway_2fa": dsschema.BoolAttribute{
				Description: "Manual Only External Gateway Authentication OTP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"refresh_config": dsschema.BoolAttribute{
				Description: "Enable portal config refresh",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mdm_address": dsschema.StringAttribute{
				Description: "IP address or hostname for GlobalProtect MDM server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mdm_enrollment_port": dsschema.StringAttribute{
				Description: "MDM enrollment port",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_user": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"third_party_vpn_clients": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"os": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"certificate": GlobalprotectPortalDataSourceClientConfigConfigsCertificateSchema(),

			"custom_checks": GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksSchema(),

			"gateways": GlobalprotectPortalDataSourceClientConfigConfigsGatewaysSchema(),

			"internal_host_detection": GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionSchema(),

			"internal_host_detection_v6": GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Schema(),

			"agent_ui": GlobalprotectPortalDataSourceClientConfigConfigsAgentUiSchema(),

			"hip_collection": GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionSchema(),

			"agent_config": GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigSchema(),

			"gp_app_config": GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigSchema(),

			"authentication_override": GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideSchema(),

			"machine_account_exists_with_serialno": GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoSchema(),

			"client_certificate": GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCertificateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"criteria": GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCertificateCriteriaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"criteria": GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"registry_key": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeySchema(),
			},

			"plist": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"default_value_data": dsschema.StringAttribute{
				Description: "Registry key default value data",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"negate": dsschema.BoolAttribute{
				Description: "Key does not exist",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"registry_value": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value_data": dsschema.StringAttribute{
				Description: "Registry value data",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"negate": dsschema.BoolAttribute{
				Description: "Value does not exist",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"negate": dsschema.BoolAttribute{
				Description: "Plist does not exist",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeySchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": dsschema.StringAttribute{
				Description: "Key value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"negate": dsschema.BoolAttribute{
				Description: "Value does not exist or match specified value data",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsCustomChecksCriteriaPlistKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"internal": GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalSchema(),

			"external": GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"list": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListSchema(),
			},

			"dhcp_option_code": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source_ip": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "fqdn",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysInternalListIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"cutoff_time": dsschema.Int64Attribute{
				Description: "Gateway discovery cutoff time in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"list": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority_rule": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleSchema(),
			},

			"manual": dsschema.BoolAttribute{
				Description: "If this GlobalProtect gateway can be manually selected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "fqdn",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.StringAttribute{
				Description: "Priority of GlobalProtect gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListPriorityRuleSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGatewaysExternalListIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_address": dsschema.StringAttribute{
				Description: "Internal IPv4 address of a host",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": dsschema.StringAttribute{
				Description: "Host name of the IPv4 in DNS record",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_address": dsschema.StringAttribute{
				Description: "Internal IPv6 address of a host",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": dsschema.StringAttribute{
				Description: "Host name of the IPv6 in DNS record",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Object) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsInternalHostDetectionV6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsAgentUiSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passcode": dsschema.StringAttribute{
				Description: "Passcode required for override",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},

			"uninstall_password": dsschema.StringAttribute{
				Description: "Password to uninstall GlobalProtect app",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},

			"agent_user_override_timeout": dsschema.Int64Attribute{
				Description: "Agent user override duration in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_agent_user_overrides": dsschema.Int64Attribute{
				Description: "Max agent user overrides",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"welcome_page": GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsAgentUiSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"page": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsAgentUiWelcomePageSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_wait_time": dsschema.Int64Attribute{
				Description: "Max Wait Time (Sec)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"collect_hip_data": dsschema.BoolAttribute{
				Description: "Collect HIP Data",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exclusion": GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionSchema(),

			"custom_checks": GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"category": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategorySchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategorySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vendor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategorySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"product": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionExclusionCategoryVendorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"windows": GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsSchema(),

			"mac_os": GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsSchema(),

			"linux": GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"registry_key": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeySchema(),
			},

			"process_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"registry_value": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"plist": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistSchema(),
			},

			"process_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"process_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsHipCollectionCustomChecksLinuxSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsAgentConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"config": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsGpAppConfigConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"generate_cookie": dsschema.BoolAttribute{
				Description: "Generate cookie for authentication override",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cookie_encrypt_decrypt_cert": dsschema.StringAttribute{
				Description: "Certificate to Encrypt/Decrypt Cookie",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"accept_cookie": GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"cookie_lifetime": GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lifetime_in_days": dsschema.Int64Attribute{
				Description: "Cookie lifetime in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_in_hours": dsschema.Int64Attribute{
				Description: "Cookie lifetime in hours",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_in_minutes": dsschema.Int64Attribute{
				Description: "Cookie lifetime in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no": GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoSchema(),

			"yes": GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsMachineAccountExistsWithSerialnoYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local": dsschema.StringAttribute{
				Description: "Select Client Certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"scep": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigConfigsClientCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientConfigRootCaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"install_in_cert_store": dsschema.BoolAttribute{
				Description: "Install in Trusted CA Certificate Store",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientConfigRootCaObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientConfigRootCaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"apps_to_user_mapping": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingSchema(),
			},

			"crypto_settings": GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSchema(),

			"dns_proxy": dsschema.StringAttribute{
				Description: "DNS proxy object used for resolving clientless-vpn application hostnames",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": dsschema.StringAttribute{
				Description: "FQDN or IP address of GlobalProtect Portal",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inactivity_logout": GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutSchema(),

			"login_lifetime": GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeSchema(),

			"max_user": dsschema.Int64Attribute{
				Description: "max number of concurrent logined users to GlobalProtect portal",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_server_setting": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingSchema(),
			},

			"rewrite_exclude_domain_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"security_zone": dsschema.StringAttribute{
				Description: "Zone to be used for clientless-vpn traffic",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source_user": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"applications": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"enable_custom_app_u_r_l_address_bar": dsschema.BoolAttribute{
				Description: "URL browse bar to access unpublished clientless VPN applications",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"display_global_protect_agent_download_link": dsschema.BoolAttribute{
				Description: "Display Global Protect Agent download link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnAppsToUserMappingSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"server_cert_verification": GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationSchema(),

			"ssl_protocol": GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"block_expired_certificate": dsschema.BoolAttribute{
				Description: "whether to block sessions if server's certificate is expired",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"block_timeout_cert": dsschema.BoolAttribute{
				Description: "whether to block a session if cert. status can't be retrieved within timeout",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"block_unknown_cert": dsschema.BoolAttribute{
				Description: "whether to block a session if cert. status is unknown",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"block_untrusted_issuer": dsschema.BoolAttribute{
				Description: "whether to block sessions if server's certificate is issued by untrusted CA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsServerCertVerificationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"auth_algo_md5": dsschema.BoolAttribute{
				Description: "Allow authentication MD5",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_algo_sha1": dsschema.BoolAttribute{
				Description: "Allow authentication SHA1",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_algo_sha256": dsschema.BoolAttribute{
				Description: "Allow authentication SHA256",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_algo_sha384": dsschema.BoolAttribute{
				Description: "Allow authentication SHA384",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_3des": dsschema.BoolAttribute{
				Description: "Allow algorithm 3DES",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_128_cbc": dsschema.BoolAttribute{
				Description: "Allow algorithm AES-128-CBC",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_128_gcm": dsschema.BoolAttribute{
				Description: "Allow algorithm AES-128-GCM",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_256_cbc": dsschema.BoolAttribute{
				Description: "Allow algorithm AES-256-CBC",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_256_gcm": dsschema.BoolAttribute{
				Description: "Allow algorithm AES-256-GCM",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_rc4": dsschema.BoolAttribute{
				Description: "Allow algorithm RC4",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keyxchg_algo_dhe": dsschema.BoolAttribute{
				Description: "Allow algorithm DHE",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keyxchg_algo_ecdhe": dsschema.BoolAttribute{
				Description: "Allow algorithm ECDHE",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keyxchg_algo_rsa": dsschema.BoolAttribute{
				Description: "Allow algorithm RSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_version": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_version": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnCryptoSettingsSslProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"hours": dsschema.Int64Attribute{
				Description: "specify inactivity time in hours",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"minutes": dsschema.Int64Attribute{
				Description: "specify inactivity time in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnInactivityLogoutSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"hours": dsschema.Int64Attribute{
				Description: "specify lifetime in hours",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"minutes": dsschema.Int64Attribute{
				Description: "specify lifetime in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnLoginLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"domains": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"use_proxy": dsschema.BoolAttribute{
				Description: "Whether to use proxy server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_server": GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"server": dsschema.StringAttribute{
				Description: "Proxy server to use",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"port": dsschema.Int64Attribute{
				Description: "Port for proxy server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"user": dsschema.StringAttribute{
				Description: "Proxy user name to use",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"password": dsschema.StringAttribute{
				Description: "Proxy password to use",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceClientlessVpnProxyServerSettingProxyServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"client_auth": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourcePortalConfigClientAuthSchema(),
			},

			"config_selection": GlobalprotectPortalDataSourcePortalConfigConfigSelectionSchema(),

			"custom_help_page": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"custom_home_page": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"custom_login_page": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": GlobalprotectPortalDataSourcePortalConfigLocalAddressSchema(),

			"log_fail": dsschema.BoolAttribute{
				Description: "Log unsuccessful TLS handshakes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_setting": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_success": dsschema.BoolAttribute{
				Description: "Log successful TLS handshakes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssl_tls_service_profile": dsschema.StringAttribute{
				Description: "SSL TLS service profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigClientAuthSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"os": dsschema.StringAttribute{
				Description: "Client OS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication_profile": dsschema.StringAttribute{
				Description: "authentication profile used for this GlobalProtect",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_retrieve_passcode": dsschema.BoolAttribute{
				Description: "Automatically retrieve passcode from SoftToken application",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username_label": dsschema.StringAttribute{
				Description: "Username Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"password_label": dsschema.StringAttribute{
				Description: "Password Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication_message": dsschema.StringAttribute{
				Description: "Authentication Message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"user_credential_or_client_cert_required": dsschema.StringAttribute{
				Description: "Allow Authentication with User Credentials OR Client Certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigClientAuthObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigClientAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigConfigSelectionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"custom_checks": GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigConfigSelectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"mac_os": GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsSchema(),

			"windows": GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"plist": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksMacOsPlistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"registry_key": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeySchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"registry_value": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address_family": dsschema.StringAttribute{
				Description: "specify the family of the local address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpSchema(),

			"ip": GlobalprotectPortalDataSourcePortalConfigLocalAddressIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Floating IPv4 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Floating IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourcePortalConfigLocalAddressIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4 addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourcePortalConfigLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourcePortalConfigLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceSatelliteConfigSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"client_certificate": GlobalprotectPortalDataSourceSatelliteConfigClientCertificateSchema(),

			"configs": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceSatelliteConfigConfigsSchema(),
			},

			"root_ca": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSatelliteConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceSatelliteConfigClientCertificateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local": GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalSchema(),

			"scep": GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSatelliteConfigClientCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("local"),
				path.MatchRelative().AtParent().AtName("scep"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"certificate_life_time": dsschema.Int64Attribute{
				Description: "Issued GlobalProtect satellite certificate life time in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"certificate_renewal_period": dsschema.Int64Attribute{
				Description: "GlobalProtect satellite certificate renewal period in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"issuing_certificate": dsschema.StringAttribute{
				Description: "Issuing certificate to issue GlobalProtect satellite certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ocsp_responder": dsschema.StringAttribute{
				Description: "OCSP responder",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSatelliteConfigClientCertificateLocalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("local"),
				path.MatchRelative().AtParent().AtName("scep"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"certificate_renewal_period": dsschema.Int64Attribute{
				Description: "GlobalProtect satellite certificate renewal period in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"scep": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSatelliteConfigClientCertificateScepSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceSatelliteConfigConfigsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"devices": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"source_user": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"gateways": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysSchema(),
			},

			"config_refresh_interval": dsschema.Int64Attribute{
				Description: "GlobalProtect satellite configuration refresh interval in hours",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSatelliteConfigConfigsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ipv6_preferred": dsschema.BoolAttribute{
				Description: "IPv6 Preferred",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority of GlobalProtect gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "fqdn",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalDataSourceSatelliteConfigConfigsGatewaysIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalDataSourceLocationSchema() rsschema.Attribute {
	return GlobalprotectPortalLocationSchema()
}

// Metadata returns the data source type name.
func (d *GlobalprotectPortalDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_globalprotect_portal"
}

// Schema defines the schema for this data source.
func (d *GlobalprotectPortalDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = GlobalprotectPortalDataSourceSchema()
}

// Configure prepares the struct.
func (d *GlobalprotectPortalDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := portal.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*portal.Entry, portal.Location, *portal.Service](d.client, portal.NewService(d.client), batchSize, specifier, portal.SpecMatches)
}
func (o *GlobalprotectPortalDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state GlobalprotectPortalDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location portal.Location

	{
		var terraformLocation GlobalprotectPortalLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &portal.TemplateLocation{}
			var innerLocation GlobalprotectPortalTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &portal.TemplateVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &portal.TemplateStackLocation{}
			var innerLocation GlobalprotectPortalTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &portal.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &portal.VsysLocation{}
			var innerLocation GlobalprotectPortalVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_globalprotect_portal_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &GlobalprotectPortalResource{}
	_ resource.ResourceWithConfigure   = &GlobalprotectPortalResource{}
	_ resource.ResourceWithImportState = &GlobalprotectPortalResource{}
)

func NewGlobalprotectPortalResource() resource.Resource {
	if _, found := resourceFuncMap["panos_globalprotect_portal"]; !found {
		resourceFuncMap["panos_globalprotect_portal"] = resourceFuncs{
			CreateImportId: GlobalprotectPortalImportStateCreator,
		}
	}
	return &GlobalprotectPortalResource{}
}

type GlobalprotectPortalResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*portal.Entry, portal.Location, *portal.Service]
}

func GlobalprotectPortalResourceLocationSchema() rsschema.Attribute {
	return GlobalprotectPortalLocationSchema()
}

type GlobalprotectPortalResourceModel struct {
	Location        types.Object `tfsdk:"location"`
	Name            types.String `tfsdk:"name"`
	ClientConfig    types.Object `tfsdk:"client_config"`
	ClientlessVpn   types.Object `tfsdk:"clientless_vpn"`
	PortalConfig    types.Object `tfsdk:"portal_config"`
	SatelliteConfig types.Object `tfsdk:"satellite_config"`
}
type GlobalprotectPortalResourceClientConfigObject struct {
	AgentUserOverrideKey types.String `tfsdk:"agent_user_override_key"`
	Configs              types.List   `tfsdk:"configs"`
	RootCa               types.List   `tfsdk:"root_ca"`
}
type GlobalprotectPortalResourceClientConfigConfigsObject struct {
	Name                             types.String `tfsdk:"name"`
	SaveUserCredentials              types.String `tfsdk:"save_user_credentials"`
	Portal2fa                        types.Bool   `tfsdk:"portal_2fa"`
	InternalGateway2fa               types.Bool   `tfsdk:"internal_gateway_2fa"`
	AutoDiscoveryExternalGateway2fa  types.Bool   `tfsdk:"auto_discovery_external_gateway_2fa"`
	ManualOnlyGateway2fa             types.Bool   `tfsdk:"manual_only_gateway_2fa"`
	RefreshConfig                    types.Bool   `tfsdk:"refresh_config"`
	MdmAddress                       types.String `tfsdk:"mdm_address"`
	MdmEnrollmentPort                types.String `tfsdk:"mdm_enrollment_port"`
	SourceUser                       types.List   `tfsdk:"source_user"`
	ThirdPartyVpnClients             types.List   `tfsdk:"third_party_vpn_clients"`
	Os                               types.List   `tfsdk:"os"`
	Certificate                      types.Object `tfsdk:"certificate"`
	CustomChecks                     types.Object `tfsdk:"custom_checks"`
	Gateways                         types.Object `tfsdk:"gateways"`
	InternalHostDetection            types.Object `tfsdk:"internal_host_detection"`
	InternalHostDetectionV6          types.Object `tfsdk:"internal_host_detection_v6"`
	AgentUi                          types.Object `tfsdk:"agent_ui"`
	HipCollection                    types.Object `tfsdk:"hip_collection"`
	AgentConfig                      types.Object `tfsdk:"agent_config"`
	GpAppConfig                      types.Object `tfsdk:"gp_app_config"`
	AuthenticationOverride           types.Object `tfsdk:"authentication_override"`
	MachineAccountExistsWithSerialno types.Object `tfsdk:"machine_account_exists_with_serialno"`
	ClientCertificate                types.Object `tfsdk:"client_certificate"`
}
type GlobalprotectPortalResourceClientConfigConfigsCertificateObject struct {
	Criteria types.Object `tfsdk:"criteria"`
}
type GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
}
type GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject struct {
	Criteria types.Object `tfsdk:"criteria"`
}
type GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject struct {
	RegistryKey types.List `tfsdk:"registry_key"`
	Plist       types.List `tfsdk:"plist"`
}
type GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject struct {
	Name             types.String `tfsdk:"name"`
	DefaultValueData types.String `tfsdk:"default_value_data"`
	Negate           types.Bool   `tfsdk:"negate"`
	RegistryValue    types.List   `tfsdk:"registry_value"`
}
type GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject struct {
	Name      types.String `tfsdk:"name"`
	ValueData types.String `tfsdk:"value_data"`
	Negate    types.Bool   `tfsdk:"negate"`
}
type GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
	Key    types.List   `tfsdk:"key"`
}
type GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject struct {
	Name   types.String `tfsdk:"name"`
	Value  types.String `tfsdk:"value"`
	Negate types.Bool   `tfsdk:"negate"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysObject struct {
	Internal types.Object `tfsdk:"internal"`
	External types.Object `tfsdk:"external"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject struct {
	List           types.List `tfsdk:"list"`
	DhcpOptionCode types.List `tfsdk:"dhcp_option_code"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject struct {
	Name     types.String `tfsdk:"name"`
	SourceIp types.List   `tfsdk:"source_ip"`
	Fqdn     types.String `tfsdk:"fqdn"`
	Ip       types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject struct {
	CutoffTime types.Int64 `tfsdk:"cutoff_time"`
	List       types.List  `tfsdk:"list"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject struct {
	Name         types.String `tfsdk:"name"`
	PriorityRule types.List   `tfsdk:"priority_rule"`
	Manual       types.Bool   `tfsdk:"manual"`
	Fqdn         types.String `tfsdk:"fqdn"`
	Ip           types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.String `tfsdk:"priority"`
}
type GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Hostname  types.String `tfsdk:"hostname"`
}
type GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Hostname  types.String `tfsdk:"hostname"`
}
type GlobalprotectPortalResourceClientConfigConfigsAgentUiObject struct {
	Passcode                 types.String `tfsdk:"passcode"`
	UninstallPassword        types.String `tfsdk:"uninstall_password"`
	AgentUserOverrideTimeout types.Int64  `tfsdk:"agent_user_override_timeout"`
	MaxAgentUserOverrides    types.Int64  `tfsdk:"max_agent_user_overrides"`
	WelcomePage              types.Object `tfsdk:"welcome_page"`
}
type GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject struct {
	Page types.String `tfsdk:"page"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	MaxWaitTime        types.Int64  `tfsdk:"max_wait_time"`
	CollectHipData     types.Bool   `tfsdk:"collect_hip_data"`
	Exclusion          types.Object `tfsdk:"exclusion"`
	CustomChecks       types.Object `tfsdk:"custom_checks"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject struct {
	Category types.List `tfsdk:"category"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject struct {
	Name   types.String `tfsdk:"name"`
	Vendor types.List   `tfsdk:"vendor"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject struct {
	Name    types.String `tfsdk:"name"`
	Product types.List   `tfsdk:"product"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject struct {
	Windows types.Object `tfsdk:"windows"`
	MacOs   types.Object `tfsdk:"mac_os"`
	Linux   types.Object `tfsdk:"linux"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject struct {
	RegistryKey types.List `tfsdk:"registry_key"`
	ProcessList types.List `tfsdk:"process_list"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject struct {
	Name          types.String `tfsdk:"name"`
	RegistryValue types.List   `tfsdk:"registry_value"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject struct {
	Plist       types.List `tfsdk:"plist"`
	ProcessList types.List `tfsdk:"process_list"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject struct {
	Name types.String `tfsdk:"name"`
	Key  types.List   `tfsdk:"key"`
}
type GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject struct {
	ProcessList types.List `tfsdk:"process_list"`
}
type GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject struct {
}
type GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject struct {
	Config types.List `tfsdk:"config"`
}
type GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.List   `tfsdk:"value"`
}
type GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject struct {
	GenerateCookie           types.Bool   `tfsdk:"generate_cookie"`
	CookieEncryptDecryptCert types.String `tfsdk:"cookie_encrypt_decrypt_cert"`
	AcceptCookie             types.Object `tfsdk:"accept_cookie"`
}
type GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject struct {
	CookieLifetime types.Object `tfsdk:"cookie_lifetime"`
}
type GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject struct {
	LifetimeInDays    types.Int64 `tfsdk:"lifetime_in_days"`
	LifetimeInHours   types.Int64 `tfsdk:"lifetime_in_hours"`
	LifetimeInMinutes types.Int64 `tfsdk:"lifetime_in_minutes"`
}
type GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject struct {
	No  types.Object `tfsdk:"no"`
	Yes types.Object `tfsdk:"yes"`
}
type GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject struct {
}
type GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject struct {
}
type GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject struct {
	Local types.String `tfsdk:"local"`
	Scep  types.String `tfsdk:"scep"`
}
type GlobalprotectPortalResourceClientConfigRootCaObject struct {
	Name               types.String `tfsdk:"name"`
	InstallInCertStore types.Bool   `tfsdk:"install_in_cert_store"`
}
type GlobalprotectPortalResourceClientlessVpnObject struct {
	AppsToUserMapping        types.List   `tfsdk:"apps_to_user_mapping"`
	CryptoSettings           types.Object `tfsdk:"crypto_settings"`
	DnsProxy                 types.String `tfsdk:"dns_proxy"`
	Hostname                 types.String `tfsdk:"hostname"`
	InactivityLogout         types.Object `tfsdk:"inactivity_logout"`
	LoginLifetime            types.Object `tfsdk:"login_lifetime"`
	MaxUser                  types.Int64  `tfsdk:"max_user"`
	ProxyServerSetting       types.List   `tfsdk:"proxy_server_setting"`
	RewriteExcludeDomainList types.List   `tfsdk:"rewrite_exclude_domain_list"`
	SecurityZone             types.String `tfsdk:"security_zone"`
}
type GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject struct {
	Name                                  types.String `tfsdk:"name"`
	SourceUser                            types.List   `tfsdk:"source_user"`
	Applications                          types.List   `tfsdk:"applications"`
	EnableCustomAppURLAddressBar          types.Bool   `tfsdk:"enable_custom_app_u_r_l_address_bar"`
	DisplayGlobalProtectAgentDownloadLink types.Bool   `tfsdk:"display_global_protect_agent_download_link"`
}
type GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject struct {
	ServerCertVerification types.Object `tfsdk:"server_cert_verification"`
	SslProtocol            types.Object `tfsdk:"ssl_protocol"`
}
type GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject struct {
	BlockExpiredCertificate types.Bool `tfsdk:"block_expired_certificate"`
	BlockTimeoutCert        types.Bool `tfsdk:"block_timeout_cert"`
	BlockUnknownCert        types.Bool `tfsdk:"block_unknown_cert"`
	BlockUntrustedIssuer    types.Bool `tfsdk:"block_untrusted_issuer"`
}
type GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject struct {
	AuthAlgoMd5      types.Bool   `tfsdk:"auth_algo_md5"`
	AuthAlgoSha1     types.Bool   `tfsdk:"auth_algo_sha1"`
	AuthAlgoSha256   types.Bool   `tfsdk:"auth_algo_sha256"`
	AuthAlgoSha384   types.Bool   `tfsdk:"auth_algo_sha384"`
	EncAlgo3des      types.Bool   `tfsdk:"enc_algo_3des"`
	EncAlgoAes128Cbc types.Bool   `tfsdk:"enc_algo_aes_128_cbc"`
	EncAlgoAes128Gcm types.Bool   `tfsdk:"enc_algo_aes_128_gcm"`
	EncAlgoAes256Cbc types.Bool   `tfsdk:"enc_algo_aes_256_cbc"`
	EncAlgoAes256Gcm types.Bool   `tfsdk:"enc_algo_aes_256_gcm"`
	EncAlgoRc4       types.Bool   `tfsdk:"enc_algo_rc4"`
	KeyxchgAlgoDhe   types.Bool   `tfsdk:"keyxchg_algo_dhe"`
	KeyxchgAlgoEcdhe types.Bool   `tfsdk:"keyxchg_algo_ecdhe"`
	KeyxchgAlgoRsa   types.Bool   `tfsdk:"keyxchg_algo_rsa"`
	MaxVersion       types.String `tfsdk:"max_version"`
	MinVersion       types.String `tfsdk:"min_version"`
}
type GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject struct {
	Hours   types.Int64 `tfsdk:"hours"`
	Minutes types.Int64 `tfsdk:"minutes"`
}
type GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject struct {
	Hours   types.Int64 `tfsdk:"hours"`
	Minutes types.Int64 `tfsdk:"minutes"`
}
type GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject struct {
	Name        types.String `tfsdk:"name"`
	Domains     types.List   `tfsdk:"domains"`
	UseProxy    types.Bool   `tfsdk:"use_proxy"`
	ProxyServer types.Object `tfsdk:"proxy_server"`
}
type GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject struct {
	Server   types.String `tfsdk:"server"`
	Port     types.Int64  `tfsdk:"port"`
	User     types.String `tfsdk:"user"`
	Password types.String `tfsdk:"password"`
}
type GlobalprotectPortalResourcePortalConfigObject struct {
	CertificateProfile   types.String `tfsdk:"certificate_profile"`
	ClientAuth           types.List   `tfsdk:"client_auth"`
	ConfigSelection      types.Object `tfsdk:"config_selection"`
	CustomHelpPage       types.String `tfsdk:"custom_help_page"`
	CustomHomePage       types.String `tfsdk:"custom_home_page"`
	CustomLoginPage      types.String `tfsdk:"custom_login_page"`
	LocalAddress         types.Object `tfsdk:"local_address"`
	LogFail              types.Bool   `tfsdk:"log_fail"`
	LogSetting           types.String `tfsdk:"log_setting"`
	LogSuccess           types.Bool   `tfsdk:"log_success"`
	SslTlsServiceProfile types.String `tfsdk:"ssl_tls_service_profile"`
}
type GlobalprotectPortalResourcePortalConfigClientAuthObject struct {
	Name                               types.String `tfsdk:"name"`
	Os                                 types.String `tfsdk:"os"`
	AuthenticationProfile              types.String `tfsdk:"authentication_profile"`
	AutoRetrievePasscode               types.Bool   `tfsdk:"auto_retrieve_passcode"`
	UsernameLabel                      types.String `tfsdk:"username_label"`
	PasswordLabel                      types.String `tfsdk:"password_label"`
	AuthenticationMessage              types.String `tfsdk:"authentication_message"`
	UserCredentialOrClientCertRequired types.String `tfsdk:"user_credential_or_client_cert_required"`
}
type GlobalprotectPortalResourcePortalConfigConfigSelectionObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	CustomChecks       types.Object `tfsdk:"custom_checks"`
}
type GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject struct {
	MacOs   types.Object `tfsdk:"mac_os"`
	Windows types.Object `tfsdk:"windows"`
}
type GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject struct {
	Plist types.List `tfsdk:"plist"`
}
type GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject struct {
	Name types.String `tfsdk:"name"`
	Key  types.List   `tfsdk:"key"`
}
type GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject struct {
	RegistryKey types.List `tfsdk:"registry_key"`
}
type GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject struct {
	Name          types.String `tfsdk:"name"`
	RegistryValue types.List   `tfsdk:"registry_value"`
}
type GlobalprotectPortalResourcePortalConfigLocalAddressObject struct {
	Interface       types.String `tfsdk:"interface"`
	IpAddressFamily types.String `tfsdk:"ip_address_family"`
	FloatingIp      types.Object `tfsdk:"floating_ip"`
	Ip              types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalResourcePortalConfigLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectPortalResourceSatelliteConfigObject struct {
	ClientCertificate types.Object `tfsdk:"client_certificate"`
	Configs           types.List   `tfsdk:"configs"`
	RootCa            types.List   `tfsdk:"root_ca"`
}
type GlobalprotectPortalResourceSatelliteConfigClientCertificateObject struct {
	Local types.Object `tfsdk:"local"`
	Scep  types.Object `tfsdk:"scep"`
}
type GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject struct {
	CertificateLifeTime      types.Int64  `tfsdk:"certificate_life_time"`
	CertificateRenewalPeriod types.Int64  `tfsdk:"certificate_renewal_period"`
	IssuingCertificate       types.String `tfsdk:"issuing_certificate"`
	OcspResponder            types.String `tfsdk:"ocsp_responder"`
}
type GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject struct {
	CertificateRenewalPeriod types.Int64  `tfsdk:"certificate_renewal_period"`
	Scep                     types.String `tfsdk:"scep"`
}
type GlobalprotectPortalResourceSatelliteConfigConfigsObject struct {
	Name                  types.String `tfsdk:"name"`
	Devices               types.List   `tfsdk:"devices"`
	SourceUser            types.List   `tfsdk:"source_user"`
	Gateways              types.List   `tfsdk:"gateways"`
	ConfigRefreshInterval types.Int64  `tfsdk:"config_refresh_interval"`
}
type GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject struct {
	Name          types.String `tfsdk:"name"`
	Ipv6Preferred types.Bool   `tfsdk:"ipv6_preferred"`
	Priority      types.Int64  `tfsdk:"priority"`
	Fqdn          types.String `tfsdk:"fqdn"`
	Ip            types.Object `tfsdk:"ip"`
}
type GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}

func (o *GlobalprotectPortalResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func GlobalprotectPortalResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": GlobalprotectPortalResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"client_config": GlobalprotectPortalResourceClientConfigSchema(),

			"clientless_vpn": GlobalprotectPortalResourceClientlessVpnSchema(),

			"portal_config": GlobalprotectPortalResourcePortalConfigSchema(),

			"satellite_config": GlobalprotectPortalResourceSatelliteConfigSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceModel) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"agent_user_override_key": rsschema.StringAttribute{
				Description: "Agent user override ticket key",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},

			"configs": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsSchema(),
			},

			"root_ca": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigRootCaSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"save_user_credentials": rsschema.StringAttribute{
				Description: "Save User Credentials",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("1"),
			},

			"portal_2fa": rsschema.BoolAttribute{
				Description: "Portal Authentication OTP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"internal_gateway_2fa": rsschema.BoolAttribute{
				Description: "Internal Gateway Authentication OTP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_discovery_external_gateway_2fa": rsschema.BoolAttribute{
				Description: "Auto Discovery External Gateway Authentication OTP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"manual_only_gateway_2fa": rsschema.BoolAttribute{
				Description: "Manual Only External Gateway Authentication OTP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"refresh_config": rsschema.BoolAttribute{
				Description: "Enable portal config refresh",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mdm_address": rsschema.StringAttribute{
				Description: "IP address or hostname for GlobalProtect MDM server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mdm_enrollment_port": rsschema.StringAttribute{
				Description: "MDM enrollment port",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("443"),
			},

			"source_user": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"third_party_vpn_clients": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"os": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"certificate": GlobalprotectPortalResourceClientConfigConfigsCertificateSchema(),

			"custom_checks": GlobalprotectPortalResourceClientConfigConfigsCustomChecksSchema(),

			"gateways": GlobalprotectPortalResourceClientConfigConfigsGatewaysSchema(),

			"internal_host_detection": GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionSchema(),

			"internal_host_detection_v6": GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Schema(),

			"agent_ui": GlobalprotectPortalResourceClientConfigConfigsAgentUiSchema(),

			"hip_collection": GlobalprotectPortalResourceClientConfigConfigsHipCollectionSchema(),

			"agent_config": GlobalprotectPortalResourceClientConfigConfigsAgentConfigSchema(),

			"gp_app_config": GlobalprotectPortalResourceClientConfigConfigsGpAppConfigSchema(),

			"authentication_override": GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideSchema(),

			"machine_account_exists_with_serialno": GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoSchema(),

			"client_certificate": GlobalprotectPortalResourceClientConfigConfigsClientCertificateSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCertificateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"criteria": GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCustomChecksSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"criteria": GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCustomChecksSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"registry_key": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeySchema(),
			},

			"plist": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"default_value_data": rsschema.StringAttribute{
				Description: "Registry key default value data",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"negate": rsschema.BoolAttribute{
				Description: "Key does not exist",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"registry_value": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value_data": rsschema.StringAttribute{
				Description: "Registry value data",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"negate": rsschema.BoolAttribute{
				Description: "Value does not exist",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"negate": rsschema.BoolAttribute{
				Description: "Plist does not exist",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeySchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": rsschema.StringAttribute{
				Description: "Key value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"negate": rsschema.BoolAttribute{
				Description: "Value does not exist or match specified value data",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"internal": GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalSchema(),

			"external": GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"list": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListSchema(),
			},

			"dhcp_option_code": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source_ip": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "fqdn",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("fqdn"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"cutoff_time": rsschema.Int64Attribute{
				Description: "Gateway discovery cutoff time in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"list": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority_rule": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleSchema(),
			},

			"manual": rsschema.BoolAttribute{
				Description: "If this GlobalProtect gateway can be manually selected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "fqdn",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("fqdn"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.StringAttribute{
				Description: "Priority of GlobalProtect gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("1"),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_address": rsschema.StringAttribute{
				Description: "Internal IPv4 address of a host",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": rsschema.StringAttribute{
				Description: "Host name of the IPv4 in DNS record",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_address": rsschema.StringAttribute{
				Description: "Internal IPv6 address of a host",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": rsschema.StringAttribute{
				Description: "Host name of the IPv6 in DNS record",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsAgentUiSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passcode": rsschema.StringAttribute{
				Description: "Passcode required for override",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},

			"uninstall_password": rsschema.StringAttribute{
				Description: "Password to uninstall GlobalProtect app",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},

			"agent_user_override_timeout": rsschema.Int64Attribute{
				Description: "Agent user override duration in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"max_agent_user_overrides": rsschema.Int64Attribute{
				Description: "Max agent user overrides",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"welcome_page": GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsAgentUiSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"page": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_wait_time": rsschema.Int64Attribute{
				Description: "Max Wait Time (Sec)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"collect_hip_data": rsschema.BoolAttribute{
				Description: "Collect HIP Data",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exclusion": GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionSchema(),

			"custom_checks": GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"category": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategorySchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategorySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vendor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategorySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"product": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"windows": GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsSchema(),

			"mac_os": GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsSchema(),

			"linux": GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"registry_key": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeySchema(),
			},

			"process_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"registry_value": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"plist": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistSchema(),
			},

			"process_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"process_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsAgentConfigSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsAgentConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGpAppConfigSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"config": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGpAppConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"generate_cookie": rsschema.BoolAttribute{
				Description: "Generate cookie for authentication override",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cookie_encrypt_decrypt_cert": rsschema.StringAttribute{
				Description: "Certificate to Encrypt/Decrypt Cookie",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"accept_cookie": GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"cookie_lifetime": GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lifetime_in_days": rsschema.Int64Attribute{
				Description: "Cookie lifetime in days",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("lifetime_in_days"),
						path.MatchRelative().AtParent().AtName("lifetime_in_hours"),
						path.MatchRelative().AtParent().AtName("lifetime_in_minutes"),
					}...),
				},
			},

			"lifetime_in_hours": rsschema.Int64Attribute{
				Description: "Cookie lifetime in hours",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_in_minutes": rsschema.Int64Attribute{
				Description: "Cookie lifetime in minutes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no": GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoSchema(),

			"yes": GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigConfigsClientCertificateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local": rsschema.StringAttribute{
				Description: "Select Client Certificate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("local"),
						path.MatchRelative().AtParent().AtName("scep"),
					}...),
				},
			},

			"scep": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigConfigsClientCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientConfigRootCaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"install_in_cert_store": rsschema.BoolAttribute{
				Description: "Install in Trusted CA Certificate Store",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientConfigRootCaObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientConfigRootCaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"apps_to_user_mapping": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientlessVpnAppsToUserMappingSchema(),
			},

			"crypto_settings": GlobalprotectPortalResourceClientlessVpnCryptoSettingsSchema(),

			"dns_proxy": rsschema.StringAttribute{
				Description: "DNS proxy object used for resolving clientless-vpn application hostnames",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": rsschema.StringAttribute{
				Description: "FQDN or IP address of GlobalProtect Portal",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inactivity_logout": GlobalprotectPortalResourceClientlessVpnInactivityLogoutSchema(),

			"login_lifetime": GlobalprotectPortalResourceClientlessVpnLoginLifetimeSchema(),

			"max_user": rsschema.Int64Attribute{
				Description: "max number of concurrent logined users to GlobalProtect portal",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_server_setting": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceClientlessVpnProxyServerSettingSchema(),
			},

			"rewrite_exclude_domain_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"security_zone": rsschema.StringAttribute{
				Description: "Zone to be used for clientless-vpn traffic",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnAppsToUserMappingSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source_user": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"applications": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"enable_custom_app_u_r_l_address_bar": rsschema.BoolAttribute{
				Description: "URL browse bar to access unpublished clientless VPN applications",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"display_global_protect_agent_download_link": rsschema.BoolAttribute{
				Description: "Display Global Protect Agent download link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnAppsToUserMappingSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnCryptoSettingsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"server_cert_verification": GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationSchema(),

			"ssl_protocol": GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnCryptoSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"block_expired_certificate": rsschema.BoolAttribute{
				Description: "whether to block sessions if server's certificate is expired",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"block_timeout_cert": rsschema.BoolAttribute{
				Description: "whether to block a session if cert. status can't be retrieved within timeout",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"block_unknown_cert": rsschema.BoolAttribute{
				Description: "whether to block a session if cert. status is unknown",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"block_untrusted_issuer": rsschema.BoolAttribute{
				Description: "whether to block sessions if server's certificate is issued by untrusted CA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"auth_algo_md5": rsschema.BoolAttribute{
				Description: "Allow authentication MD5",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_algo_sha1": rsschema.BoolAttribute{
				Description: "Allow authentication SHA1",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_algo_sha256": rsschema.BoolAttribute{
				Description: "Allow authentication SHA256",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_algo_sha384": rsschema.BoolAttribute{
				Description: "Allow authentication SHA384",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_3des": rsschema.BoolAttribute{
				Description: "Allow algorithm 3DES",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_128_cbc": rsschema.BoolAttribute{
				Description: "Allow algorithm AES-128-CBC",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_128_gcm": rsschema.BoolAttribute{
				Description: "Allow algorithm AES-128-GCM",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_256_cbc": rsschema.BoolAttribute{
				Description: "Allow algorithm AES-256-CBC",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_aes_256_gcm": rsschema.BoolAttribute{
				Description: "Allow algorithm AES-256-GCM",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enc_algo_rc4": rsschema.BoolAttribute{
				Description: "Allow algorithm RC4",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keyxchg_algo_dhe": rsschema.BoolAttribute{
				Description: "Allow algorithm DHE",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keyxchg_algo_ecdhe": rsschema.BoolAttribute{
				Description: "Allow algorithm ECDHE",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keyxchg_algo_rsa": rsschema.BoolAttribute{
				Description: "Allow algorithm RSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_version": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("max"),
			},

			"min_version": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("tls1-0"),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnInactivityLogoutSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hours": rsschema.Int64Attribute{
				Description: "specify inactivity time in hours",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("hours"),
						path.MatchRelative().AtParent().AtName("minutes"),
					}...),
				},
			},

			"minutes": rsschema.Int64Attribute{
				Description: "specify inactivity time in minutes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnInactivityLogoutSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnLoginLifetimeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hours": rsschema.Int64Attribute{
				Description: "specify lifetime in hours",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("hours"),
						path.MatchRelative().AtParent().AtName("minutes"),
					}...),
				},
			},

			"minutes": rsschema.Int64Attribute{
				Description: "specify lifetime in minutes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnLoginLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnProxyServerSettingSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"domains": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"use_proxy": rsschema.BoolAttribute{
				Description: "Whether to use proxy server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_server": GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnProxyServerSettingSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"server": rsschema.StringAttribute{
				Description: "Proxy server to use",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"port": rsschema.Int64Attribute{
				Description: "Port for proxy server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"user": rsschema.StringAttribute{
				Description: "Proxy user name to use",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"password": rsschema.StringAttribute{
				Description: "Proxy password to use",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"client_auth": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourcePortalConfigClientAuthSchema(),
			},

			"config_selection": GlobalprotectPortalResourcePortalConfigConfigSelectionSchema(),

			"custom_help_page": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"custom_home_page": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("factory-default"),
			},

			"custom_login_page": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("factory-default"),
			},

			"local_address": GlobalprotectPortalResourcePortalConfigLocalAddressSchema(),

			"log_fail": rsschema.BoolAttribute{
				Description: "Log unsuccessful TLS handshakes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_setting": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_success": rsschema.BoolAttribute{
				Description: "Log successful TLS handshakes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssl_tls_service_profile": rsschema.StringAttribute{
				Description: "SSL TLS service profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigClientAuthSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"os": rsschema.StringAttribute{
				Description: "Client OS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Any"),
			},

			"authentication_profile": rsschema.StringAttribute{
				Description: "authentication profile used for this GlobalProtect",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_retrieve_passcode": rsschema.BoolAttribute{
				Description: "Automatically retrieve passcode from SoftToken application",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username_label": rsschema.StringAttribute{
				Description: "Username Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Username"),
			},

			"password_label": rsschema.StringAttribute{
				Description: "Password Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Password"),
			},

			"authentication_message": rsschema.StringAttribute{
				Description: "Authentication Message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Enter login credentials"),
			},

			"user_credential_or_client_cert_required": rsschema.StringAttribute{
				Description: "Allow Authentication with User Credentials OR Client Certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("no"),
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigClientAuthObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigClientAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigConfigSelectionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"custom_checks": GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigConfigSelectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"mac_os": GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsSchema(),

			"windows": GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"plist": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistSchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"registry_key": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeySchema(),
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"registry_value": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address_family": rsschema.StringAttribute{
				Description: "specify the family of the local address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),
			},

			"floating_ip": GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpSchema(),

			"ip": GlobalprotectPortalResourcePortalConfigLocalAddressIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Floating IPv4 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Floating IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourcePortalConfigLocalAddressIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4 addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourcePortalConfigLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourcePortalConfigLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceSatelliteConfigSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"client_certificate": GlobalprotectPortalResourceSatelliteConfigClientCertificateSchema(),

			"configs": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceSatelliteConfigConfigsSchema(),
			},

			"root_ca": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceSatelliteConfigObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSatelliteConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceSatelliteConfigClientCertificateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local": GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalSchema(),

			"scep": GlobalprotectPortalResourceSatelliteConfigClientCertificateScepSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSatelliteConfigClientCertificateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("local"),
				path.MatchRelative().AtParent().AtName("scep"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"certificate_life_time": rsschema.Int64Attribute{
				Description: "Issued GlobalProtect satellite certificate life time in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(7),
			},

			"certificate_renewal_period": rsschema.Int64Attribute{
				Description: "GlobalProtect satellite certificate renewal period in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"issuing_certificate": rsschema.StringAttribute{
				Description: "Issuing certificate to issue GlobalProtect satellite certificate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ocsp_responder": rsschema.StringAttribute{
				Description: "OCSP responder",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceSatelliteConfigClientCertificateScepSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("local"),
				path.MatchRelative().AtParent().AtName("scep"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"certificate_renewal_period": rsschema.Int64Attribute{
				Description: "GlobalProtect satellite certificate renewal period in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"scep": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSatelliteConfigClientCertificateScepSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceSatelliteConfigConfigsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"devices": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"source_user": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"gateways": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysSchema(),
			},

			"config_refresh_interval": rsschema.Int64Attribute{
				Description: "GlobalProtect satellite configuration refresh interval in hours",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(24),
			},
		},
	}
}

func (o *GlobalprotectPortalResourceSatelliteConfigConfigsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSatelliteConfigConfigsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ipv6_preferred": rsschema.BoolAttribute{
				Description: "IPv6 Preferred",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority of GlobalProtect gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "fqdn",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("fqdn"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpSchema(),
		},
	}
}

func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *GlobalprotectPortalResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_globalprotect_portal"
}

func (o *GlobalprotectPortalResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = GlobalprotectPortalResourceSchema()
}

// </ResourceSchema>

func (o *GlobalprotectPortalResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := portal.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*portal.Entry, portal.Location, *portal.Service](o.client, portal.NewService(o.client), batchSize, specifier, portal.SpecMatches)
}

func (o *GlobalprotectPortalResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj GlobalprotectPortalLocation

	var clientConfigObj *GlobalprotectPortalResourceClientConfigObject

	var clientlessVpnObj *GlobalprotectPortalResourceClientlessVpnObject

	var portalConfigObj *GlobalprotectPortalResourcePortalConfigObject

	var satelliteConfigObj *GlobalprotectPortalResourceSatelliteConfigObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"client_config": types.ObjectType{
			AttrTypes: clientConfigObj.AttributeTypes(),
		},
		"clientless_vpn": types.ObjectType{
			AttrTypes: clientlessVpnObj.AttributeTypes(),
		},
		"portal_config": types.ObjectType{
			AttrTypes: portalConfigObj.AttributeTypes(),
		},
		"satellite_config": types.ObjectType{
			AttrTypes: satelliteConfigObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceModel) AncestorName() string {
	return ""
}

func (o GlobalprotectPortalResourceModel) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigObject) AttributeTypes() map[string]attr.Type {

	var configsObj *GlobalprotectPortalResourceClientConfigConfigsObject

	var rootCaObj *GlobalprotectPortalResourceClientConfigRootCaObject
	return map[string]attr.Type{
		"agent_user_override_key": types.StringType,
		"configs": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: configsObj.AttributeTypes(),
			},
		},
		"root_ca": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rootCaObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigObject) AncestorName() string {
	return "client-config"
}

func (o GlobalprotectPortalResourceClientConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsObject) AttributeTypes() map[string]attr.Type {

	var certificateObj *GlobalprotectPortalResourceClientConfigConfigsCertificateObject

	var customChecksObj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject

	var gatewaysObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysObject

	var internalHostDetectionObj *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject

	var internalHostDetectionV6Obj *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object

	var agentUiObj *GlobalprotectPortalResourceClientConfigConfigsAgentUiObject

	var hipCollectionObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject

	var agentConfigObj *GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject

	var gpAppConfigObj *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject

	var authenticationOverrideObj *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject

	var machineAccountExistsWithSerialnoObj *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject

	var clientCertificateObj *GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject
	return map[string]attr.Type{
		"name":                                types.StringType,
		"save_user_credentials":               types.StringType,
		"portal_2fa":                          types.BoolType,
		"internal_gateway_2fa":                types.BoolType,
		"auto_discovery_external_gateway_2fa": types.BoolType,
		"manual_only_gateway_2fa":             types.BoolType,
		"refresh_config":                      types.BoolType,
		"mdm_address":                         types.StringType,
		"mdm_enrollment_port":                 types.StringType,
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"third_party_vpn_clients": types.ListType{
			ElemType: types.StringType,
		},
		"os": types.ListType{
			ElemType: types.StringType,
		},
		"certificate": types.ObjectType{
			AttrTypes: certificateObj.AttributeTypes(),
		},
		"custom_checks": types.ObjectType{
			AttrTypes: customChecksObj.AttributeTypes(),
		},
		"gateways": types.ObjectType{
			AttrTypes: gatewaysObj.AttributeTypes(),
		},
		"internal_host_detection": types.ObjectType{
			AttrTypes: internalHostDetectionObj.AttributeTypes(),
		},
		"internal_host_detection_v6": types.ObjectType{
			AttrTypes: internalHostDetectionV6Obj.AttributeTypes(),
		},
		"agent_ui": types.ObjectType{
			AttrTypes: agentUiObj.AttributeTypes(),
		},
		"hip_collection": types.ObjectType{
			AttrTypes: hipCollectionObj.AttributeTypes(),
		},
		"agent_config": types.ObjectType{
			AttrTypes: agentConfigObj.AttributeTypes(),
		},
		"gp_app_config": types.ObjectType{
			AttrTypes: gpAppConfigObj.AttributeTypes(),
		},
		"authentication_override": types.ObjectType{
			AttrTypes: authenticationOverrideObj.AttributeTypes(),
		},
		"machine_account_exists_with_serialno": types.ObjectType{
			AttrTypes: machineAccountExistsWithSerialnoObj.AttributeTypes(),
		},
		"client_certificate": types.ObjectType{
			AttrTypes: clientCertificateObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsObject) AncestorName() string {
	return "configs"
}

func (o GlobalprotectPortalResourceClientConfigConfigsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateObject) AttributeTypes() map[string]attr.Type {

	var criteriaObj *GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject
	return map[string]attr.Type{
		"criteria": types.ObjectType{
			AttrTypes: criteriaObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCertificateObject) AncestorName() string {
	return "certificate"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCertificateObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_profile": types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject) AncestorName() string {
	return "criteria"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject) AttributeTypes() map[string]attr.Type {

	var criteriaObj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject
	return map[string]attr.Type{
		"criteria": types.ObjectType{
			AttrTypes: criteriaObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject) AncestorName() string {
	return "custom-checks"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject) AttributeTypes() map[string]attr.Type {

	var registryKeyObj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject

	var plistObj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject
	return map[string]attr.Type{
		"registry_key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryKeyObj.AttributeTypes(),
			},
		},
		"plist": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: plistObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject) AncestorName() string {
	return "criteria"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) AttributeTypes() map[string]attr.Type {

	var registryValueObj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject
	return map[string]attr.Type{
		"name":               types.StringType,
		"default_value_data": types.StringType,
		"negate":             types.BoolType,
		"registry_value": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryValueObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) AncestorName() string {
	return "registry-key"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"value_data": types.StringType,
		"negate":     types.BoolType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) AncestorName() string {
	return "registry-value"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject) AttributeTypes() map[string]attr.Type {

	var keyObj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"negate": types.BoolType,
		"key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: keyObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject) AncestorName() string {
	return "plist"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"value":  types.StringType,
		"negate": types.BoolType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) AncestorName() string {
	return "key"
}

func (o GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysObject) AttributeTypes() map[string]attr.Type {

	var internalObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject

	var externalObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject
	return map[string]attr.Type{
		"internal": types.ObjectType{
			AttrTypes: internalObj.AttributeTypes(),
		},
		"external": types.ObjectType{
			AttrTypes: externalObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysObject) AncestorName() string {
	return "gateways"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject

	return map[string]attr.Type{
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
		"dhcp_option_code": types.ListType{
			ElemType: types.Int64Type,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject) AncestorName() string {
	return "internal"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject) AttributeTypes() map[string]attr.Type {

	var ipObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject
	return map[string]attr.Type{
		"name": types.StringType,
		"source_ip": types.ListType{
			ElemType: types.StringType,
		},
		"fqdn": types.StringType,
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject
	return map[string]attr.Type{
		"cutoff_time": types.Int64Type,
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject) AncestorName() string {
	return "external"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject) AttributeTypes() map[string]attr.Type {

	var priorityRuleObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject

	var ipObj *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject
	return map[string]attr.Type{
		"name": types.StringType,
		"priority_rule": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: priorityRuleObj.AttributeTypes(),
			},
		},
		"manual": types.BoolType,
		"fqdn":   types.StringType,
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) AncestorName() string {
	return "priority-rule"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
		"hostname":   types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject) AncestorName() string {
	return "internal-host-detection"
}

func (o GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
		"hostname":   types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object) AncestorName() string {
	return "internal-host-detection-v6"
}

func (o GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiObject) AttributeTypes() map[string]attr.Type {

	var welcomePageObj *GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject
	return map[string]attr.Type{
		"passcode":                    types.StringType,
		"uninstall_password":          types.StringType,
		"agent_user_override_timeout": types.Int64Type,
		"max_agent_user_overrides":    types.Int64Type,
		"welcome_page": types.ObjectType{
			AttrTypes: welcomePageObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsAgentUiObject) AncestorName() string {
	return "agent-ui"
}

func (o GlobalprotectPortalResourceClientConfigConfigsAgentUiObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"page": types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject) AncestorName() string {
	return "welcome-page"
}

func (o GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject) AttributeTypes() map[string]attr.Type {

	var exclusionObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject

	var customChecksObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject
	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"max_wait_time":       types.Int64Type,
		"collect_hip_data":    types.BoolType,
		"exclusion": types.ObjectType{
			AttrTypes: exclusionObj.AttributeTypes(),
		},
		"custom_checks": types.ObjectType{
			AttrTypes: customChecksObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject) AncestorName() string {
	return "hip-collection"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject) AttributeTypes() map[string]attr.Type {

	var categoryObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject
	return map[string]attr.Type{
		"category": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: categoryObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject) AncestorName() string {
	return "exclusion"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject) AttributeTypes() map[string]attr.Type {

	var vendorObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject
	return map[string]attr.Type{
		"name": types.StringType,
		"vendor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: vendorObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject) AncestorName() string {
	return "category"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"product": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) AncestorName() string {
	return "vendor"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject) AttributeTypes() map[string]attr.Type {

	var windowsObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject

	var macOsObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject

	var linuxObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject
	return map[string]attr.Type{
		"windows": types.ObjectType{
			AttrTypes: windowsObj.AttributeTypes(),
		},
		"mac_os": types.ObjectType{
			AttrTypes: macOsObj.AttributeTypes(),
		},
		"linux": types.ObjectType{
			AttrTypes: linuxObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject) AncestorName() string {
	return "custom-checks"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) AttributeTypes() map[string]attr.Type {

	var registryKeyObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject

	return map[string]attr.Type{
		"registry_key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryKeyObj.AttributeTypes(),
			},
		},
		"process_list": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) AncestorName() string {
	return "windows"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"registry_value": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) AncestorName() string {
	return "registry-key"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) AttributeTypes() map[string]attr.Type {

	var plistObj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject

	return map[string]attr.Type{
		"plist": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: plistObj.AttributeTypes(),
			},
		},
		"process_list": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) AncestorName() string {
	return "mac-os"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"key": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) AncestorName() string {
	return "plist"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"process_list": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) AncestorName() string {
	return "linux"
}

func (o GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject) AncestorName() string {
	return "agent-config"
}

func (o GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject) AttributeTypes() map[string]attr.Type {

	var configObj *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject
	return map[string]attr.Type{
		"config": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: configObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject) AncestorName() string {
	return "gp-app-config"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"value": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject) AncestorName() string {
	return "config"
}

func (o GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject) AttributeTypes() map[string]attr.Type {

	var acceptCookieObj *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject
	return map[string]attr.Type{
		"generate_cookie":             types.BoolType,
		"cookie_encrypt_decrypt_cert": types.StringType,
		"accept_cookie": types.ObjectType{
			AttrTypes: acceptCookieObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject) AncestorName() string {
	return "authentication-override"
}

func (o GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) AttributeTypes() map[string]attr.Type {

	var cookieLifetimeObj *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	return map[string]attr.Type{
		"cookie_lifetime": types.ObjectType{
			AttrTypes: cookieLifetimeObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) AncestorName() string {
	return "accept-cookie"
}

func (o GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lifetime_in_days":    types.Int64Type,
		"lifetime_in_hours":   types.Int64Type,
		"lifetime_in_minutes": types.Int64Type,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AncestorName() string {
	return "cookie-lifetime"
}

func (o GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) AttributeTypes() map[string]attr.Type {

	var noObj *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject

	var yesObj *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject
	return map[string]attr.Type{
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) AncestorName() string {
	return "machine-account-exists-with-serialno"
}

func (o GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) AncestorName() string {
	return "no"
}

func (o GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) AncestorName() string {
	return "yes"
}

func (o GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local": types.StringType,
		"scep":  types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject) AncestorName() string {
	return "client-certificate"
}

func (o GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientConfigRootCaObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                  types.StringType,
		"install_in_cert_store": types.BoolType,
	}
}

func (o GlobalprotectPortalResourceClientConfigRootCaObject) AncestorName() string {
	return "root-ca"
}

func (o GlobalprotectPortalResourceClientConfigRootCaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientlessVpnObject) AttributeTypes() map[string]attr.Type {

	var appsToUserMappingObj *GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject

	var cryptoSettingsObj *GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject

	var inactivityLogoutObj *GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject

	var loginLifetimeObj *GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject

	var proxyServerSettingObj *GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject

	return map[string]attr.Type{
		"apps_to_user_mapping": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: appsToUserMappingObj.AttributeTypes(),
			},
		},
		"crypto_settings": types.ObjectType{
			AttrTypes: cryptoSettingsObj.AttributeTypes(),
		},
		"dns_proxy": types.StringType,
		"hostname":  types.StringType,
		"inactivity_logout": types.ObjectType{
			AttrTypes: inactivityLogoutObj.AttributeTypes(),
		},
		"login_lifetime": types.ObjectType{
			AttrTypes: loginLifetimeObj.AttributeTypes(),
		},
		"max_user": types.Int64Type,
		"proxy_server_setting": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: proxyServerSettingObj.AttributeTypes(),
			},
		},
		"rewrite_exclude_domain_list": types.ListType{
			ElemType: types.StringType,
		},
		"security_zone": types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientlessVpnObject) AncestorName() string {
	return "clientless-vpn"
}

func (o GlobalprotectPortalResourceClientlessVpnObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"applications": types.ListType{
			ElemType: types.StringType,
		},
		"enable_custom_app_u_r_l_address_bar":        types.BoolType,
		"display_global_protect_agent_download_link": types.BoolType,
	}
}

func (o GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject) AncestorName() string {
	return "apps-to-user-mapping"
}

func (o GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject) AttributeTypes() map[string]attr.Type {

	var serverCertVerificationObj *GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject

	var sslProtocolObj *GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject
	return map[string]attr.Type{
		"server_cert_verification": types.ObjectType{
			AttrTypes: serverCertVerificationObj.AttributeTypes(),
		},
		"ssl_protocol": types.ObjectType{
			AttrTypes: sslProtocolObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject) AncestorName() string {
	return "crypto-settings"
}

func (o GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"block_expired_certificate": types.BoolType,
		"block_timeout_cert":        types.BoolType,
		"block_unknown_cert":        types.BoolType,
		"block_untrusted_issuer":    types.BoolType,
	}
}

func (o GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject) AncestorName() string {
	return "server-cert-verification"
}

func (o GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"auth_algo_md5":        types.BoolType,
		"auth_algo_sha1":       types.BoolType,
		"auth_algo_sha256":     types.BoolType,
		"auth_algo_sha384":     types.BoolType,
		"enc_algo_3des":        types.BoolType,
		"enc_algo_aes_128_cbc": types.BoolType,
		"enc_algo_aes_128_gcm": types.BoolType,
		"enc_algo_aes_256_cbc": types.BoolType,
		"enc_algo_aes_256_gcm": types.BoolType,
		"enc_algo_rc4":         types.BoolType,
		"keyxchg_algo_dhe":     types.BoolType,
		"keyxchg_algo_ecdhe":   types.BoolType,
		"keyxchg_algo_rsa":     types.BoolType,
		"max_version":          types.StringType,
		"min_version":          types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject) AncestorName() string {
	return "ssl-protocol"
}

func (o GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"hours":   types.Int64Type,
		"minutes": types.Int64Type,
	}
}

func (o GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject) AncestorName() string {
	return "inactivity-logout"
}

func (o GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"hours":   types.Int64Type,
		"minutes": types.Int64Type,
	}
}

func (o GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject) AncestorName() string {
	return "login-lifetime"
}

func (o GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject) AttributeTypes() map[string]attr.Type {

	var proxyServerObj *GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject
	return map[string]attr.Type{
		"name": types.StringType,
		"domains": types.ListType{
			ElemType: types.StringType,
		},
		"use_proxy": types.BoolType,
		"proxy_server": types.ObjectType{
			AttrTypes: proxyServerObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject) AncestorName() string {
	return "proxy-server-setting"
}

func (o GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"server":   types.StringType,
		"port":     types.Int64Type,
		"user":     types.StringType,
		"password": types.StringType,
	}
}

func (o GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject) AncestorName() string {
	return "proxy-server"
}

func (o GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigObject) AttributeTypes() map[string]attr.Type {

	var clientAuthObj *GlobalprotectPortalResourcePortalConfigClientAuthObject

	var configSelectionObj *GlobalprotectPortalResourcePortalConfigConfigSelectionObject

	var localAddressObj *GlobalprotectPortalResourcePortalConfigLocalAddressObject

	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"client_auth": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: clientAuthObj.AttributeTypes(),
			},
		},
		"config_selection": types.ObjectType{
			AttrTypes: configSelectionObj.AttributeTypes(),
		},
		"custom_help_page":  types.StringType,
		"custom_home_page":  types.StringType,
		"custom_login_page": types.StringType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"log_fail":                types.BoolType,
		"log_setting":             types.StringType,
		"log_success":             types.BoolType,
		"ssl_tls_service_profile": types.StringType,
	}
}

func (o GlobalprotectPortalResourcePortalConfigObject) AncestorName() string {
	return "portal-config"
}

func (o GlobalprotectPortalResourcePortalConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigClientAuthObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                   types.StringType,
		"os":                     types.StringType,
		"authentication_profile": types.StringType,
		"auto_retrieve_passcode": types.BoolType,
		"username_label":         types.StringType,
		"password_label":         types.StringType,
		"authentication_message": types.StringType,
		"user_credential_or_client_cert_required": types.StringType,
	}
}

func (o GlobalprotectPortalResourcePortalConfigClientAuthObject) AncestorName() string {
	return "client-auth"
}

func (o GlobalprotectPortalResourcePortalConfigClientAuthObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionObject) AttributeTypes() map[string]attr.Type {

	var customChecksObj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject
	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"custom_checks": types.ObjectType{
			AttrTypes: customChecksObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionObject) AncestorName() string {
	return "config-selection"
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject) AttributeTypes() map[string]attr.Type {

	var macOsObj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject

	var windowsObj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject
	return map[string]attr.Type{
		"mac_os": types.ObjectType{
			AttrTypes: macOsObj.AttributeTypes(),
		},
		"windows": types.ObjectType{
			AttrTypes: windowsObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject) AncestorName() string {
	return "custom-checks"
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject) AttributeTypes() map[string]attr.Type {

	var plistObj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject
	return map[string]attr.Type{
		"plist": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: plistObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject) AncestorName() string {
	return "mac-os"
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"key": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) AncestorName() string {
	return "plist"
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject) AttributeTypes() map[string]attr.Type {

	var registryKeyObj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject
	return map[string]attr.Type{
		"registry_key": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: registryKeyObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject) AncestorName() string {
	return "windows"
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"registry_value": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) AncestorName() string {
	return "registry-key"
}

func (o GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourcePortalConfigLocalAddressObject) AttributeTypes() map[string]attr.Type {

	var floatingIpObj *GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject

	var ipObj *GlobalprotectPortalResourcePortalConfigLocalAddressIpObject
	return map[string]attr.Type{
		"interface":         types.StringType,
		"ip_address_family": types.StringType,
		"floating_ip": types.ObjectType{
			AttrTypes: floatingIpObj.AttributeTypes(),
		},
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourcePortalConfigLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o GlobalprotectPortalResourcePortalConfigLocalAddressObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject) AncestorName() string {
	return "floating-ip"
}

func (o GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourcePortalConfigLocalAddressIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalResourcePortalConfigLocalAddressIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalResourcePortalConfigLocalAddressIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceSatelliteConfigObject) AttributeTypes() map[string]attr.Type {

	var clientCertificateObj *GlobalprotectPortalResourceSatelliteConfigClientCertificateObject

	var configsObj *GlobalprotectPortalResourceSatelliteConfigConfigsObject

	return map[string]attr.Type{
		"client_certificate": types.ObjectType{
			AttrTypes: clientCertificateObj.AttributeTypes(),
		},
		"configs": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: configsObj.AttributeTypes(),
			},
		},
		"root_ca": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectPortalResourceSatelliteConfigObject) AncestorName() string {
	return "satellite-config"
}

func (o GlobalprotectPortalResourceSatelliteConfigObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateObject) AttributeTypes() map[string]attr.Type {

	var localObj *GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject

	var scepObj *GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject
	return map[string]attr.Type{
		"local": types.ObjectType{
			AttrTypes: localObj.AttributeTypes(),
		},
		"scep": types.ObjectType{
			AttrTypes: scepObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceSatelliteConfigClientCertificateObject) AncestorName() string {
	return "client-certificate"
}

func (o GlobalprotectPortalResourceSatelliteConfigClientCertificateObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_life_time":      types.Int64Type,
		"certificate_renewal_period": types.Int64Type,
		"issuing_certificate":        types.StringType,
		"ocsp_responder":             types.StringType,
	}
}

func (o GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject) AncestorName() string {
	return "local"
}

func (o GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_renewal_period": types.Int64Type,
		"scep":                       types.StringType,
	}
}

func (o GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject) AncestorName() string {
	return "scep"
}

func (o GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectPortalResourceSatelliteConfigConfigsObject) AttributeTypes() map[string]attr.Type {

	var gatewaysObj *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject

	return map[string]attr.Type{
		"name": types.StringType,
		"devices": types.ListType{
			ElemType: types.StringType,
		},
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"gateways": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: gatewaysObj.AttributeTypes(),
			},
		},
		"config_refresh_interval": types.Int64Type,
	}
}

func (o GlobalprotectPortalResourceSatelliteConfigConfigsObject) AncestorName() string {
	return "configs"
}

func (o GlobalprotectPortalResourceSatelliteConfigConfigsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject) AttributeTypes() map[string]attr.Type {

	var ipObj *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"ipv6_preferred": types.BoolType,
		"priority":       types.Int64Type,
		"fqdn":           types.StringType,
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject) AncestorName() string {
	return "gateways"
}

func (o GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject) EntryName() *string {
	return nil
}

func (o *GlobalprotectPortalResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientConfig_entry *portal.ClientConfig
	if !o.ClientConfig.IsUnknown() && !o.ClientConfig.IsNull() {
		if *obj != nil && (*obj).ClientConfig != nil {
			clientConfig_entry = (*obj).ClientConfig
		} else {
			clientConfig_entry = new(portal.ClientConfig)
		}
		var object *GlobalprotectPortalResourceClientConfigObject
		diags.Append(o.ClientConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &clientConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var clientlessVpn_entry *portal.ClientlessVpn
	if !o.ClientlessVpn.IsUnknown() && !o.ClientlessVpn.IsNull() {
		if *obj != nil && (*obj).ClientlessVpn != nil {
			clientlessVpn_entry = (*obj).ClientlessVpn
		} else {
			clientlessVpn_entry = new(portal.ClientlessVpn)
		}
		var object *GlobalprotectPortalResourceClientlessVpnObject
		diags.Append(o.ClientlessVpn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &clientlessVpn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var portalConfig_entry *portal.PortalConfig
	if !o.PortalConfig.IsUnknown() && !o.PortalConfig.IsNull() {
		if *obj != nil && (*obj).PortalConfig != nil {
			portalConfig_entry = (*obj).PortalConfig
		} else {
			portalConfig_entry = new(portal.PortalConfig)
		}
		var object *GlobalprotectPortalResourcePortalConfigObject
		diags.Append(o.PortalConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &portalConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var satelliteConfig_entry *portal.SatelliteConfig
	if !o.SatelliteConfig.IsUnknown() && !o.SatelliteConfig.IsNull() {
		if *obj != nil && (*obj).SatelliteConfig != nil {
			satelliteConfig_entry = (*obj).SatelliteConfig
		} else {
			satelliteConfig_entry = new(portal.SatelliteConfig)
		}
		var object *GlobalprotectPortalResourceSatelliteConfigObject
		diags.Append(o.SatelliteConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &satelliteConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ClientConfig = clientConfig_entry
	(*obj).ClientlessVpn = clientlessVpn_entry
	(*obj).PortalConfig = portalConfig_entry
	(*obj).SatelliteConfig = satelliteConfig_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var agentUserOverrideKey_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "agent-user-override-key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.AgentUserOverrideKey.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		agentUserOverrideKey_value = o.AgentUserOverrideKey.ValueStringPointer()
	}
	var configs_tf_entries []GlobalprotectPortalResourceClientConfigConfigsObject
	var configs_pango_entries []portal.ClientConfigConfigs
	{
		d := o.Configs.ElementsAs(ctx, &configs_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range configs_tf_entries {
			var entry *portal.ClientConfigConfigs
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			configs_pango_entries = append(configs_pango_entries, *entry)
		}
	}
	var rootCa_tf_entries []GlobalprotectPortalResourceClientConfigRootCaObject
	var rootCa_pango_entries []portal.ClientConfigRootCa
	{
		d := o.RootCa.ElementsAs(ctx, &rootCa_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rootCa_tf_entries {
			var entry *portal.ClientConfigRootCa
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rootCa_pango_entries = append(rootCa_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfig)
	}
	(*obj).AgentUserOverrideKey = agentUserOverrideKey_value
	(*obj).Configs = configs_pango_entries
	(*obj).RootCa = rootCa_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	saveUserCredentials_value := o.SaveUserCredentials.ValueStringPointer()
	portal2fa_value := o.Portal2fa.ValueBoolPointer()
	internalGateway2fa_value := o.InternalGateway2fa.ValueBoolPointer()
	autoDiscoveryExternalGateway2fa_value := o.AutoDiscoveryExternalGateway2fa.ValueBoolPointer()
	manualOnlyGateway2fa_value := o.ManualOnlyGateway2fa.ValueBoolPointer()
	refreshConfig_value := o.RefreshConfig.ValueBoolPointer()
	mdmAddress_value := o.MdmAddress.ValueStringPointer()
	mdmEnrollmentPort_value := o.MdmEnrollmentPort.ValueStringPointer()
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var thirdPartyVpnClients_pango_entries []string
	if !o.ThirdPartyVpnClients.IsUnknown() && !o.ThirdPartyVpnClients.IsNull() {
		object_entries := make([]types.String, 0, len(o.ThirdPartyVpnClients.Elements()))
		diags.Append(o.ThirdPartyVpnClients.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			thirdPartyVpnClients_pango_entries = append(thirdPartyVpnClients_pango_entries, elt.ValueString())
		}
	}
	var os_pango_entries []string
	if !o.Os.IsUnknown() && !o.Os.IsNull() {
		object_entries := make([]types.String, 0, len(o.Os.Elements()))
		diags.Append(o.Os.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			os_pango_entries = append(os_pango_entries, elt.ValueString())
		}
	}
	var certificate_entry *portal.ClientConfigConfigsCertificate
	if !o.Certificate.IsUnknown() && !o.Certificate.IsNull() {
		if *obj != nil && (*obj).Certificate != nil {
			certificate_entry = (*obj).Certificate
		} else {
			certificate_entry = new(portal.ClientConfigConfigsCertificate)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsCertificateObject
		diags.Append(o.Certificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &certificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var customChecks_entry *portal.ClientConfigConfigsCustomChecks
	if !o.CustomChecks.IsUnknown() && !o.CustomChecks.IsNull() {
		if *obj != nil && (*obj).CustomChecks != nil {
			customChecks_entry = (*obj).CustomChecks
		} else {
			customChecks_entry = new(portal.ClientConfigConfigsCustomChecks)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject
		diags.Append(o.CustomChecks.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &customChecks_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gateways_entry *portal.ClientConfigConfigsGateways
	if !o.Gateways.IsUnknown() && !o.Gateways.IsNull() {
		if *obj != nil && (*obj).Gateways != nil {
			gateways_entry = (*obj).Gateways
		} else {
			gateways_entry = new(portal.ClientConfigConfigsGateways)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsGatewaysObject
		diags.Append(o.Gateways.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gateways_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var internalHostDetection_entry *portal.ClientConfigConfigsInternalHostDetection
	if !o.InternalHostDetection.IsUnknown() && !o.InternalHostDetection.IsNull() {
		if *obj != nil && (*obj).InternalHostDetection != nil {
			internalHostDetection_entry = (*obj).InternalHostDetection
		} else {
			internalHostDetection_entry = new(portal.ClientConfigConfigsInternalHostDetection)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject
		diags.Append(o.InternalHostDetection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &internalHostDetection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var internalHostDetectionV6_entry *portal.ClientConfigConfigsInternalHostDetectionV6
	if !o.InternalHostDetectionV6.IsUnknown() && !o.InternalHostDetectionV6.IsNull() {
		if *obj != nil && (*obj).InternalHostDetectionV6 != nil {
			internalHostDetectionV6_entry = (*obj).InternalHostDetectionV6
		} else {
			internalHostDetectionV6_entry = new(portal.ClientConfigConfigsInternalHostDetectionV6)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object
		diags.Append(o.InternalHostDetectionV6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &internalHostDetectionV6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var agentUi_entry *portal.ClientConfigConfigsAgentUi
	if !o.AgentUi.IsUnknown() && !o.AgentUi.IsNull() {
		if *obj != nil && (*obj).AgentUi != nil {
			agentUi_entry = (*obj).AgentUi
		} else {
			agentUi_entry = new(portal.ClientConfigConfigsAgentUi)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsAgentUiObject
		diags.Append(o.AgentUi.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &agentUi_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hipCollection_entry *portal.ClientConfigConfigsHipCollection
	if !o.HipCollection.IsUnknown() && !o.HipCollection.IsNull() {
		if *obj != nil && (*obj).HipCollection != nil {
			hipCollection_entry = (*obj).HipCollection
		} else {
			hipCollection_entry = new(portal.ClientConfigConfigsHipCollection)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject
		diags.Append(o.HipCollection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hipCollection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var agentConfig_entry *portal.ClientConfigConfigsAgentConfig
	if !o.AgentConfig.IsUnknown() && !o.AgentConfig.IsNull() {
		if *obj != nil && (*obj).AgentConfig != nil {
			agentConfig_entry = (*obj).AgentConfig
		} else {
			agentConfig_entry = new(portal.ClientConfigConfigsAgentConfig)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject
		diags.Append(o.AgentConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &agentConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gpAppConfig_entry *portal.ClientConfigConfigsGpAppConfig
	if !o.GpAppConfig.IsUnknown() && !o.GpAppConfig.IsNull() {
		if *obj != nil && (*obj).GpAppConfig != nil {
			gpAppConfig_entry = (*obj).GpAppConfig
		} else {
			gpAppConfig_entry = new(portal.ClientConfigConfigsGpAppConfig)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject
		diags.Append(o.GpAppConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gpAppConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var authenticationOverride_entry *portal.ClientConfigConfigsAuthenticationOverride
	if !o.AuthenticationOverride.IsUnknown() && !o.AuthenticationOverride.IsNull() {
		if *obj != nil && (*obj).AuthenticationOverride != nil {
			authenticationOverride_entry = (*obj).AuthenticationOverride
		} else {
			authenticationOverride_entry = new(portal.ClientConfigConfigsAuthenticationOverride)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject
		diags.Append(o.AuthenticationOverride.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authenticationOverride_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var machineAccountExistsWithSerialno_entry *portal.ClientConfigConfigsMachineAccountExistsWithSerialno
	if !o.MachineAccountExistsWithSerialno.IsUnknown() && !o.MachineAccountExistsWithSerialno.IsNull() {
		if *obj != nil && (*obj).MachineAccountExistsWithSerialno != nil {
			machineAccountExistsWithSerialno_entry = (*obj).MachineAccountExistsWithSerialno
		} else {
			machineAccountExistsWithSerialno_entry = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialno)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject
		diags.Append(o.MachineAccountExistsWithSerialno.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &machineAccountExistsWithSerialno_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var clientCertificate_entry *portal.ClientConfigConfigsClientCertificate
	if !o.ClientCertificate.IsUnknown() && !o.ClientCertificate.IsNull() {
		if *obj != nil && (*obj).ClientCertificate != nil {
			clientCertificate_entry = (*obj).ClientCertificate
		} else {
			clientCertificate_entry = new(portal.ClientConfigConfigsClientCertificate)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject
		diags.Append(o.ClientCertificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &clientCertificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigs)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SaveUserCredentials = saveUserCredentials_value
	(*obj).Portal2fa = portal2fa_value
	(*obj).InternalGateway2fa = internalGateway2fa_value
	(*obj).AutoDiscoveryExternalGateway2fa = autoDiscoveryExternalGateway2fa_value
	(*obj).ManualOnlyGateway2fa = manualOnlyGateway2fa_value
	(*obj).RefreshConfig = refreshConfig_value
	(*obj).MdmAddress = mdmAddress_value
	(*obj).MdmEnrollmentPort = mdmEnrollmentPort_value
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).ThirdPartyVpnClients = thirdPartyVpnClients_pango_entries
	(*obj).Os = os_pango_entries
	(*obj).Certificate = certificate_entry
	(*obj).CustomChecks = customChecks_entry
	(*obj).Gateways = gateways_entry
	(*obj).InternalHostDetection = internalHostDetection_entry
	(*obj).InternalHostDetectionV6 = internalHostDetectionV6_entry
	(*obj).AgentUi = agentUi_entry
	(*obj).HipCollection = hipCollection_entry
	(*obj).AgentConfig = agentConfig_entry
	(*obj).GpAppConfig = gpAppConfig_entry
	(*obj).AuthenticationOverride = authenticationOverride_entry
	(*obj).MachineAccountExistsWithSerialno = machineAccountExistsWithSerialno_entry
	(*obj).ClientCertificate = clientCertificate_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var criteria_entry *portal.ClientConfigConfigsCertificateCriteria
	if !o.Criteria.IsUnknown() && !o.Criteria.IsNull() {
		if *obj != nil && (*obj).Criteria != nil {
			criteria_entry = (*obj).Criteria
		} else {
			criteria_entry = new(portal.ClientConfigConfigsCertificateCriteria)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject
		diags.Append(o.Criteria.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &criteria_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCertificate)
	}
	(*obj).Criteria = criteria_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCertificateCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCertificateCriteria)
	}
	(*obj).CertificateProfile = certificateProfile_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var criteria_entry *portal.ClientConfigConfigsCustomChecksCriteria
	if !o.Criteria.IsUnknown() && !o.Criteria.IsNull() {
		if *obj != nil && (*obj).Criteria != nil {
			criteria_entry = (*obj).Criteria
		} else {
			criteria_entry = new(portal.ClientConfigConfigsCustomChecksCriteria)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject
		diags.Append(o.Criteria.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &criteria_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecks)
	}
	(*obj).Criteria = criteria_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject
	var registryKey_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey
	{
		d := o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryKey_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryKey_pango_entries = append(registryKey_pango_entries, *entry)
		}
	}
	var plist_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject
	var plist_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaPlist
	{
		d := o.Plist.ElementsAs(ctx, &plist_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range plist_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaPlist
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			plist_pango_entries = append(plist_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteria)
	}
	(*obj).RegistryKey = registryKey_pango_entries
	(*obj).Plist = plist_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	defaultValueData_value := o.DefaultValueData.ValueStringPointer()
	negate_value := o.Negate.ValueBoolPointer()
	var registryValue_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject
	var registryValue_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue
	{
		d := o.RegistryValue.ElementsAs(ctx, &registryValue_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryValue_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryValue_pango_entries = append(registryValue_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).DefaultValueData = defaultValueData_value
	(*obj).Negate = negate_value
	(*obj).RegistryValue = registryValue_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	valueData_value := o.ValueData.ValueStringPointer()
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ValueData = valueData_value
	(*obj).Negate = negate_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	negate_value := o.Negate.ValueBoolPointer()
	var key_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject
	var key_pango_entries []portal.ClientConfigConfigsCustomChecksCriteriaPlistKey
	{
		d := o.Key.ElementsAs(ctx, &key_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range key_tf_entries {
			var entry *portal.ClientConfigConfigsCustomChecksCriteriaPlistKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			key_pango_entries = append(key_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaPlist)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Negate = negate_value
	(*obj).Key = key_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsCustomChecksCriteriaPlistKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsCustomChecksCriteriaPlistKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value
	(*obj).Negate = negate_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var internal_entry *portal.ClientConfigConfigsGatewaysInternal
	if !o.Internal.IsUnknown() && !o.Internal.IsNull() {
		if *obj != nil && (*obj).Internal != nil {
			internal_entry = (*obj).Internal
		} else {
			internal_entry = new(portal.ClientConfigConfigsGatewaysInternal)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject
		diags.Append(o.Internal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &internal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var external_entry *portal.ClientConfigConfigsGatewaysExternal
	if !o.External.IsUnknown() && !o.External.IsNull() {
		if *obj != nil && (*obj).External != nil {
			external_entry = (*obj).External
		} else {
			external_entry = new(portal.ClientConfigConfigsGatewaysExternal)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject
		diags.Append(o.External.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &external_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGateways)
	}
	(*obj).Internal = internal_entry
	(*obj).External = external_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysInternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject
	var list_pango_entries []portal.ClientConfigConfigsGatewaysInternalList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *portal.ClientConfigConfigsGatewaysInternalList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}
	var dhcpOptionCode_pango_entries []int64
	if !o.DhcpOptionCode.IsUnknown() && !o.DhcpOptionCode.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.DhcpOptionCode.Elements()))
		diags.Append(o.DhcpOptionCode.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			dhcpOptionCode_pango_entries = append(dhcpOptionCode_pango_entries, elt.ValueInt64())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysInternal)
	}
	(*obj).List = list_pango_entries
	(*obj).DhcpOptionCode = dhcpOptionCode_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysInternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceIp_pango_entries []string
	if !o.SourceIp.IsUnknown() && !o.SourceIp.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceIp.Elements()))
		diags.Append(o.SourceIp.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceIp_pango_entries = append(sourceIp_pango_entries, elt.ValueString())
		}
	}
	fqdn_value := o.Fqdn.ValueStringPointer()
	var ip_entry *portal.ClientConfigConfigsGatewaysInternalListIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.ClientConfigConfigsGatewaysInternalListIp)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysInternalList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SourceIp = sourceIp_pango_entries
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysInternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysInternalListIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	cutoffTime_value := o.CutoffTime.ValueInt64Pointer()
	var list_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject
	var list_pango_entries []portal.ClientConfigConfigsGatewaysExternalList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *portal.ClientConfigConfigsGatewaysExternalList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternal)
	}
	(*obj).CutoffTime = cutoffTime_value
	(*obj).List = list_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var priorityRule_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject
	var priorityRule_pango_entries []portal.ClientConfigConfigsGatewaysExternalListPriorityRule
	{
		d := o.PriorityRule.ElementsAs(ctx, &priorityRule_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range priorityRule_tf_entries {
			var entry *portal.ClientConfigConfigsGatewaysExternalListPriorityRule
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			priorityRule_pango_entries = append(priorityRule_pango_entries, *entry)
		}
	}
	manual_value := o.Manual.ValueBoolPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	var ip_entry *portal.ClientConfigConfigsGatewaysExternalListIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.ClientConfigConfigsGatewaysExternalListIp)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternalList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).PriorityRule = priorityRule_pango_entries
	(*obj).Manual = manual_value
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternalListPriorityRule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternalListPriorityRule)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGatewaysExternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGatewaysExternalListIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsInternalHostDetection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsInternalHostDetection)
	}
	(*obj).IpAddress = ipAddress_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsInternalHostDetectionV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsInternalHostDetectionV6)
	}
	(*obj).IpAddress = ipAddress_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAgentUi, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passcode_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "passcode")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.Passcode.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		passcode_value = o.Passcode.ValueStringPointer()
	}

	var uninstallPassword_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "uninstall-password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.UninstallPassword.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		uninstallPassword_value = o.UninstallPassword.ValueStringPointer()
	}
	agentUserOverrideTimeout_value := o.AgentUserOverrideTimeout.ValueInt64Pointer()
	maxAgentUserOverrides_value := o.MaxAgentUserOverrides.ValueInt64Pointer()
	var welcomePage_entry *portal.ClientConfigConfigsAgentUiWelcomePage
	if !o.WelcomePage.IsUnknown() && !o.WelcomePage.IsNull() {
		if *obj != nil && (*obj).WelcomePage != nil {
			welcomePage_entry = (*obj).WelcomePage
		} else {
			welcomePage_entry = new(portal.ClientConfigConfigsAgentUiWelcomePage)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject
		diags.Append(o.WelcomePage.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &welcomePage_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAgentUi)
	}
	(*obj).Passcode = passcode_value
	(*obj).UninstallPassword = uninstallPassword_value
	(*obj).AgentUserOverrideTimeout = agentUserOverrideTimeout_value
	(*obj).MaxAgentUserOverrides = maxAgentUserOverrides_value
	(*obj).WelcomePage = welcomePage_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAgentUiWelcomePage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	page_value := o.Page.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAgentUiWelcomePage)
	}
	(*obj).Page = page_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	maxWaitTime_value := o.MaxWaitTime.ValueInt64Pointer()
	collectHipData_value := o.CollectHipData.ValueBoolPointer()
	var exclusion_entry *portal.ClientConfigConfigsHipCollectionExclusion
	if !o.Exclusion.IsUnknown() && !o.Exclusion.IsNull() {
		if *obj != nil && (*obj).Exclusion != nil {
			exclusion_entry = (*obj).Exclusion
		} else {
			exclusion_entry = new(portal.ClientConfigConfigsHipCollectionExclusion)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject
		diags.Append(o.Exclusion.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &exclusion_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var customChecks_entry *portal.ClientConfigConfigsHipCollectionCustomChecks
	if !o.CustomChecks.IsUnknown() && !o.CustomChecks.IsNull() {
		if *obj != nil && (*obj).CustomChecks != nil {
			customChecks_entry = (*obj).CustomChecks
		} else {
			customChecks_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecks)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject
		diags.Append(o.CustomChecks.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &customChecks_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollection)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).MaxWaitTime = maxWaitTime_value
	(*obj).CollectHipData = collectHipData_value
	(*obj).Exclusion = exclusion_entry
	(*obj).CustomChecks = customChecks_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionExclusion, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var category_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject
	var category_pango_entries []portal.ClientConfigConfigsHipCollectionExclusionCategory
	{
		d := o.Category.ElementsAs(ctx, &category_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range category_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionExclusionCategory
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			category_pango_entries = append(category_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionExclusion)
	}
	(*obj).Category = category_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionExclusionCategory, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vendor_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject
	var vendor_pango_entries []portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor
	{
		d := o.Vendor.ElementsAs(ctx, &vendor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vendor_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			vendor_pango_entries = append(vendor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionExclusionCategory)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vendor = vendor_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var product_pango_entries []string
	if !o.Product.IsUnknown() && !o.Product.IsNull() {
		object_entries := make([]types.String, 0, len(o.Product.Elements()))
		diags.Append(o.Product.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			product_pango_entries = append(product_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Product = product_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var windows_entry *portal.ClientConfigConfigsHipCollectionCustomChecksWindows
	if !o.Windows.IsUnknown() && !o.Windows.IsNull() {
		if *obj != nil && (*obj).Windows != nil {
			windows_entry = (*obj).Windows
		} else {
			windows_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecksWindows)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject
		diags.Append(o.Windows.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &windows_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var macOs_entry *portal.ClientConfigConfigsHipCollectionCustomChecksMacOs
	if !o.MacOs.IsUnknown() && !o.MacOs.IsNull() {
		if *obj != nil && (*obj).MacOs != nil {
			macOs_entry = (*obj).MacOs
		} else {
			macOs_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecksMacOs)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject
		diags.Append(o.MacOs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &macOs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var linux_entry *portal.ClientConfigConfigsHipCollectionCustomChecksLinux
	if !o.Linux.IsUnknown() && !o.Linux.IsNull() {
		if *obj != nil && (*obj).Linux != nil {
			linux_entry = (*obj).Linux
		} else {
			linux_entry = new(portal.ClientConfigConfigsHipCollectionCustomChecksLinux)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject
		diags.Append(o.Linux.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linux_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecks)
	}
	(*obj).Windows = windows_entry
	(*obj).MacOs = macOs_entry
	(*obj).Linux = linux_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject
	var registryKey_pango_entries []portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey
	{
		d := o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryKey_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryKey_pango_entries = append(registryKey_pango_entries, *entry)
		}
	}
	var processList_pango_entries []string
	if !o.ProcessList.IsUnknown() && !o.ProcessList.IsNull() {
		object_entries := make([]types.String, 0, len(o.ProcessList.Elements()))
		diags.Append(o.ProcessList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			processList_pango_entries = append(processList_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksWindows)
	}
	(*obj).RegistryKey = registryKey_pango_entries
	(*obj).ProcessList = processList_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_pango_entries []string
	if !o.RegistryValue.IsUnknown() && !o.RegistryValue.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegistryValue.Elements()))
		diags.Append(o.RegistryValue.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			registryValue_pango_entries = append(registryValue_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).RegistryValue = registryValue_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject
	var plist_pango_entries []portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist
	{
		d := o.Plist.ElementsAs(ctx, &plist_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range plist_tf_entries {
			var entry *portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			plist_pango_entries = append(plist_pango_entries, *entry)
		}
	}
	var processList_pango_entries []string
	if !o.ProcessList.IsUnknown() && !o.ProcessList.IsNull() {
		object_entries := make([]types.String, 0, len(o.ProcessList.Elements()))
		diags.Append(o.ProcessList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			processList_pango_entries = append(processList_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksMacOs)
	}
	(*obj).Plist = plist_pango_entries
	(*obj).ProcessList = processList_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_pango_entries []string
	if !o.Key.IsUnknown() && !o.Key.IsNull() {
		object_entries := make([]types.String, 0, len(o.Key.Elements()))
		diags.Append(o.Key.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			key_pango_entries = append(key_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsHipCollectionCustomChecksLinux, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var processList_pango_entries []string
	if !o.ProcessList.IsUnknown() && !o.ProcessList.IsNull() {
		object_entries := make([]types.String, 0, len(o.ProcessList.Elements()))
		diags.Append(o.ProcessList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			processList_pango_entries = append(processList_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsHipCollectionCustomChecksLinux)
	}
	(*obj).ProcessList = processList_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAgentConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAgentConfig)
	}

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGpAppConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var config_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject
	var config_pango_entries []portal.ClientConfigConfigsGpAppConfigConfig
	{
		d := o.Config.ElementsAs(ctx, &config_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range config_tf_entries {
			var entry *portal.ClientConfigConfigsGpAppConfigConfig
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			config_pango_entries = append(config_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGpAppConfig)
	}
	(*obj).Config = config_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsGpAppConfigConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var value_pango_entries []string
	if !o.Value.IsUnknown() && !o.Value.IsNull() {
		object_entries := make([]types.String, 0, len(o.Value.Elements()))
		diags.Append(o.Value.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			value_pango_entries = append(value_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsGpAppConfigConfig)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	generateCookie_value := o.GenerateCookie.ValueBoolPointer()
	cookieEncryptDecryptCert_value := o.CookieEncryptDecryptCert.ValueStringPointer()
	var acceptCookie_entry *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie
	if !o.AcceptCookie.IsUnknown() && !o.AcceptCookie.IsNull() {
		if *obj != nil && (*obj).AcceptCookie != nil {
			acceptCookie_entry = (*obj).AcceptCookie
		} else {
			acceptCookie_entry = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject
		diags.Append(o.AcceptCookie.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &acceptCookie_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAuthenticationOverride)
	}
	(*obj).GenerateCookie = generateCookie_value
	(*obj).CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	(*obj).AcceptCookie = acceptCookie_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var cookieLifetime_entry *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime
	if !o.CookieLifetime.IsUnknown() && !o.CookieLifetime.IsNull() {
		if *obj != nil && (*obj).CookieLifetime != nil {
			cookieLifetime_entry = (*obj).CookieLifetime
		} else {
			cookieLifetime_entry = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
		diags.Append(o.CookieLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &cookieLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie)
	}
	(*obj).CookieLifetime = cookieLifetime_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetimeInDays_value := o.LifetimeInDays.ValueInt64Pointer()
	lifetimeInHours_value := o.LifetimeInHours.ValueInt64Pointer()
	lifetimeInMinutes_value := o.LifetimeInMinutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
	}
	(*obj).LifetimeInDays = lifetimeInDays_value
	(*obj).LifetimeInHours = lifetimeInHours_value
	(*obj).LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsMachineAccountExistsWithSerialno, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes)
		}
		var object *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialno)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo)
	}

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes)
	}

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigConfigsClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	scep_value := o.Scep.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigConfigsClientCertificate)
	}
	(*obj).Local = local_value
	(*obj).Scep = scep_value

	return diags
}
func (o *GlobalprotectPortalResourceClientConfigRootCaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientConfigRootCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	installInCertStore_value := o.InstallInCertStore.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientConfigRootCa)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).InstallInCertStore = installInCertStore_value

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var appsToUserMapping_tf_entries []GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject
	var appsToUserMapping_pango_entries []portal.ClientlessVpnAppsToUserMapping
	{
		d := o.AppsToUserMapping.ElementsAs(ctx, &appsToUserMapping_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range appsToUserMapping_tf_entries {
			var entry *portal.ClientlessVpnAppsToUserMapping
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			appsToUserMapping_pango_entries = append(appsToUserMapping_pango_entries, *entry)
		}
	}
	var cryptoSettings_entry *portal.ClientlessVpnCryptoSettings
	if !o.CryptoSettings.IsUnknown() && !o.CryptoSettings.IsNull() {
		if *obj != nil && (*obj).CryptoSettings != nil {
			cryptoSettings_entry = (*obj).CryptoSettings
		} else {
			cryptoSettings_entry = new(portal.ClientlessVpnCryptoSettings)
		}
		var object *GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject
		diags.Append(o.CryptoSettings.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &cryptoSettings_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	dnsProxy_value := o.DnsProxy.ValueStringPointer()
	hostname_value := o.Hostname.ValueStringPointer()
	var inactivityLogout_entry *portal.ClientlessVpnInactivityLogout
	if !o.InactivityLogout.IsUnknown() && !o.InactivityLogout.IsNull() {
		if *obj != nil && (*obj).InactivityLogout != nil {
			inactivityLogout_entry = (*obj).InactivityLogout
		} else {
			inactivityLogout_entry = new(portal.ClientlessVpnInactivityLogout)
		}
		var object *GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject
		diags.Append(o.InactivityLogout.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &inactivityLogout_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var loginLifetime_entry *portal.ClientlessVpnLoginLifetime
	if !o.LoginLifetime.IsUnknown() && !o.LoginLifetime.IsNull() {
		if *obj != nil && (*obj).LoginLifetime != nil {
			loginLifetime_entry = (*obj).LoginLifetime
		} else {
			loginLifetime_entry = new(portal.ClientlessVpnLoginLifetime)
		}
		var object *GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject
		diags.Append(o.LoginLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &loginLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxUser_value := o.MaxUser.ValueInt64Pointer()
	var proxyServerSetting_tf_entries []GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject
	var proxyServerSetting_pango_entries []portal.ClientlessVpnProxyServerSetting
	{
		d := o.ProxyServerSetting.ElementsAs(ctx, &proxyServerSetting_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyServerSetting_tf_entries {
			var entry *portal.ClientlessVpnProxyServerSetting
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			proxyServerSetting_pango_entries = append(proxyServerSetting_pango_entries, *entry)
		}
	}
	var rewriteExcludeDomainList_pango_entries []string
	if !o.RewriteExcludeDomainList.IsUnknown() && !o.RewriteExcludeDomainList.IsNull() {
		object_entries := make([]types.String, 0, len(o.RewriteExcludeDomainList.Elements()))
		diags.Append(o.RewriteExcludeDomainList.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			rewriteExcludeDomainList_pango_entries = append(rewriteExcludeDomainList_pango_entries, elt.ValueString())
		}
	}
	securityZone_value := o.SecurityZone.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpn)
	}
	(*obj).AppsToUserMapping = appsToUserMapping_pango_entries
	(*obj).CryptoSettings = cryptoSettings_entry
	(*obj).DnsProxy = dnsProxy_value
	(*obj).Hostname = hostname_value
	(*obj).InactivityLogout = inactivityLogout_entry
	(*obj).LoginLifetime = loginLifetime_entry
	(*obj).MaxUser = maxUser_value
	(*obj).ProxyServerSetting = proxyServerSetting_pango_entries
	(*obj).RewriteExcludeDomainList = rewriteExcludeDomainList_pango_entries
	(*obj).SecurityZone = securityZone_value

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnAppsToUserMapping, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var applications_pango_entries []string
	if !o.Applications.IsUnknown() && !o.Applications.IsNull() {
		object_entries := make([]types.String, 0, len(o.Applications.Elements()))
		diags.Append(o.Applications.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			applications_pango_entries = append(applications_pango_entries, elt.ValueString())
		}
	}
	enableCustomAppURLAddressBar_value := o.EnableCustomAppURLAddressBar.ValueBoolPointer()
	displayGlobalProtectAgentDownloadLink_value := o.DisplayGlobalProtectAgentDownloadLink.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnAppsToUserMapping)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).Applications = applications_pango_entries
	(*obj).EnableCustomAppURLAddressBar = enableCustomAppURLAddressBar_value
	(*obj).DisplayGlobalProtectAgentDownloadLink = displayGlobalProtectAgentDownloadLink_value

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnCryptoSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var serverCertVerification_entry *portal.ClientlessVpnCryptoSettingsServerCertVerification
	if !o.ServerCertVerification.IsUnknown() && !o.ServerCertVerification.IsNull() {
		if *obj != nil && (*obj).ServerCertVerification != nil {
			serverCertVerification_entry = (*obj).ServerCertVerification
		} else {
			serverCertVerification_entry = new(portal.ClientlessVpnCryptoSettingsServerCertVerification)
		}
		var object *GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject
		diags.Append(o.ServerCertVerification.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &serverCertVerification_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sslProtocol_entry *portal.ClientlessVpnCryptoSettingsSslProtocol
	if !o.SslProtocol.IsUnknown() && !o.SslProtocol.IsNull() {
		if *obj != nil && (*obj).SslProtocol != nil {
			sslProtocol_entry = (*obj).SslProtocol
		} else {
			sslProtocol_entry = new(portal.ClientlessVpnCryptoSettingsSslProtocol)
		}
		var object *GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject
		diags.Append(o.SslProtocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sslProtocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnCryptoSettings)
	}
	(*obj).ServerCertVerification = serverCertVerification_entry
	(*obj).SslProtocol = sslProtocol_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnCryptoSettingsServerCertVerification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	blockExpiredCertificate_value := o.BlockExpiredCertificate.ValueBoolPointer()
	blockTimeoutCert_value := o.BlockTimeoutCert.ValueBoolPointer()
	blockUnknownCert_value := o.BlockUnknownCert.ValueBoolPointer()
	blockUntrustedIssuer_value := o.BlockUntrustedIssuer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnCryptoSettingsServerCertVerification)
	}
	(*obj).BlockExpiredCertificate = blockExpiredCertificate_value
	(*obj).BlockTimeoutCert = blockTimeoutCert_value
	(*obj).BlockUnknownCert = blockUnknownCert_value
	(*obj).BlockUntrustedIssuer = blockUntrustedIssuer_value

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnCryptoSettingsSslProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authAlgoMd5_value := o.AuthAlgoMd5.ValueBoolPointer()
	authAlgoSha1_value := o.AuthAlgoSha1.ValueBoolPointer()
	authAlgoSha256_value := o.AuthAlgoSha256.ValueBoolPointer()
	authAlgoSha384_value := o.AuthAlgoSha384.ValueBoolPointer()
	encAlgo3des_value := o.EncAlgo3des.ValueBoolPointer()
	encAlgoAes128Cbc_value := o.EncAlgoAes128Cbc.ValueBoolPointer()
	encAlgoAes128Gcm_value := o.EncAlgoAes128Gcm.ValueBoolPointer()
	encAlgoAes256Cbc_value := o.EncAlgoAes256Cbc.ValueBoolPointer()
	encAlgoAes256Gcm_value := o.EncAlgoAes256Gcm.ValueBoolPointer()
	encAlgoRc4_value := o.EncAlgoRc4.ValueBoolPointer()
	keyxchgAlgoDhe_value := o.KeyxchgAlgoDhe.ValueBoolPointer()
	keyxchgAlgoEcdhe_value := o.KeyxchgAlgoEcdhe.ValueBoolPointer()
	keyxchgAlgoRsa_value := o.KeyxchgAlgoRsa.ValueBoolPointer()
	maxVersion_value := o.MaxVersion.ValueStringPointer()
	minVersion_value := o.MinVersion.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnCryptoSettingsSslProtocol)
	}
	(*obj).AuthAlgoMd5 = authAlgoMd5_value
	(*obj).AuthAlgoSha1 = authAlgoSha1_value
	(*obj).AuthAlgoSha256 = authAlgoSha256_value
	(*obj).AuthAlgoSha384 = authAlgoSha384_value
	(*obj).EncAlgo3des = encAlgo3des_value
	(*obj).EncAlgoAes128Cbc = encAlgoAes128Cbc_value
	(*obj).EncAlgoAes128Gcm = encAlgoAes128Gcm_value
	(*obj).EncAlgoAes256Cbc = encAlgoAes256Cbc_value
	(*obj).EncAlgoAes256Gcm = encAlgoAes256Gcm_value
	(*obj).EncAlgoRc4 = encAlgoRc4_value
	(*obj).KeyxchgAlgoDhe = keyxchgAlgoDhe_value
	(*obj).KeyxchgAlgoEcdhe = keyxchgAlgoEcdhe_value
	(*obj).KeyxchgAlgoRsa = keyxchgAlgoRsa_value
	(*obj).MaxVersion = maxVersion_value
	(*obj).MinVersion = minVersion_value

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnInactivityLogout, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hours_value := o.Hours.ValueInt64Pointer()
	minutes_value := o.Minutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnInactivityLogout)
	}
	(*obj).Hours = hours_value
	(*obj).Minutes = minutes_value

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hours_value := o.Hours.ValueInt64Pointer()
	minutes_value := o.Minutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnLoginLifetime)
	}
	(*obj).Hours = hours_value
	(*obj).Minutes = minutes_value

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnProxyServerSetting, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var domains_pango_entries []string
	if !o.Domains.IsUnknown() && !o.Domains.IsNull() {
		object_entries := make([]types.String, 0, len(o.Domains.Elements()))
		diags.Append(o.Domains.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			domains_pango_entries = append(domains_pango_entries, elt.ValueString())
		}
	}
	useProxy_value := o.UseProxy.ValueBoolPointer()
	var proxyServer_entry *portal.ClientlessVpnProxyServerSettingProxyServer
	if !o.ProxyServer.IsUnknown() && !o.ProxyServer.IsNull() {
		if *obj != nil && (*obj).ProxyServer != nil {
			proxyServer_entry = (*obj).ProxyServer
		} else {
			proxyServer_entry = new(portal.ClientlessVpnProxyServerSettingProxyServer)
		}
		var object *GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject
		diags.Append(o.ProxyServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &proxyServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnProxyServerSetting)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Domains = domains_pango_entries
	(*obj).UseProxy = useProxy_value
	(*obj).ProxyServer = proxyServer_entry

	return diags
}
func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.ClientlessVpnProxyServerSettingProxyServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	server_value := o.Server.ValueStringPointer()
	port_value := o.Port.ValueInt64Pointer()
	user_value := o.User.ValueStringPointer()

	var password_value *string
	{
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}
		err = ev.StorePlaintextValue(valueKey, "solo", o.Password.ValueString())
		if err != nil {
			diags.AddError("Failed to manage encrypted values state", err.Error())
			return diags
		}
		password_value = o.Password.ValueStringPointer()
	}

	if (*obj) == nil {
		*obj = new(portal.ClientlessVpnProxyServerSettingProxyServer)
	}
	(*obj).Server = server_value
	(*obj).Port = port_value
	(*obj).User = user_value
	(*obj).Password = password_value

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var clientAuth_tf_entries []GlobalprotectPortalResourcePortalConfigClientAuthObject
	var clientAuth_pango_entries []portal.PortalConfigClientAuth
	{
		d := o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range clientAuth_tf_entries {
			var entry *portal.PortalConfigClientAuth
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			clientAuth_pango_entries = append(clientAuth_pango_entries, *entry)
		}
	}
	var configSelection_entry *portal.PortalConfigConfigSelection
	if !o.ConfigSelection.IsUnknown() && !o.ConfigSelection.IsNull() {
		if *obj != nil && (*obj).ConfigSelection != nil {
			configSelection_entry = (*obj).ConfigSelection
		} else {
			configSelection_entry = new(portal.PortalConfigConfigSelection)
		}
		var object *GlobalprotectPortalResourcePortalConfigConfigSelectionObject
		diags.Append(o.ConfigSelection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &configSelection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	customHelpPage_value := o.CustomHelpPage.ValueStringPointer()
	customHomePage_value := o.CustomHomePage.ValueStringPointer()
	customLoginPage_value := o.CustomLoginPage.ValueStringPointer()
	var localAddress_entry *portal.PortalConfigLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(portal.PortalConfigLocalAddress)
		}
		var object *GlobalprotectPortalResourcePortalConfigLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	logFail_value := o.LogFail.ValueBoolPointer()
	logSetting_value := o.LogSetting.ValueStringPointer()
	logSuccess_value := o.LogSuccess.ValueBoolPointer()
	sslTlsServiceProfile_value := o.SslTlsServiceProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfig)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).ClientAuth = clientAuth_pango_entries
	(*obj).ConfigSelection = configSelection_entry
	(*obj).CustomHelpPage = customHelpPage_value
	(*obj).CustomHomePage = customHomePage_value
	(*obj).CustomLoginPage = customLoginPage_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).LogFail = logFail_value
	(*obj).LogSetting = logSetting_value
	(*obj).LogSuccess = logSuccess_value
	(*obj).SslTlsServiceProfile = sslTlsServiceProfile_value

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigClientAuthObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	os_value := o.Os.ValueStringPointer()
	authenticationProfile_value := o.AuthenticationProfile.ValueStringPointer()
	autoRetrievePasscode_value := o.AutoRetrievePasscode.ValueBoolPointer()
	usernameLabel_value := o.UsernameLabel.ValueStringPointer()
	passwordLabel_value := o.PasswordLabel.ValueStringPointer()
	authenticationMessage_value := o.AuthenticationMessage.ValueStringPointer()
	userCredentialOrClientCertRequired_value := o.UserCredentialOrClientCertRequired.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfigClientAuth)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Os = os_value
	(*obj).AuthenticationProfile = authenticationProfile_value
	(*obj).AutoRetrievePasscode = autoRetrievePasscode_value
	(*obj).UsernameLabel = usernameLabel_value
	(*obj).PasswordLabel = passwordLabel_value
	(*obj).AuthenticationMessage = authenticationMessage_value
	(*obj).UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var customChecks_entry *portal.PortalConfigConfigSelectionCustomChecks
	if !o.CustomChecks.IsUnknown() && !o.CustomChecks.IsNull() {
		if *obj != nil && (*obj).CustomChecks != nil {
			customChecks_entry = (*obj).CustomChecks
		} else {
			customChecks_entry = new(portal.PortalConfigConfigSelectionCustomChecks)
		}
		var object *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject
		diags.Append(o.CustomChecks.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &customChecks_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelection)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).CustomChecks = customChecks_entry

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var macOs_entry *portal.PortalConfigConfigSelectionCustomChecksMacOs
	if !o.MacOs.IsUnknown() && !o.MacOs.IsNull() {
		if *obj != nil && (*obj).MacOs != nil {
			macOs_entry = (*obj).MacOs
		} else {
			macOs_entry = new(portal.PortalConfigConfigSelectionCustomChecksMacOs)
		}
		var object *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject
		diags.Append(o.MacOs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &macOs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var windows_entry *portal.PortalConfigConfigSelectionCustomChecksWindows
	if !o.Windows.IsUnknown() && !o.Windows.IsNull() {
		if *obj != nil && (*obj).Windows != nil {
			windows_entry = (*obj).Windows
		} else {
			windows_entry = new(portal.PortalConfigConfigSelectionCustomChecksWindows)
		}
		var object *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject
		diags.Append(o.Windows.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &windows_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecks)
	}
	(*obj).MacOs = macOs_entry
	(*obj).Windows = windows_entry

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_tf_entries []GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject
	var plist_pango_entries []portal.PortalConfigConfigSelectionCustomChecksMacOsPlist
	{
		d := o.Plist.ElementsAs(ctx, &plist_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range plist_tf_entries {
			var entry *portal.PortalConfigConfigSelectionCustomChecksMacOsPlist
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			plist_pango_entries = append(plist_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksMacOs)
	}
	(*obj).Plist = plist_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_pango_entries []string
	if !o.Key.IsUnknown() && !o.Key.IsNull() {
		object_entries := make([]types.String, 0, len(o.Key.Elements()))
		diags.Append(o.Key.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			key_pango_entries = append(key_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksMacOsPlist)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_tf_entries []GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject
	var registryKey_pango_entries []portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey
	{
		d := o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range registryKey_tf_entries {
			var entry *portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			registryKey_pango_entries = append(registryKey_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksWindows)
	}
	(*obj).RegistryKey = registryKey_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_pango_entries []string
	if !o.RegistryValue.IsUnknown() && !o.RegistryValue.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegistryValue.Elements()))
		diags.Append(o.RegistryValue.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			registryValue_pango_entries = append(registryValue_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).RegistryValue = registryValue_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ipAddressFamily_value := o.IpAddressFamily.ValueStringPointer()
	var floatingIp_entry *portal.PortalConfigLocalAddressFloatingIp
	if !o.FloatingIp.IsUnknown() && !o.FloatingIp.IsNull() {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(portal.PortalConfigLocalAddressFloatingIp)
		}
		var object *GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject
		diags.Append(o.FloatingIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &floatingIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *portal.PortalConfigLocalAddressIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.PortalConfigLocalAddressIp)
		}
		var object *GlobalprotectPortalResourcePortalConfigLocalAddressIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.PortalConfigLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).IpAddressFamily = ipAddressFamily_value
	(*obj).FloatingIp = floatingIp_entry
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfigLocalAddressFloatingIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalResourcePortalConfigLocalAddressIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.PortalConfigLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.PortalConfigLocalAddressIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectPortalResourceSatelliteConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientCertificate_entry *portal.SatelliteConfigClientCertificate
	if !o.ClientCertificate.IsUnknown() && !o.ClientCertificate.IsNull() {
		if *obj != nil && (*obj).ClientCertificate != nil {
			clientCertificate_entry = (*obj).ClientCertificate
		} else {
			clientCertificate_entry = new(portal.SatelliteConfigClientCertificate)
		}
		var object *GlobalprotectPortalResourceSatelliteConfigClientCertificateObject
		diags.Append(o.ClientCertificate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &clientCertificate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var configs_tf_entries []GlobalprotectPortalResourceSatelliteConfigConfigsObject
	var configs_pango_entries []portal.SatelliteConfigConfigs
	{
		d := o.Configs.ElementsAs(ctx, &configs_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range configs_tf_entries {
			var entry *portal.SatelliteConfigConfigs
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			configs_pango_entries = append(configs_pango_entries, *entry)
		}
	}
	var rootCa_pango_entries []string
	if !o.RootCa.IsUnknown() && !o.RootCa.IsNull() {
		object_entries := make([]types.String, 0, len(o.RootCa.Elements()))
		diags.Append(o.RootCa.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			rootCa_pango_entries = append(rootCa_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfig)
	}
	(*obj).ClientCertificate = clientCertificate_entry
	(*obj).Configs = configs_pango_entries
	(*obj).RootCa = rootCa_pango_entries

	return diags
}
func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var local_entry *portal.SatelliteConfigClientCertificateLocal
	if !o.Local.IsUnknown() && !o.Local.IsNull() {
		if *obj != nil && (*obj).Local != nil {
			local_entry = (*obj).Local
		} else {
			local_entry = new(portal.SatelliteConfigClientCertificateLocal)
		}
		var object *GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject
		diags.Append(o.Local.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &local_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var scep_entry *portal.SatelliteConfigClientCertificateScep
	if !o.Scep.IsUnknown() && !o.Scep.IsNull() {
		if *obj != nil && (*obj).Scep != nil {
			scep_entry = (*obj).Scep
		} else {
			scep_entry = new(portal.SatelliteConfigClientCertificateScep)
		}
		var object *GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject
		diags.Append(o.Scep.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &scep_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigClientCertificate)
	}
	(*obj).Local = local_entry
	(*obj).Scep = scep_entry

	return diags
}
func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigClientCertificateLocal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateLifeTime_value := o.CertificateLifeTime.ValueInt64Pointer()
	certificateRenewalPeriod_value := o.CertificateRenewalPeriod.ValueInt64Pointer()
	issuingCertificate_value := o.IssuingCertificate.ValueStringPointer()
	ocspResponder_value := o.OcspResponder.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigClientCertificateLocal)
	}
	(*obj).CertificateLifeTime = certificateLifeTime_value
	(*obj).CertificateRenewalPeriod = certificateRenewalPeriod_value
	(*obj).IssuingCertificate = issuingCertificate_value
	(*obj).OcspResponder = ocspResponder_value

	return diags
}
func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigClientCertificateScep, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateRenewalPeriod_value := o.CertificateRenewalPeriod.ValueInt64Pointer()
	scep_value := o.Scep.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigClientCertificateScep)
	}
	(*obj).CertificateRenewalPeriod = certificateRenewalPeriod_value
	(*obj).Scep = scep_value

	return diags
}
func (o *GlobalprotectPortalResourceSatelliteConfigConfigsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_pango_entries []string
	if !o.Devices.IsUnknown() && !o.Devices.IsNull() {
		object_entries := make([]types.String, 0, len(o.Devices.Elements()))
		diags.Append(o.Devices.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			devices_pango_entries = append(devices_pango_entries, elt.ValueString())
		}
	}
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var gateways_tf_entries []GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject
	var gateways_pango_entries []portal.SatelliteConfigConfigsGateways
	{
		d := o.Gateways.ElementsAs(ctx, &gateways_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range gateways_tf_entries {
			var entry *portal.SatelliteConfigConfigsGateways
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			gateways_pango_entries = append(gateways_pango_entries, *entry)
		}
	}
	configRefreshInterval_value := o.ConfigRefreshInterval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigConfigs)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Devices = devices_pango_entries
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).Gateways = gateways_pango_entries
	(*obj).ConfigRefreshInterval = configRefreshInterval_value

	return diags
}
func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv6Preferred_value := o.Ipv6Preferred.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	var ip_entry *portal.SatelliteConfigConfigsGatewaysIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(portal.SatelliteConfigConfigsGatewaysIp)
		}
		var object *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigConfigsGateways)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ipv6Preferred = ipv6Preferred_value
	(*obj).Priority = priority_value
	(*obj).Fqdn = fqdn_value
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **portal.SatelliteConfigConfigsGatewaysIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(portal.SatelliteConfigConfigsGatewaysIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var clientConfig_obj *GlobalprotectPortalResourceClientConfigObject
	if o.ClientConfig.IsNull() {
		clientConfig_obj = new(GlobalprotectPortalResourceClientConfigObject)
	} else {
		diags.Append(o.ClientConfig.As(ctx, &clientConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientConfig_object := types.ObjectNull(clientConfig_obj.AttributeTypes())
	if obj.ClientConfig != nil {
		diags.Append(clientConfig_obj.CopyFromPango(ctx, client, ancestors, obj.ClientConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientConfig_object, diags_tmp = types.ObjectValueFrom(ctx, clientConfig_obj.AttributeTypes(), clientConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var clientlessVpn_obj *GlobalprotectPortalResourceClientlessVpnObject
	if o.ClientlessVpn.IsNull() {
		clientlessVpn_obj = new(GlobalprotectPortalResourceClientlessVpnObject)
	} else {
		diags.Append(o.ClientlessVpn.As(ctx, &clientlessVpn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientlessVpn_object := types.ObjectNull(clientlessVpn_obj.AttributeTypes())
	if obj.ClientlessVpn != nil {
		diags.Append(clientlessVpn_obj.CopyFromPango(ctx, client, ancestors, obj.ClientlessVpn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientlessVpn_object, diags_tmp = types.ObjectValueFrom(ctx, clientlessVpn_obj.AttributeTypes(), clientlessVpn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var portalConfig_obj *GlobalprotectPortalResourcePortalConfigObject
	if o.PortalConfig.IsNull() {
		portalConfig_obj = new(GlobalprotectPortalResourcePortalConfigObject)
	} else {
		diags.Append(o.PortalConfig.As(ctx, &portalConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	portalConfig_object := types.ObjectNull(portalConfig_obj.AttributeTypes())
	if obj.PortalConfig != nil {
		diags.Append(portalConfig_obj.CopyFromPango(ctx, client, ancestors, obj.PortalConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		portalConfig_object, diags_tmp = types.ObjectValueFrom(ctx, portalConfig_obj.AttributeTypes(), portalConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var satelliteConfig_obj *GlobalprotectPortalResourceSatelliteConfigObject
	if o.SatelliteConfig.IsNull() {
		satelliteConfig_obj = new(GlobalprotectPortalResourceSatelliteConfigObject)
	} else {
		diags.Append(o.SatelliteConfig.As(ctx, &satelliteConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	satelliteConfig_object := types.ObjectNull(satelliteConfig_obj.AttributeTypes())
	if obj.SatelliteConfig != nil {
		diags.Append(satelliteConfig_obj.CopyFromPango(ctx, client, ancestors, obj.SatelliteConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		satelliteConfig_object, diags_tmp = types.ObjectValueFrom(ctx, satelliteConfig_obj.AttributeTypes(), satelliteConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.ClientConfig = clientConfig_object
	o.ClientlessVpn = clientlessVpn_object
	o.PortalConfig = portalConfig_object
	o.SatelliteConfig = satelliteConfig_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var configs_list types.List
	{
		var configs_tf_entries []GlobalprotectPortalResourceClientConfigConfigsObject
		if !o.Configs.IsNull() {
			diags.Append(o.Configs.ElementsAs(ctx, &configs_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Configs {
			entry := GlobalprotectPortalResourceClientConfigConfigsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(configs_tf_entries) {
				entry = configs_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(configs_tf_entries) {
				configs_tf_entries[idx] = entry
			} else {
				configs_tf_entries = append(configs_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("configs")
		configs_list, list_diags = types.ListValueFrom(ctx, schemaType, configs_tf_entries)
		diags.Append(list_diags...)
	}
	var rootCa_list types.List
	{
		var rootCa_tf_entries []GlobalprotectPortalResourceClientConfigRootCaObject
		if !o.RootCa.IsNull() {
			diags.Append(o.RootCa.ElementsAs(ctx, &rootCa_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RootCa {
			entry := GlobalprotectPortalResourceClientConfigRootCaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rootCa_tf_entries) {
				entry = rootCa_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rootCa_tf_entries) {
				rootCa_tf_entries[idx] = entry
			} else {
				rootCa_tf_entries = append(rootCa_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("root_ca")
		rootCa_list, list_diags = types.ListValueFrom(ctx, schemaType, rootCa_tf_entries)
		diags.Append(list_diags...)
	}

	var agentUserOverrideKey_value types.String
	if obj.AgentUserOverrideKey != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "agent-user-override-key")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.AgentUserOverrideKey != evFromState {
			agentUserOverrideKey_value = types.StringPointerValue(obj.AgentUserOverrideKey)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			agentUserOverrideKey_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.AgentUserOverrideKey)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	o.AgentUserOverrideKey = agentUserOverrideKey_value
	o.Configs = configs_list
	o.RootCa = rootCa_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var thirdPartyVpnClients_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ThirdPartyVpnClients.IsNull() || len(obj.ThirdPartyVpnClients) > 0 {
			entries = obj.ThirdPartyVpnClients
		}

		thirdPartyVpnClients_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var os_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Os.IsNull() || len(obj.Os) > 0 {
			entries = obj.Os
		}

		os_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var certificate_obj *GlobalprotectPortalResourceClientConfigConfigsCertificateObject
	if o.Certificate.IsNull() {
		certificate_obj = new(GlobalprotectPortalResourceClientConfigConfigsCertificateObject)
	} else {
		diags.Append(o.Certificate.As(ctx, &certificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	certificate_object := types.ObjectNull(certificate_obj.AttributeTypes())
	if obj.Certificate != nil {
		diags.Append(certificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Certificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		certificate_object, diags_tmp = types.ObjectValueFrom(ctx, certificate_obj.AttributeTypes(), certificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var customChecks_obj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject
	if o.CustomChecks.IsNull() {
		customChecks_obj = new(GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject)
	} else {
		diags.Append(o.CustomChecks.As(ctx, &customChecks_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	customChecks_object := types.ObjectNull(customChecks_obj.AttributeTypes())
	if obj.CustomChecks != nil {
		diags.Append(customChecks_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CustomChecks, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		customChecks_object, diags_tmp = types.ObjectValueFrom(ctx, customChecks_obj.AttributeTypes(), customChecks_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gateways_obj *GlobalprotectPortalResourceClientConfigConfigsGatewaysObject
	if o.Gateways.IsNull() {
		gateways_obj = new(GlobalprotectPortalResourceClientConfigConfigsGatewaysObject)
	} else {
		diags.Append(o.Gateways.As(ctx, &gateways_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gateways_object := types.ObjectNull(gateways_obj.AttributeTypes())
	if obj.Gateways != nil {
		diags.Append(gateways_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Gateways, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gateways_object, diags_tmp = types.ObjectValueFrom(ctx, gateways_obj.AttributeTypes(), gateways_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var internalHostDetection_obj *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject
	if o.InternalHostDetection.IsNull() {
		internalHostDetection_obj = new(GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject)
	} else {
		diags.Append(o.InternalHostDetection.As(ctx, &internalHostDetection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	internalHostDetection_object := types.ObjectNull(internalHostDetection_obj.AttributeTypes())
	if obj.InternalHostDetection != nil {
		diags.Append(internalHostDetection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InternalHostDetection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		internalHostDetection_object, diags_tmp = types.ObjectValueFrom(ctx, internalHostDetection_obj.AttributeTypes(), internalHostDetection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var internalHostDetectionV6_obj *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object
	if o.InternalHostDetectionV6.IsNull() {
		internalHostDetectionV6_obj = new(GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object)
	} else {
		diags.Append(o.InternalHostDetectionV6.As(ctx, &internalHostDetectionV6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	internalHostDetectionV6_object := types.ObjectNull(internalHostDetectionV6_obj.AttributeTypes())
	if obj.InternalHostDetectionV6 != nil {
		diags.Append(internalHostDetectionV6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InternalHostDetectionV6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		internalHostDetectionV6_object, diags_tmp = types.ObjectValueFrom(ctx, internalHostDetectionV6_obj.AttributeTypes(), internalHostDetectionV6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var agentUi_obj *GlobalprotectPortalResourceClientConfigConfigsAgentUiObject
	if o.AgentUi.IsNull() {
		agentUi_obj = new(GlobalprotectPortalResourceClientConfigConfigsAgentUiObject)
	} else {
		diags.Append(o.AgentUi.As(ctx, &agentUi_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	agentUi_object := types.ObjectNull(agentUi_obj.AttributeTypes())
	if obj.AgentUi != nil {
		diags.Append(agentUi_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AgentUi, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		agentUi_object, diags_tmp = types.ObjectValueFrom(ctx, agentUi_obj.AttributeTypes(), agentUi_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hipCollection_obj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject
	if o.HipCollection.IsNull() {
		hipCollection_obj = new(GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject)
	} else {
		diags.Append(o.HipCollection.As(ctx, &hipCollection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hipCollection_object := types.ObjectNull(hipCollection_obj.AttributeTypes())
	if obj.HipCollection != nil {
		diags.Append(hipCollection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HipCollection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hipCollection_object, diags_tmp = types.ObjectValueFrom(ctx, hipCollection_obj.AttributeTypes(), hipCollection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var agentConfig_obj *GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject
	if o.AgentConfig.IsNull() {
		agentConfig_obj = new(GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject)
	} else {
		diags.Append(o.AgentConfig.As(ctx, &agentConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	agentConfig_object := types.ObjectNull(agentConfig_obj.AttributeTypes())
	if obj.AgentConfig != nil {
		diags.Append(agentConfig_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AgentConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		agentConfig_object, diags_tmp = types.ObjectValueFrom(ctx, agentConfig_obj.AttributeTypes(), agentConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gpAppConfig_obj *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject
	if o.GpAppConfig.IsNull() {
		gpAppConfig_obj = new(GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject)
	} else {
		diags.Append(o.GpAppConfig.As(ctx, &gpAppConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gpAppConfig_object := types.ObjectNull(gpAppConfig_obj.AttributeTypes())
	if obj.GpAppConfig != nil {
		diags.Append(gpAppConfig_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GpAppConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gpAppConfig_object, diags_tmp = types.ObjectValueFrom(ctx, gpAppConfig_obj.AttributeTypes(), gpAppConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authenticationOverride_obj *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject
	if o.AuthenticationOverride.IsNull() {
		authenticationOverride_obj = new(GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject)
	} else {
		diags.Append(o.AuthenticationOverride.As(ctx, &authenticationOverride_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authenticationOverride_object := types.ObjectNull(authenticationOverride_obj.AttributeTypes())
	if obj.AuthenticationOverride != nil {
		diags.Append(authenticationOverride_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AuthenticationOverride, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authenticationOverride_object, diags_tmp = types.ObjectValueFrom(ctx, authenticationOverride_obj.AttributeTypes(), authenticationOverride_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var machineAccountExistsWithSerialno_obj *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject
	if o.MachineAccountExistsWithSerialno.IsNull() {
		machineAccountExistsWithSerialno_obj = new(GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject)
	} else {
		diags.Append(o.MachineAccountExistsWithSerialno.As(ctx, &machineAccountExistsWithSerialno_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	machineAccountExistsWithSerialno_object := types.ObjectNull(machineAccountExistsWithSerialno_obj.AttributeTypes())
	if obj.MachineAccountExistsWithSerialno != nil {
		diags.Append(machineAccountExistsWithSerialno_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MachineAccountExistsWithSerialno, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		machineAccountExistsWithSerialno_object, diags_tmp = types.ObjectValueFrom(ctx, machineAccountExistsWithSerialno_obj.AttributeTypes(), machineAccountExistsWithSerialno_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var clientCertificate_obj *GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject
	if o.ClientCertificate.IsNull() {
		clientCertificate_obj = new(GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject)
	} else {
		diags.Append(o.ClientCertificate.As(ctx, &clientCertificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientCertificate_object := types.ObjectNull(clientCertificate_obj.AttributeTypes())
	if obj.ClientCertificate != nil {
		diags.Append(clientCertificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ClientCertificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientCertificate_object, diags_tmp = types.ObjectValueFrom(ctx, clientCertificate_obj.AttributeTypes(), clientCertificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var saveUserCredentials_value types.String
	if obj.SaveUserCredentials != nil {
		saveUserCredentials_value = types.StringValue(*obj.SaveUserCredentials)
	}
	var portal2fa_value types.Bool
	if obj.Portal2fa != nil {
		portal2fa_value = types.BoolValue(*obj.Portal2fa)
	}
	var internalGateway2fa_value types.Bool
	if obj.InternalGateway2fa != nil {
		internalGateway2fa_value = types.BoolValue(*obj.InternalGateway2fa)
	}
	var autoDiscoveryExternalGateway2fa_value types.Bool
	if obj.AutoDiscoveryExternalGateway2fa != nil {
		autoDiscoveryExternalGateway2fa_value = types.BoolValue(*obj.AutoDiscoveryExternalGateway2fa)
	}
	var manualOnlyGateway2fa_value types.Bool
	if obj.ManualOnlyGateway2fa != nil {
		manualOnlyGateway2fa_value = types.BoolValue(*obj.ManualOnlyGateway2fa)
	}
	var refreshConfig_value types.Bool
	if obj.RefreshConfig != nil {
		refreshConfig_value = types.BoolValue(*obj.RefreshConfig)
	}
	var mdmAddress_value types.String
	if obj.MdmAddress != nil {
		mdmAddress_value = types.StringValue(*obj.MdmAddress)
	}
	var mdmEnrollmentPort_value types.String
	if obj.MdmEnrollmentPort != nil {
		mdmEnrollmentPort_value = types.StringValue(*obj.MdmEnrollmentPort)
	}
	o.Name = types.StringValue(obj.Name)
	o.SaveUserCredentials = saveUserCredentials_value
	o.Portal2fa = portal2fa_value
	o.InternalGateway2fa = internalGateway2fa_value
	o.AutoDiscoveryExternalGateway2fa = autoDiscoveryExternalGateway2fa_value
	o.ManualOnlyGateway2fa = manualOnlyGateway2fa_value
	o.RefreshConfig = refreshConfig_value
	o.MdmAddress = mdmAddress_value
	o.MdmEnrollmentPort = mdmEnrollmentPort_value
	o.SourceUser = sourceUser_list
	o.ThirdPartyVpnClients = thirdPartyVpnClients_list
	o.Os = os_list
	o.Certificate = certificate_object
	o.CustomChecks = customChecks_object
	o.Gateways = gateways_object
	o.InternalHostDetection = internalHostDetection_object
	o.InternalHostDetectionV6 = internalHostDetectionV6_object
	o.AgentUi = agentUi_object
	o.HipCollection = hipCollection_object
	o.AgentConfig = agentConfig_object
	o.GpAppConfig = gpAppConfig_object
	o.AuthenticationOverride = authenticationOverride_object
	o.MachineAccountExistsWithSerialno = machineAccountExistsWithSerialno_object
	o.ClientCertificate = clientCertificate_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var criteria_obj *GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject
	if o.Criteria.IsNull() {
		criteria_obj = new(GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject)
	} else {
		diags.Append(o.Criteria.As(ctx, &criteria_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	criteria_object := types.ObjectNull(criteria_obj.AttributeTypes())
	if obj.Criteria != nil {
		diags.Append(criteria_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Criteria, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		criteria_object, diags_tmp = types.ObjectValueFrom(ctx, criteria_obj.AttributeTypes(), criteria_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Criteria = criteria_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCertificateCriteriaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCertificateCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	o.CertificateProfile = certificateProfile_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var criteria_obj *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject
	if o.Criteria.IsNull() {
		criteria_obj = new(GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject)
	} else {
		diags.Append(o.Criteria.As(ctx, &criteria_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	criteria_object := types.ObjectNull(criteria_obj.AttributeTypes())
	if obj.Criteria != nil {
		diags.Append(criteria_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Criteria, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		criteria_object, diags_tmp = types.ObjectValueFrom(ctx, criteria_obj.AttributeTypes(), criteria_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Criteria = criteria_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteria, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_list types.List
	{
		var registryKey_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject
		if !o.RegistryKey.IsNull() {
			diags.Append(o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryKey {
			entry := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryKey_tf_entries) {
				entry = registryKey_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryKey_tf_entries) {
				registryKey_tf_entries[idx] = entry
			} else {
				registryKey_tf_entries = append(registryKey_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_key")
		registryKey_list, list_diags = types.ListValueFrom(ctx, schemaType, registryKey_tf_entries)
		diags.Append(list_diags...)
	}
	var plist_list types.List
	{
		var plist_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject
		if !o.Plist.IsNull() {
			diags.Append(o.Plist.ElementsAs(ctx, &plist_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Plist {
			entry := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(plist_tf_entries) {
				entry = plist_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(plist_tf_entries) {
				plist_tf_entries[idx] = entry
			} else {
				plist_tf_entries = append(plist_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("plist")
		plist_list, list_diags = types.ListValueFrom(ctx, schemaType, plist_tf_entries)
		diags.Append(list_diags...)
	}

	o.RegistryKey = registryKey_list
	o.Plist = plist_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_list types.List
	{
		var registryValue_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject
		if !o.RegistryValue.IsNull() {
			diags.Append(o.RegistryValue.ElementsAs(ctx, &registryValue_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryValue {
			entry := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryValue_tf_entries) {
				entry = registryValue_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryValue_tf_entries) {
				registryValue_tf_entries[idx] = entry
			} else {
				registryValue_tf_entries = append(registryValue_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_value")
		registryValue_list, list_diags = types.ListValueFrom(ctx, schemaType, registryValue_tf_entries)
		diags.Append(list_diags...)
	}

	var defaultValueData_value types.String
	if obj.DefaultValueData != nil {
		defaultValueData_value = types.StringValue(*obj.DefaultValueData)
	}
	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.DefaultValueData = defaultValueData_value
	o.Negate = negate_value
	o.RegistryValue = registryValue_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValueObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaRegistryKeyRegistryValue, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var valueData_value types.String
	if obj.ValueData != nil {
		valueData_value = types.StringValue(*obj.ValueData)
	}
	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.ValueData = valueData_value
	o.Negate = negate_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_list types.List
	{
		var key_tf_entries []GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject
		if !o.Key.IsNull() {
			diags.Append(o.Key.ElementsAs(ctx, &key_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Key {
			entry := GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(key_tf_entries) {
				entry = key_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(key_tf_entries) {
				key_tf_entries[idx] = entry
			} else {
				key_tf_entries = append(key_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("key")
		key_list, list_diags = types.ListValueFrom(ctx, schemaType, key_tf_entries)
		diags.Append(list_diags...)
	}

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Negate = negate_value
	o.Key = key_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsCustomChecksCriteriaPlistKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsCustomChecksCriteriaPlistKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value
	o.Negate = negate_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var internal_obj *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject
	if o.Internal.IsNull() {
		internal_obj = new(GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject)
	} else {
		diags.Append(o.Internal.As(ctx, &internal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	internal_object := types.ObjectNull(internal_obj.AttributeTypes())
	if obj.Internal != nil {
		diags.Append(internal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Internal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		internal_object, diags_tmp = types.ObjectValueFrom(ctx, internal_obj.AttributeTypes(), internal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var external_obj *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject
	if o.External.IsNull() {
		external_obj = new(GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject)
	} else {
		diags.Append(o.External.As(ctx, &external_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	external_object := types.ObjectNull(external_obj.AttributeTypes())
	if obj.External != nil {
		diags.Append(external_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.External, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		external_object, diags_tmp = types.ObjectValueFrom(ctx, external_obj.AttributeTypes(), external_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Internal = internal_object
	o.External = external_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysInternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}
	var dhcpOptionCode_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.DhcpOptionCode.IsNull() || len(obj.DhcpOptionCode) > 0 {
			entries = obj.DhcpOptionCode
		}

		dhcpOptionCode_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.List = list_list
	o.DhcpOptionCode = dhcpOptionCode_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysInternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceIp_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceIp.IsNull() || len(obj.SourceIp) > 0 {
			entries = obj.SourceIp
		}

		sourceIp_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Name = types.StringValue(obj.Name)
	o.SourceIp = sourceIp_list
	o.Fqdn = fqdn_value
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysInternalListIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysInternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}

	var cutoffTime_value types.Int64
	if obj.CutoffTime != nil {
		cutoffTime_value = types.Int64Value(*obj.CutoffTime)
	}
	o.CutoffTime = cutoffTime_value
	o.List = list_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternalList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var priorityRule_list types.List
	{
		var priorityRule_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject
		if !o.PriorityRule.IsNull() {
			diags.Append(o.PriorityRule.ElementsAs(ctx, &priorityRule_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.PriorityRule {
			entry := GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(priorityRule_tf_entries) {
				entry = priorityRule_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(priorityRule_tf_entries) {
				priorityRule_tf_entries[idx] = entry
			} else {
				priorityRule_tf_entries = append(priorityRule_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("priority_rule")
		priorityRule_list, list_diags = types.ListValueFrom(ctx, schemaType, priorityRule_tf_entries)
		diags.Append(list_diags...)
	}

	var ip_obj *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_value types.Bool
	if obj.Manual != nil {
		manual_value = types.BoolValue(*obj.Manual)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Name = types.StringValue(obj.Name)
	o.PriorityRule = priorityRule_list
	o.Manual = manual_value
	o.Fqdn = fqdn_value
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListPriorityRuleObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternalListPriorityRule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.String
	if obj.Priority != nil {
		priority_value = types.StringValue(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGatewaysExternalListIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGatewaysExternalListIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsInternalHostDetection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.IpAddress = ipAddress_value
	o.Hostname = hostname_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsInternalHostDetectionV6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsInternalHostDetectionV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.IpAddress = ipAddress_value
	o.Hostname = hostname_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAgentUi, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var welcomePage_obj *GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject
	if o.WelcomePage.IsNull() {
		welcomePage_obj = new(GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject)
	} else {
		diags.Append(o.WelcomePage.As(ctx, &welcomePage_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	welcomePage_object := types.ObjectNull(welcomePage_obj.AttributeTypes())
	if obj.WelcomePage != nil {
		diags.Append(welcomePage_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WelcomePage, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		welcomePage_object, diags_tmp = types.ObjectValueFrom(ctx, welcomePage_obj.AttributeTypes(), welcomePage_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var passcode_value types.String
	if obj.Passcode != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "passcode")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.Passcode != evFromState {
			passcode_value = types.StringPointerValue(obj.Passcode)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			passcode_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.Passcode)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	var uninstallPassword_value types.String
	if obj.UninstallPassword != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "uninstall-password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.UninstallPassword != evFromState {
			uninstallPassword_value = types.StringPointerValue(obj.UninstallPassword)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			uninstallPassword_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.UninstallPassword)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	var agentUserOverrideTimeout_value types.Int64
	if obj.AgentUserOverrideTimeout != nil {
		agentUserOverrideTimeout_value = types.Int64Value(*obj.AgentUserOverrideTimeout)
	}
	var maxAgentUserOverrides_value types.Int64
	if obj.MaxAgentUserOverrides != nil {
		maxAgentUserOverrides_value = types.Int64Value(*obj.MaxAgentUserOverrides)
	}
	o.Passcode = passcode_value
	o.UninstallPassword = uninstallPassword_value
	o.AgentUserOverrideTimeout = agentUserOverrideTimeout_value
	o.MaxAgentUserOverrides = maxAgentUserOverrides_value
	o.WelcomePage = welcomePage_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAgentUiWelcomePageObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAgentUiWelcomePage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var page_value types.String
	if obj.Page != nil {
		page_value = types.StringValue(*obj.Page)
	}
	o.Page = page_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exclusion_obj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject
	if o.Exclusion.IsNull() {
		exclusion_obj = new(GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject)
	} else {
		diags.Append(o.Exclusion.As(ctx, &exclusion_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	exclusion_object := types.ObjectNull(exclusion_obj.AttributeTypes())
	if obj.Exclusion != nil {
		diags.Append(exclusion_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Exclusion, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		exclusion_object, diags_tmp = types.ObjectValueFrom(ctx, exclusion_obj.AttributeTypes(), exclusion_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var customChecks_obj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject
	if o.CustomChecks.IsNull() {
		customChecks_obj = new(GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject)
	} else {
		diags.Append(o.CustomChecks.As(ctx, &customChecks_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	customChecks_object := types.ObjectNull(customChecks_obj.AttributeTypes())
	if obj.CustomChecks != nil {
		diags.Append(customChecks_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CustomChecks, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		customChecks_object, diags_tmp = types.ObjectValueFrom(ctx, customChecks_obj.AttributeTypes(), customChecks_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var maxWaitTime_value types.Int64
	if obj.MaxWaitTime != nil {
		maxWaitTime_value = types.Int64Value(*obj.MaxWaitTime)
	}
	var collectHipData_value types.Bool
	if obj.CollectHipData != nil {
		collectHipData_value = types.BoolValue(*obj.CollectHipData)
	}
	o.CertificateProfile = certificateProfile_value
	o.MaxWaitTime = maxWaitTime_value
	o.CollectHipData = collectHipData_value
	o.Exclusion = exclusion_object
	o.CustomChecks = customChecks_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionExclusion, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var category_list types.List
	{
		var category_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject
		if !o.Category.IsNull() {
			diags.Append(o.Category.ElementsAs(ctx, &category_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Category {
			entry := GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(category_tf_entries) {
				entry = category_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(category_tf_entries) {
				category_tf_entries[idx] = entry
			} else {
				category_tf_entries = append(category_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("category")
		category_list, list_diags = types.ListValueFrom(ctx, schemaType, category_tf_entries)
		diags.Append(list_diags...)
	}

	o.Category = category_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionExclusionCategory, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vendor_list types.List
	{
		var vendor_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject
		if !o.Vendor.IsNull() {
			diags.Append(o.Vendor.ElementsAs(ctx, &vendor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Vendor {
			entry := GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(vendor_tf_entries) {
				entry = vendor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(vendor_tf_entries) {
				vendor_tf_entries[idx] = entry
			} else {
				vendor_tf_entries = append(vendor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vendor")
		vendor_list, list_diags = types.ListValueFrom(ctx, schemaType, vendor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vendor = vendor_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionExclusionCategoryVendorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionExclusionCategoryVendor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var product_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Product.IsNull() || len(obj.Product) > 0 {
			entries = obj.Product
		}

		product_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Product = product_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var windows_obj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject
	if o.Windows.IsNull() {
		windows_obj = new(GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject)
	} else {
		diags.Append(o.Windows.As(ctx, &windows_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	windows_object := types.ObjectNull(windows_obj.AttributeTypes())
	if obj.Windows != nil {
		diags.Append(windows_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Windows, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		windows_object, diags_tmp = types.ObjectValueFrom(ctx, windows_obj.AttributeTypes(), windows_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var macOs_obj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject
	if o.MacOs.IsNull() {
		macOs_obj = new(GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject)
	} else {
		diags.Append(o.MacOs.As(ctx, &macOs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	macOs_object := types.ObjectNull(macOs_obj.AttributeTypes())
	if obj.MacOs != nil {
		diags.Append(macOs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MacOs, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		macOs_object, diags_tmp = types.ObjectValueFrom(ctx, macOs_obj.AttributeTypes(), macOs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var linux_obj *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject
	if o.Linux.IsNull() {
		linux_obj = new(GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject)
	} else {
		diags.Append(o.Linux.As(ctx, &linux_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linux_object := types.ObjectNull(linux_obj.AttributeTypes())
	if obj.Linux != nil {
		diags.Append(linux_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Linux, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linux_object, diags_tmp = types.ObjectValueFrom(ctx, linux_obj.AttributeTypes(), linux_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Windows = windows_object
	o.MacOs = macOs_object
	o.Linux = linux_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_list types.List
	{
		var registryKey_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject
		if !o.RegistryKey.IsNull() {
			diags.Append(o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryKey {
			entry := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryKey_tf_entries) {
				entry = registryKey_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryKey_tf_entries) {
				registryKey_tf_entries[idx] = entry
			} else {
				registryKey_tf_entries = append(registryKey_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_key")
		registryKey_list, list_diags = types.ListValueFrom(ctx, schemaType, registryKey_tf_entries)
		diags.Append(list_diags...)
	}
	var processList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ProcessList.IsNull() || len(obj.ProcessList) > 0 {
			entries = obj.ProcessList
		}

		processList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.RegistryKey = registryKey_list
	o.ProcessList = processList_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegistryValue.IsNull() || len(obj.RegistryValue) > 0 {
			entries = obj.RegistryValue
		}

		registryValue_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.RegistryValue = registryValue_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_list types.List
	{
		var plist_tf_entries []GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject
		if !o.Plist.IsNull() {
			diags.Append(o.Plist.ElementsAs(ctx, &plist_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Plist {
			entry := GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(plist_tf_entries) {
				entry = plist_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(plist_tf_entries) {
				plist_tf_entries[idx] = entry
			} else {
				plist_tf_entries = append(plist_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("plist")
		plist_list, list_diags = types.ListValueFrom(ctx, schemaType, plist_tf_entries)
		diags.Append(list_diags...)
	}
	var processList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ProcessList.IsNull() || len(obj.ProcessList) > 0 {
			entries = obj.ProcessList
		}

		processList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Plist = plist_list
	o.ProcessList = processList_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksMacOsPlistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Key.IsNull() || len(obj.Key) > 0 {
			entries = obj.Key
		}

		key_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Key = key_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsHipCollectionCustomChecksLinuxObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsHipCollectionCustomChecksLinux, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var processList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ProcessList.IsNull() || len(obj.ProcessList) > 0 {
			entries = obj.ProcessList
		}

		processList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.ProcessList = processList_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAgentConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAgentConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGpAppConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var config_list types.List
	{
		var config_tf_entries []GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject
		if !o.Config.IsNull() {
			diags.Append(o.Config.ElementsAs(ctx, &config_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Config {
			entry := GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(config_tf_entries) {
				entry = config_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(config_tf_entries) {
				config_tf_entries[idx] = entry
			} else {
				config_tf_entries = append(config_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("config")
		config_list, list_diags = types.ListValueFrom(ctx, schemaType, config_tf_entries)
		diags.Append(list_diags...)
	}

	o.Config = config_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsGpAppConfigConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsGpAppConfigConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var value_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Value.IsNull() || len(obj.Value) > 0 {
			entries = obj.Value
		}

		value_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Value = value_list

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var acceptCookie_obj *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject
	if o.AcceptCookie.IsNull() {
		acceptCookie_obj = new(GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject)
	} else {
		diags.Append(o.AcceptCookie.As(ctx, &acceptCookie_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	acceptCookie_object := types.ObjectNull(acceptCookie_obj.AttributeTypes())
	if obj.AcceptCookie != nil {
		diags.Append(acceptCookie_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AcceptCookie, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		acceptCookie_object, diags_tmp = types.ObjectValueFrom(ctx, acceptCookie_obj.AttributeTypes(), acceptCookie_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var generateCookie_value types.Bool
	if obj.GenerateCookie != nil {
		generateCookie_value = types.BoolValue(*obj.GenerateCookie)
	}
	var cookieEncryptDecryptCert_value types.String
	if obj.CookieEncryptDecryptCert != nil {
		cookieEncryptDecryptCert_value = types.StringValue(*obj.CookieEncryptDecryptCert)
	}
	o.GenerateCookie = generateCookie_value
	o.CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	o.AcceptCookie = acceptCookie_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var cookieLifetime_obj *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	if o.CookieLifetime.IsNull() {
		cookieLifetime_obj = new(GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject)
	} else {
		diags.Append(o.CookieLifetime.As(ctx, &cookieLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	cookieLifetime_object := types.ObjectNull(cookieLifetime_obj.AttributeTypes())
	if obj.CookieLifetime != nil {
		diags.Append(cookieLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CookieLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		cookieLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, cookieLifetime_obj.AttributeTypes(), cookieLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.CookieLifetime = cookieLifetime_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetimeInDays_value types.Int64
	if obj.LifetimeInDays != nil {
		lifetimeInDays_value = types.Int64Value(*obj.LifetimeInDays)
	}
	var lifetimeInHours_value types.Int64
	if obj.LifetimeInHours != nil {
		lifetimeInHours_value = types.Int64Value(*obj.LifetimeInHours)
	}
	var lifetimeInMinutes_value types.Int64
	if obj.LifetimeInMinutes != nil {
		lifetimeInMinutes_value = types.Int64Value(*obj.LifetimeInMinutes)
	}
	o.LifetimeInDays = lifetimeInDays_value
	o.LifetimeInHours = lifetimeInHours_value
	o.LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsMachineAccountExistsWithSerialno, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var no_obj *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject
	if o.No.IsNull() {
		no_obj = new(GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var yes_obj *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject
	if o.Yes.IsNull() {
		yes_obj = new(GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsMachineAccountExistsWithSerialnoYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsMachineAccountExistsWithSerialnoYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigConfigsClientCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigConfigsClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var scep_value types.String
	if obj.Scep != nil {
		scep_value = types.StringValue(*obj.Scep)
	}
	o.Local = local_value
	o.Scep = scep_value

	return diags
}

func (o *GlobalprotectPortalResourceClientConfigRootCaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientConfigRootCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var installInCertStore_value types.Bool
	if obj.InstallInCertStore != nil {
		installInCertStore_value = types.BoolValue(*obj.InstallInCertStore)
	}
	o.Name = types.StringValue(obj.Name)
	o.InstallInCertStore = installInCertStore_value

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var appsToUserMapping_list types.List
	{
		var appsToUserMapping_tf_entries []GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject
		if !o.AppsToUserMapping.IsNull() {
			diags.Append(o.AppsToUserMapping.ElementsAs(ctx, &appsToUserMapping_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AppsToUserMapping {
			entry := GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(appsToUserMapping_tf_entries) {
				entry = appsToUserMapping_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(appsToUserMapping_tf_entries) {
				appsToUserMapping_tf_entries[idx] = entry
			} else {
				appsToUserMapping_tf_entries = append(appsToUserMapping_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("apps_to_user_mapping")
		appsToUserMapping_list, list_diags = types.ListValueFrom(ctx, schemaType, appsToUserMapping_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyServerSetting_list types.List
	{
		var proxyServerSetting_tf_entries []GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject
		if !o.ProxyServerSetting.IsNull() {
			diags.Append(o.ProxyServerSetting.ElementsAs(ctx, &proxyServerSetting_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ProxyServerSetting {
			entry := GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(proxyServerSetting_tf_entries) {
				entry = proxyServerSetting_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(proxyServerSetting_tf_entries) {
				proxyServerSetting_tf_entries[idx] = entry
			} else {
				proxyServerSetting_tf_entries = append(proxyServerSetting_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_server_setting")
		proxyServerSetting_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyServerSetting_tf_entries)
		diags.Append(list_diags...)
	}
	var rewriteExcludeDomainList_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RewriteExcludeDomainList.IsNull() || len(obj.RewriteExcludeDomainList) > 0 {
			entries = obj.RewriteExcludeDomainList
		}

		rewriteExcludeDomainList_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var cryptoSettings_obj *GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject
	if o.CryptoSettings.IsNull() {
		cryptoSettings_obj = new(GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject)
	} else {
		diags.Append(o.CryptoSettings.As(ctx, &cryptoSettings_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	cryptoSettings_object := types.ObjectNull(cryptoSettings_obj.AttributeTypes())
	if obj.CryptoSettings != nil {
		diags.Append(cryptoSettings_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CryptoSettings, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		cryptoSettings_object, diags_tmp = types.ObjectValueFrom(ctx, cryptoSettings_obj.AttributeTypes(), cryptoSettings_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var inactivityLogout_obj *GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject
	if o.InactivityLogout.IsNull() {
		inactivityLogout_obj = new(GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject)
	} else {
		diags.Append(o.InactivityLogout.As(ctx, &inactivityLogout_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	inactivityLogout_object := types.ObjectNull(inactivityLogout_obj.AttributeTypes())
	if obj.InactivityLogout != nil {
		diags.Append(inactivityLogout_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InactivityLogout, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		inactivityLogout_object, diags_tmp = types.ObjectValueFrom(ctx, inactivityLogout_obj.AttributeTypes(), inactivityLogout_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var loginLifetime_obj *GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject
	if o.LoginLifetime.IsNull() {
		loginLifetime_obj = new(GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject)
	} else {
		diags.Append(o.LoginLifetime.As(ctx, &loginLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	loginLifetime_object := types.ObjectNull(loginLifetime_obj.AttributeTypes())
	if obj.LoginLifetime != nil {
		diags.Append(loginLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LoginLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		loginLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, loginLifetime_obj.AttributeTypes(), loginLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsProxy_value types.String
	if obj.DnsProxy != nil {
		dnsProxy_value = types.StringValue(*obj.DnsProxy)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	var maxUser_value types.Int64
	if obj.MaxUser != nil {
		maxUser_value = types.Int64Value(*obj.MaxUser)
	}
	var securityZone_value types.String
	if obj.SecurityZone != nil {
		securityZone_value = types.StringValue(*obj.SecurityZone)
	}
	o.AppsToUserMapping = appsToUserMapping_list
	o.CryptoSettings = cryptoSettings_object
	o.DnsProxy = dnsProxy_value
	o.Hostname = hostname_value
	o.InactivityLogout = inactivityLogout_object
	o.LoginLifetime = loginLifetime_object
	o.MaxUser = maxUser_value
	o.ProxyServerSetting = proxyServerSetting_list
	o.RewriteExcludeDomainList = rewriteExcludeDomainList_list
	o.SecurityZone = securityZone_value

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnAppsToUserMappingObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnAppsToUserMapping, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var applications_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Applications.IsNull() || len(obj.Applications) > 0 {
			entries = obj.Applications
		}

		applications_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var enableCustomAppURLAddressBar_value types.Bool
	if obj.EnableCustomAppURLAddressBar != nil {
		enableCustomAppURLAddressBar_value = types.BoolValue(*obj.EnableCustomAppURLAddressBar)
	}
	var displayGlobalProtectAgentDownloadLink_value types.Bool
	if obj.DisplayGlobalProtectAgentDownloadLink != nil {
		displayGlobalProtectAgentDownloadLink_value = types.BoolValue(*obj.DisplayGlobalProtectAgentDownloadLink)
	}
	o.Name = types.StringValue(obj.Name)
	o.SourceUser = sourceUser_list
	o.Applications = applications_list
	o.EnableCustomAppURLAddressBar = enableCustomAppURLAddressBar_value
	o.DisplayGlobalProtectAgentDownloadLink = displayGlobalProtectAgentDownloadLink_value

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnCryptoSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var serverCertVerification_obj *GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject
	if o.ServerCertVerification.IsNull() {
		serverCertVerification_obj = new(GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject)
	} else {
		diags.Append(o.ServerCertVerification.As(ctx, &serverCertVerification_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	serverCertVerification_object := types.ObjectNull(serverCertVerification_obj.AttributeTypes())
	if obj.ServerCertVerification != nil {
		diags.Append(serverCertVerification_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ServerCertVerification, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		serverCertVerification_object, diags_tmp = types.ObjectValueFrom(ctx, serverCertVerification_obj.AttributeTypes(), serverCertVerification_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sslProtocol_obj *GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject
	if o.SslProtocol.IsNull() {
		sslProtocol_obj = new(GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject)
	} else {
		diags.Append(o.SslProtocol.As(ctx, &sslProtocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sslProtocol_object := types.ObjectNull(sslProtocol_obj.AttributeTypes())
	if obj.SslProtocol != nil {
		diags.Append(sslProtocol_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SslProtocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sslProtocol_object, diags_tmp = types.ObjectValueFrom(ctx, sslProtocol_obj.AttributeTypes(), sslProtocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.ServerCertVerification = serverCertVerification_object
	o.SslProtocol = sslProtocol_object

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsServerCertVerificationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnCryptoSettingsServerCertVerification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var blockExpiredCertificate_value types.Bool
	if obj.BlockExpiredCertificate != nil {
		blockExpiredCertificate_value = types.BoolValue(*obj.BlockExpiredCertificate)
	}
	var blockTimeoutCert_value types.Bool
	if obj.BlockTimeoutCert != nil {
		blockTimeoutCert_value = types.BoolValue(*obj.BlockTimeoutCert)
	}
	var blockUnknownCert_value types.Bool
	if obj.BlockUnknownCert != nil {
		blockUnknownCert_value = types.BoolValue(*obj.BlockUnknownCert)
	}
	var blockUntrustedIssuer_value types.Bool
	if obj.BlockUntrustedIssuer != nil {
		blockUntrustedIssuer_value = types.BoolValue(*obj.BlockUntrustedIssuer)
	}
	o.BlockExpiredCertificate = blockExpiredCertificate_value
	o.BlockTimeoutCert = blockTimeoutCert_value
	o.BlockUnknownCert = blockUnknownCert_value
	o.BlockUntrustedIssuer = blockUntrustedIssuer_value

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnCryptoSettingsSslProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnCryptoSettingsSslProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authAlgoMd5_value types.Bool
	if obj.AuthAlgoMd5 != nil {
		authAlgoMd5_value = types.BoolValue(*obj.AuthAlgoMd5)
	}
	var authAlgoSha1_value types.Bool
	if obj.AuthAlgoSha1 != nil {
		authAlgoSha1_value = types.BoolValue(*obj.AuthAlgoSha1)
	}
	var authAlgoSha256_value types.Bool
	if obj.AuthAlgoSha256 != nil {
		authAlgoSha256_value = types.BoolValue(*obj.AuthAlgoSha256)
	}
	var authAlgoSha384_value types.Bool
	if obj.AuthAlgoSha384 != nil {
		authAlgoSha384_value = types.BoolValue(*obj.AuthAlgoSha384)
	}
	var encAlgo3des_value types.Bool
	if obj.EncAlgo3des != nil {
		encAlgo3des_value = types.BoolValue(*obj.EncAlgo3des)
	}
	var encAlgoAes128Cbc_value types.Bool
	if obj.EncAlgoAes128Cbc != nil {
		encAlgoAes128Cbc_value = types.BoolValue(*obj.EncAlgoAes128Cbc)
	}
	var encAlgoAes128Gcm_value types.Bool
	if obj.EncAlgoAes128Gcm != nil {
		encAlgoAes128Gcm_value = types.BoolValue(*obj.EncAlgoAes128Gcm)
	}
	var encAlgoAes256Cbc_value types.Bool
	if obj.EncAlgoAes256Cbc != nil {
		encAlgoAes256Cbc_value = types.BoolValue(*obj.EncAlgoAes256Cbc)
	}
	var encAlgoAes256Gcm_value types.Bool
	if obj.EncAlgoAes256Gcm != nil {
		encAlgoAes256Gcm_value = types.BoolValue(*obj.EncAlgoAes256Gcm)
	}
	var encAlgoRc4_value types.Bool
	if obj.EncAlgoRc4 != nil {
		encAlgoRc4_value = types.BoolValue(*obj.EncAlgoRc4)
	}
	var keyxchgAlgoDhe_value types.Bool
	if obj.KeyxchgAlgoDhe != nil {
		keyxchgAlgoDhe_value = types.BoolValue(*obj.KeyxchgAlgoDhe)
	}
	var keyxchgAlgoEcdhe_value types.Bool
	if obj.KeyxchgAlgoEcdhe != nil {
		keyxchgAlgoEcdhe_value = types.BoolValue(*obj.KeyxchgAlgoEcdhe)
	}
	var keyxchgAlgoRsa_value types.Bool
	if obj.KeyxchgAlgoRsa != nil {
		keyxchgAlgoRsa_value = types.BoolValue(*obj.KeyxchgAlgoRsa)
	}
	var maxVersion_value types.String
	if obj.MaxVersion != nil {
		maxVersion_value = types.StringValue(*obj.MaxVersion)
	}
	var minVersion_value types.String
	if obj.MinVersion != nil {
		minVersion_value = types.StringValue(*obj.MinVersion)
	}
	o.AuthAlgoMd5 = authAlgoMd5_value
	o.AuthAlgoSha1 = authAlgoSha1_value
	o.AuthAlgoSha256 = authAlgoSha256_value
	o.AuthAlgoSha384 = authAlgoSha384_value
	o.EncAlgo3des = encAlgo3des_value
	o.EncAlgoAes128Cbc = encAlgoAes128Cbc_value
	o.EncAlgoAes128Gcm = encAlgoAes128Gcm_value
	o.EncAlgoAes256Cbc = encAlgoAes256Cbc_value
	o.EncAlgoAes256Gcm = encAlgoAes256Gcm_value
	o.EncAlgoRc4 = encAlgoRc4_value
	o.KeyxchgAlgoDhe = keyxchgAlgoDhe_value
	o.KeyxchgAlgoEcdhe = keyxchgAlgoEcdhe_value
	o.KeyxchgAlgoRsa = keyxchgAlgoRsa_value
	o.MaxVersion = maxVersion_value
	o.MinVersion = minVersion_value

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnInactivityLogoutObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnInactivityLogout, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hours_value types.Int64
	if obj.Hours != nil {
		hours_value = types.Int64Value(*obj.Hours)
	}
	var minutes_value types.Int64
	if obj.Minutes != nil {
		minutes_value = types.Int64Value(*obj.Minutes)
	}
	o.Hours = hours_value
	o.Minutes = minutes_value

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnLoginLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hours_value types.Int64
	if obj.Hours != nil {
		hours_value = types.Int64Value(*obj.Hours)
	}
	var minutes_value types.Int64
	if obj.Minutes != nil {
		minutes_value = types.Int64Value(*obj.Minutes)
	}
	o.Hours = hours_value
	o.Minutes = minutes_value

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnProxyServerSetting, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var domains_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Domains.IsNull() || len(obj.Domains) > 0 {
			entries = obj.Domains
		}

		domains_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var proxyServer_obj *GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject
	if o.ProxyServer.IsNull() {
		proxyServer_obj = new(GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject)
	} else {
		diags.Append(o.ProxyServer.As(ctx, &proxyServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	proxyServer_object := types.ObjectNull(proxyServer_obj.AttributeTypes())
	if obj.ProxyServer != nil {
		diags.Append(proxyServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ProxyServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		proxyServer_object, diags_tmp = types.ObjectValueFrom(ctx, proxyServer_obj.AttributeTypes(), proxyServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var useProxy_value types.Bool
	if obj.UseProxy != nil {
		useProxy_value = types.BoolValue(*obj.UseProxy)
	}
	o.Name = types.StringValue(obj.Name)
	o.Domains = domains_list
	o.UseProxy = useProxy_value
	o.ProxyServer = proxyServer_object

	return diags
}

func (o *GlobalprotectPortalResourceClientlessVpnProxyServerSettingProxyServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.ClientlessVpnProxyServerSettingProxyServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var server_value types.String
	if obj.Server != nil {
		server_value = types.StringValue(*obj.Server)
	}
	var port_value types.Int64
	if obj.Port != nil {
		port_value = types.Int64Value(*obj.Port)
	}
	var user_value types.String
	if obj.User != nil {
		user_value = types.StringValue(*obj.User)
	}
	var password_value types.String
	if obj.Password != nil {
		valueKey, err := CreateXpathForAttributeWithAncestors(ancestors, "password")
		if err != nil {
			diags.AddError("Failed to create encrypted values state key", err.Error())
			return diags
		}

		if evFromState, found := ev.GetEncryptedValue(valueKey); found && ev.PreferServerState() && *obj.Password != evFromState {
			password_value = types.StringPointerValue(obj.Password)
		} else if value, found := ev.GetPlaintextValue(valueKey); found {
			password_value = types.StringValue(value)
		} else {
			diags.AddError("Failed to read encrypted values state", fmt.Sprintf("Missing plaintext value for %s", valueKey))
			return diags
		}

		if !ev.PreferServerState() {
			err = ev.StoreEncryptedValue(valueKey, "solo", *obj.Password)
			if err != nil {
				diags.AddError("Failed to store encrypted values state", err.Error())
				return diags
			}
		}
	}
	o.Server = server_value
	o.Port = port_value
	o.User = user_value
	o.Password = password_value

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientAuth_list types.List
	{
		var clientAuth_tf_entries []GlobalprotectPortalResourcePortalConfigClientAuthObject
		if !o.ClientAuth.IsNull() {
			diags.Append(o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ClientAuth {
			entry := GlobalprotectPortalResourcePortalConfigClientAuthObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(clientAuth_tf_entries) {
				entry = clientAuth_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(clientAuth_tf_entries) {
				clientAuth_tf_entries[idx] = entry
			} else {
				clientAuth_tf_entries = append(clientAuth_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("client_auth")
		clientAuth_list, list_diags = types.ListValueFrom(ctx, schemaType, clientAuth_tf_entries)
		diags.Append(list_diags...)
	}

	var configSelection_obj *GlobalprotectPortalResourcePortalConfigConfigSelectionObject
	if o.ConfigSelection.IsNull() {
		configSelection_obj = new(GlobalprotectPortalResourcePortalConfigConfigSelectionObject)
	} else {
		diags.Append(o.ConfigSelection.As(ctx, &configSelection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	configSelection_object := types.ObjectNull(configSelection_obj.AttributeTypes())
	if obj.ConfigSelection != nil {
		diags.Append(configSelection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConfigSelection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		configSelection_object, diags_tmp = types.ObjectValueFrom(ctx, configSelection_obj.AttributeTypes(), configSelection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *GlobalprotectPortalResourcePortalConfigLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(GlobalprotectPortalResourcePortalConfigLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var customHelpPage_value types.String
	if obj.CustomHelpPage != nil {
		customHelpPage_value = types.StringValue(*obj.CustomHelpPage)
	}
	var customHomePage_value types.String
	if obj.CustomHomePage != nil {
		customHomePage_value = types.StringValue(*obj.CustomHomePage)
	}
	var customLoginPage_value types.String
	if obj.CustomLoginPage != nil {
		customLoginPage_value = types.StringValue(*obj.CustomLoginPage)
	}
	var logFail_value types.Bool
	if obj.LogFail != nil {
		logFail_value = types.BoolValue(*obj.LogFail)
	}
	var logSetting_value types.String
	if obj.LogSetting != nil {
		logSetting_value = types.StringValue(*obj.LogSetting)
	}
	var logSuccess_value types.Bool
	if obj.LogSuccess != nil {
		logSuccess_value = types.BoolValue(*obj.LogSuccess)
	}
	var sslTlsServiceProfile_value types.String
	if obj.SslTlsServiceProfile != nil {
		sslTlsServiceProfile_value = types.StringValue(*obj.SslTlsServiceProfile)
	}
	o.CertificateProfile = certificateProfile_value
	o.ClientAuth = clientAuth_list
	o.ConfigSelection = configSelection_object
	o.CustomHelpPage = customHelpPage_value
	o.CustomHomePage = customHomePage_value
	o.CustomLoginPage = customLoginPage_value
	o.LocalAddress = localAddress_object
	o.LogFail = logFail_value
	o.LogSetting = logSetting_value
	o.LogSuccess = logSuccess_value
	o.SslTlsServiceProfile = sslTlsServiceProfile_value

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigClientAuthObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var os_value types.String
	if obj.Os != nil {
		os_value = types.StringValue(*obj.Os)
	}
	var authenticationProfile_value types.String
	if obj.AuthenticationProfile != nil {
		authenticationProfile_value = types.StringValue(*obj.AuthenticationProfile)
	}
	var autoRetrievePasscode_value types.Bool
	if obj.AutoRetrievePasscode != nil {
		autoRetrievePasscode_value = types.BoolValue(*obj.AutoRetrievePasscode)
	}
	var usernameLabel_value types.String
	if obj.UsernameLabel != nil {
		usernameLabel_value = types.StringValue(*obj.UsernameLabel)
	}
	var passwordLabel_value types.String
	if obj.PasswordLabel != nil {
		passwordLabel_value = types.StringValue(*obj.PasswordLabel)
	}
	var authenticationMessage_value types.String
	if obj.AuthenticationMessage != nil {
		authenticationMessage_value = types.StringValue(*obj.AuthenticationMessage)
	}
	var userCredentialOrClientCertRequired_value types.String
	if obj.UserCredentialOrClientCertRequired != nil {
		userCredentialOrClientCertRequired_value = types.StringValue(*obj.UserCredentialOrClientCertRequired)
	}
	o.Name = types.StringValue(obj.Name)
	o.Os = os_value
	o.AuthenticationProfile = authenticationProfile_value
	o.AutoRetrievePasscode = autoRetrievePasscode_value
	o.UsernameLabel = usernameLabel_value
	o.PasswordLabel = passwordLabel_value
	o.AuthenticationMessage = authenticationMessage_value
	o.UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var customChecks_obj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject
	if o.CustomChecks.IsNull() {
		customChecks_obj = new(GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject)
	} else {
		diags.Append(o.CustomChecks.As(ctx, &customChecks_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	customChecks_object := types.ObjectNull(customChecks_obj.AttributeTypes())
	if obj.CustomChecks != nil {
		diags.Append(customChecks_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CustomChecks, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		customChecks_object, diags_tmp = types.ObjectValueFrom(ctx, customChecks_obj.AttributeTypes(), customChecks_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	o.CertificateProfile = certificateProfile_value
	o.CustomChecks = customChecks_object

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecks, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var macOs_obj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject
	if o.MacOs.IsNull() {
		macOs_obj = new(GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject)
	} else {
		diags.Append(o.MacOs.As(ctx, &macOs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	macOs_object := types.ObjectNull(macOs_obj.AttributeTypes())
	if obj.MacOs != nil {
		diags.Append(macOs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MacOs, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		macOs_object, diags_tmp = types.ObjectValueFrom(ctx, macOs_obj.AttributeTypes(), macOs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var windows_obj *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject
	if o.Windows.IsNull() {
		windows_obj = new(GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject)
	} else {
		diags.Append(o.Windows.As(ctx, &windows_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	windows_object := types.ObjectNull(windows_obj.AttributeTypes())
	if obj.Windows != nil {
		diags.Append(windows_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Windows, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		windows_object, diags_tmp = types.ObjectValueFrom(ctx, windows_obj.AttributeTypes(), windows_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.MacOs = macOs_object
	o.Windows = windows_object

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksMacOs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var plist_list types.List
	{
		var plist_tf_entries []GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject
		if !o.Plist.IsNull() {
			diags.Append(o.Plist.ElementsAs(ctx, &plist_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Plist {
			entry := GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(plist_tf_entries) {
				entry = plist_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(plist_tf_entries) {
				plist_tf_entries[idx] = entry
			} else {
				plist_tf_entries = append(plist_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("plist")
		plist_list, list_diags = types.ListValueFrom(ctx, schemaType, plist_tf_entries)
		diags.Append(list_diags...)
	}

	o.Plist = plist_list

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksMacOsPlistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksMacOsPlist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var key_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Key.IsNull() || len(obj.Key) > 0 {
			entries = obj.Key
		}

		key_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Key = key_list

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksWindows, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryKey_list types.List
	{
		var registryKey_tf_entries []GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject
		if !o.RegistryKey.IsNull() {
			diags.Append(o.RegistryKey.ElementsAs(ctx, &registryKey_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RegistryKey {
			entry := GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(registryKey_tf_entries) {
				entry = registryKey_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(registryKey_tf_entries) {
				registryKey_tf_entries[idx] = entry
			} else {
				registryKey_tf_entries = append(registryKey_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("registry_key")
		registryKey_list, list_diags = types.ListValueFrom(ctx, schemaType, registryKey_tf_entries)
		diags.Append(list_diags...)
	}

	o.RegistryKey = registryKey_list

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigConfigSelectionCustomChecksWindowsRegistryKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigConfigSelectionCustomChecksWindowsRegistryKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var registryValue_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegistryValue.IsNull() || len(obj.RegistryValue) > 0 {
			entries = obj.RegistryValue
		}

		registryValue_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.RegistryValue = registryValue_list

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var floatingIp_obj *GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject
	if o.FloatingIp.IsNull() {
		floatingIp_obj = new(GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject)
	} else {
		diags.Append(o.FloatingIp.As(ctx, &floatingIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	floatingIp_object := types.ObjectNull(floatingIp_obj.AttributeTypes())
	if obj.FloatingIp != nil {
		diags.Append(floatingIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FloatingIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		floatingIp_object, diags_tmp = types.ObjectValueFrom(ctx, floatingIp_obj.AttributeTypes(), floatingIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *GlobalprotectPortalResourcePortalConfigLocalAddressIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalResourcePortalConfigLocalAddressIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ipAddressFamily_value types.String
	if obj.IpAddressFamily != nil {
		ipAddressFamily_value = types.StringValue(*obj.IpAddressFamily)
	}
	o.Interface = interface_value
	o.IpAddressFamily = ipAddressFamily_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalResourcePortalConfigLocalAddressIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.PortalConfigLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalResourceSatelliteConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var configs_list types.List
	{
		var configs_tf_entries []GlobalprotectPortalResourceSatelliteConfigConfigsObject
		if !o.Configs.IsNull() {
			diags.Append(o.Configs.ElementsAs(ctx, &configs_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Configs {
			entry := GlobalprotectPortalResourceSatelliteConfigConfigsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(configs_tf_entries) {
				entry = configs_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(configs_tf_entries) {
				configs_tf_entries[idx] = entry
			} else {
				configs_tf_entries = append(configs_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("configs")
		configs_list, list_diags = types.ListValueFrom(ctx, schemaType, configs_tf_entries)
		diags.Append(list_diags...)
	}
	var rootCa_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RootCa.IsNull() || len(obj.RootCa) > 0 {
			entries = obj.RootCa
		}

		rootCa_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var clientCertificate_obj *GlobalprotectPortalResourceSatelliteConfigClientCertificateObject
	if o.ClientCertificate.IsNull() {
		clientCertificate_obj = new(GlobalprotectPortalResourceSatelliteConfigClientCertificateObject)
	} else {
		diags.Append(o.ClientCertificate.As(ctx, &clientCertificate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	clientCertificate_object := types.ObjectNull(clientCertificate_obj.AttributeTypes())
	if obj.ClientCertificate != nil {
		diags.Append(clientCertificate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ClientCertificate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		clientCertificate_object, diags_tmp = types.ObjectValueFrom(ctx, clientCertificate_obj.AttributeTypes(), clientCertificate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.ClientCertificate = clientCertificate_object
	o.Configs = configs_list
	o.RootCa = rootCa_list

	return diags
}

func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigClientCertificate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var local_obj *GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject
	if o.Local.IsNull() {
		local_obj = new(GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject)
	} else {
		diags.Append(o.Local.As(ctx, &local_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	local_object := types.ObjectNull(local_obj.AttributeTypes())
	if obj.Local != nil {
		diags.Append(local_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Local, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		local_object, diags_tmp = types.ObjectValueFrom(ctx, local_obj.AttributeTypes(), local_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var scep_obj *GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject
	if o.Scep.IsNull() {
		scep_obj = new(GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject)
	} else {
		diags.Append(o.Scep.As(ctx, &scep_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	scep_object := types.ObjectNull(scep_obj.AttributeTypes())
	if obj.Scep != nil {
		diags.Append(scep_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Scep, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		scep_object, diags_tmp = types.ObjectValueFrom(ctx, scep_obj.AttributeTypes(), scep_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Local = local_object
	o.Scep = scep_object

	return diags
}

func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateLocalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigClientCertificateLocal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateLifeTime_value types.Int64
	if obj.CertificateLifeTime != nil {
		certificateLifeTime_value = types.Int64Value(*obj.CertificateLifeTime)
	}
	var certificateRenewalPeriod_value types.Int64
	if obj.CertificateRenewalPeriod != nil {
		certificateRenewalPeriod_value = types.Int64Value(*obj.CertificateRenewalPeriod)
	}
	var issuingCertificate_value types.String
	if obj.IssuingCertificate != nil {
		issuingCertificate_value = types.StringValue(*obj.IssuingCertificate)
	}
	var ocspResponder_value types.String
	if obj.OcspResponder != nil {
		ocspResponder_value = types.StringValue(*obj.OcspResponder)
	}
	o.CertificateLifeTime = certificateLifeTime_value
	o.CertificateRenewalPeriod = certificateRenewalPeriod_value
	o.IssuingCertificate = issuingCertificate_value
	o.OcspResponder = ocspResponder_value

	return diags
}

func (o *GlobalprotectPortalResourceSatelliteConfigClientCertificateScepObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigClientCertificateScep, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateRenewalPeriod_value types.Int64
	if obj.CertificateRenewalPeriod != nil {
		certificateRenewalPeriod_value = types.Int64Value(*obj.CertificateRenewalPeriod)
	}
	var scep_value types.String
	if obj.Scep != nil {
		scep_value = types.StringValue(*obj.Scep)
	}
	o.CertificateRenewalPeriod = certificateRenewalPeriod_value
	o.Scep = scep_value

	return diags
}

func (o *GlobalprotectPortalResourceSatelliteConfigConfigsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Devices.IsNull() || len(obj.Devices) > 0 {
			entries = obj.Devices
		}

		devices_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var gateways_list types.List
	{
		var gateways_tf_entries []GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject
		if !o.Gateways.IsNull() {
			diags.Append(o.Gateways.ElementsAs(ctx, &gateways_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Gateways {
			entry := GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(gateways_tf_entries) {
				entry = gateways_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(gateways_tf_entries) {
				gateways_tf_entries[idx] = entry
			} else {
				gateways_tf_entries = append(gateways_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("gateways")
		gateways_list, list_diags = types.ListValueFrom(ctx, schemaType, gateways_tf_entries)
		diags.Append(list_diags...)
	}

	var configRefreshInterval_value types.Int64
	if obj.ConfigRefreshInterval != nil {
		configRefreshInterval_value = types.Int64Value(*obj.ConfigRefreshInterval)
	}
	o.Name = types.StringValue(obj.Name)
	o.Devices = devices_list
	o.SourceUser = sourceUser_list
	o.Gateways = gateways_list
	o.ConfigRefreshInterval = configRefreshInterval_value

	return diags
}

func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigConfigsGateways, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_obj *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Preferred_value types.Bool
	if obj.Ipv6Preferred != nil {
		ipv6Preferred_value = types.BoolValue(*obj.Ipv6Preferred)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Name = types.StringValue(obj.Name)
	o.Ipv6Preferred = ipv6Preferred_value
	o.Priority = priority_value
	o.Fqdn = fqdn_value
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectPortalResourceSatelliteConfigConfigsGatewaysIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *portal.SatelliteConfigConfigsGatewaysIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectPortalResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *GlobalprotectPortalResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state GlobalprotectPortalResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_globalprotect_portal_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location portal.Location

	{
		var terraformLocation GlobalprotectPortalLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &portal.TemplateLocation{}
			var innerLocation GlobalprotectPortalTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &portal.TemplateVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &portal.TemplateStackLocation{}
			var innerLocation GlobalprotectPortalTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &portal.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &portal.VsysLocation{}
			var innerLocation GlobalprotectPortalVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *portal.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *GlobalprotectPortalResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state GlobalprotectPortalResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location portal.Location

	{
		var terraformLocation GlobalprotectPortalLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &portal.TemplateLocation{}
			var innerLocation GlobalprotectPortalTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &portal.TemplateVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &portal.TemplateStackLocation{}
			var innerLocation GlobalprotectPortalTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &portal.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &portal.VsysLocation{}
			var innerLocation GlobalprotectPortalVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_globalprotect_portal_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *GlobalprotectPortalResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state GlobalprotectPortalResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location portal.Location

	{
		var terraformLocation GlobalprotectPortalLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &portal.TemplateLocation{}
			var innerLocation GlobalprotectPortalTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &portal.TemplateVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &portal.TemplateStackLocation{}
			var innerLocation GlobalprotectPortalTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &portal.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &portal.VsysLocation{}
			var innerLocation GlobalprotectPortalVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_globalprotect_portal_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := o.manager.Read(ctx, location, components, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := o.manager.Update(ctx, location, components, obj, obj.Name)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *GlobalprotectPortalResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state GlobalprotectPortalResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_globalprotect_portal_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location portal.Location

	{
		var terraformLocation GlobalprotectPortalLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &portal.TemplateLocation{}
			var innerLocation GlobalprotectPortalTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &portal.TemplateVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &portal.TemplateStackLocation{}
			var innerLocation GlobalprotectPortalTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &portal.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectPortalTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &portal.VsysLocation{}
			var innerLocation GlobalprotectPortalVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type GlobalprotectPortalImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o GlobalprotectPortalImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *GlobalprotectPortalLocation `json:"location"`
		Name     *string                      `json:"name"`
	}
	var location_object *GlobalprotectPortalLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectPortalImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *GlobalprotectPortalLocation `json:"location"`
		Name     *string                      `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func GlobalprotectPortalImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := GlobalprotectPortalImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *GlobalprotectPortalResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj GlobalprotectPortalImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type GlobalprotectPortalTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type GlobalprotectPortalTemplateVsysLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Template       types.String `tfsdk:"template"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
	Vsys           types.String `tfsdk:"vsys"`
}
type GlobalprotectPortalTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type GlobalprotectPortalTemplateStackVsysLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	TemplateStack  types.String `tfsdk:"template_stack"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
	Vsys           types.String `tfsdk:"vsys"`
}
type GlobalprotectPortalVsysLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
	Name       types.String `tfsdk:"name"`
}
type GlobalprotectPortalLocation struct {
	Template          types.Object `tfsdk:"template"`
	TemplateVsys      types.Object `tfsdk:"template_vsys"`
	TemplateStack     types.Object `tfsdk:"template_stack"`
	TemplateStackVsys types.Object `tfsdk:"template_stack_vsys"`
	Vsys              types.Object `tfsdk:"vsys"`
}

func GlobalprotectPortalLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_vsys"),
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("template_stack_vsys"),
						path.MatchRelative().AtParent().AtName("vsys"),
					}...),
				},
			},
			"template_vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template, device and vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"template": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"vsys": rsschema.StringAttribute{
						Description: "The vsys.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack_vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template, device and vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"template_stack": rsschema.StringAttribute{
						Description: "The template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"vsys": rsschema.StringAttribute{
						Description: "The vsys.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Virtual System",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The Virtual System name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o GlobalprotectPortalTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectPortalTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o GlobalprotectPortalTemplateVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Template       *string `json:"template,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Template:       o.Template.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		Vsys:           o.Vsys.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectPortalTemplateVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Template       *string `json:"template,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Template = types.StringPointerValue(shadow.Template)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Vsys = types.StringPointerValue(shadow.Vsys)

	return nil
}
func (o GlobalprotectPortalTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectPortalTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o GlobalprotectPortalTemplateStackVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		TemplateStack  *string `json:"template_stack,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		TemplateStack:  o.TemplateStack.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		Vsys:           o.Vsys.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectPortalTemplateStackVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		TemplateStack  *string `json:"template_stack,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.TemplateStack = types.StringPointerValue(shadow.TemplateStack)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Vsys = types.StringPointerValue(shadow.Vsys)

	return nil
}
func (o GlobalprotectPortalVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
		Name:       o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectPortalVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o GlobalprotectPortalLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Template          *GlobalprotectPortalTemplateLocation          `json:"template,omitempty"`
		TemplateVsys      *GlobalprotectPortalTemplateVsysLocation      `json:"template_vsys,omitempty"`
		TemplateStack     *GlobalprotectPortalTemplateStackLocation     `json:"template_stack,omitempty"`
		TemplateStackVsys *GlobalprotectPortalTemplateStackVsysLocation `json:"template_stack_vsys,omitempty"`
		Vsys              *GlobalprotectPortalVsysLocation              `json:"vsys,omitempty"`
	}
	var template_object *GlobalprotectPortalTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateVsys_object *GlobalprotectPortalTemplateVsysLocation
	{
		diags := o.TemplateVsys.As(context.TODO(), &templateVsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_vsys into JSON document", diags.Errors())
		}
	}
	var templateStack_object *GlobalprotectPortalTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}
	var templateStackVsys_object *GlobalprotectPortalTemplateStackVsysLocation
	{
		diags := o.TemplateStackVsys.As(context.TODO(), &templateStackVsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack_vsys into JSON document", diags.Errors())
		}
	}
	var vsys_object *GlobalprotectPortalVsysLocation
	{
		diags := o.Vsys.As(context.TODO(), &vsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal vsys into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Template:          template_object,
		TemplateVsys:      templateVsys_object,
		TemplateStack:     templateStack_object,
		TemplateStackVsys: templateStackVsys_object,
		Vsys:              vsys_object,
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectPortalLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Template          *GlobalprotectPortalTemplateLocation          `json:"template,omitempty"`
		TemplateVsys      *GlobalprotectPortalTemplateVsysLocation      `json:"template_vsys,omitempty"`
		TemplateStack     *GlobalprotectPortalTemplateStackLocation     `json:"template_stack,omitempty"`
		TemplateStackVsys *GlobalprotectPortalTemplateStackVsysLocation `json:"template_stack_vsys,omitempty"`
		Vsys              *GlobalprotectPortalVsysLocation              `json:"vsys,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateVsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateVsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateVsys.AttributeTypes(), shadow.TemplateVsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_vsys", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	var templateStackVsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStackVsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStackVsys.AttributeTypes(), shadow.TemplateStackVsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack_vsys", diags_tmp.Errors())
		}
	}
	var vsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		vsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Vsys.AttributeTypes(), shadow.Vsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into vsys", diags_tmp.Errors())
		}
	}
	o.Template = template_object
	o.TemplateVsys = templateVsys_object
	o.TemplateStack = templateStack_object
	o.TemplateStackVsys = templateStackVsys_object
	o.Vsys = vsys_object

	return nil
}

func (o *GlobalprotectPortalTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *GlobalprotectPortalTemplateVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"template":        types.StringType,
		"ngfw_device":     types.StringType,
		"vsys":            types.StringType,
	}
}
func (o *GlobalprotectPortalTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *GlobalprotectPortalTemplateStackVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"template_stack":  types.StringType,
		"ngfw_device":     types.StringType,
		"vsys":            types.StringType,
	}
}
func (o *GlobalprotectPortalVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
		"name":        types.StringType,
	}
}
func (o *GlobalprotectPortalLocation) AttributeTypes() map[string]attr.Type {
	var templateObj GlobalprotectPortalTemplateLocation
	var templateVsysObj GlobalprotectPortalTemplateVsysLocation
	var templateStackObj GlobalprotectPortalTemplateStackLocation
	var templateStackVsysObj GlobalprotectPortalTemplateStackVsysLocation
	var vsysObj GlobalprotectPortalVsysLocation
	return map[string]attr.Type{
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_vsys": types.ObjectType{
			AttrTypes: templateVsysObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
		"template_stack_vsys": types.ObjectType{
			AttrTypes: templateStackVsysObj.AttributeTypes(),
		},
		"vsys": types.ObjectType{
			AttrTypes: vsysObj.AttributeTypes(),
		},
	}
}
