package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/device/dynamicupdates"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &DynamicUpdatesDataSource{}
	_ datasource.DataSourceWithConfigure = &DynamicUpdatesDataSource{}
)

func NewDynamicUpdatesDataSource() datasource.DataSource {
	return &DynamicUpdatesDataSource{}
}

type DynamicUpdatesDataSource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*dynamicupdates.Config, dynamicupdates.Location, *dynamicupdates.Service]
}

type DynamicUpdatesDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type DynamicUpdatesDataSourceModel struct {
	Location       DynamicUpdatesLocation                        `tfsdk:"location"`
	UpdateSchedule *DynamicUpdatesDataSourceUpdateScheduleObject `tfsdk:"update_schedule"`
}
type DynamicUpdatesDataSourceUpdateScheduleObject struct {
	AppProfile                 *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject                 `tfsdk:"app_profile"`
	GlobalProtectClientlessVpn *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject `tfsdk:"global_protect_clientless_vpn"`
	GlobalProtectDatafile      *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject      `tfsdk:"global_protect_datafile"`
	StatisticsService          *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject          `tfsdk:"statistics_service"`
	Threats                    *DynamicUpdatesDataSourceUpdateScheduleThreatsObject                    `tfsdk:"threats"`
	WfPrivate                  *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject                  `tfsdk:"wf_private"`
	Wildfire                   *DynamicUpdatesDataSourceUpdateScheduleWildfireObject                   `tfsdk:"wildfire"`
	AntiVirus                  *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject                  `tfsdk:"anti_virus"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject struct {
	Recurring *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject struct {
	Daily  *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject  `tfsdk:"daily"`
	Hourly *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject `tfsdk:"hourly"`
	None   *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject   `tfsdk:"none"`
	Weekly *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject `tfsdk:"weekly"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject struct {
	At     types.String `tfsdk:"at"`
	Action types.String `tfsdk:"action"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject struct {
	At     types.Int64  `tfsdk:"at"`
	Action types.String `tfsdk:"action"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject struct {
	Recurring *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject struct {
	None   *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject   `tfsdk:"none"`
	Weekly *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject `tfsdk:"weekly"`
	Daily  *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject  `tfsdk:"daily"`
	Hourly *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject `tfsdk:"hourly"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject struct {
	At     types.Int64  `tfsdk:"at"`
	Action types.String `tfsdk:"action"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject struct {
	PassiveDnsMonitoring        types.Bool `tfsdk:"passive_dns_monitoring"`
	ThreatPreventionInformation types.Bool `tfsdk:"threat_prevention_information"`
	ThreatPreventionPcap        types.Bool `tfsdk:"threat_prevention_pcap"`
	ThreatPreventionReports     types.Bool `tfsdk:"threat_prevention_reports"`
	UrlReports                  types.Bool `tfsdk:"url_reports"`
	ApplicationReports          types.Bool `tfsdk:"application_reports"`
	FileIdentificationReports   types.Bool `tfsdk:"file_identification_reports"`
	HealthPerformanceReports    types.Bool `tfsdk:"health_performance_reports"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsObject struct {
	Recurring *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject struct {
	NewAppThreshold types.Int64                                                              `tfsdk:"new_app_threshold"`
	SyncToPeer      types.Bool                                                               `tfsdk:"sync_to_peer"`
	Threshold       types.Int64                                                              `tfsdk:"threshold"`
	Hourly          *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject      `tfsdk:"hourly"`
	None            *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject        `tfsdk:"none"`
	Weekly          *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject      `tfsdk:"weekly"`
	Daily           *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject       `tfsdk:"daily"`
	Every30Mins     *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject `tfsdk:"every_30_mins"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject struct {
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
	Action            types.String `tfsdk:"action"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DayOfWeek         types.String `tfsdk:"day_of_week"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject struct {
	Recurring *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject struct {
	SyncToPeer  types.Bool                                                                 `tfsdk:"sync_to_peer"`
	Every15Mins *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject `tfsdk:"every_15_mins"`
	Every30Mins *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject `tfsdk:"every_30_mins"`
	Every5Mins  *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject  `tfsdk:"every_5_mins"`
	EveryHour   *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject   `tfsdk:"every_hour"`
	None        *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject        `tfsdk:"none"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireObject struct {
	Recurring *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject struct {
	None        *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject        `tfsdk:"none"`
	RealTime    *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject    `tfsdk:"real_time"`
	Every15Mins *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject `tfsdk:"every_15_mins"`
	Every30Mins *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject `tfsdk:"every_30_mins"`
	EveryHour   *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject   `tfsdk:"every_hour"`
	EveryMin    *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject    `tfsdk:"every_min"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject struct {
	Action     types.String `tfsdk:"action"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject struct {
	Recurring *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject struct {
	SyncToPeer types.Bool                                                            `tfsdk:"sync_to_peer"`
	Threshold  types.Int64                                                           `tfsdk:"threshold"`
	Hourly     *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject `tfsdk:"hourly"`
	None       *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject   `tfsdk:"none"`
	Weekly     *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject `tfsdk:"weekly"`
	Daily      *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject  `tfsdk:"daily"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileObject struct {
	Recurring *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject struct {
	SyncToPeer types.Bool                                                             `tfsdk:"sync_to_peer"`
	Threshold  types.Int64                                                            `tfsdk:"threshold"`
	Weekly     *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject `tfsdk:"weekly"`
	Daily      *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject  `tfsdk:"daily"`
	None       *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject   `tfsdk:"none"`
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject struct {
	At     types.String `tfsdk:"at"`
	Action types.String `tfsdk:"action"`
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}

func (o *DynamicUpdatesDataSourceModel) CopyToPango(ctx context.Context, obj **dynamicupdates.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var updateSchedule_entry *dynamicupdates.UpdateSchedule
	if o.UpdateSchedule != nil {
		if *obj != nil && (*obj).UpdateSchedule != nil {
			updateSchedule_entry = (*obj).UpdateSchedule
		} else {
			updateSchedule_entry = new(dynamicupdates.UpdateSchedule)
		}

		diags.Append(o.UpdateSchedule.CopyToPango(ctx, &updateSchedule_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.Config)
	}
	(*obj).UpdateSchedule = updateSchedule_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateSchedule, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var threats_entry *dynamicupdates.UpdateScheduleThreats
	if o.Threats != nil {
		if *obj != nil && (*obj).Threats != nil {
			threats_entry = (*obj).Threats
		} else {
			threats_entry = new(dynamicupdates.UpdateScheduleThreats)
		}

		diags.Append(o.Threats.CopyToPango(ctx, &threats_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var wfPrivate_entry *dynamicupdates.UpdateScheduleWfPrivate
	if o.WfPrivate != nil {
		if *obj != nil && (*obj).WfPrivate != nil {
			wfPrivate_entry = (*obj).WfPrivate
		} else {
			wfPrivate_entry = new(dynamicupdates.UpdateScheduleWfPrivate)
		}

		diags.Append(o.WfPrivate.CopyToPango(ctx, &wfPrivate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var wildfire_entry *dynamicupdates.UpdateScheduleWildfire
	if o.Wildfire != nil {
		if *obj != nil && (*obj).Wildfire != nil {
			wildfire_entry = (*obj).Wildfire
		} else {
			wildfire_entry = new(dynamicupdates.UpdateScheduleWildfire)
		}

		diags.Append(o.Wildfire.CopyToPango(ctx, &wildfire_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var antiVirus_entry *dynamicupdates.UpdateScheduleAntiVirus
	if o.AntiVirus != nil {
		if *obj != nil && (*obj).AntiVirus != nil {
			antiVirus_entry = (*obj).AntiVirus
		} else {
			antiVirus_entry = new(dynamicupdates.UpdateScheduleAntiVirus)
		}

		diags.Append(o.AntiVirus.CopyToPango(ctx, &antiVirus_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var appProfile_entry *dynamicupdates.UpdateScheduleAppProfile
	if o.AppProfile != nil {
		if *obj != nil && (*obj).AppProfile != nil {
			appProfile_entry = (*obj).AppProfile
		} else {
			appProfile_entry = new(dynamicupdates.UpdateScheduleAppProfile)
		}

		diags.Append(o.AppProfile.CopyToPango(ctx, &appProfile_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectClientlessVpn_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn
	if o.GlobalProtectClientlessVpn != nil {
		if *obj != nil && (*obj).GlobalProtectClientlessVpn != nil {
			globalProtectClientlessVpn_entry = (*obj).GlobalProtectClientlessVpn
		} else {
			globalProtectClientlessVpn_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
		}

		diags.Append(o.GlobalProtectClientlessVpn.CopyToPango(ctx, &globalProtectClientlessVpn_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectDatafile_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafile
	if o.GlobalProtectDatafile != nil {
		if *obj != nil && (*obj).GlobalProtectDatafile != nil {
			globalProtectDatafile_entry = (*obj).GlobalProtectDatafile
		} else {
			globalProtectDatafile_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
		}

		diags.Append(o.GlobalProtectDatafile.CopyToPango(ctx, &globalProtectDatafile_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var statisticsService_entry *dynamicupdates.UpdateScheduleStatisticsService
	if o.StatisticsService != nil {
		if *obj != nil && (*obj).StatisticsService != nil {
			statisticsService_entry = (*obj).StatisticsService
		} else {
			statisticsService_entry = new(dynamicupdates.UpdateScheduleStatisticsService)
		}

		diags.Append(o.StatisticsService.CopyToPango(ctx, &statisticsService_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateSchedule)
	}
	(*obj).Threats = threats_entry
	(*obj).WfPrivate = wfPrivate_entry
	(*obj).Wildfire = wildfire_entry
	(*obj).AntiVirus = antiVirus_entry
	(*obj).AppProfile = appProfile_entry
	(*obj).GlobalProtectClientlessVpn = globalProtectClientlessVpn_entry
	(*obj).GlobalProtectDatafile = globalProtectDatafile_entry
	(*obj).StatisticsService = statisticsService_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreats, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleThreatsRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleThreatsRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreats)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	newAppThreshold_value := o.NewAppThreshold.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleThreatsRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins
	if o.Every30Mins != nil {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
		}

		diags.Append(o.Every30Mins.CopyToPango(ctx, &every30Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleThreatsRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleThreatsRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleThreatsRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurring)
	}
	(*obj).NewAppThreshold = newAppThreshold_value
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWfPrivateRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivate)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	var none_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every15Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins
	if o.Every15Mins != nil {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
		}

		diags.Append(o.Every15Mins.CopyToPango(ctx, &every15Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins
	if o.Every30Mins != nil {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
		}

		diags.Append(o.Every30Mins.CopyToPango(ctx, &every30Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every5Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins
	if o.Every5Mins != nil {
		if *obj != nil && (*obj).Every5Mins != nil {
			every5Mins_entry = (*obj).Every5Mins
		} else {
			every5Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
		}

		diags.Append(o.Every5Mins.CopyToPango(ctx, &every5Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour
	if o.EveryHour != nil {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
		}

		diags.Append(o.EveryHour.CopyToPango(ctx, &everyHour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).None = none_entry
	(*obj).Every15Mins = every15Mins_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Every5Mins = every5Mins_entry
	(*obj).EveryHour = everyHour_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWildfireRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWildfireRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfire)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var every30Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins
	if o.Every30Mins != nil {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
		}

		diags.Append(o.Every30Mins.CopyToPango(ctx, &every30Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour
	if o.EveryHour != nil {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
		}

		diags.Append(o.EveryHour.CopyToPango(ctx, &everyHour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyMin_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin
	if o.EveryMin != nil {
		if *obj != nil && (*obj).EveryMin != nil {
			everyMin_entry = (*obj).EveryMin
		} else {
			everyMin_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
		}

		diags.Append(o.EveryMin.CopyToPango(ctx, &everyMin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleWildfireRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var realTime_entry *dynamicupdates.UpdateScheduleWildfireRecurringRealTime
	if o.RealTime != nil {
		if *obj != nil && (*obj).RealTime != nil {
			realTime_entry = (*obj).RealTime
		} else {
			realTime_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
		}

		diags.Append(o.RealTime.CopyToPango(ctx, &realTime_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every15Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins
	if o.Every15Mins != nil {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
		}

		diags.Append(o.Every15Mins.CopyToPango(ctx, &every15Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurring)
	}
	(*obj).Every30Mins = every30Mins_entry
	(*obj).EveryHour = everyHour_entry
	(*obj).EveryMin = everyMin_entry
	(*obj).None = none_entry
	(*obj).RealTime = realTime_entry
	(*obj).Every15Mins = every15Mins_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
	}
	(*obj).Action = action_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringRealTime, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirus, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAntiVirusRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirus)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
	}
	(*obj).At = at_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
	}
	(*obj).At = at_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAppProfileRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleAppProfileRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAppProfileRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
	}
	(*obj).At = at_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
	}
	(*obj).At = at_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleStatisticsService, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	applicationReports_value := o.ApplicationReports.ValueBoolPointer()
	fileIdentificationReports_value := o.FileIdentificationReports.ValueBoolPointer()
	healthPerformanceReports_value := o.HealthPerformanceReports.ValueBoolPointer()
	passiveDnsMonitoring_value := o.PassiveDnsMonitoring.ValueBoolPointer()
	threatPreventionInformation_value := o.ThreatPreventionInformation.ValueBoolPointer()
	threatPreventionPcap_value := o.ThreatPreventionPcap.ValueBoolPointer()
	threatPreventionReports_value := o.ThreatPreventionReports.ValueBoolPointer()
	urlReports_value := o.UrlReports.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleStatisticsService)
	}
	(*obj).ApplicationReports = applicationReports_value
	(*obj).FileIdentificationReports = fileIdentificationReports_value
	(*obj).HealthPerformanceReports = healthPerformanceReports_value
	(*obj).PassiveDnsMonitoring = passiveDnsMonitoring_value
	(*obj).ThreatPreventionInformation = threatPreventionInformation_value
	(*obj).ThreatPreventionPcap = threatPreventionPcap_value
	(*obj).ThreatPreventionReports = threatPreventionReports_value
	(*obj).UrlReports = urlReports_value

	return diags
}

func (o *DynamicUpdatesDataSourceModel) CopyFromPango(ctx context.Context, obj *dynamicupdates.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var updateSchedule_object *DynamicUpdatesDataSourceUpdateScheduleObject
	if obj.UpdateSchedule != nil {
		updateSchedule_object = new(DynamicUpdatesDataSourceUpdateScheduleObject)

		diags.Append(updateSchedule_object.CopyFromPango(ctx, obj.UpdateSchedule, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.UpdateSchedule = updateSchedule_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateSchedule, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var wfPrivate_object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject
	if obj.WfPrivate != nil {
		wfPrivate_object = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject)

		diags.Append(wfPrivate_object.CopyFromPango(ctx, obj.WfPrivate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var wildfire_object *DynamicUpdatesDataSourceUpdateScheduleWildfireObject
	if obj.Wildfire != nil {
		wildfire_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireObject)

		diags.Append(wildfire_object.CopyFromPango(ctx, obj.Wildfire, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var antiVirus_object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject
	if obj.AntiVirus != nil {
		antiVirus_object = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject)

		diags.Append(antiVirus_object.CopyFromPango(ctx, obj.AntiVirus, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var appProfile_object *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject
	if obj.AppProfile != nil {
		appProfile_object = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileObject)

		diags.Append(appProfile_object.CopyFromPango(ctx, obj.AppProfile, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectClientlessVpn_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject
	if obj.GlobalProtectClientlessVpn != nil {
		globalProtectClientlessVpn_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject)

		diags.Append(globalProtectClientlessVpn_object.CopyFromPango(ctx, obj.GlobalProtectClientlessVpn, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectDatafile_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject
	if obj.GlobalProtectDatafile != nil {
		globalProtectDatafile_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject)

		diags.Append(globalProtectDatafile_object.CopyFromPango(ctx, obj.GlobalProtectDatafile, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var statisticsService_object *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject
	if obj.StatisticsService != nil {
		statisticsService_object = new(DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject)

		diags.Append(statisticsService_object.CopyFromPango(ctx, obj.StatisticsService, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var threats_object *DynamicUpdatesDataSourceUpdateScheduleThreatsObject
	if obj.Threats != nil {
		threats_object = new(DynamicUpdatesDataSourceUpdateScheduleThreatsObject)

		diags.Append(threats_object.CopyFromPango(ctx, obj.Threats, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.WfPrivate = wfPrivate_object
	o.Wildfire = wildfire_object
	o.AntiVirus = antiVirus_object
	o.AppProfile = appProfile_object
	o.GlobalProtectClientlessVpn = globalProtectClientlessVpn_object
	o.GlobalProtectDatafile = globalProtectDatafile_object
	o.StatisticsService = statisticsService_object
	o.Threats = threats_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirus, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.At = at_value
	o.Action = action_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value
	o.Action = action_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleStatisticsService, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var fileIdentificationReports_value types.Bool
	if obj.FileIdentificationReports != nil {
		fileIdentificationReports_value = types.BoolValue(*obj.FileIdentificationReports)
	}
	var healthPerformanceReports_value types.Bool
	if obj.HealthPerformanceReports != nil {
		healthPerformanceReports_value = types.BoolValue(*obj.HealthPerformanceReports)
	}
	var passiveDnsMonitoring_value types.Bool
	if obj.PassiveDnsMonitoring != nil {
		passiveDnsMonitoring_value = types.BoolValue(*obj.PassiveDnsMonitoring)
	}
	var threatPreventionInformation_value types.Bool
	if obj.ThreatPreventionInformation != nil {
		threatPreventionInformation_value = types.BoolValue(*obj.ThreatPreventionInformation)
	}
	var threatPreventionPcap_value types.Bool
	if obj.ThreatPreventionPcap != nil {
		threatPreventionPcap_value = types.BoolValue(*obj.ThreatPreventionPcap)
	}
	var threatPreventionReports_value types.Bool
	if obj.ThreatPreventionReports != nil {
		threatPreventionReports_value = types.BoolValue(*obj.ThreatPreventionReports)
	}
	var urlReports_value types.Bool
	if obj.UrlReports != nil {
		urlReports_value = types.BoolValue(*obj.UrlReports)
	}
	var applicationReports_value types.Bool
	if obj.ApplicationReports != nil {
		applicationReports_value = types.BoolValue(*obj.ApplicationReports)
	}
	o.FileIdentificationReports = fileIdentificationReports_value
	o.HealthPerformanceReports = healthPerformanceReports_value
	o.PassiveDnsMonitoring = passiveDnsMonitoring_value
	o.ThreatPreventionInformation = threatPreventionInformation_value
	o.ThreatPreventionPcap = threatPreventionPcap_value
	o.ThreatPreventionReports = threatPreventionReports_value
	o.UrlReports = urlReports_value
	o.ApplicationReports = applicationReports_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreats, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject
	if obj.Every30Mins != nil {
		every30Mins_object = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject)

		diags.Append(every30Mins_object.CopyFromPango(ctx, obj.Every30Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	var newAppThreshold_value types.Int64
	if obj.NewAppThreshold != nil {
		newAppThreshold_value = types.Int64Value(*obj.NewAppThreshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.NewAppThreshold = newAppThreshold_value
	o.Daily = daily_object
	o.Every30Mins = every30Mins_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var everyHour_object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject
	if obj.EveryHour != nil {
		everyHour_object = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject)

		diags.Append(everyHour_object.CopyFromPango(ctx, obj.EveryHour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every15Mins_object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject
	if obj.Every15Mins != nil {
		every15Mins_object = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject)

		diags.Append(every15Mins_object.CopyFromPango(ctx, obj.Every15Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject
	if obj.Every30Mins != nil {
		every30Mins_object = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject)

		diags.Append(every30Mins_object.CopyFromPango(ctx, obj.Every30Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every5Mins_object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject
	if obj.Every5Mins != nil {
		every5Mins_object = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject)

		diags.Append(every5Mins_object.CopyFromPango(ctx, obj.Every5Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.SyncToPeer = syncToPeer_value
	o.EveryHour = everyHour_object
	o.None = none_object
	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object
	o.Every5Mins = every5Mins_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var everyHour_object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject
	if obj.EveryHour != nil {
		everyHour_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject)

		diags.Append(everyHour_object.CopyFromPango(ctx, obj.EveryHour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyMin_object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject
	if obj.EveryMin != nil {
		everyMin_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject)

		diags.Append(everyMin_object.CopyFromPango(ctx, obj.EveryMin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var realTime_object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject
	if obj.RealTime != nil {
		realTime_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject)

		diags.Append(realTime_object.CopyFromPango(ctx, obj.RealTime, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every15Mins_object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject
	if obj.Every15Mins != nil {
		every15Mins_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject)

		diags.Append(every15Mins_object.CopyFromPango(ctx, obj.Every15Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject
	if obj.Every30Mins != nil {
		every30Mins_object = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject)

		diags.Append(every30Mins_object.CopyFromPango(ctx, obj.Every30Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.EveryHour = everyHour_object
	o.EveryMin = everyMin_object
	o.None = none_object
	o.RealTime = realTime_object
	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringRealTime, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func DynamicUpdatesDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": DynamicUpdatesDataSourceLocationSchema(),

			"update_schedule": DynamicUpdatesDataSourceUpdateScheduleSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceModel) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"wf_private": DynamicUpdatesDataSourceUpdateScheduleWfPrivateSchema(),

			"wildfire": DynamicUpdatesDataSourceUpdateScheduleWildfireSchema(),

			"anti_virus": DynamicUpdatesDataSourceUpdateScheduleAntiVirusSchema(),

			"app_profile": DynamicUpdatesDataSourceUpdateScheduleAppProfileSchema(),

			"global_protect_clientless_vpn": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnSchema(),

			"global_protect_datafile": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileSchema(),

			"statistics_service": DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceSchema(),

			"threats": DynamicUpdatesDataSourceUpdateScheduleThreatsSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"every_15_mins": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsSchema(),

			"every_hour": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourSchema(),

			"every_min": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinSchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneSchema(),

			"real_time": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past quarter-hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"threshold": dsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailySchema(),

			"hourly": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"daily": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema(),

			"hourly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"daily": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema(),

			"hourly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"file_identification_reports": dsschema.BoolAttribute{
				Description: "File Type Identification Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"health_performance_reports": dsschema.BoolAttribute{
				Description: "Health and Performance Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive_dns_monitoring": dsschema.BoolAttribute{
				Description: "Passive DNS Monitor",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_information": dsschema.BoolAttribute{
				Description: "Threat Prevention Information",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_pcap": dsschema.BoolAttribute{
				Description: "Enable sending packet-captures with threat prevention information",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_reports": dsschema.BoolAttribute{
				Description: "Threat Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"url_reports": dsschema.BoolAttribute{
				Description: "URL Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"application_reports": dsschema.BoolAttribute{
				Description: "Application Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"threshold": dsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"new_app_threshold": dsschema.Int64Attribute{
				Description: "ignore new apps if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hourly": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklySchema(),

			"daily": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailySchema(),

			"every_30_mins": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"every_15_mins": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema(),

			"every_5_mins": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema(),

			"every_hour": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourSchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past Quarter-Hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past Half-Hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past five minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past Hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceLocationSchema() rsschema.Attribute {
	return DynamicUpdatesLocationSchema()
}

// Metadata returns the data source type name.
func (d *DynamicUpdatesDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dynamic_updates"
}

// Schema defines the schema for this data source.
func (d *DynamicUpdatesDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = DynamicUpdatesDataSourceSchema()
}

// Configure prepares the struct.
func (d *DynamicUpdatesDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := dynamicupdates.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewConfigObjectManager(d.client, dynamicupdates.NewService(d.client), specifier)
}
func (o *DynamicUpdatesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state DynamicUpdatesDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location dynamicupdates.Location

	if savestate.Location.System != nil {
		location.System = &dynamicupdates.SystemLocation{

			NgfwDevice: savestate.Location.System.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Template != nil {
		location.Template = &dynamicupdates.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &dynamicupdates.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Read",
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &DynamicUpdatesResource{}
	_ resource.ResourceWithConfigure   = &DynamicUpdatesResource{}
	_ resource.ResourceWithImportState = &DynamicUpdatesResource{}
)

func NewDynamicUpdatesResource() resource.Resource {
	return &DynamicUpdatesResource{}
}

type DynamicUpdatesResource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*dynamicupdates.Config, dynamicupdates.Location, *dynamicupdates.Service]
}

func DynamicUpdatesResourceLocationSchema() rsschema.Attribute {
	return DynamicUpdatesLocationSchema()
}

type DynamicUpdatesResourceModel struct {
	Location       DynamicUpdatesLocation                      `tfsdk:"location"`
	UpdateSchedule *DynamicUpdatesResourceUpdateScheduleObject `tfsdk:"update_schedule"`
}
type DynamicUpdatesResourceUpdateScheduleObject struct {
	StatisticsService          *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject          `tfsdk:"statistics_service"`
	Threats                    *DynamicUpdatesResourceUpdateScheduleThreatsObject                    `tfsdk:"threats"`
	WfPrivate                  *DynamicUpdatesResourceUpdateScheduleWfPrivateObject                  `tfsdk:"wf_private"`
	Wildfire                   *DynamicUpdatesResourceUpdateScheduleWildfireObject                   `tfsdk:"wildfire"`
	AntiVirus                  *DynamicUpdatesResourceUpdateScheduleAntiVirusObject                  `tfsdk:"anti_virus"`
	AppProfile                 *DynamicUpdatesResourceUpdateScheduleAppProfileObject                 `tfsdk:"app_profile"`
	GlobalProtectClientlessVpn *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject `tfsdk:"global_protect_clientless_vpn"`
	GlobalProtectDatafile      *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject      `tfsdk:"global_protect_datafile"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject struct {
	Recurring *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject struct {
	Daily  *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject  `tfsdk:"daily"`
	Hourly *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject `tfsdk:"hourly"`
	None   *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject   `tfsdk:"none"`
	Weekly *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject struct {
	Recurring *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject struct {
	Daily  *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject  `tfsdk:"daily"`
	Hourly *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject `tfsdk:"hourly"`
	None   *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject   `tfsdk:"none"`
	Weekly *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject struct {
	At     types.String `tfsdk:"at"`
	Action types.String `tfsdk:"action"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject struct {
	ThreatPreventionInformation types.Bool `tfsdk:"threat_prevention_information"`
	ThreatPreventionPcap        types.Bool `tfsdk:"threat_prevention_pcap"`
	ThreatPreventionReports     types.Bool `tfsdk:"threat_prevention_reports"`
	UrlReports                  types.Bool `tfsdk:"url_reports"`
	ApplicationReports          types.Bool `tfsdk:"application_reports"`
	FileIdentificationReports   types.Bool `tfsdk:"file_identification_reports"`
	HealthPerformanceReports    types.Bool `tfsdk:"health_performance_reports"`
	PassiveDnsMonitoring        types.Bool `tfsdk:"passive_dns_monitoring"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsObject struct {
	Recurring *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject struct {
	NewAppThreshold types.Int64                                                            `tfsdk:"new_app_threshold"`
	SyncToPeer      types.Bool                                                             `tfsdk:"sync_to_peer"`
	Threshold       types.Int64                                                            `tfsdk:"threshold"`
	Daily           *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject       `tfsdk:"daily"`
	Every30Mins     *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject `tfsdk:"every_30_mins"`
	Hourly          *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject      `tfsdk:"hourly"`
	None            *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject        `tfsdk:"none"`
	Weekly          *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject      `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DayOfWeek         types.String `tfsdk:"day_of_week"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateObject struct {
	Recurring *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject struct {
	SyncToPeer  types.Bool                                                               `tfsdk:"sync_to_peer"`
	Every30Mins *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject `tfsdk:"every_30_mins"`
	Every5Mins  *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject  `tfsdk:"every_5_mins"`
	EveryHour   *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject   `tfsdk:"every_hour"`
	None        *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject        `tfsdk:"none"`
	Every15Mins *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject `tfsdk:"every_15_mins"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireObject struct {
	Recurring *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject struct {
	Every15Mins *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject `tfsdk:"every_15_mins"`
	Every30Mins *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject `tfsdk:"every_30_mins"`
	EveryHour   *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject   `tfsdk:"every_hour"`
	EveryMin    *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject    `tfsdk:"every_min"`
	None        *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject        `tfsdk:"none"`
	RealTime    *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject    `tfsdk:"real_time"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject struct {
	Action     types.String `tfsdk:"action"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject struct {
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusObject struct {
	Recurring *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject struct {
	SyncToPeer types.Bool                                                          `tfsdk:"sync_to_peer"`
	Threshold  types.Int64                                                         `tfsdk:"threshold"`
	Daily      *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject  `tfsdk:"daily"`
	Hourly     *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject `tfsdk:"hourly"`
	None       *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject   `tfsdk:"none"`
	Weekly     *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileObject struct {
	Recurring *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject struct {
	SyncToPeer types.Bool                                                           `tfsdk:"sync_to_peer"`
	Threshold  types.Int64                                                          `tfsdk:"threshold"`
	Weekly     *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject `tfsdk:"weekly"`
	Daily      *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject  `tfsdk:"daily"`
	None       *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject   `tfsdk:"none"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}

func (r *DynamicUpdatesResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func DynamicUpdatesResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": DynamicUpdatesResourceLocationSchema(),

			"update_schedule": DynamicUpdatesResourceUpdateScheduleSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceModel) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"app_profile": DynamicUpdatesResourceUpdateScheduleAppProfileSchema(),

			"global_protect_clientless_vpn": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnSchema(),

			"global_protect_datafile": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileSchema(),

			"statistics_service": DynamicUpdatesResourceUpdateScheduleStatisticsServiceSchema(),

			"threats": DynamicUpdatesResourceUpdateScheduleThreatsSchema(),

			"wf_private": DynamicUpdatesResourceUpdateScheduleWfPrivateSchema(),

			"wildfire": DynamicUpdatesResourceUpdateScheduleWildfireSchema(),

			"anti_virus": DynamicUpdatesResourceUpdateScheduleAntiVirusSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleStatisticsServiceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_dns_monitoring": rsschema.BoolAttribute{
				Description: "Passive DNS Monitor",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_information": rsschema.BoolAttribute{
				Description: "Threat Prevention Information",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_pcap": rsschema.BoolAttribute{
				Description: "Enable sending packet-captures with threat prevention information",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_reports": rsschema.BoolAttribute{
				Description: "Threat Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"url_reports": rsschema.BoolAttribute{
				Description: "URL Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"application_reports": rsschema.BoolAttribute{
				Description: "Application Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"file_identification_reports": rsschema.BoolAttribute{
				Description: "File Type Identification Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"health_performance_reports": rsschema.BoolAttribute{
				Description: "Health and Performance Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleStatisticsServiceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleThreatsRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"new_app_threshold": rsschema.Int64Attribute{
				Description: "ignore new apps if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailySchema(),

			"every_30_mins": DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsSchema(),

			"hourly": DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"every_15_mins": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema(),

			"every_5_mins": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema(),

			"every_hour": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourSchema(),

			"none": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past five minutes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past Hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past Quarter-Hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past Half-Hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleWildfireRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"every_15_mins": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsSchema(),

			"every_hour": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourSchema(),

			"every_min": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinSchema(),

			"none": DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneSchema(),

			"real_time": DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past quarter-hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailySchema(),

			"hourly": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weekly": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklySchema(),

			"daily": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hourly": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema(),

			"daily": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema(),

			"daily": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema(),

			"hourly": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *DynamicUpdatesResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dynamic_updates"
}

func (r *DynamicUpdatesResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = DynamicUpdatesResourceSchema()
}

// </ResourceSchema>

func (r *DynamicUpdatesResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := dynamicupdates.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewConfigObjectManager(r.client, dynamicupdates.NewService(r.client), specifier)
}

func (o *DynamicUpdatesResourceModel) CopyToPango(ctx context.Context, obj **dynamicupdates.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var updateSchedule_entry *dynamicupdates.UpdateSchedule
	if o.UpdateSchedule != nil {
		if *obj != nil && (*obj).UpdateSchedule != nil {
			updateSchedule_entry = (*obj).UpdateSchedule
		} else {
			updateSchedule_entry = new(dynamicupdates.UpdateSchedule)
		}

		diags.Append(o.UpdateSchedule.CopyToPango(ctx, &updateSchedule_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.Config)
	}
	(*obj).UpdateSchedule = updateSchedule_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateSchedule, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var threats_entry *dynamicupdates.UpdateScheduleThreats
	if o.Threats != nil {
		if *obj != nil && (*obj).Threats != nil {
			threats_entry = (*obj).Threats
		} else {
			threats_entry = new(dynamicupdates.UpdateScheduleThreats)
		}

		diags.Append(o.Threats.CopyToPango(ctx, &threats_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var wfPrivate_entry *dynamicupdates.UpdateScheduleWfPrivate
	if o.WfPrivate != nil {
		if *obj != nil && (*obj).WfPrivate != nil {
			wfPrivate_entry = (*obj).WfPrivate
		} else {
			wfPrivate_entry = new(dynamicupdates.UpdateScheduleWfPrivate)
		}

		diags.Append(o.WfPrivate.CopyToPango(ctx, &wfPrivate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var wildfire_entry *dynamicupdates.UpdateScheduleWildfire
	if o.Wildfire != nil {
		if *obj != nil && (*obj).Wildfire != nil {
			wildfire_entry = (*obj).Wildfire
		} else {
			wildfire_entry = new(dynamicupdates.UpdateScheduleWildfire)
		}

		diags.Append(o.Wildfire.CopyToPango(ctx, &wildfire_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var antiVirus_entry *dynamicupdates.UpdateScheduleAntiVirus
	if o.AntiVirus != nil {
		if *obj != nil && (*obj).AntiVirus != nil {
			antiVirus_entry = (*obj).AntiVirus
		} else {
			antiVirus_entry = new(dynamicupdates.UpdateScheduleAntiVirus)
		}

		diags.Append(o.AntiVirus.CopyToPango(ctx, &antiVirus_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var appProfile_entry *dynamicupdates.UpdateScheduleAppProfile
	if o.AppProfile != nil {
		if *obj != nil && (*obj).AppProfile != nil {
			appProfile_entry = (*obj).AppProfile
		} else {
			appProfile_entry = new(dynamicupdates.UpdateScheduleAppProfile)
		}

		diags.Append(o.AppProfile.CopyToPango(ctx, &appProfile_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectClientlessVpn_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn
	if o.GlobalProtectClientlessVpn != nil {
		if *obj != nil && (*obj).GlobalProtectClientlessVpn != nil {
			globalProtectClientlessVpn_entry = (*obj).GlobalProtectClientlessVpn
		} else {
			globalProtectClientlessVpn_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
		}

		diags.Append(o.GlobalProtectClientlessVpn.CopyToPango(ctx, &globalProtectClientlessVpn_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectDatafile_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafile
	if o.GlobalProtectDatafile != nil {
		if *obj != nil && (*obj).GlobalProtectDatafile != nil {
			globalProtectDatafile_entry = (*obj).GlobalProtectDatafile
		} else {
			globalProtectDatafile_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
		}

		diags.Append(o.GlobalProtectDatafile.CopyToPango(ctx, &globalProtectDatafile_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var statisticsService_entry *dynamicupdates.UpdateScheduleStatisticsService
	if o.StatisticsService != nil {
		if *obj != nil && (*obj).StatisticsService != nil {
			statisticsService_entry = (*obj).StatisticsService
		} else {
			statisticsService_entry = new(dynamicupdates.UpdateScheduleStatisticsService)
		}

		diags.Append(o.StatisticsService.CopyToPango(ctx, &statisticsService_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateSchedule)
	}
	(*obj).Threats = threats_entry
	(*obj).WfPrivate = wfPrivate_entry
	(*obj).Wildfire = wildfire_entry
	(*obj).AntiVirus = antiVirus_entry
	(*obj).AppProfile = appProfile_entry
	(*obj).GlobalProtectClientlessVpn = globalProtectClientlessVpn_entry
	(*obj).GlobalProtectDatafile = globalProtectDatafile_entry
	(*obj).StatisticsService = statisticsService_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleStatisticsService, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	threatPreventionPcap_value := o.ThreatPreventionPcap.ValueBoolPointer()
	threatPreventionReports_value := o.ThreatPreventionReports.ValueBoolPointer()
	urlReports_value := o.UrlReports.ValueBoolPointer()
	applicationReports_value := o.ApplicationReports.ValueBoolPointer()
	fileIdentificationReports_value := o.FileIdentificationReports.ValueBoolPointer()
	healthPerformanceReports_value := o.HealthPerformanceReports.ValueBoolPointer()
	passiveDnsMonitoring_value := o.PassiveDnsMonitoring.ValueBoolPointer()
	threatPreventionInformation_value := o.ThreatPreventionInformation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleStatisticsService)
	}
	(*obj).ThreatPreventionPcap = threatPreventionPcap_value
	(*obj).ThreatPreventionReports = threatPreventionReports_value
	(*obj).UrlReports = urlReports_value
	(*obj).ApplicationReports = applicationReports_value
	(*obj).FileIdentificationReports = fileIdentificationReports_value
	(*obj).HealthPerformanceReports = healthPerformanceReports_value
	(*obj).PassiveDnsMonitoring = passiveDnsMonitoring_value
	(*obj).ThreatPreventionInformation = threatPreventionInformation_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreats, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleThreatsRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleThreatsRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreats)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	newAppThreshold_value := o.NewAppThreshold.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var none_entry *dynamicupdates.UpdateScheduleThreatsRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleThreatsRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *dynamicupdates.UpdateScheduleThreatsRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins
	if o.Every30Mins != nil {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
		}

		diags.Append(o.Every30Mins.CopyToPango(ctx, &every30Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleThreatsRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurring)
	}
	(*obj).NewAppThreshold = newAppThreshold_value
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Hourly = hourly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleThreatsRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWfPrivateRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivate)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	var every15Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins
	if o.Every15Mins != nil {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
		}

		diags.Append(o.Every15Mins.CopyToPango(ctx, &every15Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins
	if o.Every30Mins != nil {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
		}

		diags.Append(o.Every30Mins.CopyToPango(ctx, &every30Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every5Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins
	if o.Every5Mins != nil {
		if *obj != nil && (*obj).Every5Mins != nil {
			every5Mins_entry = (*obj).Every5Mins
		} else {
			every5Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
		}

		diags.Append(o.Every5Mins.CopyToPango(ctx, &every5Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour
	if o.EveryHour != nil {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
		}

		diags.Append(o.EveryHour.CopyToPango(ctx, &everyHour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Every15Mins = every15Mins_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Every5Mins = every5Mins_entry
	(*obj).EveryHour = everyHour_entry
	(*obj).None = none_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWildfireRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWildfireRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfire)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *dynamicupdates.UpdateScheduleWildfireRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var realTime_entry *dynamicupdates.UpdateScheduleWildfireRecurringRealTime
	if o.RealTime != nil {
		if *obj != nil && (*obj).RealTime != nil {
			realTime_entry = (*obj).RealTime
		} else {
			realTime_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
		}

		diags.Append(o.RealTime.CopyToPango(ctx, &realTime_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every15Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins
	if o.Every15Mins != nil {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
		}

		diags.Append(o.Every15Mins.CopyToPango(ctx, &every15Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins
	if o.Every30Mins != nil {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
		}

		diags.Append(o.Every30Mins.CopyToPango(ctx, &every30Mins_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour
	if o.EveryHour != nil {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
		}

		diags.Append(o.EveryHour.CopyToPango(ctx, &everyHour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyMin_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin
	if o.EveryMin != nil {
		if *obj != nil && (*obj).EveryMin != nil {
			everyMin_entry = (*obj).EveryMin
		} else {
			everyMin_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
		}

		diags.Append(o.EveryMin.CopyToPango(ctx, &everyMin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurring)
	}
	(*obj).None = none_entry
	(*obj).RealTime = realTime_entry
	(*obj).Every15Mins = every15Mins_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).EveryHour = everyHour_entry
	(*obj).EveryMin = everyMin_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
	}
	(*obj).Action = action_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleWildfireRecurringRealTime, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirus, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAntiVirusRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirus)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	var daily_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
	}
	(*obj).Threshold = threshold_value
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
	}
	(*obj).At = at_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
	}
	(*obj).At = at_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAppProfileRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var weekly_entry *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *dynamicupdates.UpdateScheduleAppProfileRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAppProfileRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).None = none_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
	}
	(*obj).At = at_value
	(*obj).Action = action_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
	}
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
	}
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesResourceModel) CopyFromPango(ctx context.Context, obj *dynamicupdates.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var updateSchedule_object *DynamicUpdatesResourceUpdateScheduleObject
	if obj.UpdateSchedule != nil {
		updateSchedule_object = new(DynamicUpdatesResourceUpdateScheduleObject)

		diags.Append(updateSchedule_object.CopyFromPango(ctx, obj.UpdateSchedule, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.UpdateSchedule = updateSchedule_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateSchedule, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var globalProtectDatafile_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject
	if obj.GlobalProtectDatafile != nil {
		globalProtectDatafile_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject)

		diags.Append(globalProtectDatafile_object.CopyFromPango(ctx, obj.GlobalProtectDatafile, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var statisticsService_object *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject
	if obj.StatisticsService != nil {
		statisticsService_object = new(DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject)

		diags.Append(statisticsService_object.CopyFromPango(ctx, obj.StatisticsService, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var threats_object *DynamicUpdatesResourceUpdateScheduleThreatsObject
	if obj.Threats != nil {
		threats_object = new(DynamicUpdatesResourceUpdateScheduleThreatsObject)

		diags.Append(threats_object.CopyFromPango(ctx, obj.Threats, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var wfPrivate_object *DynamicUpdatesResourceUpdateScheduleWfPrivateObject
	if obj.WfPrivate != nil {
		wfPrivate_object = new(DynamicUpdatesResourceUpdateScheduleWfPrivateObject)

		diags.Append(wfPrivate_object.CopyFromPango(ctx, obj.WfPrivate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var wildfire_object *DynamicUpdatesResourceUpdateScheduleWildfireObject
	if obj.Wildfire != nil {
		wildfire_object = new(DynamicUpdatesResourceUpdateScheduleWildfireObject)

		diags.Append(wildfire_object.CopyFromPango(ctx, obj.Wildfire, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var antiVirus_object *DynamicUpdatesResourceUpdateScheduleAntiVirusObject
	if obj.AntiVirus != nil {
		antiVirus_object = new(DynamicUpdatesResourceUpdateScheduleAntiVirusObject)

		diags.Append(antiVirus_object.CopyFromPango(ctx, obj.AntiVirus, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var appProfile_object *DynamicUpdatesResourceUpdateScheduleAppProfileObject
	if obj.AppProfile != nil {
		appProfile_object = new(DynamicUpdatesResourceUpdateScheduleAppProfileObject)

		diags.Append(appProfile_object.CopyFromPango(ctx, obj.AppProfile, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectClientlessVpn_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject
	if obj.GlobalProtectClientlessVpn != nil {
		globalProtectClientlessVpn_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject)

		diags.Append(globalProtectClientlessVpn_object.CopyFromPango(ctx, obj.GlobalProtectClientlessVpn, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.GlobalProtectDatafile = globalProtectDatafile_object
	o.StatisticsService = statisticsService_object
	o.Threats = threats_object
	o.WfPrivate = wfPrivate_object
	o.Wildfire = wildfire_object
	o.AntiVirus = antiVirus_object
	o.AppProfile = appProfile_object
	o.GlobalProtectClientlessVpn = globalProtectClientlessVpn_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var every15Mins_object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject
	if obj.Every15Mins != nil {
		every15Mins_object = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject)

		diags.Append(every15Mins_object.CopyFromPango(ctx, obj.Every15Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject
	if obj.Every30Mins != nil {
		every30Mins_object = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject)

		diags.Append(every30Mins_object.CopyFromPango(ctx, obj.Every30Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every5Mins_object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject
	if obj.Every5Mins != nil {
		every5Mins_object = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject)

		diags.Append(every5Mins_object.CopyFromPango(ctx, obj.Every5Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject
	if obj.EveryHour != nil {
		everyHour_object = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject)

		diags.Append(everyHour_object.CopyFromPango(ctx, obj.EveryHour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.SyncToPeer = syncToPeer_value
	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object
	o.Every5Mins = every5Mins_object
	o.EveryHour = everyHour_object
	o.None = none_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var everyHour_object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject
	if obj.EveryHour != nil {
		everyHour_object = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject)

		diags.Append(everyHour_object.CopyFromPango(ctx, obj.EveryHour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyMin_object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject
	if obj.EveryMin != nil {
		everyMin_object = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject)

		diags.Append(everyMin_object.CopyFromPango(ctx, obj.EveryMin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var realTime_object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject
	if obj.RealTime != nil {
		realTime_object = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject)

		diags.Append(realTime_object.CopyFromPango(ctx, obj.RealTime, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every15Mins_object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject
	if obj.Every15Mins != nil {
		every15Mins_object = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject)

		diags.Append(every15Mins_object.CopyFromPango(ctx, obj.Every15Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject
	if obj.Every30Mins != nil {
		every30Mins_object = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject)

		diags.Append(every30Mins_object.CopyFromPango(ctx, obj.Every30Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.EveryHour = everyHour_object
	o.EveryMin = everyMin_object
	o.None = none_object
	o.RealTime = realTime_object
	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleWildfireRecurringRealTime, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirus, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Threshold = threshold_value
	o.SyncToPeer = syncToPeer_value
	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.DayOfWeek = dayOfWeek_value
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleAppProfileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value
	o.Action = action_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hourly_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object
	o.Daily = daily_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value
	o.Action = action_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.At = at_value
	o.Action = action_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleStatisticsService, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var threatPreventionReports_value types.Bool
	if obj.ThreatPreventionReports != nil {
		threatPreventionReports_value = types.BoolValue(*obj.ThreatPreventionReports)
	}
	var urlReports_value types.Bool
	if obj.UrlReports != nil {
		urlReports_value = types.BoolValue(*obj.UrlReports)
	}
	var applicationReports_value types.Bool
	if obj.ApplicationReports != nil {
		applicationReports_value = types.BoolValue(*obj.ApplicationReports)
	}
	var fileIdentificationReports_value types.Bool
	if obj.FileIdentificationReports != nil {
		fileIdentificationReports_value = types.BoolValue(*obj.FileIdentificationReports)
	}
	var healthPerformanceReports_value types.Bool
	if obj.HealthPerformanceReports != nil {
		healthPerformanceReports_value = types.BoolValue(*obj.HealthPerformanceReports)
	}
	var passiveDnsMonitoring_value types.Bool
	if obj.PassiveDnsMonitoring != nil {
		passiveDnsMonitoring_value = types.BoolValue(*obj.PassiveDnsMonitoring)
	}
	var threatPreventionInformation_value types.Bool
	if obj.ThreatPreventionInformation != nil {
		threatPreventionInformation_value = types.BoolValue(*obj.ThreatPreventionInformation)
	}
	var threatPreventionPcap_value types.Bool
	if obj.ThreatPreventionPcap != nil {
		threatPreventionPcap_value = types.BoolValue(*obj.ThreatPreventionPcap)
	}
	o.ThreatPreventionReports = threatPreventionReports_value
	o.UrlReports = urlReports_value
	o.ApplicationReports = applicationReports_value
	o.FileIdentificationReports = fileIdentificationReports_value
	o.HealthPerformanceReports = healthPerformanceReports_value
	o.PassiveDnsMonitoring = passiveDnsMonitoring_value
	o.ThreatPreventionInformation = threatPreventionInformation_value
	o.ThreatPreventionPcap = threatPreventionPcap_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreats, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var weekly_object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject
	if obj.Every30Mins != nil {
		every30Mins_object = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject)

		diags.Append(every30Mins_object.CopyFromPango(ctx, obj.Every30Mins, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject
	if obj.None != nil {
		none_object = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var newAppThreshold_value types.Int64
	if obj.NewAppThreshold != nil {
		newAppThreshold_value = types.Int64Value(*obj.NewAppThreshold)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.NewAppThreshold = newAppThreshold_value
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Weekly = weekly_object
	o.Daily = daily_object
	o.Every30Mins = every30Mins_object
	o.Hourly = hourly_object
	o.None = none_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, obj *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.At = at_value
	o.DisableNewContent = disableNewContent_value
	o.Action = action_value

	return diags
}

func (r *DynamicUpdatesResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Create",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location dynamicupdates.Location

	if state.Location.TemplateStack != nil {
		location.TemplateStack = &dynamicupdates.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if state.Location.System != nil {
		location.System = &dynamicupdates.SystemLocation{

			NgfwDevice: state.Location.System.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &dynamicupdates.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *dynamicupdates.Config

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *DynamicUpdatesResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location dynamicupdates.Location

	if savestate.Location.System != nil {
		location.System = &dynamicupdates.SystemLocation{

			NgfwDevice: savestate.Location.System.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Template != nil {
		location.Template = &dynamicupdates.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &dynamicupdates.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Read",
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *DynamicUpdatesResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location dynamicupdates.Location

	if state.Location.System != nil {
		location.System = &dynamicupdates.SystemLocation{

			NgfwDevice: state.Location.System.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &dynamicupdates.TemplateLocation{

			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &dynamicupdates.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *DynamicUpdatesResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Delete",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location dynamicupdates.Location

	if state.Location.System != nil {
		location.System = &dynamicupdates.SystemLocation{

			NgfwDevice: state.Location.System.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &dynamicupdates.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &dynamicupdates.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	var obj *dynamicupdates.Config
	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.manager.Delete(ctx, location, obj)
	if err != nil && errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

func (r *DynamicUpdatesResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

}

type DynamicUpdatesTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type DynamicUpdatesSystemLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type DynamicUpdatesTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type DynamicUpdatesLocation struct {
	TemplateStack *DynamicUpdatesTemplateStackLocation `tfsdk:"template_stack"`
	System        *DynamicUpdatesSystemLocation        `tfsdk:"system"`
	Template      *DynamicUpdatesTemplateLocation      `tfsdk:"template"`
}

func DynamicUpdatesLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"system": rsschema.SingleNestedAttribute{
				Description: "Located in a system settings.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("system"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template stack.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o DynamicUpdatesSystemLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		NgfwDevice *string `json:"ngfw_device"`
	}{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesSystemLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DynamicUpdatesTemplateLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DynamicUpdatesTemplateStackLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DynamicUpdatesLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		System        *DynamicUpdatesSystemLocation        `json:"system"`
		Template      *DynamicUpdatesTemplateLocation      `json:"template"`
		TemplateStack *DynamicUpdatesTemplateStackLocation `json:"template_stack"`
	}{
		System:        o.System,
		Template:      o.Template,
		TemplateStack: o.TemplateStack,
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		System        *DynamicUpdatesSystemLocation        `json:"system"`
		Template      *DynamicUpdatesTemplateLocation      `json:"template"`
		TemplateStack *DynamicUpdatesTemplateStackLocation `json:"template_stack"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.System = shadow.System
	o.Template = shadow.Template
	o.TemplateStack = shadow.TemplateStack

	return nil
}
