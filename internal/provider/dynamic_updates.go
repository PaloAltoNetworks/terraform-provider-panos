package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/device/dynamicupdates"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &DynamicUpdatesDataSource{}
	_ datasource.DataSourceWithConfigure = &DynamicUpdatesDataSource{}
)

func NewDynamicUpdatesDataSource() datasource.DataSource {
	return &DynamicUpdatesDataSource{}
}

type DynamicUpdatesDataSource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*dynamicupdates.Config, dynamicupdates.Location, *dynamicupdates.Service]
}

type DynamicUpdatesDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type DynamicUpdatesDataSourceModel struct {
	Location       types.Object `tfsdk:"location"`
	UpdateSchedule types.Object `tfsdk:"update_schedule"`
}
type DynamicUpdatesDataSourceUpdateScheduleObject struct {
	AntiVirus                  types.Object `tfsdk:"anti_virus"`
	AppProfile                 types.Object `tfsdk:"app_profile"`
	GlobalProtectClientlessVpn types.Object `tfsdk:"global_protect_clientless_vpn"`
	GlobalProtectDatafile      types.Object `tfsdk:"global_protect_datafile"`
	StatisticsService          types.Object `tfsdk:"statistics_service"`
	Threats                    types.Object `tfsdk:"threats"`
	WfPrivate                  types.Object `tfsdk:"wf_private"`
	Wildfire                   types.Object `tfsdk:"wildfire"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject struct {
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
	Threshold  types.Int64  `tfsdk:"threshold"`
	Daily      types.Object `tfsdk:"daily"`
	Hourly     types.Object `tfsdk:"hourly"`
	None       types.Object `tfsdk:"none"`
	Weekly     types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject struct {
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
	Threshold  types.Int64  `tfsdk:"threshold"`
	Daily      types.Object `tfsdk:"daily"`
	None       types.Object `tfsdk:"none"`
	Weekly     types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject struct {
	Daily  types.Object `tfsdk:"daily"`
	Hourly types.Object `tfsdk:"hourly"`
	None   types.Object `tfsdk:"none"`
	Weekly types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject struct {
	Daily  types.Object `tfsdk:"daily"`
	Hourly types.Object `tfsdk:"hourly"`
	None   types.Object `tfsdk:"none"`
	Weekly types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject struct {
	ApplicationReports          types.Bool `tfsdk:"application_reports"`
	FileIdentificationReports   types.Bool `tfsdk:"file_identification_reports"`
	HealthPerformanceReports    types.Bool `tfsdk:"health_performance_reports"`
	PassiveDnsMonitoring        types.Bool `tfsdk:"passive_dns_monitoring"`
	ThreatPreventionInformation types.Bool `tfsdk:"threat_prevention_information"`
	ThreatPreventionPcap        types.Bool `tfsdk:"threat_prevention_pcap"`
	ThreatPreventionReports     types.Bool `tfsdk:"threat_prevention_reports"`
	UrlReports                  types.Bool `tfsdk:"url_reports"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject struct {
	NewAppThreshold types.Int64  `tfsdk:"new_app_threshold"`
	SyncToPeer      types.Bool   `tfsdk:"sync_to_peer"`
	Threshold       types.Int64  `tfsdk:"threshold"`
	Daily           types.Object `tfsdk:"daily"`
	Every30Mins     types.Object `tfsdk:"every_30_mins"`
	Hourly          types.Object `tfsdk:"hourly"`
	None            types.Object `tfsdk:"none"`
	Weekly          types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DayOfWeek         types.String `tfsdk:"day_of_week"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject struct {
	SyncToPeer  types.Bool   `tfsdk:"sync_to_peer"`
	Every15Mins types.Object `tfsdk:"every_15_mins"`
	Every30Mins types.Object `tfsdk:"every_30_mins"`
	Every5Mins  types.Object `tfsdk:"every_5_mins"`
	EveryHour   types.Object `tfsdk:"every_hour"`
	None        types.Object `tfsdk:"none"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject struct {
	Every15Mins types.Object `tfsdk:"every_15_mins"`
	Every30Mins types.Object `tfsdk:"every_30_mins"`
	EveryHour   types.Object `tfsdk:"every_hour"`
	EveryMin    types.Object `tfsdk:"every_min"`
	None        types.Object `tfsdk:"none"`
	RealTime    types.Object `tfsdk:"real_time"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject struct {
	Action     types.String `tfsdk:"action"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject struct {
}
type DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject struct {
}

func (o *DynamicUpdatesDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj DynamicUpdatesLocation

	var updateScheduleObj *DynamicUpdatesDataSourceUpdateScheduleObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"update_schedule": types.ObjectType{
			AttrTypes: updateScheduleObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceModel) AncestorName() string {
	return ""
}

func (o DynamicUpdatesDataSourceModel) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleObject) AttributeTypes() map[string]attr.Type {

	var antiVirusObj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject

	var appProfileObj *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject

	var globalProtectClientlessVpnObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject

	var globalProtectDatafileObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject

	var statisticsServiceObj *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject

	var threatsObj *DynamicUpdatesDataSourceUpdateScheduleThreatsObject

	var wfPrivateObj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject

	var wildfireObj *DynamicUpdatesDataSourceUpdateScheduleWildfireObject
	return map[string]attr.Type{
		"anti_virus": types.ObjectType{
			AttrTypes: antiVirusObj.AttributeTypes(),
		},
		"app_profile": types.ObjectType{
			AttrTypes: appProfileObj.AttributeTypes(),
		},
		"global_protect_clientless_vpn": types.ObjectType{
			AttrTypes: globalProtectClientlessVpnObj.AttributeTypes(),
		},
		"global_protect_datafile": types.ObjectType{
			AttrTypes: globalProtectDatafileObj.AttributeTypes(),
		},
		"statistics_service": types.ObjectType{
			AttrTypes: statisticsServiceObj.AttributeTypes(),
		},
		"threats": types.ObjectType{
			AttrTypes: threatsObj.AttributeTypes(),
		},
		"wf_private": types.ObjectType{
			AttrTypes: wfPrivateObj.AttributeTypes(),
		},
		"wildfire": types.ObjectType{
			AttrTypes: wildfireObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleObject) AncestorName() string {
	return "update-schedule"
}

func (o DynamicUpdatesDataSourceUpdateScheduleObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) AncestorName() string {
	return "anti-virus"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject

	var hourlyObj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject

	var noneObj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject

	var weeklyObj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject
	return map[string]attr.Type{
		"sync_to_peer": types.BoolType,
		"threshold":    types.Int64Type,
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) AncestorName() string {
	return "app-profile"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject

	var noneObj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject

	var weeklyObj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject
	return map[string]attr.Type{
		"sync_to_peer": types.BoolType,
		"threshold":    types.Int64Type,
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) AncestorName() string {
	return "global-protect-clientless-vpn"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject

	var hourlyObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject

	var noneObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject

	var weeklyObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
	return map[string]attr.Type{
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) AncestorName() string {
	return "global-protect-datafile"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject

	var hourlyObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject

	var noneObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject

	var weeklyObj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
	return map[string]attr.Type{
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"application_reports":           types.BoolType,
		"file_identification_reports":   types.BoolType,
		"health_performance_reports":    types.BoolType,
		"passive_dns_monitoring":        types.BoolType,
		"threat_prevention_information": types.BoolType,
		"threat_prevention_pcap":        types.BoolType,
		"threat_prevention_reports":     types.BoolType,
		"url_reports":                   types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) AncestorName() string {
	return "statistics-service"
}

func (o DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsObject) AncestorName() string {
	return "threats"
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject

	var every30MinsObj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject

	var hourlyObj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject

	var noneObj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject

	var weeklyObj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject
	return map[string]attr.Type{
		"new_app_threshold": types.Int64Type,
		"sync_to_peer":      types.BoolType,
		"threshold":         types.Int64Type,
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"every_30_mins": types.ObjectType{
			AttrTypes: every30MinsObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.StringType,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.Int64Type,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) AncestorName() string {
	return "every-30-mins"
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.Int64Type,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.StringType,
		"day_of_week":         types.StringType,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) AncestorName() string {
	return "wf-private"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) AttributeTypes() map[string]attr.Type {

	var every15MinsObj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject

	var every30MinsObj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject

	var every5MinsObj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject

	var everyHourObj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject

	var noneObj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject
	return map[string]attr.Type{
		"sync_to_peer": types.BoolType,
		"every_15_mins": types.ObjectType{
			AttrTypes: every15MinsObj.AttributeTypes(),
		},
		"every_30_mins": types.ObjectType{
			AttrTypes: every30MinsObj.AttributeTypes(),
		},
		"every_5_mins": types.ObjectType{
			AttrTypes: every5MinsObj.AttributeTypes(),
		},
		"every_hour": types.ObjectType{
			AttrTypes: everyHourObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) AncestorName() string {
	return "every-15-mins"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) AncestorName() string {
	return "every-30-mins"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) AncestorName() string {
	return "every-5-mins"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) AncestorName() string {
	return "every-hour"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireObject) AncestorName() string {
	return "wildfire"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) AttributeTypes() map[string]attr.Type {

	var every15MinsObj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject

	var every30MinsObj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject

	var everyHourObj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject

	var everyMinObj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject

	var noneObj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject

	var realTimeObj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject
	return map[string]attr.Type{
		"every_15_mins": types.ObjectType{
			AttrTypes: every15MinsObj.AttributeTypes(),
		},
		"every_30_mins": types.ObjectType{
			AttrTypes: every30MinsObj.AttributeTypes(),
		},
		"every_hour": types.ObjectType{
			AttrTypes: everyHourObj.AttributeTypes(),
		},
		"every_min": types.ObjectType{
			AttrTypes: everyMinObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"real_time": types.ObjectType{
			AttrTypes: realTimeObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"at":           types.Int64Type,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) AncestorName() string {
	return "every-15-mins"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"at":           types.Int64Type,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) AncestorName() string {
	return "every-30-mins"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"at":           types.Int64Type,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) AncestorName() string {
	return "every-hour"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) AncestorName() string {
	return "every-min"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) AncestorName() string {
	return "real-time"
}

func (o DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) EntryName() *string {
	return nil
}

func (o *DynamicUpdatesDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var updateSchedule_entry *dynamicupdates.UpdateSchedule
	if !o.UpdateSchedule.IsUnknown() && !o.UpdateSchedule.IsNull() {
		if *obj != nil && (*obj).UpdateSchedule != nil {
			updateSchedule_entry = (*obj).UpdateSchedule
		} else {
			updateSchedule_entry = new(dynamicupdates.UpdateSchedule)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleObject
		diags.Append(o.UpdateSchedule.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &updateSchedule_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.Config)
	}
	(*obj).UpdateSchedule = updateSchedule_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateSchedule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var antiVirus_entry *dynamicupdates.UpdateScheduleAntiVirus
	if !o.AntiVirus.IsUnknown() && !o.AntiVirus.IsNull() {
		if *obj != nil && (*obj).AntiVirus != nil {
			antiVirus_entry = (*obj).AntiVirus
		} else {
			antiVirus_entry = new(dynamicupdates.UpdateScheduleAntiVirus)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject
		diags.Append(o.AntiVirus.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &antiVirus_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var appProfile_entry *dynamicupdates.UpdateScheduleAppProfile
	if !o.AppProfile.IsUnknown() && !o.AppProfile.IsNull() {
		if *obj != nil && (*obj).AppProfile != nil {
			appProfile_entry = (*obj).AppProfile
		} else {
			appProfile_entry = new(dynamicupdates.UpdateScheduleAppProfile)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject
		diags.Append(o.AppProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &appProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectClientlessVpn_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn
	if !o.GlobalProtectClientlessVpn.IsUnknown() && !o.GlobalProtectClientlessVpn.IsNull() {
		if *obj != nil && (*obj).GlobalProtectClientlessVpn != nil {
			globalProtectClientlessVpn_entry = (*obj).GlobalProtectClientlessVpn
		} else {
			globalProtectClientlessVpn_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject
		diags.Append(o.GlobalProtectClientlessVpn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalProtectClientlessVpn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectDatafile_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafile
	if !o.GlobalProtectDatafile.IsUnknown() && !o.GlobalProtectDatafile.IsNull() {
		if *obj != nil && (*obj).GlobalProtectDatafile != nil {
			globalProtectDatafile_entry = (*obj).GlobalProtectDatafile
		} else {
			globalProtectDatafile_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject
		diags.Append(o.GlobalProtectDatafile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalProtectDatafile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var statisticsService_entry *dynamicupdates.UpdateScheduleStatisticsService
	if !o.StatisticsService.IsUnknown() && !o.StatisticsService.IsNull() {
		if *obj != nil && (*obj).StatisticsService != nil {
			statisticsService_entry = (*obj).StatisticsService
		} else {
			statisticsService_entry = new(dynamicupdates.UpdateScheduleStatisticsService)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject
		diags.Append(o.StatisticsService.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &statisticsService_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var threats_entry *dynamicupdates.UpdateScheduleThreats
	if !o.Threats.IsUnknown() && !o.Threats.IsNull() {
		if *obj != nil && (*obj).Threats != nil {
			threats_entry = (*obj).Threats
		} else {
			threats_entry = new(dynamicupdates.UpdateScheduleThreats)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleThreatsObject
		diags.Append(o.Threats.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &threats_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var wfPrivate_entry *dynamicupdates.UpdateScheduleWfPrivate
	if !o.WfPrivate.IsUnknown() && !o.WfPrivate.IsNull() {
		if *obj != nil && (*obj).WfPrivate != nil {
			wfPrivate_entry = (*obj).WfPrivate
		} else {
			wfPrivate_entry = new(dynamicupdates.UpdateScheduleWfPrivate)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject
		diags.Append(o.WfPrivate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &wfPrivate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var wildfire_entry *dynamicupdates.UpdateScheduleWildfire
	if !o.Wildfire.IsUnknown() && !o.Wildfire.IsNull() {
		if *obj != nil && (*obj).Wildfire != nil {
			wildfire_entry = (*obj).Wildfire
		} else {
			wildfire_entry = new(dynamicupdates.UpdateScheduleWildfire)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireObject
		diags.Append(o.Wildfire.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &wildfire_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateSchedule)
	}
	(*obj).AntiVirus = antiVirus_entry
	(*obj).AppProfile = appProfile_entry
	(*obj).GlobalProtectClientlessVpn = globalProtectClientlessVpn_entry
	(*obj).GlobalProtectDatafile = globalProtectDatafile_entry
	(*obj).StatisticsService = statisticsService_entry
	(*obj).Threats = threats_entry
	(*obj).WfPrivate = wfPrivate_entry
	(*obj).Wildfire = wildfire_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirus, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAntiVirusRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirus)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAppProfileRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleAppProfileRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAppProfileRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleStatisticsService, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	applicationReports_value := o.ApplicationReports.ValueBoolPointer()
	fileIdentificationReports_value := o.FileIdentificationReports.ValueBoolPointer()
	healthPerformanceReports_value := o.HealthPerformanceReports.ValueBoolPointer()
	passiveDnsMonitoring_value := o.PassiveDnsMonitoring.ValueBoolPointer()
	threatPreventionInformation_value := o.ThreatPreventionInformation.ValueBoolPointer()
	threatPreventionPcap_value := o.ThreatPreventionPcap.ValueBoolPointer()
	threatPreventionReports_value := o.ThreatPreventionReports.ValueBoolPointer()
	urlReports_value := o.UrlReports.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleStatisticsService)
	}
	(*obj).ApplicationReports = applicationReports_value
	(*obj).FileIdentificationReports = fileIdentificationReports_value
	(*obj).HealthPerformanceReports = healthPerformanceReports_value
	(*obj).PassiveDnsMonitoring = passiveDnsMonitoring_value
	(*obj).ThreatPreventionInformation = threatPreventionInformation_value
	(*obj).ThreatPreventionPcap = threatPreventionPcap_value
	(*obj).ThreatPreventionReports = threatPreventionReports_value
	(*obj).UrlReports = urlReports_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreats, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleThreatsRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleThreatsRecurring)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreats)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	newAppThreshold_value := o.NewAppThreshold.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleThreatsRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins
	if !o.Every30Mins.IsUnknown() && !o.Every30Mins.IsNull() {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject
		diags.Append(o.Every30Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every30Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleThreatsRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleThreatsRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleThreatsRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurring)
	}
	(*obj).NewAppThreshold = newAppThreshold_value
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWfPrivateRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivate)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	var every15Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins
	if !o.Every15Mins.IsUnknown() && !o.Every15Mins.IsNull() {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject
		diags.Append(o.Every15Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every15Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins
	if !o.Every30Mins.IsUnknown() && !o.Every30Mins.IsNull() {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject
		diags.Append(o.Every30Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every30Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every5Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins
	if !o.Every5Mins.IsUnknown() && !o.Every5Mins.IsNull() {
		if *obj != nil && (*obj).Every5Mins != nil {
			every5Mins_entry = (*obj).Every5Mins
		} else {
			every5Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject
		diags.Append(o.Every5Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every5Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour
	if !o.EveryHour.IsUnknown() && !o.EveryHour.IsNull() {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject
		diags.Append(o.EveryHour.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &everyHour_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Every15Mins = every15Mins_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Every5Mins = every5Mins_entry
	(*obj).EveryHour = everyHour_entry
	(*obj).None = none_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWildfireRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWildfireRecurring)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfire)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var every15Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins
	if !o.Every15Mins.IsUnknown() && !o.Every15Mins.IsNull() {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject
		diags.Append(o.Every15Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every15Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins
	if !o.Every30Mins.IsUnknown() && !o.Every30Mins.IsNull() {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject
		diags.Append(o.Every30Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every30Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour
	if !o.EveryHour.IsUnknown() && !o.EveryHour.IsNull() {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject
		diags.Append(o.EveryHour.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &everyHour_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyMin_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin
	if !o.EveryMin.IsUnknown() && !o.EveryMin.IsNull() {
		if *obj != nil && (*obj).EveryMin != nil {
			everyMin_entry = (*obj).EveryMin
		} else {
			everyMin_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject
		diags.Append(o.EveryMin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &everyMin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleWildfireRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var realTime_entry *dynamicupdates.UpdateScheduleWildfireRecurringRealTime
	if !o.RealTime.IsUnknown() && !o.RealTime.IsNull() {
		if *obj != nil && (*obj).RealTime != nil {
			realTime_entry = (*obj).RealTime
		} else {
			realTime_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
		}
		var object *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject
		diags.Append(o.RealTime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &realTime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurring)
	}
	(*obj).Every15Mins = every15Mins_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).EveryHour = everyHour_entry
	(*obj).EveryMin = everyMin_entry
	(*obj).None = none_entry
	(*obj).RealTime = realTime_entry

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
	}
	(*obj).Action = action_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringRealTime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
	}

	return diags
}

func (o *DynamicUpdatesDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var updateSchedule_obj *DynamicUpdatesDataSourceUpdateScheduleObject
	if o.UpdateSchedule.IsNull() {
		updateSchedule_obj = new(DynamicUpdatesDataSourceUpdateScheduleObject)
	} else {
		diags.Append(o.UpdateSchedule.As(ctx, &updateSchedule_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	updateSchedule_object := types.ObjectNull(updateSchedule_obj.AttributeTypes())
	if obj.UpdateSchedule != nil {
		diags.Append(updateSchedule_obj.CopyFromPango(ctx, client, ancestors, obj.UpdateSchedule, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		updateSchedule_object, diags_tmp = types.ObjectValueFrom(ctx, updateSchedule_obj.AttributeTypes(), updateSchedule_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.UpdateSchedule = updateSchedule_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateSchedule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var antiVirus_obj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject
	if o.AntiVirus.IsNull() {
		antiVirus_obj = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject)
	} else {
		diags.Append(o.AntiVirus.As(ctx, &antiVirus_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	antiVirus_object := types.ObjectNull(antiVirus_obj.AttributeTypes())
	if obj.AntiVirus != nil {
		diags.Append(antiVirus_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AntiVirus, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		antiVirus_object, diags_tmp = types.ObjectValueFrom(ctx, antiVirus_obj.AttributeTypes(), antiVirus_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var appProfile_obj *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject
	if o.AppProfile.IsNull() {
		appProfile_obj = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileObject)
	} else {
		diags.Append(o.AppProfile.As(ctx, &appProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	appProfile_object := types.ObjectNull(appProfile_obj.AttributeTypes())
	if obj.AppProfile != nil {
		diags.Append(appProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AppProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		appProfile_object, diags_tmp = types.ObjectValueFrom(ctx, appProfile_obj.AttributeTypes(), appProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalProtectClientlessVpn_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject
	if o.GlobalProtectClientlessVpn.IsNull() {
		globalProtectClientlessVpn_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject)
	} else {
		diags.Append(o.GlobalProtectClientlessVpn.As(ctx, &globalProtectClientlessVpn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalProtectClientlessVpn_object := types.ObjectNull(globalProtectClientlessVpn_obj.AttributeTypes())
	if obj.GlobalProtectClientlessVpn != nil {
		diags.Append(globalProtectClientlessVpn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalProtectClientlessVpn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalProtectClientlessVpn_object, diags_tmp = types.ObjectValueFrom(ctx, globalProtectClientlessVpn_obj.AttributeTypes(), globalProtectClientlessVpn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalProtectDatafile_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject
	if o.GlobalProtectDatafile.IsNull() {
		globalProtectDatafile_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject)
	} else {
		diags.Append(o.GlobalProtectDatafile.As(ctx, &globalProtectDatafile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalProtectDatafile_object := types.ObjectNull(globalProtectDatafile_obj.AttributeTypes())
	if obj.GlobalProtectDatafile != nil {
		diags.Append(globalProtectDatafile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalProtectDatafile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalProtectDatafile_object, diags_tmp = types.ObjectValueFrom(ctx, globalProtectDatafile_obj.AttributeTypes(), globalProtectDatafile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var statisticsService_obj *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject
	if o.StatisticsService.IsNull() {
		statisticsService_obj = new(DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject)
	} else {
		diags.Append(o.StatisticsService.As(ctx, &statisticsService_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	statisticsService_object := types.ObjectNull(statisticsService_obj.AttributeTypes())
	if obj.StatisticsService != nil {
		diags.Append(statisticsService_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StatisticsService, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		statisticsService_object, diags_tmp = types.ObjectValueFrom(ctx, statisticsService_obj.AttributeTypes(), statisticsService_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var threats_obj *DynamicUpdatesDataSourceUpdateScheduleThreatsObject
	if o.Threats.IsNull() {
		threats_obj = new(DynamicUpdatesDataSourceUpdateScheduleThreatsObject)
	} else {
		diags.Append(o.Threats.As(ctx, &threats_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	threats_object := types.ObjectNull(threats_obj.AttributeTypes())
	if obj.Threats != nil {
		diags.Append(threats_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Threats, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		threats_object, diags_tmp = types.ObjectValueFrom(ctx, threats_obj.AttributeTypes(), threats_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var wfPrivate_obj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject
	if o.WfPrivate.IsNull() {
		wfPrivate_obj = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject)
	} else {
		diags.Append(o.WfPrivate.As(ctx, &wfPrivate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	wfPrivate_object := types.ObjectNull(wfPrivate_obj.AttributeTypes())
	if obj.WfPrivate != nil {
		diags.Append(wfPrivate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WfPrivate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		wfPrivate_object, diags_tmp = types.ObjectValueFrom(ctx, wfPrivate_obj.AttributeTypes(), wfPrivate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var wildfire_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireObject
	if o.Wildfire.IsNull() {
		wildfire_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireObject)
	} else {
		diags.Append(o.Wildfire.As(ctx, &wildfire_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	wildfire_object := types.ObjectNull(wildfire_obj.AttributeTypes())
	if obj.Wildfire != nil {
		diags.Append(wildfire_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Wildfire, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		wildfire_object, diags_tmp = types.ObjectValueFrom(ctx, wildfire_obj.AttributeTypes(), wildfire_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.AntiVirus = antiVirus_object
	o.AppProfile = appProfile_object
	o.GlobalProtectClientlessVpn = globalProtectClientlessVpn_object
	o.GlobalProtectDatafile = globalProtectDatafile_object
	o.StatisticsService = statisticsService_object
	o.Threats = threats_object
	o.WfPrivate = wfPrivate_object
	o.Wildfire = wildfire_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirus, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleStatisticsService, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var applicationReports_value types.Bool
	if obj.ApplicationReports != nil {
		applicationReports_value = types.BoolValue(*obj.ApplicationReports)
	}
	var fileIdentificationReports_value types.Bool
	if obj.FileIdentificationReports != nil {
		fileIdentificationReports_value = types.BoolValue(*obj.FileIdentificationReports)
	}
	var healthPerformanceReports_value types.Bool
	if obj.HealthPerformanceReports != nil {
		healthPerformanceReports_value = types.BoolValue(*obj.HealthPerformanceReports)
	}
	var passiveDnsMonitoring_value types.Bool
	if obj.PassiveDnsMonitoring != nil {
		passiveDnsMonitoring_value = types.BoolValue(*obj.PassiveDnsMonitoring)
	}
	var threatPreventionInformation_value types.Bool
	if obj.ThreatPreventionInformation != nil {
		threatPreventionInformation_value = types.BoolValue(*obj.ThreatPreventionInformation)
	}
	var threatPreventionPcap_value types.Bool
	if obj.ThreatPreventionPcap != nil {
		threatPreventionPcap_value = types.BoolValue(*obj.ThreatPreventionPcap)
	}
	var threatPreventionReports_value types.Bool
	if obj.ThreatPreventionReports != nil {
		threatPreventionReports_value = types.BoolValue(*obj.ThreatPreventionReports)
	}
	var urlReports_value types.Bool
	if obj.UrlReports != nil {
		urlReports_value = types.BoolValue(*obj.UrlReports)
	}
	o.ApplicationReports = applicationReports_value
	o.FileIdentificationReports = fileIdentificationReports_value
	o.HealthPerformanceReports = healthPerformanceReports_value
	o.PassiveDnsMonitoring = passiveDnsMonitoring_value
	o.ThreatPreventionInformation = threatPreventionInformation_value
	o.ThreatPreventionPcap = threatPreventionPcap_value
	o.ThreatPreventionReports = threatPreventionReports_value
	o.UrlReports = urlReports_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreats, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every30Mins_obj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject
	if o.Every30Mins.IsNull() {
		every30Mins_obj = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject)
	} else {
		diags.Append(o.Every30Mins.As(ctx, &every30Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every30Mins_object := types.ObjectNull(every30Mins_obj.AttributeTypes())
	if obj.Every30Mins != nil {
		diags.Append(every30Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every30Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every30Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every30Mins_obj.AttributeTypes(), every30Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var newAppThreshold_value types.Int64
	if obj.NewAppThreshold != nil {
		newAppThreshold_value = types.Int64Value(*obj.NewAppThreshold)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.NewAppThreshold = newAppThreshold_value
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.Every30Mins = every30Mins_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var every15Mins_obj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject
	if o.Every15Mins.IsNull() {
		every15Mins_obj = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject)
	} else {
		diags.Append(o.Every15Mins.As(ctx, &every15Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every15Mins_object := types.ObjectNull(every15Mins_obj.AttributeTypes())
	if obj.Every15Mins != nil {
		diags.Append(every15Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every15Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every15Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every15Mins_obj.AttributeTypes(), every15Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every30Mins_obj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject
	if o.Every30Mins.IsNull() {
		every30Mins_obj = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject)
	} else {
		diags.Append(o.Every30Mins.As(ctx, &every30Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every30Mins_object := types.ObjectNull(every30Mins_obj.AttributeTypes())
	if obj.Every30Mins != nil {
		diags.Append(every30Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every30Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every30Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every30Mins_obj.AttributeTypes(), every30Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every5Mins_obj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject
	if o.Every5Mins.IsNull() {
		every5Mins_obj = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject)
	} else {
		diags.Append(o.Every5Mins.As(ctx, &every5Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every5Mins_object := types.ObjectNull(every5Mins_obj.AttributeTypes())
	if obj.Every5Mins != nil {
		diags.Append(every5Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every5Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every5Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every5Mins_obj.AttributeTypes(), every5Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var everyHour_obj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject
	if o.EveryHour.IsNull() {
		everyHour_obj = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject)
	} else {
		diags.Append(o.EveryHour.As(ctx, &everyHour_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	everyHour_object := types.ObjectNull(everyHour_obj.AttributeTypes())
	if obj.EveryHour != nil {
		diags.Append(everyHour_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EveryHour, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		everyHour_object, diags_tmp = types.ObjectValueFrom(ctx, everyHour_obj.AttributeTypes(), everyHour_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.SyncToPeer = syncToPeer_value
	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object
	o.Every5Mins = every5Mins_object
	o.EveryHour = everyHour_object
	o.None = none_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var every15Mins_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject
	if o.Every15Mins.IsNull() {
		every15Mins_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject)
	} else {
		diags.Append(o.Every15Mins.As(ctx, &every15Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every15Mins_object := types.ObjectNull(every15Mins_obj.AttributeTypes())
	if obj.Every15Mins != nil {
		diags.Append(every15Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every15Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every15Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every15Mins_obj.AttributeTypes(), every15Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every30Mins_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject
	if o.Every30Mins.IsNull() {
		every30Mins_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject)
	} else {
		diags.Append(o.Every30Mins.As(ctx, &every30Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every30Mins_object := types.ObjectNull(every30Mins_obj.AttributeTypes())
	if obj.Every30Mins != nil {
		diags.Append(every30Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every30Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every30Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every30Mins_obj.AttributeTypes(), every30Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var everyHour_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject
	if o.EveryHour.IsNull() {
		everyHour_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject)
	} else {
		diags.Append(o.EveryHour.As(ctx, &everyHour_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	everyHour_object := types.ObjectNull(everyHour_obj.AttributeTypes())
	if obj.EveryHour != nil {
		diags.Append(everyHour_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EveryHour, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		everyHour_object, diags_tmp = types.ObjectValueFrom(ctx, everyHour_obj.AttributeTypes(), everyHour_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var everyMin_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject
	if o.EveryMin.IsNull() {
		everyMin_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject)
	} else {
		diags.Append(o.EveryMin.As(ctx, &everyMin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	everyMin_object := types.ObjectNull(everyMin_obj.AttributeTypes())
	if obj.EveryMin != nil {
		diags.Append(everyMin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EveryMin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		everyMin_object, diags_tmp = types.ObjectValueFrom(ctx, everyMin_obj.AttributeTypes(), everyMin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var realTime_obj *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject
	if o.RealTime.IsNull() {
		realTime_obj = new(DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject)
	} else {
		diags.Append(o.RealTime.As(ctx, &realTime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	realTime_object := types.ObjectNull(realTime_obj.AttributeTypes())
	if obj.RealTime != nil {
		diags.Append(realTime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RealTime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		realTime_object, diags_tmp = types.ObjectValueFrom(ctx, realTime_obj.AttributeTypes(), realTime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object
	o.EveryHour = everyHour_object
	o.EveryMin = everyMin_object
	o.None = none_object
	o.RealTime = realTime_object

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringRealTime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func DynamicUpdatesDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": DynamicUpdatesDataSourceLocationSchema(),

			"update_schedule": DynamicUpdatesDataSourceUpdateScheduleSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceModel) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"anti_virus": DynamicUpdatesDataSourceUpdateScheduleAntiVirusSchema(),

			"app_profile": DynamicUpdatesDataSourceUpdateScheduleAppProfileSchema(),

			"global_protect_clientless_vpn": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnSchema(),

			"global_protect_datafile": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileSchema(),

			"statistics_service": DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceSchema(),

			"threats": DynamicUpdatesDataSourceUpdateScheduleThreatsSchema(),

			"wf_private": DynamicUpdatesDataSourceUpdateScheduleWfPrivateSchema(),

			"wildfire": DynamicUpdatesDataSourceUpdateScheduleWildfireSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailySchema(),

			"hourly": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAntiVirusRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleAppProfileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"daily": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema(),

			"hourly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"daily": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema(),

			"hourly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"application_reports": dsschema.BoolAttribute{
				Description: "Application Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"file_identification_reports": dsschema.BoolAttribute{
				Description: "File Type Identification Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"health_performance_reports": dsschema.BoolAttribute{
				Description: "Health and Performance Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive_dns_monitoring": dsschema.BoolAttribute{
				Description: "Passive DNS Monitor",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_information": dsschema.BoolAttribute{
				Description: "Threat Prevention Information",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_pcap": dsschema.BoolAttribute{
				Description: "Enable sending packet-captures with threat prevention information",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_reports": dsschema.BoolAttribute{
				Description: "Threat Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"url_reports": dsschema.BoolAttribute{
				Description: "URL Reports",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleStatisticsServiceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"new_app_threshold": dsschema.Int64Attribute{
				Description: "ignore new apps if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailySchema(),

			"every_30_mins": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsSchema(),

			"hourly": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlySchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneSchema(),

			"weekly": DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": dsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleThreatsRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"every_15_mins": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema(),

			"every_5_mins": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema(),

			"every_hour": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourSchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past Quarter-Hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past Half-Hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past five minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes Past Hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWfPrivateRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"recurring": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"every_15_mins": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsSchema(),

			"every_hour": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourSchema(),

			"every_min": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinSchema(),

			"none": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneSchema(),

			"real_time": DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeSchema(),
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past quarter-hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"action": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": dsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringEveryMinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesDataSourceUpdateScheduleWildfireRecurringRealTimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesDataSourceLocationSchema() rsschema.Attribute {
	return DynamicUpdatesLocationSchema()
}

// Metadata returns the data source type name.
func (d *DynamicUpdatesDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dynamic_updates"
}

// Schema defines the schema for this data source.
func (d *DynamicUpdatesDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = DynamicUpdatesDataSourceSchema()
}

// Configure prepares the struct.
func (d *DynamicUpdatesDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := dynamicupdates.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewConfigObjectManager(d.client, dynamicupdates.NewService(d.client), specifier)
}
func (o *DynamicUpdatesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state DynamicUpdatesDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location dynamicupdates.Location

	{
		var terraformLocation DynamicUpdatesLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &dynamicupdates.SystemLocation{}
			var innerLocation DynamicUpdatesSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dynamicupdates.TemplateLocation{}
			var innerLocation DynamicUpdatesTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dynamicupdates.TemplateStackLocation{}
			var innerLocation DynamicUpdatesTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Read",
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &DynamicUpdatesResource{}
	_ resource.ResourceWithConfigure   = &DynamicUpdatesResource{}
	_ resource.ResourceWithImportState = &DynamicUpdatesResource{}
)

func NewDynamicUpdatesResource() resource.Resource {
	return &DynamicUpdatesResource{}
}

type DynamicUpdatesResource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*dynamicupdates.Config, dynamicupdates.Location, *dynamicupdates.Service]
}

func DynamicUpdatesResourceLocationSchema() rsschema.Attribute {
	return DynamicUpdatesLocationSchema()
}

type DynamicUpdatesResourceModel struct {
	Location       types.Object `tfsdk:"location"`
	UpdateSchedule types.Object `tfsdk:"update_schedule"`
}
type DynamicUpdatesResourceUpdateScheduleObject struct {
	AntiVirus                  types.Object `tfsdk:"anti_virus"`
	AppProfile                 types.Object `tfsdk:"app_profile"`
	GlobalProtectClientlessVpn types.Object `tfsdk:"global_protect_clientless_vpn"`
	GlobalProtectDatafile      types.Object `tfsdk:"global_protect_datafile"`
	StatisticsService          types.Object `tfsdk:"statistics_service"`
	Threats                    types.Object `tfsdk:"threats"`
	WfPrivate                  types.Object `tfsdk:"wf_private"`
	Wildfire                   types.Object `tfsdk:"wildfire"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject struct {
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
	Threshold  types.Int64  `tfsdk:"threshold"`
	Daily      types.Object `tfsdk:"daily"`
	Hourly     types.Object `tfsdk:"hourly"`
	None       types.Object `tfsdk:"none"`
	Weekly     types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject struct {
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
	Threshold  types.Int64  `tfsdk:"threshold"`
	Daily      types.Object `tfsdk:"daily"`
	None       types.Object `tfsdk:"none"`
	Weekly     types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject struct {
	Daily  types.Object `tfsdk:"daily"`
	Hourly types.Object `tfsdk:"hourly"`
	None   types.Object `tfsdk:"none"`
	Weekly types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject struct {
	Daily  types.Object `tfsdk:"daily"`
	Hourly types.Object `tfsdk:"hourly"`
	None   types.Object `tfsdk:"none"`
	Weekly types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.String `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject struct {
	Action    types.String `tfsdk:"action"`
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject struct {
	ApplicationReports          types.Bool `tfsdk:"application_reports"`
	FileIdentificationReports   types.Bool `tfsdk:"file_identification_reports"`
	HealthPerformanceReports    types.Bool `tfsdk:"health_performance_reports"`
	PassiveDnsMonitoring        types.Bool `tfsdk:"passive_dns_monitoring"`
	ThreatPreventionInformation types.Bool `tfsdk:"threat_prevention_information"`
	ThreatPreventionPcap        types.Bool `tfsdk:"threat_prevention_pcap"`
	ThreatPreventionReports     types.Bool `tfsdk:"threat_prevention_reports"`
	UrlReports                  types.Bool `tfsdk:"url_reports"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject struct {
	NewAppThreshold types.Int64  `tfsdk:"new_app_threshold"`
	SyncToPeer      types.Bool   `tfsdk:"sync_to_peer"`
	Threshold       types.Int64  `tfsdk:"threshold"`
	Daily           types.Object `tfsdk:"daily"`
	Every30Mins     types.Object `tfsdk:"every_30_mins"`
	Hourly          types.Object `tfsdk:"hourly"`
	None            types.Object `tfsdk:"none"`
	Weekly          types.Object `tfsdk:"weekly"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.Int64  `tfsdk:"at"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject struct {
	Action            types.String `tfsdk:"action"`
	At                types.String `tfsdk:"at"`
	DayOfWeek         types.String `tfsdk:"day_of_week"`
	DisableNewContent types.Bool   `tfsdk:"disable_new_content"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject struct {
	SyncToPeer  types.Bool   `tfsdk:"sync_to_peer"`
	Every15Mins types.Object `tfsdk:"every_15_mins"`
	Every30Mins types.Object `tfsdk:"every_30_mins"`
	Every5Mins  types.Object `tfsdk:"every_5_mins"`
	EveryHour   types.Object `tfsdk:"every_hour"`
	None        types.Object `tfsdk:"none"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject struct {
	Action types.String `tfsdk:"action"`
	At     types.Int64  `tfsdk:"at"`
}
type DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleWildfireObject struct {
	Recurring types.Object `tfsdk:"recurring"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject struct {
	Every15Mins types.Object `tfsdk:"every_15_mins"`
	Every30Mins types.Object `tfsdk:"every_30_mins"`
	EveryHour   types.Object `tfsdk:"every_hour"`
	EveryMin    types.Object `tfsdk:"every_min"`
	None        types.Object `tfsdk:"none"`
	RealTime    types.Object `tfsdk:"real_time"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject struct {
	Action     types.String `tfsdk:"action"`
	At         types.Int64  `tfsdk:"at"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject struct {
	Action     types.String `tfsdk:"action"`
	SyncToPeer types.Bool   `tfsdk:"sync_to_peer"`
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject struct {
}
type DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject struct {
}

func (o *DynamicUpdatesResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func DynamicUpdatesResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": DynamicUpdatesResourceLocationSchema(),

			"update_schedule": DynamicUpdatesResourceUpdateScheduleSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceModel) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"anti_virus": DynamicUpdatesResourceUpdateScheduleAntiVirusSchema(),

			"app_profile": DynamicUpdatesResourceUpdateScheduleAppProfileSchema(),

			"global_protect_clientless_vpn": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnSchema(),

			"global_protect_datafile": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileSchema(),

			"statistics_service": DynamicUpdatesResourceUpdateScheduleStatisticsServiceSchema(),

			"threats": DynamicUpdatesResourceUpdateScheduleThreatsSchema(),

			"wf_private": DynamicUpdatesResourceUpdateScheduleWfPrivateSchema(),

			"wildfire": DynamicUpdatesResourceUpdateScheduleWildfireSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailySchema(),

			"hourly": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"daily": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema(),

			"hourly": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"daily": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema(),

			"hourly": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleStatisticsServiceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"application_reports": rsschema.BoolAttribute{
				Description: "Application Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"file_identification_reports": rsschema.BoolAttribute{
				Description: "File Type Identification Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"health_performance_reports": rsschema.BoolAttribute{
				Description: "Health and Performance Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive_dns_monitoring": rsschema.BoolAttribute{
				Description: "Passive DNS Monitor",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_information": rsschema.BoolAttribute{
				Description: "Threat Prevention Information",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_pcap": rsschema.BoolAttribute{
				Description: "Enable sending packet-captures with threat prevention information",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threat_prevention_reports": rsschema.BoolAttribute{
				Description: "Threat Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"url_reports": rsschema.BoolAttribute{
				Description: "URL Reports",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleStatisticsServiceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleThreatsRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"new_app_threshold": rsschema.Int64Attribute{
				Description: "ignore new apps if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": rsschema.Int64Attribute{
				Description: "ignore if release date is new (hours)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"daily": DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailySchema(),

			"every_30_mins": DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsSchema(),

			"hourly": DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlySchema(),

			"none": DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneSchema(),

			"weekly": DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklySchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.StringAttribute{
				Description: "Time specification hh:mm (e.g. 20:10)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_new_content": rsschema.BoolAttribute{
				Description: "Disable new applications after installation",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"every_15_mins": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema(),

			"every_5_mins": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema(),

			"every_hour": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourSchema(),

			"none": DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past Quarter-Hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past Half-Hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past five minutes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes Past Hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_5_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"recurring": DynamicUpdatesResourceUpdateScheduleWildfireRecurringSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"every_15_mins": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsSchema(),

			"every_30_mins": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsSchema(),

			"every_hour": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourSchema(),

			"every_min": DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinSchema(),

			"none": DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneSchema(),

			"real_time": DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeSchema(),
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past quarter-hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past half-hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": rsschema.Int64Attribute{
				Description: "Minutes past hour",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"action": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sync_to_peer": rsschema.BoolAttribute{
				Description: "Synchronize content with HA peer after download/install",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("every_15_mins"),
				path.MatchRelative().AtParent().AtName("every_30_mins"),
				path.MatchRelative().AtParent().AtName("every_hour"),
				path.MatchRelative().AtParent().AtName("every_min"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("real_time"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) getTypeFor(name string) attr.Type {
	schema := DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *DynamicUpdatesResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dynamic_updates"
}

func (o *DynamicUpdatesResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = DynamicUpdatesResourceSchema()
}

// </ResourceSchema>

func (o *DynamicUpdatesResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := dynamicupdates.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	o.manager = sdkmanager.NewConfigObjectManager(o.client, dynamicupdates.NewService(o.client), specifier)
}

func (o *DynamicUpdatesResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj DynamicUpdatesLocation

	var updateScheduleObj *DynamicUpdatesResourceUpdateScheduleObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"update_schedule": types.ObjectType{
			AttrTypes: updateScheduleObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceModel) AncestorName() string {
	return ""
}

func (o DynamicUpdatesResourceModel) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleObject) AttributeTypes() map[string]attr.Type {

	var antiVirusObj *DynamicUpdatesResourceUpdateScheduleAntiVirusObject

	var appProfileObj *DynamicUpdatesResourceUpdateScheduleAppProfileObject

	var globalProtectClientlessVpnObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject

	var globalProtectDatafileObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject

	var statisticsServiceObj *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject

	var threatsObj *DynamicUpdatesResourceUpdateScheduleThreatsObject

	var wfPrivateObj *DynamicUpdatesResourceUpdateScheduleWfPrivateObject

	var wildfireObj *DynamicUpdatesResourceUpdateScheduleWildfireObject
	return map[string]attr.Type{
		"anti_virus": types.ObjectType{
			AttrTypes: antiVirusObj.AttributeTypes(),
		},
		"app_profile": types.ObjectType{
			AttrTypes: appProfileObj.AttributeTypes(),
		},
		"global_protect_clientless_vpn": types.ObjectType{
			AttrTypes: globalProtectClientlessVpnObj.AttributeTypes(),
		},
		"global_protect_datafile": types.ObjectType{
			AttrTypes: globalProtectDatafileObj.AttributeTypes(),
		},
		"statistics_service": types.ObjectType{
			AttrTypes: statisticsServiceObj.AttributeTypes(),
		},
		"threats": types.ObjectType{
			AttrTypes: threatsObj.AttributeTypes(),
		},
		"wf_private": types.ObjectType{
			AttrTypes: wfPrivateObj.AttributeTypes(),
		},
		"wildfire": types.ObjectType{
			AttrTypes: wildfireObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleObject) AncestorName() string {
	return "update-schedule"
}

func (o DynamicUpdatesResourceUpdateScheduleObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusObject) AncestorName() string {
	return "anti-virus"
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject

	var hourlyObj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject

	var noneObj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject

	var weeklyObj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject
	return map[string]attr.Type{
		"sync_to_peer": types.BoolType,
		"threshold":    types.Int64Type,
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileObject) AncestorName() string {
	return "app-profile"
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject

	var noneObj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject

	var weeklyObj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject
	return map[string]attr.Type{
		"sync_to_peer": types.BoolType,
		"threshold":    types.Int64Type,
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) AncestorName() string {
	return "global-protect-clientless-vpn"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject

	var hourlyObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject

	var noneObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject

	var weeklyObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
	return map[string]attr.Type{
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) AncestorName() string {
	return "global-protect-datafile"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject

	var hourlyObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject

	var noneObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject

	var weeklyObj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
	return map[string]attr.Type{
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":      types.StringType,
		"at":          types.StringType,
		"day_of_week": types.StringType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"application_reports":           types.BoolType,
		"file_identification_reports":   types.BoolType,
		"health_performance_reports":    types.BoolType,
		"passive_dns_monitoring":        types.BoolType,
		"threat_prevention_information": types.BoolType,
		"threat_prevention_pcap":        types.BoolType,
		"threat_prevention_reports":     types.BoolType,
		"url_reports":                   types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) AncestorName() string {
	return "statistics-service"
}

func (o DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsObject) AncestorName() string {
	return "threats"
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) AttributeTypes() map[string]attr.Type {

	var dailyObj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject

	var every30MinsObj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject

	var hourlyObj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject

	var noneObj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject

	var weeklyObj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject
	return map[string]attr.Type{
		"new_app_threshold": types.Int64Type,
		"sync_to_peer":      types.BoolType,
		"threshold":         types.Int64Type,
		"daily": types.ObjectType{
			AttrTypes: dailyObj.AttributeTypes(),
		},
		"every_30_mins": types.ObjectType{
			AttrTypes: every30MinsObj.AttributeTypes(),
		},
		"hourly": types.ObjectType{
			AttrTypes: hourlyObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"weekly": types.ObjectType{
			AttrTypes: weeklyObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.StringType,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) AncestorName() string {
	return "daily"
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.Int64Type,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) AncestorName() string {
	return "every-30-mins"
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.Int64Type,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) AncestorName() string {
	return "hourly"
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":              types.StringType,
		"at":                  types.StringType,
		"day_of_week":         types.StringType,
		"disable_new_content": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) AncestorName() string {
	return "weekly"
}

func (o DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateObject) AncestorName() string {
	return "wf-private"
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) AttributeTypes() map[string]attr.Type {

	var every15MinsObj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject

	var every30MinsObj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject

	var every5MinsObj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject

	var everyHourObj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject

	var noneObj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject
	return map[string]attr.Type{
		"sync_to_peer": types.BoolType,
		"every_15_mins": types.ObjectType{
			AttrTypes: every15MinsObj.AttributeTypes(),
		},
		"every_30_mins": types.ObjectType{
			AttrTypes: every30MinsObj.AttributeTypes(),
		},
		"every_5_mins": types.ObjectType{
			AttrTypes: every5MinsObj.AttributeTypes(),
		},
		"every_hour": types.ObjectType{
			AttrTypes: everyHourObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) AncestorName() string {
	return "every-15-mins"
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) AncestorName() string {
	return "every-30-mins"
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) AncestorName() string {
	return "every-5-mins"
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action": types.StringType,
		"at":     types.Int64Type,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) AncestorName() string {
	return "every-hour"
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireObject) AttributeTypes() map[string]attr.Type {

	var recurringObj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject
	return map[string]attr.Type{
		"recurring": types.ObjectType{
			AttrTypes: recurringObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireObject) AncestorName() string {
	return "wildfire"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) AttributeTypes() map[string]attr.Type {

	var every15MinsObj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject

	var every30MinsObj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject

	var everyHourObj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject

	var everyMinObj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject

	var noneObj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject

	var realTimeObj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject
	return map[string]attr.Type{
		"every_15_mins": types.ObjectType{
			AttrTypes: every15MinsObj.AttributeTypes(),
		},
		"every_30_mins": types.ObjectType{
			AttrTypes: every30MinsObj.AttributeTypes(),
		},
		"every_hour": types.ObjectType{
			AttrTypes: everyHourObj.AttributeTypes(),
		},
		"every_min": types.ObjectType{
			AttrTypes: everyMinObj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"real_time": types.ObjectType{
			AttrTypes: realTimeObj.AttributeTypes(),
		},
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) AncestorName() string {
	return "recurring"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"at":           types.Int64Type,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) AncestorName() string {
	return "every-15-mins"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"at":           types.Int64Type,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) AncestorName() string {
	return "every-30-mins"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"at":           types.Int64Type,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) AncestorName() string {
	return "every-hour"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"action":       types.StringType,
		"sync_to_peer": types.BoolType,
	}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) AncestorName() string {
	return "every-min"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) AncestorName() string {
	return "none"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) EntryName() *string {
	return nil
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) AncestorName() string {
	return "real-time"
}

func (o DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) EntryName() *string {
	return nil
}

func (o *DynamicUpdatesResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var updateSchedule_entry *dynamicupdates.UpdateSchedule
	if !o.UpdateSchedule.IsUnknown() && !o.UpdateSchedule.IsNull() {
		if *obj != nil && (*obj).UpdateSchedule != nil {
			updateSchedule_entry = (*obj).UpdateSchedule
		} else {
			updateSchedule_entry = new(dynamicupdates.UpdateSchedule)
		}
		var object *DynamicUpdatesResourceUpdateScheduleObject
		diags.Append(o.UpdateSchedule.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &updateSchedule_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.Config)
	}
	(*obj).UpdateSchedule = updateSchedule_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateSchedule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var antiVirus_entry *dynamicupdates.UpdateScheduleAntiVirus
	if !o.AntiVirus.IsUnknown() && !o.AntiVirus.IsNull() {
		if *obj != nil && (*obj).AntiVirus != nil {
			antiVirus_entry = (*obj).AntiVirus
		} else {
			antiVirus_entry = new(dynamicupdates.UpdateScheduleAntiVirus)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAntiVirusObject
		diags.Append(o.AntiVirus.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &antiVirus_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var appProfile_entry *dynamicupdates.UpdateScheduleAppProfile
	if !o.AppProfile.IsUnknown() && !o.AppProfile.IsNull() {
		if *obj != nil && (*obj).AppProfile != nil {
			appProfile_entry = (*obj).AppProfile
		} else {
			appProfile_entry = new(dynamicupdates.UpdateScheduleAppProfile)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAppProfileObject
		diags.Append(o.AppProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &appProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectClientlessVpn_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn
	if !o.GlobalProtectClientlessVpn.IsUnknown() && !o.GlobalProtectClientlessVpn.IsNull() {
		if *obj != nil && (*obj).GlobalProtectClientlessVpn != nil {
			globalProtectClientlessVpn_entry = (*obj).GlobalProtectClientlessVpn
		} else {
			globalProtectClientlessVpn_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject
		diags.Append(o.GlobalProtectClientlessVpn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalProtectClientlessVpn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectDatafile_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafile
	if !o.GlobalProtectDatafile.IsUnknown() && !o.GlobalProtectDatafile.IsNull() {
		if *obj != nil && (*obj).GlobalProtectDatafile != nil {
			globalProtectDatafile_entry = (*obj).GlobalProtectDatafile
		} else {
			globalProtectDatafile_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject
		diags.Append(o.GlobalProtectDatafile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalProtectDatafile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var statisticsService_entry *dynamicupdates.UpdateScheduleStatisticsService
	if !o.StatisticsService.IsUnknown() && !o.StatisticsService.IsNull() {
		if *obj != nil && (*obj).StatisticsService != nil {
			statisticsService_entry = (*obj).StatisticsService
		} else {
			statisticsService_entry = new(dynamicupdates.UpdateScheduleStatisticsService)
		}
		var object *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject
		diags.Append(o.StatisticsService.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &statisticsService_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var threats_entry *dynamicupdates.UpdateScheduleThreats
	if !o.Threats.IsUnknown() && !o.Threats.IsNull() {
		if *obj != nil && (*obj).Threats != nil {
			threats_entry = (*obj).Threats
		} else {
			threats_entry = new(dynamicupdates.UpdateScheduleThreats)
		}
		var object *DynamicUpdatesResourceUpdateScheduleThreatsObject
		diags.Append(o.Threats.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &threats_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var wfPrivate_entry *dynamicupdates.UpdateScheduleWfPrivate
	if !o.WfPrivate.IsUnknown() && !o.WfPrivate.IsNull() {
		if *obj != nil && (*obj).WfPrivate != nil {
			wfPrivate_entry = (*obj).WfPrivate
		} else {
			wfPrivate_entry = new(dynamicupdates.UpdateScheduleWfPrivate)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWfPrivateObject
		diags.Append(o.WfPrivate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &wfPrivate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var wildfire_entry *dynamicupdates.UpdateScheduleWildfire
	if !o.Wildfire.IsUnknown() && !o.Wildfire.IsNull() {
		if *obj != nil && (*obj).Wildfire != nil {
			wildfire_entry = (*obj).Wildfire
		} else {
			wildfire_entry = new(dynamicupdates.UpdateScheduleWildfire)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireObject
		diags.Append(o.Wildfire.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &wildfire_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateSchedule)
	}
	(*obj).AntiVirus = antiVirus_entry
	(*obj).AppProfile = appProfile_entry
	(*obj).GlobalProtectClientlessVpn = globalProtectClientlessVpn_entry
	(*obj).GlobalProtectDatafile = globalProtectDatafile_entry
	(*obj).StatisticsService = statisticsService_entry
	(*obj).Threats = threats_entry
	(*obj).WfPrivate = wfPrivate_entry
	(*obj).Wildfire = wildfire_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirus, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAntiVirusRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirus)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleAppProfileRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleAppProfileRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleAppProfileRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleAppProfileRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafile)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleStatisticsService, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	applicationReports_value := o.ApplicationReports.ValueBoolPointer()
	fileIdentificationReports_value := o.FileIdentificationReports.ValueBoolPointer()
	healthPerformanceReports_value := o.HealthPerformanceReports.ValueBoolPointer()
	passiveDnsMonitoring_value := o.PassiveDnsMonitoring.ValueBoolPointer()
	threatPreventionInformation_value := o.ThreatPreventionInformation.ValueBoolPointer()
	threatPreventionPcap_value := o.ThreatPreventionPcap.ValueBoolPointer()
	threatPreventionReports_value := o.ThreatPreventionReports.ValueBoolPointer()
	urlReports_value := o.UrlReports.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleStatisticsService)
	}
	(*obj).ApplicationReports = applicationReports_value
	(*obj).FileIdentificationReports = fileIdentificationReports_value
	(*obj).HealthPerformanceReports = healthPerformanceReports_value
	(*obj).PassiveDnsMonitoring = passiveDnsMonitoring_value
	(*obj).ThreatPreventionInformation = threatPreventionInformation_value
	(*obj).ThreatPreventionPcap = threatPreventionPcap_value
	(*obj).ThreatPreventionReports = threatPreventionReports_value
	(*obj).UrlReports = urlReports_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreats, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleThreatsRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleThreatsRecurring)
		}
		var object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreats)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	newAppThreshold_value := o.NewAppThreshold.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	threshold_value := o.Threshold.ValueInt64Pointer()
	var daily_entry *dynamicupdates.UpdateScheduleThreatsRecurringDaily
	if !o.Daily.IsUnknown() && !o.Daily.IsNull() {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
		}
		var object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject
		diags.Append(o.Daily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &daily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins
	if !o.Every30Mins.IsUnknown() && !o.Every30Mins.IsNull() {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
		}
		var object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject
		diags.Append(o.Every30Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every30Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *dynamicupdates.UpdateScheduleThreatsRecurringHourly
	if !o.Hourly.IsUnknown() && !o.Hourly.IsNull() {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject
		diags.Append(o.Hourly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &hourly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleThreatsRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
		}
		var object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *dynamicupdates.UpdateScheduleThreatsRecurringWeekly
	if !o.Weekly.IsUnknown() && !o.Weekly.IsNull() {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
		}
		var object *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject
		diags.Append(o.Weekly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weekly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurring)
	}
	(*obj).NewAppThreshold = newAppThreshold_value
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Threshold = threshold_value
	(*obj).Daily = daily_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Hourly = hourly_entry
	(*obj).None = none_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringDaily)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringHourly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleThreatsRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	disableNewContent_value := o.DisableNewContent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleThreatsRecurringWeekly)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).DisableNewContent = disableNewContent_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWfPrivateRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivate)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()
	var every15Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins
	if !o.Every15Mins.IsUnknown() && !o.Every15Mins.IsNull() {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject
		diags.Append(o.Every15Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every15Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins
	if !o.Every30Mins.IsUnknown() && !o.Every30Mins.IsNull() {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject
		diags.Append(o.Every30Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every30Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every5Mins_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins
	if !o.Every5Mins.IsUnknown() && !o.Every5Mins.IsNull() {
		if *obj != nil && (*obj).Every5Mins != nil {
			every5Mins_entry = (*obj).Every5Mins
		} else {
			every5Mins_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject
		diags.Append(o.Every5Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every5Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour
	if !o.EveryHour.IsUnknown() && !o.EveryHour.IsNull() {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject
		diags.Append(o.EveryHour.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &everyHour_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleWfPrivateRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurring)
	}
	(*obj).SyncToPeer = syncToPeer_value
	(*obj).Every15Mins = every15Mins_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).Every5Mins = every5Mins_entry
	(*obj).EveryHour = everyHour_entry
	(*obj).None = none_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWfPrivateRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWfPrivateRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *dynamicupdates.UpdateScheduleWildfireRecurring
	if !o.Recurring.IsUnknown() && !o.Recurring.IsNull() {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(dynamicupdates.UpdateScheduleWildfireRecurring)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject
		diags.Append(o.Recurring.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &recurring_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfire)
	}
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var every15Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins
	if !o.Every15Mins.IsUnknown() && !o.Every15Mins.IsNull() {
		if *obj != nil && (*obj).Every15Mins != nil {
			every15Mins_entry = (*obj).Every15Mins
		} else {
			every15Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject
		diags.Append(o.Every15Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every15Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var every30Mins_entry *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins
	if !o.Every30Mins.IsUnknown() && !o.Every30Mins.IsNull() {
		if *obj != nil && (*obj).Every30Mins != nil {
			every30Mins_entry = (*obj).Every30Mins
		} else {
			every30Mins_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject
		diags.Append(o.Every30Mins.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &every30Mins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyHour_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour
	if !o.EveryHour.IsUnknown() && !o.EveryHour.IsNull() {
		if *obj != nil && (*obj).EveryHour != nil {
			everyHour_entry = (*obj).EveryHour
		} else {
			everyHour_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject
		diags.Append(o.EveryHour.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &everyHour_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var everyMin_entry *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin
	if !o.EveryMin.IsUnknown() && !o.EveryMin.IsNull() {
		if *obj != nil && (*obj).EveryMin != nil {
			everyMin_entry = (*obj).EveryMin
		} else {
			everyMin_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject
		diags.Append(o.EveryMin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &everyMin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *dynamicupdates.UpdateScheduleWildfireRecurringNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var realTime_entry *dynamicupdates.UpdateScheduleWildfireRecurringRealTime
	if !o.RealTime.IsUnknown() && !o.RealTime.IsNull() {
		if *obj != nil && (*obj).RealTime != nil {
			realTime_entry = (*obj).RealTime
		} else {
			realTime_entry = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
		}
		var object *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject
		diags.Append(o.RealTime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &realTime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurring)
	}
	(*obj).Every15Mins = every15Mins_entry
	(*obj).Every30Mins = every30Mins_entry
	(*obj).EveryHour = everyHour_entry
	(*obj).EveryMin = everyMin_entry
	(*obj).None = none_entry
	(*obj).RealTime = realTime_entry

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	at_value := o.At.ValueInt64Pointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryHour)
	}
	(*obj).Action = action_value
	(*obj).At = at_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	syncToPeer_value := o.SyncToPeer.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringEveryMin)
	}
	(*obj).Action = action_value
	(*obj).SyncToPeer = syncToPeer_value

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringNone)
	}

	return diags
}
func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **dynamicupdates.UpdateScheduleWildfireRecurringRealTime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dynamicupdates.UpdateScheduleWildfireRecurringRealTime)
	}

	return diags
}

func (o *DynamicUpdatesResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var updateSchedule_obj *DynamicUpdatesResourceUpdateScheduleObject
	if o.UpdateSchedule.IsNull() {
		updateSchedule_obj = new(DynamicUpdatesResourceUpdateScheduleObject)
	} else {
		diags.Append(o.UpdateSchedule.As(ctx, &updateSchedule_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	updateSchedule_object := types.ObjectNull(updateSchedule_obj.AttributeTypes())
	if obj.UpdateSchedule != nil {
		diags.Append(updateSchedule_obj.CopyFromPango(ctx, client, ancestors, obj.UpdateSchedule, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		updateSchedule_object, diags_tmp = types.ObjectValueFrom(ctx, updateSchedule_obj.AttributeTypes(), updateSchedule_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.UpdateSchedule = updateSchedule_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateSchedule, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var antiVirus_obj *DynamicUpdatesResourceUpdateScheduleAntiVirusObject
	if o.AntiVirus.IsNull() {
		antiVirus_obj = new(DynamicUpdatesResourceUpdateScheduleAntiVirusObject)
	} else {
		diags.Append(o.AntiVirus.As(ctx, &antiVirus_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	antiVirus_object := types.ObjectNull(antiVirus_obj.AttributeTypes())
	if obj.AntiVirus != nil {
		diags.Append(antiVirus_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AntiVirus, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		antiVirus_object, diags_tmp = types.ObjectValueFrom(ctx, antiVirus_obj.AttributeTypes(), antiVirus_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var appProfile_obj *DynamicUpdatesResourceUpdateScheduleAppProfileObject
	if o.AppProfile.IsNull() {
		appProfile_obj = new(DynamicUpdatesResourceUpdateScheduleAppProfileObject)
	} else {
		diags.Append(o.AppProfile.As(ctx, &appProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	appProfile_object := types.ObjectNull(appProfile_obj.AttributeTypes())
	if obj.AppProfile != nil {
		diags.Append(appProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AppProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		appProfile_object, diags_tmp = types.ObjectValueFrom(ctx, appProfile_obj.AttributeTypes(), appProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalProtectClientlessVpn_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject
	if o.GlobalProtectClientlessVpn.IsNull() {
		globalProtectClientlessVpn_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject)
	} else {
		diags.Append(o.GlobalProtectClientlessVpn.As(ctx, &globalProtectClientlessVpn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalProtectClientlessVpn_object := types.ObjectNull(globalProtectClientlessVpn_obj.AttributeTypes())
	if obj.GlobalProtectClientlessVpn != nil {
		diags.Append(globalProtectClientlessVpn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalProtectClientlessVpn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalProtectClientlessVpn_object, diags_tmp = types.ObjectValueFrom(ctx, globalProtectClientlessVpn_obj.AttributeTypes(), globalProtectClientlessVpn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalProtectDatafile_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject
	if o.GlobalProtectDatafile.IsNull() {
		globalProtectDatafile_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject)
	} else {
		diags.Append(o.GlobalProtectDatafile.As(ctx, &globalProtectDatafile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalProtectDatafile_object := types.ObjectNull(globalProtectDatafile_obj.AttributeTypes())
	if obj.GlobalProtectDatafile != nil {
		diags.Append(globalProtectDatafile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalProtectDatafile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalProtectDatafile_object, diags_tmp = types.ObjectValueFrom(ctx, globalProtectDatafile_obj.AttributeTypes(), globalProtectDatafile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var statisticsService_obj *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject
	if o.StatisticsService.IsNull() {
		statisticsService_obj = new(DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject)
	} else {
		diags.Append(o.StatisticsService.As(ctx, &statisticsService_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	statisticsService_object := types.ObjectNull(statisticsService_obj.AttributeTypes())
	if obj.StatisticsService != nil {
		diags.Append(statisticsService_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StatisticsService, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		statisticsService_object, diags_tmp = types.ObjectValueFrom(ctx, statisticsService_obj.AttributeTypes(), statisticsService_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var threats_obj *DynamicUpdatesResourceUpdateScheduleThreatsObject
	if o.Threats.IsNull() {
		threats_obj = new(DynamicUpdatesResourceUpdateScheduleThreatsObject)
	} else {
		diags.Append(o.Threats.As(ctx, &threats_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	threats_object := types.ObjectNull(threats_obj.AttributeTypes())
	if obj.Threats != nil {
		diags.Append(threats_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Threats, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		threats_object, diags_tmp = types.ObjectValueFrom(ctx, threats_obj.AttributeTypes(), threats_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var wfPrivate_obj *DynamicUpdatesResourceUpdateScheduleWfPrivateObject
	if o.WfPrivate.IsNull() {
		wfPrivate_obj = new(DynamicUpdatesResourceUpdateScheduleWfPrivateObject)
	} else {
		diags.Append(o.WfPrivate.As(ctx, &wfPrivate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	wfPrivate_object := types.ObjectNull(wfPrivate_obj.AttributeTypes())
	if obj.WfPrivate != nil {
		diags.Append(wfPrivate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WfPrivate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		wfPrivate_object, diags_tmp = types.ObjectValueFrom(ctx, wfPrivate_obj.AttributeTypes(), wfPrivate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var wildfire_obj *DynamicUpdatesResourceUpdateScheduleWildfireObject
	if o.Wildfire.IsNull() {
		wildfire_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireObject)
	} else {
		diags.Append(o.Wildfire.As(ctx, &wildfire_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	wildfire_object := types.ObjectNull(wildfire_obj.AttributeTypes())
	if obj.Wildfire != nil {
		diags.Append(wildfire_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Wildfire, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		wildfire_object, diags_tmp = types.ObjectValueFrom(ctx, wildfire_obj.AttributeTypes(), wildfire_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.AntiVirus = antiVirus_object
	o.AppProfile = appProfile_object
	o.GlobalProtectClientlessVpn = globalProtectClientlessVpn_object
	o.GlobalProtectDatafile = globalProtectDatafile_object
	o.StatisticsService = statisticsService_object
	o.Threats = threats_object
	o.WfPrivate = wfPrivate_object
	o.Wildfire = wildfire_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirus, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAntiVirusRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAntiVirusRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleAppProfileRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleAppProfileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectClientlessVpnRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectClientlessVpnRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleGlobalProtectDatafileRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleGlobalProtectDatafileRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleStatisticsServiceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleStatisticsService, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var applicationReports_value types.Bool
	if obj.ApplicationReports != nil {
		applicationReports_value = types.BoolValue(*obj.ApplicationReports)
	}
	var fileIdentificationReports_value types.Bool
	if obj.FileIdentificationReports != nil {
		fileIdentificationReports_value = types.BoolValue(*obj.FileIdentificationReports)
	}
	var healthPerformanceReports_value types.Bool
	if obj.HealthPerformanceReports != nil {
		healthPerformanceReports_value = types.BoolValue(*obj.HealthPerformanceReports)
	}
	var passiveDnsMonitoring_value types.Bool
	if obj.PassiveDnsMonitoring != nil {
		passiveDnsMonitoring_value = types.BoolValue(*obj.PassiveDnsMonitoring)
	}
	var threatPreventionInformation_value types.Bool
	if obj.ThreatPreventionInformation != nil {
		threatPreventionInformation_value = types.BoolValue(*obj.ThreatPreventionInformation)
	}
	var threatPreventionPcap_value types.Bool
	if obj.ThreatPreventionPcap != nil {
		threatPreventionPcap_value = types.BoolValue(*obj.ThreatPreventionPcap)
	}
	var threatPreventionReports_value types.Bool
	if obj.ThreatPreventionReports != nil {
		threatPreventionReports_value = types.BoolValue(*obj.ThreatPreventionReports)
	}
	var urlReports_value types.Bool
	if obj.UrlReports != nil {
		urlReports_value = types.BoolValue(*obj.UrlReports)
	}
	o.ApplicationReports = applicationReports_value
	o.FileIdentificationReports = fileIdentificationReports_value
	o.HealthPerformanceReports = healthPerformanceReports_value
	o.PassiveDnsMonitoring = passiveDnsMonitoring_value
	o.ThreatPreventionInformation = threatPreventionInformation_value
	o.ThreatPreventionPcap = threatPreventionPcap_value
	o.ThreatPreventionReports = threatPreventionReports_value
	o.UrlReports = urlReports_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreats, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var daily_obj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject
	if o.Daily.IsNull() {
		daily_obj = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject)
	} else {
		diags.Append(o.Daily.As(ctx, &daily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	daily_object := types.ObjectNull(daily_obj.AttributeTypes())
	if obj.Daily != nil {
		diags.Append(daily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Daily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		daily_object, diags_tmp = types.ObjectValueFrom(ctx, daily_obj.AttributeTypes(), daily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every30Mins_obj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject
	if o.Every30Mins.IsNull() {
		every30Mins_obj = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject)
	} else {
		diags.Append(o.Every30Mins.As(ctx, &every30Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every30Mins_object := types.ObjectNull(every30Mins_obj.AttributeTypes())
	if obj.Every30Mins != nil {
		diags.Append(every30Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every30Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every30Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every30Mins_obj.AttributeTypes(), every30Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var hourly_obj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject
	if o.Hourly.IsNull() {
		hourly_obj = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject)
	} else {
		diags.Append(o.Hourly.As(ctx, &hourly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	hourly_object := types.ObjectNull(hourly_obj.AttributeTypes())
	if obj.Hourly != nil {
		diags.Append(hourly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Hourly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		hourly_object, diags_tmp = types.ObjectValueFrom(ctx, hourly_obj.AttributeTypes(), hourly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weekly_obj *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject
	if o.Weekly.IsNull() {
		weekly_obj = new(DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject)
	} else {
		diags.Append(o.Weekly.As(ctx, &weekly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weekly_object := types.ObjectNull(weekly_obj.AttributeTypes())
	if obj.Weekly != nil {
		diags.Append(weekly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Weekly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weekly_object, diags_tmp = types.ObjectValueFrom(ctx, weekly_obj.AttributeTypes(), weekly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var newAppThreshold_value types.Int64
	if obj.NewAppThreshold != nil {
		newAppThreshold_value = types.Int64Value(*obj.NewAppThreshold)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.NewAppThreshold = newAppThreshold_value
	o.SyncToPeer = syncToPeer_value
	o.Threshold = threshold_value
	o.Daily = daily_object
	o.Every30Mins = every30Mins_object
	o.Hourly = hourly_object
	o.None = none_object
	o.Weekly = weekly_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringDailyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringDaily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringHourlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringHourly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleThreatsRecurringWeeklyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleThreatsRecurringWeekly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var disableNewContent_value types.Bool
	if obj.DisableNewContent != nil {
		disableNewContent_value = types.BoolValue(*obj.DisableNewContent)
	}
	o.Action = action_value
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value
	o.DisableNewContent = disableNewContent_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var every15Mins_obj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject
	if o.Every15Mins.IsNull() {
		every15Mins_obj = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject)
	} else {
		diags.Append(o.Every15Mins.As(ctx, &every15Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every15Mins_object := types.ObjectNull(every15Mins_obj.AttributeTypes())
	if obj.Every15Mins != nil {
		diags.Append(every15Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every15Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every15Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every15Mins_obj.AttributeTypes(), every15Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every30Mins_obj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject
	if o.Every30Mins.IsNull() {
		every30Mins_obj = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject)
	} else {
		diags.Append(o.Every30Mins.As(ctx, &every30Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every30Mins_object := types.ObjectNull(every30Mins_obj.AttributeTypes())
	if obj.Every30Mins != nil {
		diags.Append(every30Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every30Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every30Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every30Mins_obj.AttributeTypes(), every30Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every5Mins_obj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject
	if o.Every5Mins.IsNull() {
		every5Mins_obj = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject)
	} else {
		diags.Append(o.Every5Mins.As(ctx, &every5Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every5Mins_object := types.ObjectNull(every5Mins_obj.AttributeTypes())
	if obj.Every5Mins != nil {
		diags.Append(every5Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every5Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every5Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every5Mins_obj.AttributeTypes(), every5Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var everyHour_obj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject
	if o.EveryHour.IsNull() {
		everyHour_obj = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject)
	} else {
		diags.Append(o.EveryHour.As(ctx, &everyHour_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	everyHour_object := types.ObjectNull(everyHour_obj.AttributeTypes())
	if obj.EveryHour != nil {
		diags.Append(everyHour_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EveryHour, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		everyHour_object, diags_tmp = types.ObjectValueFrom(ctx, everyHour_obj.AttributeTypes(), everyHour_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.SyncToPeer = syncToPeer_value
	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object
	o.Every5Mins = every5Mins_object
	o.EveryHour = everyHour_object
	o.None = none_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEvery5MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEvery5Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringEveryHourObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	o.Action = action_value
	o.At = at_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWfPrivateRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWfPrivateRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurring_obj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject
	if o.Recurring.IsNull() {
		recurring_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject)
	} else {
		diags.Append(o.Recurring.As(ctx, &recurring_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	recurring_object := types.ObjectNull(recurring_obj.AttributeTypes())
	if obj.Recurring != nil {
		diags.Append(recurring_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Recurring, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		recurring_object, diags_tmp = types.ObjectValueFrom(ctx, recurring_obj.AttributeTypes(), recurring_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Recurring = recurring_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurring, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var every15Mins_obj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject
	if o.Every15Mins.IsNull() {
		every15Mins_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject)
	} else {
		diags.Append(o.Every15Mins.As(ctx, &every15Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every15Mins_object := types.ObjectNull(every15Mins_obj.AttributeTypes())
	if obj.Every15Mins != nil {
		diags.Append(every15Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every15Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every15Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every15Mins_obj.AttributeTypes(), every15Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var every30Mins_obj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject
	if o.Every30Mins.IsNull() {
		every30Mins_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject)
	} else {
		diags.Append(o.Every30Mins.As(ctx, &every30Mins_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	every30Mins_object := types.ObjectNull(every30Mins_obj.AttributeTypes())
	if obj.Every30Mins != nil {
		diags.Append(every30Mins_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Every30Mins, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		every30Mins_object, diags_tmp = types.ObjectValueFrom(ctx, every30Mins_obj.AttributeTypes(), every30Mins_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var everyHour_obj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject
	if o.EveryHour.IsNull() {
		everyHour_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject)
	} else {
		diags.Append(o.EveryHour.As(ctx, &everyHour_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	everyHour_object := types.ObjectNull(everyHour_obj.AttributeTypes())
	if obj.EveryHour != nil {
		diags.Append(everyHour_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EveryHour, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		everyHour_object, diags_tmp = types.ObjectValueFrom(ctx, everyHour_obj.AttributeTypes(), everyHour_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var everyMin_obj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject
	if o.EveryMin.IsNull() {
		everyMin_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject)
	} else {
		diags.Append(o.EveryMin.As(ctx, &everyMin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	everyMin_object := types.ObjectNull(everyMin_obj.AttributeTypes())
	if obj.EveryMin != nil {
		diags.Append(everyMin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EveryMin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		everyMin_object, diags_tmp = types.ObjectValueFrom(ctx, everyMin_obj.AttributeTypes(), everyMin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject
	if o.None.IsNull() {
		none_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var realTime_obj *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject
	if o.RealTime.IsNull() {
		realTime_obj = new(DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject)
	} else {
		diags.Append(o.RealTime.As(ctx, &realTime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	realTime_object := types.ObjectNull(realTime_obj.AttributeTypes())
	if obj.RealTime != nil {
		diags.Append(realTime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RealTime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		realTime_object, diags_tmp = types.ObjectValueFrom(ctx, realTime_obj.AttributeTypes(), realTime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Every15Mins = every15Mins_object
	o.Every30Mins = every30Mins_object
	o.EveryHour = everyHour_object
	o.EveryMin = everyMin_object
	o.None = none_object
	o.RealTime = realTime_object

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery15MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery15Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEvery30MinsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEvery30Mins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryHourObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryHour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var at_value types.Int64
	if obj.At != nil {
		at_value = types.Int64Value(*obj.At)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.At = at_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringEveryMinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringEveryMin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var syncToPeer_value types.Bool
	if obj.SyncToPeer != nil {
		syncToPeer_value = types.BoolValue(*obj.SyncToPeer)
	}
	o.Action = action_value
	o.SyncToPeer = syncToPeer_value

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceUpdateScheduleWildfireRecurringRealTimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *dynamicupdates.UpdateScheduleWildfireRecurringRealTime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DynamicUpdatesResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *DynamicUpdatesResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Create",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location dynamicupdates.Location

	{
		var terraformLocation DynamicUpdatesLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &dynamicupdates.SystemLocation{}
			var innerLocation DynamicUpdatesSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dynamicupdates.TemplateLocation{}
			var innerLocation DynamicUpdatesTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dynamicupdates.TemplateStackLocation{}
			var innerLocation DynamicUpdatesTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *dynamicupdates.Config
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *DynamicUpdatesResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location dynamicupdates.Location

	{
		var terraformLocation DynamicUpdatesLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &dynamicupdates.SystemLocation{}
			var innerLocation DynamicUpdatesSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dynamicupdates.TemplateLocation{}
			var innerLocation DynamicUpdatesTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dynamicupdates.TemplateStackLocation{}
			var innerLocation DynamicUpdatesTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Read",
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *DynamicUpdatesResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location dynamicupdates.Location

	{
		var terraformLocation DynamicUpdatesLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &dynamicupdates.SystemLocation{}
			var innerLocation DynamicUpdatesSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dynamicupdates.TemplateLocation{}
			var innerLocation DynamicUpdatesTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dynamicupdates.TemplateStackLocation{}
			var innerLocation DynamicUpdatesTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := o.manager.Read(ctx, location, components)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := o.manager.Update(ctx, location, components, obj)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *DynamicUpdatesResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state DynamicUpdatesResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_dynamic_updates_resource",
		"function":      "Delete",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location dynamicupdates.Location

	{
		var terraformLocation DynamicUpdatesLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &dynamicupdates.SystemLocation{}
			var innerLocation DynamicUpdatesSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dynamicupdates.TemplateLocation{}
			var innerLocation DynamicUpdatesTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dynamicupdates.TemplateStackLocation{}
			var innerLocation DynamicUpdatesTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	existing, err := o.manager.Read(ctx, location, components)
	if err != nil {
		resp.Diagnostics.AddError("Error while deleting resource", err.Error())
		return
	}

	var obj dynamicupdates.Config
	obj.Misc = existing.Misc

	err = o.manager.Delete(ctx, location, &obj)
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

func (o *DynamicUpdatesResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

}

type DynamicUpdatesSystemLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type DynamicUpdatesTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type DynamicUpdatesTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type DynamicUpdatesLocation struct {
	System        types.Object `tfsdk:"system"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func DynamicUpdatesLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"system": rsschema.SingleNestedAttribute{
				Description: "Located in a system settings.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("system"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template stack.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o DynamicUpdatesSystemLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesSystemLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DynamicUpdatesTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DynamicUpdatesTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DynamicUpdatesLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		System        *DynamicUpdatesSystemLocation        `json:"system,omitempty"`
		Template      *DynamicUpdatesTemplateLocation      `json:"template,omitempty"`
		TemplateStack *DynamicUpdatesTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var system_object *DynamicUpdatesSystemLocation
	{
		diags := o.System.As(context.TODO(), &system_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal system into JSON document", diags.Errors())
		}
	}
	var template_object *DynamicUpdatesTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *DynamicUpdatesTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		System:        system_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *DynamicUpdatesLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		System        *DynamicUpdatesSystemLocation        `json:"system,omitempty"`
		Template      *DynamicUpdatesTemplateLocation      `json:"template,omitempty"`
		TemplateStack *DynamicUpdatesTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var system_object types.Object
	{
		var diags_tmp diag.Diagnostics
		system_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.System.AttributeTypes(), shadow.System)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into system", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.System = system_object
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *DynamicUpdatesSystemLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *DynamicUpdatesTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *DynamicUpdatesTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *DynamicUpdatesLocation) AttributeTypes() map[string]attr.Type {
	var systemObj DynamicUpdatesSystemLocation
	var templateObj DynamicUpdatesTemplateLocation
	var templateStackObj DynamicUpdatesTemplateStackLocation
	return map[string]attr.Type{
		"system": types.ObjectType{
			AttrTypes: systemObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
