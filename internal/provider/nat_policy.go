package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/movement"
	"github.com/PaloAltoNetworks/pango/policies/rules/nat"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &NatPolicyDataSource{}
	_ datasource.DataSourceWithConfigure = &NatPolicyDataSource{}
)

func NewNatPolicyDataSource() datasource.DataSource {
	return &NatPolicyDataSource{}
}

type NatPolicyDataSource struct {
	client  *pango.Client
	manager *sdkmanager.UuidObjectManager[*nat.Entry, nat.Location, *nat.Service]
}

type NatPolicyDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type NatPolicyDataSourceModel struct {
	Location types.Object `tfsdk:"location"`
	Rules    types.List   `tfsdk:"rules"`
}
type NatPolicyDataSourceRulesObject struct {
	Name                          types.String                                                 `tfsdk:"name"`
	ActiveActiveDeviceBinding     types.String                                                 `tfsdk:"active_active_device_binding"`
	Description                   types.String                                                 `tfsdk:"description"`
	DestinationAddresses          types.List                                                   `tfsdk:"destination_addresses"`
	Disabled                      types.Bool                                                   `tfsdk:"disabled"`
	SourceZones                   types.List                                                   `tfsdk:"source_zones"`
	GroupTag                      types.String                                                 `tfsdk:"group_tag"`
	NatType                       types.String                                                 `tfsdk:"nat_type"`
	Service                       types.String                                                 `tfsdk:"service"`
	SourceAddresses               types.List                                                   `tfsdk:"source_addresses"`
	SourceTranslation             *NatPolicyDataSourceRulesSourceTranslationObject             `tfsdk:"source_translation"`
	Tag                           types.List                                                   `tfsdk:"tag"`
	Target                        *NatPolicyDataSourceRulesTargetObject                        `tfsdk:"target"`
	DestinationZone               types.List                                                   `tfsdk:"destination_zone"`
	ToInterface                   types.String                                                 `tfsdk:"to_interface"`
	DestinationTranslation        *NatPolicyDataSourceRulesDestinationTranslationObject        `tfsdk:"destination_translation"`
	DynamicDestinationTranslation *NatPolicyDataSourceRulesDynamicDestinationTranslationObject `tfsdk:"dynamic_destination_translation"`
}
type NatPolicyDataSourceRulesSourceTranslationObject struct {
	DynamicIp        *NatPolicyDataSourceRulesSourceTranslationDynamicIpObject        `tfsdk:"dynamic_ip"`
	DynamicIpAndPort *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject `tfsdk:"dynamic_ip_and_port"`
	StaticIp         *NatPolicyDataSourceRulesSourceTranslationStaticIpObject         `tfsdk:"static_ip"`
}
type NatPolicyDataSourceRulesSourceTranslationDynamicIpObject struct {
	Fallback          *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject `tfsdk:"fallback"`
	TranslatedAddress types.List                                                        `tfsdk:"translated_address"`
}
type NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject struct {
	InterfaceAddress  *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                        `tfsdk:"translated_address"`
}
type NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject struct {
	InterfaceAddress  *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                       `tfsdk:"translated_address"`
}
type NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyDataSourceRulesSourceTranslationStaticIpObject struct {
	BiDirectional     types.String `tfsdk:"bi_directional"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
}
type NatPolicyDataSourceRulesTargetObject struct {
	Devices types.List `tfsdk:"devices"`
	Negate  types.Bool `tfsdk:"negate"`
	Tags    types.List `tfsdk:"tags"`
}
type NatPolicyDataSourceRulesTargetDevicesObject struct {
	Name types.String `tfsdk:"name"`
	Vsys types.List   `tfsdk:"vsys"`
}
type NatPolicyDataSourceRulesTargetDevicesVsysObject struct {
	Name types.String `tfsdk:"name"`
}
type NatPolicyDataSourceRulesDestinationTranslationObject struct {
	TranslatedAddress types.String                                                    `tfsdk:"translated_address"`
	TranslatedPort    types.Int64                                                     `tfsdk:"translated_port"`
	DnsRewrite        *NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject `tfsdk:"dns_rewrite"`
}
type NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject struct {
	Direction types.String `tfsdk:"direction"`
}
type NatPolicyDataSourceRulesDynamicDestinationTranslationObject struct {
	Distribution      types.String `tfsdk:"distribution"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
	TranslatedPort    types.Int64  `tfsdk:"translated_port"`
}

func (o *NatPolicyDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj NatPolicyLocation

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"rules": types.ListType{},
	}
}
func (o *NatPolicyDataSourceRulesObject) AttributeTypes() map[string]attr.Type {

	var sourceTranslationObj *NatPolicyDataSourceRulesSourceTranslationObject

	var targetObj *NatPolicyDataSourceRulesTargetObject

	var destinationTranslationObj *NatPolicyDataSourceRulesDestinationTranslationObject

	var dynamicDestinationTranslationObj *NatPolicyDataSourceRulesDynamicDestinationTranslationObject
	return map[string]attr.Type{
		"name":                         types.StringType,
		"active_active_device_binding": types.StringType,
		"description":                  types.StringType,
		"destination_addresses":        types.ListType{},
		"disabled":                     types.BoolType,
		"source_zones":                 types.ListType{},
		"group_tag":                    types.StringType,
		"nat_type":                     types.StringType,
		"service":                      types.StringType,
		"source_addresses":             types.ListType{},
		"source_translation": types.ObjectType{
			AttrTypes: sourceTranslationObj.AttributeTypes(),
		},
		"tag": types.ListType{},
		"target": types.ObjectType{
			AttrTypes: targetObj.AttributeTypes(),
		},
		"destination_zone": types.ListType{},
		"to_interface":     types.StringType,
		"destination_translation": types.ObjectType{
			AttrTypes: destinationTranslationObj.AttributeTypes(),
		},
		"dynamic_destination_translation": types.ObjectType{
			AttrTypes: dynamicDestinationTranslationObj.AttributeTypes(),
		},
	}
}
func (o *NatPolicyDataSourceRulesSourceTranslationObject) AttributeTypes() map[string]attr.Type {

	var dynamicIpObj *NatPolicyDataSourceRulesSourceTranslationDynamicIpObject

	var dynamicIpAndPortObj *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject

	var staticIpObj *NatPolicyDataSourceRulesSourceTranslationStaticIpObject
	return map[string]attr.Type{
		"dynamic_ip": types.ObjectType{
			AttrTypes: dynamicIpObj.AttributeTypes(),
		},
		"dynamic_ip_and_port": types.ObjectType{
			AttrTypes: dynamicIpAndPortObj.AttributeTypes(),
		},
		"static_ip": types.ObjectType{
			AttrTypes: staticIpObj.AttributeTypes(),
		},
	}
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpObject) AttributeTypes() map[string]attr.Type {

	var fallbackObj *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject

	return map[string]attr.Type{
		"fallback": types.ObjectType{
			AttrTypes: fallbackObj.AttributeTypes(),
		},
		"translated_address": types.ListType{},
	}
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject) AttributeTypes() map[string]attr.Type {

	var interfaceAddressObj *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject

	return map[string]attr.Type{
		"interface_address": types.ObjectType{
			AttrTypes: interfaceAddressObj.AttributeTypes(),
		},
		"translated_address": types.ListType{},
	}
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject) AttributeTypes() map[string]attr.Type {

	var interfaceAddressObj *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject

	return map[string]attr.Type{
		"interface_address": types.ObjectType{
			AttrTypes: interfaceAddressObj.AttributeTypes(),
		},
		"translated_address": types.ListType{},
	}
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}
func (o *NatPolicyDataSourceRulesSourceTranslationStaticIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"bi_directional":     types.StringType,
		"translated_address": types.StringType,
	}
}
func (o *NatPolicyDataSourceRulesTargetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"devices": types.ListType{},
		"negate":  types.BoolType,
		"tags":    types.ListType{},
	}
}
func (o *NatPolicyDataSourceRulesTargetDevicesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"vsys": types.ListType{},
	}
}
func (o *NatPolicyDataSourceRulesTargetDevicesVsysObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}
func (o *NatPolicyDataSourceRulesDestinationTranslationObject) AttributeTypes() map[string]attr.Type {

	var dnsRewriteObj *NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject
	return map[string]attr.Type{
		"translated_address": types.StringType,
		"translated_port":    types.Int64Type,
		"dns_rewrite": types.ObjectType{
			AttrTypes: dnsRewriteObj.AttributeTypes(),
		},
	}
}
func (o *NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"direction": types.StringType,
	}
}
func (o *NatPolicyDataSourceRulesDynamicDestinationTranslationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"distribution":       types.StringType,
		"translated_address": types.StringType,
		"translated_port":    types.Int64Type,
	}
}

func (o *NatPolicyDataSourceRulesObject) CopyToPango(ctx context.Context, obj **nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	activeActiveDeviceBinding_value := o.ActiveActiveDeviceBinding.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	destinationAddresses_pango_entries := make([]string, 0)
	diags.Append(o.DestinationAddresses.ElementsAs(ctx, &destinationAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	disabled_value := o.Disabled.ValueBoolPointer()
	sourceZones_pango_entries := make([]string, 0)
	diags.Append(o.SourceZones.ElementsAs(ctx, &sourceZones_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	groupTag_value := o.GroupTag.ValueStringPointer()
	natType_value := o.NatType.ValueStringPointer()
	service_value := o.Service.ValueStringPointer()
	sourceAddresses_pango_entries := make([]string, 0)
	diags.Append(o.SourceAddresses.ElementsAs(ctx, &sourceAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var sourceTranslation_entry *nat.SourceTranslation
	if o.SourceTranslation != nil {
		if *obj != nil && (*obj).SourceTranslation != nil {
			sourceTranslation_entry = (*obj).SourceTranslation
		} else {
			sourceTranslation_entry = new(nat.SourceTranslation)
		}

		diags.Append(o.SourceTranslation.CopyToPango(ctx, &sourceTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var target_entry *nat.Target
	if o.Target != nil {
		if *obj != nil && (*obj).Target != nil {
			target_entry = (*obj).Target
		} else {
			target_entry = new(nat.Target)
		}

		diags.Append(o.Target.CopyToPango(ctx, &target_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	destinationZone_pango_entries := make([]string, 0)
	diags.Append(o.DestinationZone.ElementsAs(ctx, &destinationZone_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	toInterface_value := o.ToInterface.ValueStringPointer()
	var destinationTranslation_entry *nat.DestinationTranslation
	if o.DestinationTranslation != nil {
		if *obj != nil && (*obj).DestinationTranslation != nil {
			destinationTranslation_entry = (*obj).DestinationTranslation
		} else {
			destinationTranslation_entry = new(nat.DestinationTranslation)
		}

		diags.Append(o.DestinationTranslation.CopyToPango(ctx, &destinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_entry *nat.DynamicDestinationTranslation
	if o.DynamicDestinationTranslation != nil {
		if *obj != nil && (*obj).DynamicDestinationTranslation != nil {
			dynamicDestinationTranslation_entry = (*obj).DynamicDestinationTranslation
		} else {
			dynamicDestinationTranslation_entry = new(nat.DynamicDestinationTranslation)
		}

		diags.Append(o.DynamicDestinationTranslation.CopyToPango(ctx, &dynamicDestinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	(*obj).Description = description_value
	(*obj).Destination = destinationAddresses_pango_entries
	(*obj).Disabled = disabled_value
	(*obj).From = sourceZones_pango_entries
	(*obj).GroupTag = groupTag_value
	(*obj).NatType = natType_value
	(*obj).Service = service_value
	(*obj).Source = sourceAddresses_pango_entries
	(*obj).SourceTranslation = sourceTranslation_entry
	(*obj).Tag = tag_pango_entries
	(*obj).Target = target_entry
	(*obj).To = destinationZone_pango_entries
	(*obj).ToInterface = toInterface_value
	(*obj).DestinationTranslation = destinationTranslation_entry
	(*obj).DynamicDestinationTranslation = dynamicDestinationTranslation_entry

	return diags
}
func (o *NatPolicyDataSourceRulesSourceTranslationObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_entry *nat.SourceTranslationDynamicIp
	if o.DynamicIp != nil {
		if *obj != nil && (*obj).DynamicIp != nil {
			dynamicIp_entry = (*obj).DynamicIp
		} else {
			dynamicIp_entry = new(nat.SourceTranslationDynamicIp)
		}

		diags.Append(o.DynamicIp.CopyToPango(ctx, &dynamicIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_entry *nat.SourceTranslationDynamicIpAndPort
	if o.DynamicIpAndPort != nil {
		if *obj != nil && (*obj).DynamicIpAndPort != nil {
			dynamicIpAndPort_entry = (*obj).DynamicIpAndPort
		} else {
			dynamicIpAndPort_entry = new(nat.SourceTranslationDynamicIpAndPort)
		}

		diags.Append(o.DynamicIpAndPort.CopyToPango(ctx, &dynamicIpAndPort_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *nat.SourceTranslationStaticIp
	if o.StaticIp != nil {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(nat.SourceTranslationStaticIp)
		}

		diags.Append(o.StaticIp.CopyToPango(ctx, &staticIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslation)
	}
	(*obj).DynamicIp = dynamicIp_entry
	(*obj).DynamicIpAndPort = dynamicIpAndPort_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fallback_entry *nat.SourceTranslationDynamicIpFallback
	if o.Fallback != nil {
		if *obj != nil && (*obj).Fallback != nil {
			fallback_entry = (*obj).Fallback
		} else {
			fallback_entry = new(nat.SourceTranslationDynamicIpFallback)
		}

		diags.Append(o.Fallback.CopyToPango(ctx, &fallback_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIp)
	}
	(*obj).Fallback = fallback_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpFallbackInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallback)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpAndPortInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPort)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyDataSourceRulesSourceTranslationStaticIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	biDirectional_value := o.BiDirectional.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationStaticIp)
	}
	(*obj).BiDirectional = biDirectional_value
	(*obj).TranslatedAddress = translatedAddress_value

	return diags
}
func (o *NatPolicyDataSourceRulesTargetObject) CopyToPango(ctx context.Context, obj **nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_tf_entries []NatPolicyDataSourceRulesTargetDevicesObject
	var devices_pango_entries []nat.TargetDevices
	{
		d := o.Devices.ElementsAs(ctx, &devices_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range devices_tf_entries {
			var entry *nat.TargetDevices
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			devices_pango_entries = append(devices_pango_entries, *entry)
		}
	}
	negate_value := o.Negate.ValueBoolPointer()
	tags_pango_entries := make([]string, 0)
	diags.Append(o.Tags.ElementsAs(ctx, &tags_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.Target)
	}
	(*obj).Devices = devices_pango_entries
	(*obj).Negate = negate_value
	(*obj).Tags = tags_pango_entries

	return diags
}
func (o *NatPolicyDataSourceRulesTargetDevicesObject) CopyToPango(ctx context.Context, obj **nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_tf_entries []NatPolicyDataSourceRulesTargetDevicesVsysObject
	var vsys_pango_entries []nat.TargetDevicesVsys
	{
		d := o.Vsys.ElementsAs(ctx, &vsys_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vsys_tf_entries {
			var entry *nat.TargetDevicesVsys
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			vsys_pango_entries = append(vsys_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(nat.TargetDevices)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vsys = vsys_pango_entries

	return diags
}
func (o *NatPolicyDataSourceRulesTargetDevicesVsysObject) CopyToPango(ctx context.Context, obj **nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(nat.TargetDevicesVsys)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *NatPolicyDataSourceRulesDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()
	var dnsRewrite_entry *nat.DestinationTranslationDnsRewrite
	if o.DnsRewrite != nil {
		if *obj != nil && (*obj).DnsRewrite != nil {
			dnsRewrite_entry = (*obj).DnsRewrite
		} else {
			dnsRewrite_entry = new(nat.DestinationTranslationDnsRewrite)
		}

		diags.Append(o.DnsRewrite.CopyToPango(ctx, &dnsRewrite_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslation)
	}
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value
	(*obj).DnsRewrite = dnsRewrite_entry

	return diags
}
func (o *NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	direction_value := o.Direction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslationDnsRewrite)
	}
	(*obj).Direction = direction_value

	return diags
}
func (o *NatPolicyDataSourceRulesDynamicDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	distribution_value := o.Distribution.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(nat.DynamicDestinationTranslation)
	}
	(*obj).Distribution = distribution_value
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value

	return diags
}

func (o *NatPolicyDataSourceRulesObject) CopyFromPango(ctx context.Context, obj *nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var destinationAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		destinationAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var sourceZones_list types.List
	{
		var list_diags diag.Diagnostics
		sourceZones_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.From)
		diags.Append(list_diags...)
	}
	var sourceAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		sourceAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Source)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}
	var destinationZone_list types.List
	{
		var list_diags diag.Diagnostics
		destinationZone_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.To)
		diags.Append(list_diags...)
	}
	var sourceTranslation_object *NatPolicyDataSourceRulesSourceTranslationObject
	if obj.SourceTranslation != nil {
		sourceTranslation_object = new(NatPolicyDataSourceRulesSourceTranslationObject)

		diags.Append(sourceTranslation_object.CopyFromPango(ctx, obj.SourceTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var target_object *NatPolicyDataSourceRulesTargetObject
	if obj.Target != nil {
		target_object = new(NatPolicyDataSourceRulesTargetObject)

		diags.Append(target_object.CopyFromPango(ctx, obj.Target, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var destinationTranslation_object *NatPolicyDataSourceRulesDestinationTranslationObject
	if obj.DestinationTranslation != nil {
		destinationTranslation_object = new(NatPolicyDataSourceRulesDestinationTranslationObject)

		diags.Append(destinationTranslation_object.CopyFromPango(ctx, obj.DestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_object *NatPolicyDataSourceRulesDynamicDestinationTranslationObject
	if obj.DynamicDestinationTranslation != nil {
		dynamicDestinationTranslation_object = new(NatPolicyDataSourceRulesDynamicDestinationTranslationObject)

		diags.Append(dynamicDestinationTranslation_object.CopyFromPango(ctx, obj.DynamicDestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var activeActiveDeviceBinding_value types.String
	if obj.ActiveActiveDeviceBinding != nil {
		activeActiveDeviceBinding_value = types.StringValue(*obj.ActiveActiveDeviceBinding)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var groupTag_value types.String
	if obj.GroupTag != nil {
		groupTag_value = types.StringValue(*obj.GroupTag)
	}
	var natType_value types.String
	if obj.NatType != nil {
		natType_value = types.StringValue(*obj.NatType)
	}
	var service_value types.String
	if obj.Service != nil {
		service_value = types.StringValue(*obj.Service)
	}
	var toInterface_value types.String
	if obj.ToInterface != nil {
		toInterface_value = types.StringValue(*obj.ToInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	o.Description = description_value
	o.DestinationAddresses = destinationAddresses_list
	o.Disabled = disabled_value
	o.SourceZones = sourceZones_list
	o.GroupTag = groupTag_value
	o.NatType = natType_value
	o.Service = service_value
	o.SourceAddresses = sourceAddresses_list
	o.SourceTranslation = sourceTranslation_object
	o.Tag = tag_list
	o.Target = target_object
	o.DestinationZone = destinationZone_list
	o.ToInterface = toInterface_value
	o.DestinationTranslation = destinationTranslation_object
	o.DynamicDestinationTranslation = dynamicDestinationTranslation_object

	return diags
}

func (o *NatPolicyDataSourceRulesSourceTranslationObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_object *NatPolicyDataSourceRulesSourceTranslationDynamicIpObject
	if obj.DynamicIp != nil {
		dynamicIp_object = new(NatPolicyDataSourceRulesSourceTranslationDynamicIpObject)

		diags.Append(dynamicIp_object.CopyFromPango(ctx, obj.DynamicIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_object *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject
	if obj.DynamicIpAndPort != nil {
		dynamicIpAndPort_object = new(NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject)

		diags.Append(dynamicIpAndPort_object.CopyFromPango(ctx, obj.DynamicIpAndPort, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_object *NatPolicyDataSourceRulesSourceTranslationStaticIpObject
	if obj.StaticIp != nil {
		staticIp_object = new(NatPolicyDataSourceRulesSourceTranslationStaticIpObject)

		diags.Append(staticIp_object.CopyFromPango(ctx, obj.StaticIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.DynamicIp = dynamicIp_object
	o.DynamicIpAndPort = dynamicIpAndPort_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var fallback_object *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject
	if obj.Fallback != nil {
		fallback_object = new(NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject)

		diags.Append(fallback_object.CopyFromPango(ctx, obj.Fallback, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Fallback = fallback_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyDataSourceRulesSourceTranslationStaticIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var biDirectional_value types.String
	if obj.BiDirectional != nil {
		biDirectional_value = types.StringValue(*obj.BiDirectional)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	o.BiDirectional = biDirectional_value
	o.TranslatedAddress = translatedAddress_value

	return diags
}

func (o *NatPolicyDataSourceRulesTargetObject) CopyFromPango(ctx context.Context, obj *nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_list types.List
	{
		var devices_tf_entries []NatPolicyDataSourceRulesTargetDevicesObject
		for _, elt := range obj.Devices {
			var entry NatPolicyDataSourceRulesTargetDevicesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			devices_tf_entries = append(devices_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("devices")
		devices_list, list_diags = types.ListValueFrom(ctx, schemaType, devices_tf_entries)
		diags.Append(list_diags...)
	}
	var tags_list types.List
	{
		var list_diags diag.Diagnostics
		tags_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tags)
		diags.Append(list_diags...)
	}

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Devices = devices_list
	o.Negate = negate_value
	o.Tags = tags_list

	return diags
}

func (o *NatPolicyDataSourceRulesTargetDevicesObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_list types.List
	{
		var vsys_tf_entries []NatPolicyDataSourceRulesTargetDevicesVsysObject
		for _, elt := range obj.Vsys {
			var entry NatPolicyDataSourceRulesTargetDevicesVsysObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			vsys_tf_entries = append(vsys_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vsys")
		vsys_list, list_diags = types.ListValueFrom(ctx, schemaType, vsys_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vsys = vsys_list

	return diags
}

func (o *NatPolicyDataSourceRulesTargetDevicesVsysObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *NatPolicyDataSourceRulesDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsRewrite_object *NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject
	if obj.DnsRewrite != nil {
		dnsRewrite_object = new(NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject)

		diags.Append(dnsRewrite_object.CopyFromPango(ctx, obj.DnsRewrite, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value
	o.DnsRewrite = dnsRewrite_object

	return diags
}

func (o *NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var direction_value types.String
	if obj.Direction != nil {
		direction_value = types.StringValue(*obj.Direction)
	}
	o.Direction = direction_value

	return diags
}

func (o *NatPolicyDataSourceRulesDynamicDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var distribution_value types.String
	if obj.Distribution != nil {
		distribution_value = types.StringValue(*obj.Distribution)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.Distribution = distribution_value
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value

	return diags
}

func NatPolicyDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": NatPolicyDataSourceLocationSchema(),

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     true,
				Optional:     false,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyDataSourceRulesSchema(),
			},
		},
	}
}

func (o *NatPolicyDataSourceModel) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"active_active_device_binding": dsschema.StringAttribute{
				Description: "Device binding configuration in HA Active-Active mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"disabled": dsschema.BoolAttribute{
				Description: "Disable the rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_zones": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_tag": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nat_type": dsschema.StringAttribute{
				Description: "type of nat",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"service": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"source_translation": NatPolicyDataSourceRulesSourceTranslationSchema(),

			"tag": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"target": NatPolicyDataSourceRulesTargetSchema(),

			"destination_zone": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"to_interface": dsschema.StringAttribute{
				Description: "Egress interface from route lookup",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination_translation": NatPolicyDataSourceRulesDestinationTranslationSchema(),

			"dynamic_destination_translation": NatPolicyDataSourceRulesDynamicDestinationTranslationSchema(),
		},
	}
}

func (o *NatPolicyDataSourceRulesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSourceTranslationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dynamic_ip": NatPolicyDataSourceRulesSourceTranslationDynamicIpSchema(),

			"dynamic_ip_and_port": NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortSchema(),

			"static_ip": NatPolicyDataSourceRulesSourceTranslationStaticIpSchema(),
		},
	}
}

func (o *NatPolicyDataSourceRulesSourceTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSourceTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSourceTranslationDynamicIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"fallback": NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackSchema(),

			"translated_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSourceTranslationDynamicIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface_address": NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema(),

			"translated_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface_address": NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema(),

			"translated_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesSourceTranslationStaticIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"bi_directional": dsschema.StringAttribute{
				Description: "allow reverse translation from translated address to original address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesSourceTranslationStaticIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesSourceTranslationStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesTargetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"devices": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: NatPolicyDataSourceRulesTargetDevicesSchema(),
			},

			"negate": dsschema.BoolAttribute{
				Description: "Target to all but these specified devices and tags",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tags": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesTargetObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesTargetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesTargetDevicesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vsys": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: NatPolicyDataSourceRulesTargetDevicesVsysSchema(),
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesTargetDevicesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesTargetDevicesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesTargetDevicesVsysSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesTargetDevicesVsysObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesTargetDevicesVsysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesDestinationTranslationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"translated_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_rewrite": NatPolicyDataSourceRulesDestinationTranslationDnsRewriteSchema(),
		},
	}
}

func (o *NatPolicyDataSourceRulesDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesDestinationTranslationDnsRewriteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"direction": dsschema.StringAttribute{
				Description: "Select direction to apply DNS rewrite",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesDestinationTranslationDnsRewriteObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesDestinationTranslationDnsRewriteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceRulesDynamicDestinationTranslationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"distribution": dsschema.StringAttribute{
				Description: "Distribution algorithm for destination address pool",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_address": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyDataSourceRulesDynamicDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyDataSourceRulesDynamicDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyDataSourceLocationSchema() rsschema.Attribute {
	return NatPolicyLocationSchema()
}

// Metadata returns the data source type name.
func (d *NatPolicyDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_nat_policy"
}

// Schema defines the schema for this data source.
func (d *NatPolicyDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = NatPolicyDataSourceSchema()
}

// Configure prepares the struct.
func (d *NatPolicyDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := nat.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewUuidObjectManager(d.client, nat.NewService(d.client), batchSize, specifier, nat.SpecMatches)
}
func (o *NatPolicyDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state NatPolicyDataSourceModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy",
		"function":      "Create",
	})

	var location nat.Location

	{
		var terraformLocation NatPolicyLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &nat.SharedLocation{}
			var innerLocation NatPolicySharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Shared.Rulebase = innerLocation.Rulebase.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &nat.VsysLocation{}
			var innerLocation NatPolicyVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &nat.DeviceGroupLocation{}
			var innerLocation NatPolicyDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
			location.DeviceGroup.Rulebase = innerLocation.Rulebase.ValueString()
		}
	}

	var elements []NatPolicyDataSourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() || len(elements) == 0 {
		return
	}

	entries := make([]*nat.Entry, 0, len(elements))
	for _, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		entries = append(entries, entry)
	}

	// true

	position := movement.PositionFirst{}
	readEntries, _, err := o.manager.ReadMany(ctx, location, entries, sdkmanager.Exhaustive, position)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Failed to read entries from the server", err.Error())
		}
		return
	}

	var objects []NatPolicyDataSourceRulesObject
	for _, elt := range readEntries {
		var object NatPolicyDataSourceRulesObject
		err := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(err...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects = append(objects, object)
	}

	var list_diags diag.Diagnostics
	state.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &NatPolicyResource{}
	_ resource.ResourceWithConfigure   = &NatPolicyResource{}
	_ resource.ResourceWithImportState = &NatPolicyResource{}
)

func NewNatPolicyResource() resource.Resource {
	if _, found := resourceFuncMap["panos_nat_policy"]; !found {
		resourceFuncMap["panos_nat_policy"] = resourceFuncs{
			CreateImportId: NatPolicyImportStateCreator,
		}
	}
	return &NatPolicyResource{}
}

type NatPolicyResource struct {
	client  *pango.Client
	manager *sdkmanager.UuidObjectManager[*nat.Entry, nat.Location, *nat.Service]
}

func NatPolicyResourceLocationSchema() rsschema.Attribute {
	return NatPolicyLocationSchema()
}

type NatPolicyResourceModel struct {
	Location types.Object `tfsdk:"location"`
	Rules    types.List   `tfsdk:"rules"`
}
type NatPolicyResourceRulesObject struct {
	Name                          types.String                                               `tfsdk:"name"`
	ActiveActiveDeviceBinding     types.String                                               `tfsdk:"active_active_device_binding"`
	Description                   types.String                                               `tfsdk:"description"`
	DestinationAddresses          types.List                                                 `tfsdk:"destination_addresses"`
	Disabled                      types.Bool                                                 `tfsdk:"disabled"`
	SourceZones                   types.List                                                 `tfsdk:"source_zones"`
	GroupTag                      types.String                                               `tfsdk:"group_tag"`
	NatType                       types.String                                               `tfsdk:"nat_type"`
	Service                       types.String                                               `tfsdk:"service"`
	SourceAddresses               types.List                                                 `tfsdk:"source_addresses"`
	SourceTranslation             *NatPolicyResourceRulesSourceTranslationObject             `tfsdk:"source_translation"`
	Tag                           types.List                                                 `tfsdk:"tag"`
	Target                        *NatPolicyResourceRulesTargetObject                        `tfsdk:"target"`
	DestinationZone               types.List                                                 `tfsdk:"destination_zone"`
	ToInterface                   types.String                                               `tfsdk:"to_interface"`
	DestinationTranslation        *NatPolicyResourceRulesDestinationTranslationObject        `tfsdk:"destination_translation"`
	DynamicDestinationTranslation *NatPolicyResourceRulesDynamicDestinationTranslationObject `tfsdk:"dynamic_destination_translation"`
}
type NatPolicyResourceRulesSourceTranslationObject struct {
	DynamicIp        *NatPolicyResourceRulesSourceTranslationDynamicIpObject        `tfsdk:"dynamic_ip"`
	DynamicIpAndPort *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject `tfsdk:"dynamic_ip_and_port"`
	StaticIp         *NatPolicyResourceRulesSourceTranslationStaticIpObject         `tfsdk:"static_ip"`
}
type NatPolicyResourceRulesSourceTranslationDynamicIpObject struct {
	Fallback          *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject `tfsdk:"fallback"`
	TranslatedAddress types.List                                                      `tfsdk:"translated_address"`
}
type NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject struct {
	InterfaceAddress  *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                      `tfsdk:"translated_address"`
}
type NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject struct {
	InterfaceAddress  *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject `tfsdk:"interface_address"`
	TranslatedAddress types.List                                                                     `tfsdk:"translated_address"`
}
type NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type NatPolicyResourceRulesSourceTranslationStaticIpObject struct {
	BiDirectional     types.String `tfsdk:"bi_directional"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
}
type NatPolicyResourceRulesTargetObject struct {
	Devices types.List `tfsdk:"devices"`
	Negate  types.Bool `tfsdk:"negate"`
	Tags    types.List `tfsdk:"tags"`
}
type NatPolicyResourceRulesTargetDevicesObject struct {
	Name types.String `tfsdk:"name"`
	Vsys types.List   `tfsdk:"vsys"`
}
type NatPolicyResourceRulesTargetDevicesVsysObject struct {
	Name types.String `tfsdk:"name"`
}
type NatPolicyResourceRulesDestinationTranslationObject struct {
	TranslatedAddress types.String                                                  `tfsdk:"translated_address"`
	TranslatedPort    types.Int64                                                   `tfsdk:"translated_port"`
	DnsRewrite        *NatPolicyResourceRulesDestinationTranslationDnsRewriteObject `tfsdk:"dns_rewrite"`
}
type NatPolicyResourceRulesDestinationTranslationDnsRewriteObject struct {
	Direction types.String `tfsdk:"direction"`
}
type NatPolicyResourceRulesDynamicDestinationTranslationObject struct {
	Distribution      types.String `tfsdk:"distribution"`
	TranslatedAddress types.String `tfsdk:"translated_address"`
	TranslatedPort    types.Int64  `tfsdk:"translated_port"`
}

func (r *NatPolicyResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	{
		var resource NatPolicyResourceModel
		resp.Diagnostics.Append(req.Config.Get(ctx, &resource)...)
		if resp.Diagnostics.HasError() {
			return
		}

		entries := make(map[string]struct{})
		duplicated := make(map[string]struct{})

		var elements []types.Object
		resp.Diagnostics.Append(resource.Rules.ElementsAs(ctx, &elements, true)...)
		if resp.Diagnostics.HasError() {
			return
		}

		for _, elt := range elements {
			var typedElt NatPolicyResourceRulesObject
			resp.Diagnostics.Append(elt.As(ctx, &typedElt, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}

			if typedElt.Name.IsUnknown() {
				continue
			}

			entry := typedElt.Name.ValueString()
			if _, found := entries[entry]; found {
				duplicated[entry] = struct{}{}
			}
			entries[entry] = struct{}{}
		}

		var _ = strings.Join([]string{"a", "b"}, ",")

		if len(duplicated) > 0 {
			var entries []string
			for elt := range duplicated {
				entries = append(entries, fmt.Sprintf("'%s'", elt))
			}
			resp.Diagnostics.AddError("Failed to validate resource", fmt.Sprintf("Non-unique entry names in the list: %s", strings.Join(entries, ",")))
			return
		}

	}
}

// <ResourceSchema>

func NatPolicyResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": NatPolicyResourceLocationSchema(),

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     true,
				Optional:     false,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyResourceRulesSchema(),
			},
		},
	}
}

func (o *NatPolicyResourceModel) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"active_active_device_binding": rsschema.StringAttribute{
				Description: "Device binding configuration in HA Active-Active mode",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"primary",
						"both",
						"0",
						"1",
					}...),
				},
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"disabled": rsschema.BoolAttribute{
				Description: "Disable the rule",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_zones": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_tag": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nat_type": rsschema.StringAttribute{
				Description: "type of nat",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"ipv4",
						"nat64",
						"nptv6",
					}...),
				},
			},

			"service": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"source_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"source_translation": NatPolicyResourceRulesSourceTranslationSchema(),

			"tag": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"target": NatPolicyResourceRulesTargetSchema(),

			"destination_zone": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"to_interface": rsschema.StringAttribute{
				Description: "Egress interface from route lookup",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"destination_translation": NatPolicyResourceRulesDestinationTranslationSchema(),

			"dynamic_destination_translation": NatPolicyResourceRulesDynamicDestinationTranslationSchema(),
		},
	}
}

func (o *NatPolicyResourceRulesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSourceTranslationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dynamic_ip": NatPolicyResourceRulesSourceTranslationDynamicIpSchema(),

			"dynamic_ip_and_port": NatPolicyResourceRulesSourceTranslationDynamicIpAndPortSchema(),

			"static_ip": NatPolicyResourceRulesSourceTranslationStaticIpSchema(),
		},
	}
}

func (o *NatPolicyResourceRulesSourceTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSourceTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSourceTranslationDynamicIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"fallback": NatPolicyResourceRulesSourceTranslationDynamicIpFallbackSchema(),

			"translated_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSourceTranslationDynamicIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSourceTranslationDynamicIpFallbackSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface_address": NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema(),

			"translated_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSourceTranslationDynamicIpFallbackSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSourceTranslationDynamicIpAndPortSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface_address": NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema(),

			"translated_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSourceTranslationDynamicIpAndPortSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("interface_address"),
				path.MatchRelative().AtParent().AtName("translated_address"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesSourceTranslationStaticIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic_ip"),
				path.MatchRelative().AtParent().AtName("dynamic_ip_and_port"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"bi_directional": rsschema.StringAttribute{
				Description: "allow reverse translation from translated address to original address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("no"),
			},

			"translated_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyResourceRulesSourceTranslationStaticIpObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesSourceTranslationStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesTargetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"devices": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyResourceRulesTargetDevicesSchema(),
			},

			"negate": rsschema.BoolAttribute{
				Description: "Target to all but these specified devices and tags",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tags": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *NatPolicyResourceRulesTargetObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesTargetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesTargetDevicesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vsys": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: NatPolicyResourceRulesTargetDevicesVsysSchema(),
			},
		},
	}
}

func (o *NatPolicyResourceRulesTargetDevicesObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesTargetDevicesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesTargetDevicesVsysSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyResourceRulesTargetDevicesVsysObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesTargetDevicesVsysSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesDestinationTranslationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ConflictsWith(path.Expressions{
				path.MatchRelative().AtParent().AtName("destination_translation"),
				path.MatchRelative().AtParent().AtName("dynamic_destination_translation"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"translated_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_rewrite": NatPolicyResourceRulesDestinationTranslationDnsRewriteSchema(),
		},
	}
}

func (o *NatPolicyResourceRulesDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesDestinationTranslationDnsRewriteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"direction": rsschema.StringAttribute{
				Description: "Select direction to apply DNS rewrite",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("reverse"),
			},
		},
	}
}

func (o *NatPolicyResourceRulesDestinationTranslationDnsRewriteObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesDestinationTranslationDnsRewriteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func NatPolicyResourceRulesDynamicDestinationTranslationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"distribution": rsschema.StringAttribute{
				Description: "Distribution algorithm for destination address pool",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("round-robin"),
			},

			"translated_address": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"translated_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *NatPolicyResourceRulesDynamicDestinationTranslationObject) getTypeFor(name string) attr.Type {
	schema := NatPolicyResourceRulesDynamicDestinationTranslationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *NatPolicyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_nat_policy"
}

func (r *NatPolicyResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = NatPolicyResourceSchema()
}

// </ResourceSchema>

func (r *NatPolicyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	r.client = providerData.Client
	specifier, _, err := nat.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	r.manager = sdkmanager.NewUuidObjectManager(r.client, nat.NewService(r.client), batchSize, specifier, nat.SpecMatches)
}

func (o *NatPolicyResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj NatPolicyLocation

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"rules": types.ListType{},
	}
}
func (o *NatPolicyResourceRulesObject) AttributeTypes() map[string]attr.Type {

	var sourceTranslationObj *NatPolicyResourceRulesSourceTranslationObject

	var targetObj *NatPolicyResourceRulesTargetObject

	var destinationTranslationObj *NatPolicyResourceRulesDestinationTranslationObject

	var dynamicDestinationTranslationObj *NatPolicyResourceRulesDynamicDestinationTranslationObject
	return map[string]attr.Type{
		"name":                         types.StringType,
		"active_active_device_binding": types.StringType,
		"description":                  types.StringType,
		"destination_addresses":        types.ListType{},
		"disabled":                     types.BoolType,
		"source_zones":                 types.ListType{},
		"group_tag":                    types.StringType,
		"nat_type":                     types.StringType,
		"service":                      types.StringType,
		"source_addresses":             types.ListType{},
		"source_translation": types.ObjectType{
			AttrTypes: sourceTranslationObj.AttributeTypes(),
		},
		"tag": types.ListType{},
		"target": types.ObjectType{
			AttrTypes: targetObj.AttributeTypes(),
		},
		"destination_zone": types.ListType{},
		"to_interface":     types.StringType,
		"destination_translation": types.ObjectType{
			AttrTypes: destinationTranslationObj.AttributeTypes(),
		},
		"dynamic_destination_translation": types.ObjectType{
			AttrTypes: dynamicDestinationTranslationObj.AttributeTypes(),
		},
	}
}
func (o *NatPolicyResourceRulesSourceTranslationObject) AttributeTypes() map[string]attr.Type {

	var dynamicIpObj *NatPolicyResourceRulesSourceTranslationDynamicIpObject

	var dynamicIpAndPortObj *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject

	var staticIpObj *NatPolicyResourceRulesSourceTranslationStaticIpObject
	return map[string]attr.Type{
		"dynamic_ip": types.ObjectType{
			AttrTypes: dynamicIpObj.AttributeTypes(),
		},
		"dynamic_ip_and_port": types.ObjectType{
			AttrTypes: dynamicIpAndPortObj.AttributeTypes(),
		},
		"static_ip": types.ObjectType{
			AttrTypes: staticIpObj.AttributeTypes(),
		},
	}
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpObject) AttributeTypes() map[string]attr.Type {

	var fallbackObj *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject

	return map[string]attr.Type{
		"fallback": types.ObjectType{
			AttrTypes: fallbackObj.AttributeTypes(),
		},
		"translated_address": types.ListType{},
	}
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject) AttributeTypes() map[string]attr.Type {

	var interfaceAddressObj *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject

	return map[string]attr.Type{
		"interface_address": types.ObjectType{
			AttrTypes: interfaceAddressObj.AttributeTypes(),
		},
		"translated_address": types.ListType{},
	}
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject) AttributeTypes() map[string]attr.Type {

	var interfaceAddressObj *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject

	return map[string]attr.Type{
		"interface_address": types.ObjectType{
			AttrTypes: interfaceAddressObj.AttributeTypes(),
		},
		"translated_address": types.ListType{},
	}
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}
func (o *NatPolicyResourceRulesSourceTranslationStaticIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"bi_directional":     types.StringType,
		"translated_address": types.StringType,
	}
}
func (o *NatPolicyResourceRulesTargetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"devices": types.ListType{},
		"negate":  types.BoolType,
		"tags":    types.ListType{},
	}
}
func (o *NatPolicyResourceRulesTargetDevicesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"vsys": types.ListType{},
	}
}
func (o *NatPolicyResourceRulesTargetDevicesVsysObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}
func (o *NatPolicyResourceRulesDestinationTranslationObject) AttributeTypes() map[string]attr.Type {

	var dnsRewriteObj *NatPolicyResourceRulesDestinationTranslationDnsRewriteObject
	return map[string]attr.Type{
		"translated_address": types.StringType,
		"translated_port":    types.Int64Type,
		"dns_rewrite": types.ObjectType{
			AttrTypes: dnsRewriteObj.AttributeTypes(),
		},
	}
}
func (o *NatPolicyResourceRulesDestinationTranslationDnsRewriteObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"direction": types.StringType,
	}
}
func (o *NatPolicyResourceRulesDynamicDestinationTranslationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"distribution":       types.StringType,
		"translated_address": types.StringType,
		"translated_port":    types.Int64Type,
	}
}

func (o *NatPolicyResourceRulesObject) CopyToPango(ctx context.Context, obj **nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	activeActiveDeviceBinding_value := o.ActiveActiveDeviceBinding.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	destinationAddresses_pango_entries := make([]string, 0)
	diags.Append(o.DestinationAddresses.ElementsAs(ctx, &destinationAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	disabled_value := o.Disabled.ValueBoolPointer()
	sourceZones_pango_entries := make([]string, 0)
	diags.Append(o.SourceZones.ElementsAs(ctx, &sourceZones_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	groupTag_value := o.GroupTag.ValueStringPointer()
	natType_value := o.NatType.ValueStringPointer()
	service_value := o.Service.ValueStringPointer()
	sourceAddresses_pango_entries := make([]string, 0)
	diags.Append(o.SourceAddresses.ElementsAs(ctx, &sourceAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var sourceTranslation_entry *nat.SourceTranslation
	if o.SourceTranslation != nil {
		if *obj != nil && (*obj).SourceTranslation != nil {
			sourceTranslation_entry = (*obj).SourceTranslation
		} else {
			sourceTranslation_entry = new(nat.SourceTranslation)
		}

		diags.Append(o.SourceTranslation.CopyToPango(ctx, &sourceTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var target_entry *nat.Target
	if o.Target != nil {
		if *obj != nil && (*obj).Target != nil {
			target_entry = (*obj).Target
		} else {
			target_entry = new(nat.Target)
		}

		diags.Append(o.Target.CopyToPango(ctx, &target_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	destinationZone_pango_entries := make([]string, 0)
	diags.Append(o.DestinationZone.ElementsAs(ctx, &destinationZone_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	toInterface_value := o.ToInterface.ValueStringPointer()
	var destinationTranslation_entry *nat.DestinationTranslation
	if o.DestinationTranslation != nil {
		if *obj != nil && (*obj).DestinationTranslation != nil {
			destinationTranslation_entry = (*obj).DestinationTranslation
		} else {
			destinationTranslation_entry = new(nat.DestinationTranslation)
		}

		diags.Append(o.DestinationTranslation.CopyToPango(ctx, &destinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_entry *nat.DynamicDestinationTranslation
	if o.DynamicDestinationTranslation != nil {
		if *obj != nil && (*obj).DynamicDestinationTranslation != nil {
			dynamicDestinationTranslation_entry = (*obj).DynamicDestinationTranslation
		} else {
			dynamicDestinationTranslation_entry = new(nat.DynamicDestinationTranslation)
		}

		diags.Append(o.DynamicDestinationTranslation.CopyToPango(ctx, &dynamicDestinationTranslation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	(*obj).Description = description_value
	(*obj).Destination = destinationAddresses_pango_entries
	(*obj).Disabled = disabled_value
	(*obj).From = sourceZones_pango_entries
	(*obj).GroupTag = groupTag_value
	(*obj).NatType = natType_value
	(*obj).Service = service_value
	(*obj).Source = sourceAddresses_pango_entries
	(*obj).SourceTranslation = sourceTranslation_entry
	(*obj).Tag = tag_pango_entries
	(*obj).Target = target_entry
	(*obj).To = destinationZone_pango_entries
	(*obj).ToInterface = toInterface_value
	(*obj).DestinationTranslation = destinationTranslation_entry
	(*obj).DynamicDestinationTranslation = dynamicDestinationTranslation_entry

	return diags
}
func (o *NatPolicyResourceRulesSourceTranslationObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_entry *nat.SourceTranslationDynamicIp
	if o.DynamicIp != nil {
		if *obj != nil && (*obj).DynamicIp != nil {
			dynamicIp_entry = (*obj).DynamicIp
		} else {
			dynamicIp_entry = new(nat.SourceTranslationDynamicIp)
		}

		diags.Append(o.DynamicIp.CopyToPango(ctx, &dynamicIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_entry *nat.SourceTranslationDynamicIpAndPort
	if o.DynamicIpAndPort != nil {
		if *obj != nil && (*obj).DynamicIpAndPort != nil {
			dynamicIpAndPort_entry = (*obj).DynamicIpAndPort
		} else {
			dynamicIpAndPort_entry = new(nat.SourceTranslationDynamicIpAndPort)
		}

		diags.Append(o.DynamicIpAndPort.CopyToPango(ctx, &dynamicIpAndPort_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *nat.SourceTranslationStaticIp
	if o.StaticIp != nil {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(nat.SourceTranslationStaticIp)
		}

		diags.Append(o.StaticIp.CopyToPango(ctx, &staticIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslation)
	}
	(*obj).DynamicIp = dynamicIp_entry
	(*obj).DynamicIpAndPort = dynamicIpAndPort_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fallback_entry *nat.SourceTranslationDynamicIpFallback
	if o.Fallback != nil {
		if *obj != nil && (*obj).Fallback != nil {
			fallback_entry = (*obj).Fallback
		} else {
			fallback_entry = new(nat.SourceTranslationDynamicIpFallback)
		}

		diags.Append(o.Fallback.CopyToPango(ctx, &fallback_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIp)
	}
	(*obj).Fallback = fallback_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpFallbackInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallback)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpFallbackInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceAddress_entry *nat.SourceTranslationDynamicIpAndPortInterfaceAddress
	if o.InterfaceAddress != nil {
		if *obj != nil && (*obj).InterfaceAddress != nil {
			interfaceAddress_entry = (*obj).InterfaceAddress
		} else {
			interfaceAddress_entry = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
		}

		diags.Append(o.InterfaceAddress.CopyToPango(ctx, &interfaceAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	translatedAddress_pango_entries := make([]string, 0)
	diags.Append(o.TranslatedAddress.ElementsAs(ctx, &translatedAddress_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPort)
	}
	(*obj).InterfaceAddress = interfaceAddress_entry
	(*obj).TranslatedAddress = translatedAddress_pango_entries

	return diags
}
func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationDynamicIpAndPortInterfaceAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *NatPolicyResourceRulesSourceTranslationStaticIpObject) CopyToPango(ctx context.Context, obj **nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	biDirectional_value := o.BiDirectional.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.SourceTranslationStaticIp)
	}
	(*obj).BiDirectional = biDirectional_value
	(*obj).TranslatedAddress = translatedAddress_value

	return diags
}
func (o *NatPolicyResourceRulesTargetObject) CopyToPango(ctx context.Context, obj **nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_tf_entries []NatPolicyResourceRulesTargetDevicesObject
	var devices_pango_entries []nat.TargetDevices
	{
		d := o.Devices.ElementsAs(ctx, &devices_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range devices_tf_entries {
			var entry *nat.TargetDevices
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			devices_pango_entries = append(devices_pango_entries, *entry)
		}
	}
	negate_value := o.Negate.ValueBoolPointer()
	tags_pango_entries := make([]string, 0)
	diags.Append(o.Tags.ElementsAs(ctx, &tags_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(nat.Target)
	}
	(*obj).Devices = devices_pango_entries
	(*obj).Negate = negate_value
	(*obj).Tags = tags_pango_entries

	return diags
}
func (o *NatPolicyResourceRulesTargetDevicesObject) CopyToPango(ctx context.Context, obj **nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_tf_entries []NatPolicyResourceRulesTargetDevicesVsysObject
	var vsys_pango_entries []nat.TargetDevicesVsys
	{
		d := o.Vsys.ElementsAs(ctx, &vsys_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vsys_tf_entries {
			var entry *nat.TargetDevicesVsys
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			vsys_pango_entries = append(vsys_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(nat.TargetDevices)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vsys = vsys_pango_entries

	return diags
}
func (o *NatPolicyResourceRulesTargetDevicesVsysObject) CopyToPango(ctx context.Context, obj **nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(nat.TargetDevicesVsys)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *NatPolicyResourceRulesDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()
	var dnsRewrite_entry *nat.DestinationTranslationDnsRewrite
	if o.DnsRewrite != nil {
		if *obj != nil && (*obj).DnsRewrite != nil {
			dnsRewrite_entry = (*obj).DnsRewrite
		} else {
			dnsRewrite_entry = new(nat.DestinationTranslationDnsRewrite)
		}

		diags.Append(o.DnsRewrite.CopyToPango(ctx, &dnsRewrite_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslation)
	}
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value
	(*obj).DnsRewrite = dnsRewrite_entry

	return diags
}
func (o *NatPolicyResourceRulesDestinationTranslationDnsRewriteObject) CopyToPango(ctx context.Context, obj **nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	direction_value := o.Direction.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(nat.DestinationTranslationDnsRewrite)
	}
	(*obj).Direction = direction_value

	return diags
}
func (o *NatPolicyResourceRulesDynamicDestinationTranslationObject) CopyToPango(ctx context.Context, obj **nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	distribution_value := o.Distribution.ValueStringPointer()
	translatedAddress_value := o.TranslatedAddress.ValueStringPointer()
	translatedPort_value := o.TranslatedPort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(nat.DynamicDestinationTranslation)
	}
	(*obj).Distribution = distribution_value
	(*obj).TranslatedAddress = translatedAddress_value
	(*obj).TranslatedPort = translatedPort_value

	return diags
}

func (o *NatPolicyResourceRulesObject) CopyFromPango(ctx context.Context, obj *nat.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var destinationAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		destinationAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var sourceZones_list types.List
	{
		var list_diags diag.Diagnostics
		sourceZones_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.From)
		diags.Append(list_diags...)
	}
	var sourceAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		sourceAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Source)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}
	var destinationZone_list types.List
	{
		var list_diags diag.Diagnostics
		destinationZone_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.To)
		diags.Append(list_diags...)
	}
	var sourceTranslation_object *NatPolicyResourceRulesSourceTranslationObject
	if obj.SourceTranslation != nil {
		sourceTranslation_object = new(NatPolicyResourceRulesSourceTranslationObject)

		diags.Append(sourceTranslation_object.CopyFromPango(ctx, obj.SourceTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var target_object *NatPolicyResourceRulesTargetObject
	if obj.Target != nil {
		target_object = new(NatPolicyResourceRulesTargetObject)

		diags.Append(target_object.CopyFromPango(ctx, obj.Target, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var destinationTranslation_object *NatPolicyResourceRulesDestinationTranslationObject
	if obj.DestinationTranslation != nil {
		destinationTranslation_object = new(NatPolicyResourceRulesDestinationTranslationObject)

		diags.Append(destinationTranslation_object.CopyFromPango(ctx, obj.DestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicDestinationTranslation_object *NatPolicyResourceRulesDynamicDestinationTranslationObject
	if obj.DynamicDestinationTranslation != nil {
		dynamicDestinationTranslation_object = new(NatPolicyResourceRulesDynamicDestinationTranslationObject)

		diags.Append(dynamicDestinationTranslation_object.CopyFromPango(ctx, obj.DynamicDestinationTranslation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var activeActiveDeviceBinding_value types.String
	if obj.ActiveActiveDeviceBinding != nil {
		activeActiveDeviceBinding_value = types.StringValue(*obj.ActiveActiveDeviceBinding)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var groupTag_value types.String
	if obj.GroupTag != nil {
		groupTag_value = types.StringValue(*obj.GroupTag)
	}
	var natType_value types.String
	if obj.NatType != nil {
		natType_value = types.StringValue(*obj.NatType)
	}
	var service_value types.String
	if obj.Service != nil {
		service_value = types.StringValue(*obj.Service)
	}
	var toInterface_value types.String
	if obj.ToInterface != nil {
		toInterface_value = types.StringValue(*obj.ToInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.ActiveActiveDeviceBinding = activeActiveDeviceBinding_value
	o.Description = description_value
	o.DestinationAddresses = destinationAddresses_list
	o.Disabled = disabled_value
	o.SourceZones = sourceZones_list
	o.GroupTag = groupTag_value
	o.NatType = natType_value
	o.Service = service_value
	o.SourceAddresses = sourceAddresses_list
	o.SourceTranslation = sourceTranslation_object
	o.Tag = tag_list
	o.Target = target_object
	o.DestinationZone = destinationZone_list
	o.ToInterface = toInterface_value
	o.DestinationTranslation = destinationTranslation_object
	o.DynamicDestinationTranslation = dynamicDestinationTranslation_object

	return diags
}

func (o *NatPolicyResourceRulesSourceTranslationObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamicIp_object *NatPolicyResourceRulesSourceTranslationDynamicIpObject
	if obj.DynamicIp != nil {
		dynamicIp_object = new(NatPolicyResourceRulesSourceTranslationDynamicIpObject)

		diags.Append(dynamicIp_object.CopyFromPango(ctx, obj.DynamicIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicIpAndPort_object *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject
	if obj.DynamicIpAndPort != nil {
		dynamicIpAndPort_object = new(NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject)

		diags.Append(dynamicIpAndPort_object.CopyFromPango(ctx, obj.DynamicIpAndPort, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_object *NatPolicyResourceRulesSourceTranslationStaticIpObject
	if obj.StaticIp != nil {
		staticIp_object = new(NatPolicyResourceRulesSourceTranslationStaticIpObject)

		diags.Append(staticIp_object.CopyFromPango(ctx, obj.StaticIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.DynamicIp = dynamicIp_object
	o.DynamicIpAndPort = dynamicIpAndPort_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var fallback_object *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject
	if obj.Fallback != nil {
		fallback_object = new(NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject)

		diags.Append(fallback_object.CopyFromPango(ctx, obj.Fallback, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Fallback = fallback_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallback, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpFallbackInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpFallbackInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPort, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var translatedAddress_list types.List
	{
		var list_diags diag.Diagnostics
		translatedAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TranslatedAddress)
		diags.Append(list_diags...)
	}
	var interfaceAddress_object *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject
	if obj.InterfaceAddress != nil {
		interfaceAddress_object = new(NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject)

		diags.Append(interfaceAddress_object.CopyFromPango(ctx, obj.InterfaceAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.InterfaceAddress = interfaceAddress_object
	o.TranslatedAddress = translatedAddress_list

	return diags
}

func (o *NatPolicyResourceRulesSourceTranslationDynamicIpAndPortInterfaceAddressObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationDynamicIpAndPortInterfaceAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *NatPolicyResourceRulesSourceTranslationStaticIpObject) CopyFromPango(ctx context.Context, obj *nat.SourceTranslationStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var biDirectional_value types.String
	if obj.BiDirectional != nil {
		biDirectional_value = types.StringValue(*obj.BiDirectional)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	o.BiDirectional = biDirectional_value
	o.TranslatedAddress = translatedAddress_value

	return diags
}

func (o *NatPolicyResourceRulesTargetObject) CopyFromPango(ctx context.Context, obj *nat.Target, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var devices_list types.List
	{
		var devices_tf_entries []NatPolicyResourceRulesTargetDevicesObject
		for _, elt := range obj.Devices {
			var entry NatPolicyResourceRulesTargetDevicesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			devices_tf_entries = append(devices_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("devices")
		devices_list, list_diags = types.ListValueFrom(ctx, schemaType, devices_tf_entries)
		diags.Append(list_diags...)
	}
	var tags_list types.List
	{
		var list_diags diag.Diagnostics
		tags_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tags)
		diags.Append(list_diags...)
	}

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Devices = devices_list
	o.Negate = negate_value
	o.Tags = tags_list

	return diags
}

func (o *NatPolicyResourceRulesTargetDevicesObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevices, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var vsys_list types.List
	{
		var vsys_tf_entries []NatPolicyResourceRulesTargetDevicesVsysObject
		for _, elt := range obj.Vsys {
			var entry NatPolicyResourceRulesTargetDevicesVsysObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			vsys_tf_entries = append(vsys_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vsys")
		vsys_list, list_diags = types.ListValueFrom(ctx, schemaType, vsys_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vsys = vsys_list

	return diags
}

func (o *NatPolicyResourceRulesTargetDevicesVsysObject) CopyFromPango(ctx context.Context, obj *nat.TargetDevicesVsys, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *NatPolicyResourceRulesDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsRewrite_object *NatPolicyResourceRulesDestinationTranslationDnsRewriteObject
	if obj.DnsRewrite != nil {
		dnsRewrite_object = new(NatPolicyResourceRulesDestinationTranslationDnsRewriteObject)

		diags.Append(dnsRewrite_object.CopyFromPango(ctx, obj.DnsRewrite, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value
	o.DnsRewrite = dnsRewrite_object

	return diags
}

func (o *NatPolicyResourceRulesDestinationTranslationDnsRewriteObject) CopyFromPango(ctx context.Context, obj *nat.DestinationTranslationDnsRewrite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var direction_value types.String
	if obj.Direction != nil {
		direction_value = types.StringValue(*obj.Direction)
	}
	o.Direction = direction_value

	return diags
}

func (o *NatPolicyResourceRulesDynamicDestinationTranslationObject) CopyFromPango(ctx context.Context, obj *nat.DynamicDestinationTranslation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var distribution_value types.String
	if obj.Distribution != nil {
		distribution_value = types.StringValue(*obj.Distribution)
	}
	var translatedAddress_value types.String
	if obj.TranslatedAddress != nil {
		translatedAddress_value = types.StringValue(*obj.TranslatedAddress)
	}
	var translatedPort_value types.Int64
	if obj.TranslatedPort != nil {
		translatedPort_value = types.Int64Value(*obj.TranslatedPort)
	}
	o.Distribution = distribution_value
	o.TranslatedAddress = translatedAddress_value
	o.TranslatedPort = translatedPort_value

	return diags
}

func (r *NatPolicyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	var state NatPolicyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy_resource",
		"function":      "Create",
	})

	var location nat.Location

	{
		var terraformLocation NatPolicyLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &nat.SharedLocation{}
			var innerLocation NatPolicySharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Shared.Rulebase = innerLocation.Rulebase.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &nat.VsysLocation{}
			var innerLocation NatPolicyVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &nat.DeviceGroupLocation{}
			var innerLocation NatPolicyDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
			location.DeviceGroup.Rulebase = innerLocation.Rulebase.ValueString()
		}
	}

	var elements []NatPolicyResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	entries := make([]*nat.Entry, len(elements))
	for idx, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		entries[idx] = entry
	}
	processed, err := r.manager.CreateMany(ctx, location, entries, sdkmanager.Exhaustive, movement.PositionFirst{})
	if err != nil {
		resp.Diagnostics.AddError("Error during CreateMany() call", err.Error())
		return
	}
	objects := make([]NatPolicyResourceRulesObject, len(processed))
	for idx, elt := range processed {
		var object NatPolicyResourceRulesObject
		copy_diags := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(copy_diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects[idx] = object
	}

	var list_diags diag.Diagnostics
	state.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *NatPolicyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state NatPolicyResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy",
		"function":      "Create",
	})

	var location nat.Location

	{
		var terraformLocation NatPolicyLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &nat.SharedLocation{}
			var innerLocation NatPolicySharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Shared.Rulebase = innerLocation.Rulebase.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &nat.VsysLocation{}
			var innerLocation NatPolicyVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &nat.DeviceGroupLocation{}
			var innerLocation NatPolicyDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
			location.DeviceGroup.Rulebase = innerLocation.Rulebase.ValueString()
		}
	}

	var elements []NatPolicyResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() || len(elements) == 0 {
		return
	}

	entries := make([]*nat.Entry, 0, len(elements))
	for _, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		entries = append(entries, entry)
	}

	// true

	position := movement.PositionFirst{}
	readEntries, _, err := o.manager.ReadMany(ctx, location, entries, sdkmanager.Exhaustive, position)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Failed to read entries from the server", err.Error())
		}
		return
	}

	var objects []NatPolicyResourceRulesObject
	for _, elt := range readEntries {
		var object NatPolicyResourceRulesObject
		err := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(err...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects = append(objects, object)
	}

	var list_diags diag.Diagnostics
	state.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *NatPolicyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var state, plan NatPolicyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_nat_policy_resource",
		"function":      "Create",
	})

	var location nat.Location

	{
		var terraformLocation NatPolicyLocation
		resp.Diagnostics.Append(plan.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &nat.SharedLocation{}
			var innerLocation NatPolicySharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Shared.Rulebase = innerLocation.Rulebase.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &nat.VsysLocation{}
			var innerLocation NatPolicyVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &nat.DeviceGroupLocation{}
			var innerLocation NatPolicyDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
			location.DeviceGroup.Rulebase = innerLocation.Rulebase.ValueString()
		}
	}

	var elements []NatPolicyResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	stateEntries := make([]*nat.Entry, len(elements))
	for idx, elt := range elements {
		var entry *nat.Entry
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		stateEntries[idx] = entry
	}

	position := movement.PositionFirst{}

	existing, _, err := r.manager.ReadMany(ctx, location, stateEntries, sdkmanager.Exhaustive, position)
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error while reading entries from the server", err.Error())
		return
	}

	existingEntriesByName := make(map[string]*nat.Entry, len(existing))
	for _, elt := range existing {
		existingEntriesByName[elt.Name] = elt
	}

	resp.Diagnostics.Append(plan.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	planEntries := make([]*nat.Entry, len(elements))
	for idx, elt := range elements {
		entry, _ := existingEntriesByName[elt.Name.ValueString()]
		resp.Diagnostics.Append(elt.CopyToPango(ctx, &entry, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		planEntries[idx] = entry
	}

	processed, err := r.manager.UpdateMany(ctx, location, stateEntries, planEntries, sdkmanager.Exhaustive, position)
	if err != nil {
		resp.Diagnostics.AddError("Failed to udpate entries", err.Error())
	}

	objects := make([]*NatPolicyResourceRulesObject, len(processed))
	for idx, elt := range processed {
		var object NatPolicyResourceRulesObject
		copy_diags := object.CopyFromPango(ctx, elt, nil)
		resp.Diagnostics.Append(copy_diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		objects[idx] = &object
	}

	var list_diags diag.Diagnostics
	plan.Rules, list_diags = types.ListValueFrom(ctx, state.getTypeFor("rules"), objects)
	resp.Diagnostics.Append(list_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (r *NatPolicyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state NatPolicyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_nat_policy_resource",
		"function":      "Delete",
	})
	var elements []NatPolicyResourceRulesObject
	resp.Diagnostics.Append(state.Rules.ElementsAs(ctx, &elements, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location nat.Location

	{
		var terraformLocation NatPolicyLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &nat.SharedLocation{}
			var innerLocation NatPolicySharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Shared.Rulebase = innerLocation.Rulebase.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &nat.VsysLocation{}
			var innerLocation NatPolicyVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.DeviceGroup.IsNull() {
			location.DeviceGroup = &nat.DeviceGroupLocation{}
			var innerLocation NatPolicyDeviceGroupLocation
			resp.Diagnostics.Append(terraformLocation.DeviceGroup.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.DeviceGroup.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.DeviceGroup.DeviceGroup = innerLocation.Name.ValueString()
			location.DeviceGroup.Rulebase = innerLocation.Rulebase.ValueString()
		}
	}

	var names []string
	for _, elt := range elements {
		names = append(names, elt.Name.ValueString())
	}
	err := r.manager.Delete(ctx, location, names, sdkmanager.Exhaustive)
	if err != nil {
		resp.Diagnostics.AddError("error while deleting entries", err.Error())
		return
	}

}

type NatPolicyImportState struct {
	Location types.Object `json:"location"`
	Names    types.List   `json:"names"`
}

func (o NatPolicyImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *NatPolicyLocation `json:"location"`
		Names    []string           `json:"names"`
	}
	var location_object *NatPolicyLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}
	var names_list []string
	{
		diags := o.Names.ElementsAs(context.TODO(), &names_list, false)
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal names into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Names:    names_list,
	}

	return json.Marshal(obj)
}

func (o *NatPolicyImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *NatPolicyLocation `json:"location"`
		Names    []string           `json:"names"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	var names_list types.List
	{
		var diags_tmp diag.Diagnostics
		names_list, diags_tmp = types.ListValueFrom(context.TODO(), types.StringType, shadow.Names)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into names", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Names = names_list

	return nil
}

func NatPolicyImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	itemsAttr, ok := attrs["rules"]
	if !ok {
		return nil, fmt.Errorf("rules attribute missing")
	}

	var items []*NatPolicyResourceRulesObject
	switch value := itemsAttr.(type) {
	case types.List:
		diags := value.ElementsAs(ctx, &items, false)
		if diags.HasError() {
			return nil, fmt.Errorf("Invalid rules attribute element type, expected list of valid objects")
		}
	default:
		return nil, fmt.Errorf("Invalid names attribute type, expected list of strings")
	}

	var names []string
	for _, elt := range items {
		names = append(names, elt.Name.ValueString())
	}

	var namesObject types.List
	namesObject, diags_tmp := types.ListValueFrom(ctx, types.StringType, names)
	if diags_tmp.HasError() {
		return nil, NewDiagnosticsError("Failed to generate import ID", diags_tmp.Errors())
	}

	importStruct := NatPolicyImportState{
		Location: location,
		Names:    namesObject,
	}

	return json.Marshal(importStruct)
}

func (r *NatPolicyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj NatPolicyImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var names []*NatPolicyResourceRulesObject
	var objectNames []string
	resp.Diagnostics.Append(obj.Names.ElementsAs(ctx, &objectNames, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	for _, elt := range objectNames {
		object := &NatPolicyResourceRulesObject{}
		resp.Diagnostics.Append(object.CopyFromPango(ctx, &nat.Entry{}, nil)...)
		if resp.Diagnostics.HasError() {
			return
		}
		object.Name = types.StringValue(elt)
		names = append(names, object)
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("rules"), names)...)
}

type NatPolicySharedLocation struct {
	Rulebase types.String `tfsdk:"rulebase"`
}
type NatPolicyVsysLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
	Name       types.String `tfsdk:"name"`
}
type NatPolicyDeviceGroupLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	Rulebase       types.String `tfsdk:"rulebase"`
}
type NatPolicyLocation struct {
	Shared      types.Object `tfsdk:"shared"`
	Vsys        types.Object `tfsdk:"vsys"`
	DeviceGroup types.Object `tfsdk:"device_group"`
}

func NatPolicyLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.SingleNestedAttribute{
				Description: "Located in a shared rulebase",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"rulebase": rsschema.StringAttribute{
						Description: "Rulebase name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("pre-rulebase"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("shared"),
						path.MatchRelative().AtParent().AtName("vsys"),
						path.MatchRelative().AtParent().AtName("device_group"),
					}...),
				},
			},
			"vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The vsys name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"device_group": rsschema.SingleNestedAttribute{
				Description: "Located in a specific device group.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The device group.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"rulebase": rsschema.StringAttribute{
						Description: "The rulebase.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("pre-rulebase"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o NatPolicySharedLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Rulebase *string `json:"rulebase,omitempty"`
	}

	obj := shadow{
		Rulebase: o.Rulebase.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *NatPolicySharedLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Rulebase *string `json:"rulebase,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Rulebase = types.StringPointerValue(shadow.Rulebase)

	return nil
}
func (o NatPolicyVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
		Name:       o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *NatPolicyVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o NatPolicyDeviceGroupLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		Rulebase       *string `json:"rulebase,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		Rulebase:       o.Rulebase.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *NatPolicyDeviceGroupLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		Rulebase       *string `json:"rulebase,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.Rulebase = types.StringPointerValue(shadow.Rulebase)

	return nil
}
func (o NatPolicyLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Shared      *NatPolicySharedLocation      `json:"shared,omitempty"`
		Vsys        *NatPolicyVsysLocation        `json:"vsys,omitempty"`
		DeviceGroup *NatPolicyDeviceGroupLocation `json:"device_group,omitempty"`
	}
	var shared_object *NatPolicySharedLocation
	{
		diags := o.Shared.As(context.TODO(), &shared_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal shared into JSON document", diags.Errors())
		}
	}
	var vsys_object *NatPolicyVsysLocation
	{
		diags := o.Vsys.As(context.TODO(), &vsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal vsys into JSON document", diags.Errors())
		}
	}
	var deviceGroup_object *NatPolicyDeviceGroupLocation
	{
		diags := o.DeviceGroup.As(context.TODO(), &deviceGroup_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal device_group into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Shared:      shared_object,
		Vsys:        vsys_object,
		DeviceGroup: deviceGroup_object,
	}

	return json.Marshal(obj)
}

func (o *NatPolicyLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared      *NatPolicySharedLocation      `json:"shared,omitempty"`
		Vsys        *NatPolicyVsysLocation        `json:"vsys,omitempty"`
		DeviceGroup *NatPolicyDeviceGroupLocation `json:"device_group,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var shared_object types.Object
	{
		var diags_tmp diag.Diagnostics
		shared_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Shared.AttributeTypes(), shadow.Shared)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into shared", diags_tmp.Errors())
		}
	}
	var vsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		vsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Vsys.AttributeTypes(), shadow.Vsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into vsys", diags_tmp.Errors())
		}
	}
	var deviceGroup_object types.Object
	{
		var diags_tmp diag.Diagnostics
		deviceGroup_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.DeviceGroup.AttributeTypes(), shadow.DeviceGroup)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into device_group", diags_tmp.Errors())
		}
	}
	o.Shared = shared_object
	o.Vsys = vsys_object
	o.DeviceGroup = deviceGroup_object

	return nil
}

func (o *NatPolicySharedLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"rulebase": types.StringType,
	}
}
func (o *NatPolicyVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
		"name":        types.StringType,
	}
}
func (o *NatPolicyDeviceGroupLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"rulebase":        types.StringType,
	}
}
func (o *NatPolicyLocation) AttributeTypes() map[string]attr.Type {
	var sharedObj NatPolicySharedLocation
	var vsysObj NatPolicyVsysLocation
	var deviceGroupObj NatPolicyDeviceGroupLocation
	return map[string]attr.Type{
		"shared": types.ObjectType{
			AttrTypes: sharedObj.AttributeTypes(),
		},
		"vsys": types.ObjectType{
			AttrTypes: vsysObj.AttributeTypes(),
		},
		"device_group": types.ObjectType{
			AttrTypes: deviceGroupObj.AttributeTypes(),
		},
	}
}
