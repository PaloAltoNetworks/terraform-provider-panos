package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/device/globalprotect/gateway"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &GlobalprotectGatewayDataSource{}
	_ datasource.DataSourceWithConfigure = &GlobalprotectGatewayDataSource{}
)

func NewGlobalprotectGatewayDataSource() datasource.DataSource {
	return &GlobalprotectGatewayDataSource{}
}

type GlobalprotectGatewayDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service]
}

type GlobalprotectGatewayDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type GlobalprotectGatewayDataSourceModel struct {
	Location                types.Object `tfsdk:"location"`
	Name                    types.String `tfsdk:"name"`
	BlockQuarantinedDevices types.Bool   `tfsdk:"block_quarantined_devices"`
	CertificateProfile      types.String `tfsdk:"certificate_profile"`
	ClientAuth              types.List   `tfsdk:"client_auth"`
	HipNotification         types.List   `tfsdk:"hip_notification"`
	LocalAddress            types.Object `tfsdk:"local_address"`
	LogFail                 types.Bool   `tfsdk:"log_fail"`
	LogSetting              types.String `tfsdk:"log_setting"`
	LogSuccess              types.Bool   `tfsdk:"log_success"`
	RemoteUserTunnel        types.String `tfsdk:"remote_user_tunnel"`
	RemoteUserTunnelConfigs types.List   `tfsdk:"remote_user_tunnel_configs"`
	Roles                   types.List   `tfsdk:"roles"`
	SatelliteTunnel         types.String `tfsdk:"satellite_tunnel"`
	SecurityRestrictions    types.Object `tfsdk:"security_restrictions"`
	SslTlsServiceProfile    types.String `tfsdk:"ssl_tls_service_profile"`
	TunnelMode              types.Bool   `tfsdk:"tunnel_mode"`
}
type GlobalprotectGatewayDataSourceClientAuthObject struct {
	Name                               types.String `tfsdk:"name"`
	Os                                 types.String `tfsdk:"os"`
	AuthenticationProfile              types.String `tfsdk:"authentication_profile"`
	AutoRetrievePasscode               types.Bool   `tfsdk:"auto_retrieve_passcode"`
	UsernameLabel                      types.String `tfsdk:"username_label"`
	PasswordLabel                      types.String `tfsdk:"password_label"`
	AuthenticationMessage              types.String `tfsdk:"authentication_message"`
	UserCredentialOrClientCertRequired types.String `tfsdk:"user_credential_or_client_cert_required"`
}
type GlobalprotectGatewayDataSourceHipNotificationObject struct {
	Name            types.String `tfsdk:"name"`
	MatchMessage    types.Object `tfsdk:"match_message"`
	NotMatchMessage types.Object `tfsdk:"not_match_message"`
}
type GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject struct {
	IncludeAppList     types.Bool   `tfsdk:"include_app_list"`
	ShowNotificationAs types.String `tfsdk:"show_notification_as"`
	Message            types.String `tfsdk:"message"`
}
type GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject struct {
	ShowNotificationAs types.String `tfsdk:"show_notification_as"`
	Message            types.String `tfsdk:"message"`
}
type GlobalprotectGatewayDataSourceLocalAddressObject struct {
	Interface       types.String `tfsdk:"interface"`
	IpAddressFamily types.String `tfsdk:"ip_address_family"`
	FloatingIp      types.Object `tfsdk:"floating_ip"`
	Ip              types.Object `tfsdk:"ip"`
}
type GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectGatewayDataSourceLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject struct {
	Name                         types.String `tfsdk:"name"`
	SourceUser                   types.List   `tfsdk:"source_user"`
	Os                           types.List   `tfsdk:"os"`
	DnsServer                    types.List   `tfsdk:"dns_server"`
	DnsSuffix                    types.List   `tfsdk:"dns_suffix"`
	IpPool                       types.List   `tfsdk:"ip_pool"`
	AuthenticationServerIpPool   types.List   `tfsdk:"authentication_server_ip_pool"`
	AuthenticationOverride       types.Object `tfsdk:"authentication_override"`
	SourceAddress                types.Object `tfsdk:"source_address"`
	SplitTunneling               types.Object `tfsdk:"split_tunneling"`
	NoDirectAccessToLocalNetwork types.Bool   `tfsdk:"no_direct_access_to_local_network"`
	RetrieveFramedIpAddress      types.Bool   `tfsdk:"retrieve_framed_ip_address"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject struct {
	GenerateCookie           types.Bool   `tfsdk:"generate_cookie"`
	CookieEncryptDecryptCert types.String `tfsdk:"cookie_encrypt_decrypt_cert"`
	AcceptCookie             types.Object `tfsdk:"accept_cookie"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject struct {
	CookieLifetime types.Object `tfsdk:"cookie_lifetime"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject struct {
	LifetimeInDays    types.Int64 `tfsdk:"lifetime_in_days"`
	LifetimeInHours   types.Int64 `tfsdk:"lifetime_in_hours"`
	LifetimeInMinutes types.Int64 `tfsdk:"lifetime_in_minutes"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject struct {
	Region    types.List `tfsdk:"region"`
	IpAddress types.List `tfsdk:"ip_address"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject struct {
	AccessRoute         types.List   `tfsdk:"access_route"`
	ExcludeAccessRoute  types.List   `tfsdk:"exclude_access_route"`
	IncludeApplications types.List   `tfsdk:"include_applications"`
	ExcludeApplications types.List   `tfsdk:"exclude_applications"`
	IncludeDomains      types.Object `tfsdk:"include_domains"`
	ExcludeDomains      types.Object `tfsdk:"exclude_domains"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject struct {
	List types.List `tfsdk:"list"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject struct {
	Name  types.String `tfsdk:"name"`
	Ports types.List   `tfsdk:"ports"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject struct {
	List types.List `tfsdk:"list"`
}
type GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject struct {
	Name  types.String `tfsdk:"name"`
	Ports types.List   `tfsdk:"ports"`
}
type GlobalprotectGatewayDataSourceRolesObject struct {
	Name                     types.String `tfsdk:"name"`
	LoginLifetime            types.Object `tfsdk:"login_lifetime"`
	InactivityLogout         types.Int64  `tfsdk:"inactivity_logout"`
	LifetimeNotifyPrior      types.Int64  `tfsdk:"lifetime_notify_prior"`
	LifetimeNotifyMessage    types.String `tfsdk:"lifetime_notify_message"`
	InactivityNotifyPrior    types.Int64  `tfsdk:"inactivity_notify_prior"`
	InactivityNotifyMessage  types.String `tfsdk:"inactivity_notify_message"`
	AdminLogoutNotify        types.Bool   `tfsdk:"admin_logout_notify"`
	AdminLogoutNotifyMessage types.String `tfsdk:"admin_logout_notify_message"`
}
type GlobalprotectGatewayDataSourceRolesLoginLifetimeObject struct {
	Minutes types.Int64 `tfsdk:"minutes"`
	Hours   types.Int64 `tfsdk:"hours"`
	Days    types.Int64 `tfsdk:"days"`
}
type GlobalprotectGatewayDataSourceSecurityRestrictionsObject struct {
	DisallowAutomaticRestoration types.Bool   `tfsdk:"disallow_automatic_restoration"`
	SourceIpEnforcement          types.Object `tfsdk:"source_ip_enforcement"`
}
type GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject struct {
	Enable  types.Bool   `tfsdk:"enable"`
	Custom  types.Object `tfsdk:"custom"`
	Default types.Object `tfsdk:"default"`
}
type GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject struct {
	SourceIpv4Netmask types.Int64 `tfsdk:"source_ipv4_netmask"`
	SourceIpv6Netmask types.Int64 `tfsdk:"source_ipv6_netmask"`
}
type GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject struct {
}

func (o *GlobalprotectGatewayDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj GlobalprotectGatewayLocation

	var clientAuthObj *GlobalprotectGatewayDataSourceClientAuthObject

	var hipNotificationObj *GlobalprotectGatewayDataSourceHipNotificationObject

	var localAddressObj *GlobalprotectGatewayDataSourceLocalAddressObject

	var remoteUserTunnelConfigsObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject

	var rolesObj *GlobalprotectGatewayDataSourceRolesObject

	var securityRestrictionsObj *GlobalprotectGatewayDataSourceSecurityRestrictionsObject

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":                      types.StringType,
		"block_quarantined_devices": types.BoolType,
		"certificate_profile":       types.StringType,
		"client_auth": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: clientAuthObj.AttributeTypes(),
			},
		},
		"hip_notification": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: hipNotificationObj.AttributeTypes(),
			},
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"log_fail":           types.BoolType,
		"log_setting":        types.StringType,
		"log_success":        types.BoolType,
		"remote_user_tunnel": types.StringType,
		"remote_user_tunnel_configs": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: remoteUserTunnelConfigsObj.AttributeTypes(),
			},
		},
		"roles": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rolesObj.AttributeTypes(),
			},
		},
		"satellite_tunnel": types.StringType,
		"security_restrictions": types.ObjectType{
			AttrTypes: securityRestrictionsObj.AttributeTypes(),
		},
		"ssl_tls_service_profile": types.StringType,
		"tunnel_mode":             types.BoolType,
	}
}

func (o GlobalprotectGatewayDataSourceModel) AncestorName() string {
	return ""
}

func (o GlobalprotectGatewayDataSourceModel) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceClientAuthObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                   types.StringType,
		"os":                     types.StringType,
		"authentication_profile": types.StringType,
		"auto_retrieve_passcode": types.BoolType,
		"username_label":         types.StringType,
		"password_label":         types.StringType,
		"authentication_message": types.StringType,
		"user_credential_or_client_cert_required": types.StringType,
	}
}

func (o GlobalprotectGatewayDataSourceClientAuthObject) AncestorName() string {
	return "client-auth"
}

func (o GlobalprotectGatewayDataSourceClientAuthObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayDataSourceHipNotificationObject) AttributeTypes() map[string]attr.Type {

	var matchMessageObj *GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject

	var notMatchMessageObj *GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject
	return map[string]attr.Type{
		"name": types.StringType,
		"match_message": types.ObjectType{
			AttrTypes: matchMessageObj.AttributeTypes(),
		},
		"not_match_message": types.ObjectType{
			AttrTypes: notMatchMessageObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayDataSourceHipNotificationObject) AncestorName() string {
	return "hip-notification"
}

func (o GlobalprotectGatewayDataSourceHipNotificationObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"include_app_list":     types.BoolType,
		"show_notification_as": types.StringType,
		"message":              types.StringType,
	}
}

func (o GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject) AncestorName() string {
	return "match-message"
}

func (o GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"show_notification_as": types.StringType,
		"message":              types.StringType,
	}
}

func (o GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject) AncestorName() string {
	return "not-match-message"
}

func (o GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceLocalAddressObject) AttributeTypes() map[string]attr.Type {

	var floatingIpObj *GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject

	var ipObj *GlobalprotectGatewayDataSourceLocalAddressIpObject
	return map[string]attr.Type{
		"interface":         types.StringType,
		"ip_address_family": types.StringType,
		"floating_ip": types.ObjectType{
			AttrTypes: floatingIpObj.AttributeTypes(),
		},
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayDataSourceLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o GlobalprotectGatewayDataSourceLocalAddressObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject) AncestorName() string {
	return "floating-ip"
}

func (o GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceLocalAddressIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectGatewayDataSourceLocalAddressIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectGatewayDataSourceLocalAddressIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject) AttributeTypes() map[string]attr.Type {

	var authenticationOverrideObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject

	var sourceAddressObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject

	var splitTunnelingObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject

	return map[string]attr.Type{
		"name": types.StringType,
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"os": types.ListType{
			ElemType: types.StringType,
		},
		"dns_server": types.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": types.ListType{
			ElemType: types.StringType,
		},
		"ip_pool": types.ListType{
			ElemType: types.StringType,
		},
		"authentication_server_ip_pool": types.ListType{
			ElemType: types.StringType,
		},
		"authentication_override": types.ObjectType{
			AttrTypes: authenticationOverrideObj.AttributeTypes(),
		},
		"source_address": types.ObjectType{
			AttrTypes: sourceAddressObj.AttributeTypes(),
		},
		"split_tunneling": types.ObjectType{
			AttrTypes: splitTunnelingObj.AttributeTypes(),
		},
		"no_direct_access_to_local_network": types.BoolType,
		"retrieve_framed_ip_address":        types.BoolType,
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject) AncestorName() string {
	return "remote-user-tunnel-configs"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject) AttributeTypes() map[string]attr.Type {

	var acceptCookieObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject
	return map[string]attr.Type{
		"generate_cookie":             types.BoolType,
		"cookie_encrypt_decrypt_cert": types.StringType,
		"accept_cookie": types.ObjectType{
			AttrTypes: acceptCookieObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject) AncestorName() string {
	return "authentication-override"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) AttributeTypes() map[string]attr.Type {

	var cookieLifetimeObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	return map[string]attr.Type{
		"cookie_lifetime": types.ObjectType{
			AttrTypes: cookieLifetimeObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) AncestorName() string {
	return "accept-cookie"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lifetime_in_days":    types.Int64Type,
		"lifetime_in_hours":   types.Int64Type,
		"lifetime_in_minutes": types.Int64Type,
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AncestorName() string {
	return "cookie-lifetime"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"region": types.ListType{
			ElemType: types.StringType,
		},
		"ip_address": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject) AncestorName() string {
	return "source-address"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject) AttributeTypes() map[string]attr.Type {

	var includeDomainsObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject

	var excludeDomainsObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject
	return map[string]attr.Type{
		"access_route": types.ListType{
			ElemType: types.StringType,
		},
		"exclude_access_route": types.ListType{
			ElemType: types.StringType,
		},
		"include_applications": types.ListType{
			ElemType: types.StringType,
		},
		"exclude_applications": types.ListType{
			ElemType: types.StringType,
		},
		"include_domains": types.ObjectType{
			AttrTypes: includeDomainsObj.AttributeTypes(),
		},
		"exclude_domains": types.ObjectType{
			AttrTypes: excludeDomainsObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject) AncestorName() string {
	return "split-tunneling"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject
	return map[string]attr.Type{
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) AncestorName() string {
	return "include-domains"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"ports": types.ListType{
			ElemType: types.Int64Type,
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject
	return map[string]attr.Type{
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) AncestorName() string {
	return "exclude-domains"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"ports": types.ListType{
			ElemType: types.Int64Type,
		},
	}
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayDataSourceRolesObject) AttributeTypes() map[string]attr.Type {

	var loginLifetimeObj *GlobalprotectGatewayDataSourceRolesLoginLifetimeObject

	return map[string]attr.Type{
		"name": types.StringType,
		"login_lifetime": types.ObjectType{
			AttrTypes: loginLifetimeObj.AttributeTypes(),
		},
		"inactivity_logout":           types.Int64Type,
		"lifetime_notify_prior":       types.Int64Type,
		"lifetime_notify_message":     types.StringType,
		"inactivity_notify_prior":     types.Int64Type,
		"inactivity_notify_message":   types.StringType,
		"admin_logout_notify":         types.BoolType,
		"admin_logout_notify_message": types.StringType,
	}
}

func (o GlobalprotectGatewayDataSourceRolesObject) AncestorName() string {
	return "roles"
}

func (o GlobalprotectGatewayDataSourceRolesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayDataSourceRolesLoginLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"minutes": types.Int64Type,
		"hours":   types.Int64Type,
		"days":    types.Int64Type,
	}
}

func (o GlobalprotectGatewayDataSourceRolesLoginLifetimeObject) AncestorName() string {
	return "login-lifetime"
}

func (o GlobalprotectGatewayDataSourceRolesLoginLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsObject) AttributeTypes() map[string]attr.Type {

	var sourceIpEnforcementObj *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject
	return map[string]attr.Type{
		"disallow_automatic_restoration": types.BoolType,
		"source_ip_enforcement": types.ObjectType{
			AttrTypes: sourceIpEnforcementObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsObject) AncestorName() string {
	return "security-restrictions"
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject) AttributeTypes() map[string]attr.Type {

	var customObj *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject

	var defaultObj *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"custom": types.ObjectType{
			AttrTypes: customObj.AttributeTypes(),
		},
		"default": types.ObjectType{
			AttrTypes: defaultObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject) AncestorName() string {
	return "source-ip-enforcement"
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_ipv4_netmask": types.Int64Type,
		"source_ipv6_netmask": types.Int64Type,
	}
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject) AncestorName() string {
	return "custom"
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject) AncestorName() string {
	return "default"
}

func (o GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject) EntryName() *string {
	return nil
}

func (o *GlobalprotectGatewayDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	blockQuarantinedDevices_value := o.BlockQuarantinedDevices.ValueBoolPointer()
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var clientAuth_tf_entries []GlobalprotectGatewayDataSourceClientAuthObject
	var clientAuth_pango_entries []gateway.ClientAuth
	{
		d := o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range clientAuth_tf_entries {
			var entry *gateway.ClientAuth
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			clientAuth_pango_entries = append(clientAuth_pango_entries, *entry)
		}
	}
	var hipNotification_tf_entries []GlobalprotectGatewayDataSourceHipNotificationObject
	var hipNotification_pango_entries []gateway.HipNotification
	{
		d := o.HipNotification.ElementsAs(ctx, &hipNotification_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range hipNotification_tf_entries {
			var entry *gateway.HipNotification
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			hipNotification_pango_entries = append(hipNotification_pango_entries, *entry)
		}
	}
	var localAddress_entry *gateway.LocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(gateway.LocalAddress)
		}
		var object *GlobalprotectGatewayDataSourceLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	logFail_value := o.LogFail.ValueBoolPointer()
	logSetting_value := o.LogSetting.ValueStringPointer()
	logSuccess_value := o.LogSuccess.ValueBoolPointer()
	remoteUserTunnel_value := o.RemoteUserTunnel.ValueStringPointer()
	var remoteUserTunnelConfigs_tf_entries []GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject
	var remoteUserTunnelConfigs_pango_entries []gateway.RemoteUserTunnelConfigs
	{
		d := o.RemoteUserTunnelConfigs.ElementsAs(ctx, &remoteUserTunnelConfigs_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range remoteUserTunnelConfigs_tf_entries {
			var entry *gateway.RemoteUserTunnelConfigs
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			remoteUserTunnelConfigs_pango_entries = append(remoteUserTunnelConfigs_pango_entries, *entry)
		}
	}
	var roles_tf_entries []GlobalprotectGatewayDataSourceRolesObject
	var roles_pango_entries []gateway.Roles
	{
		d := o.Roles.ElementsAs(ctx, &roles_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range roles_tf_entries {
			var entry *gateway.Roles
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			roles_pango_entries = append(roles_pango_entries, *entry)
		}
	}
	satelliteTunnel_value := o.SatelliteTunnel.ValueStringPointer()
	var securityRestrictions_entry *gateway.SecurityRestrictions
	if !o.SecurityRestrictions.IsUnknown() && !o.SecurityRestrictions.IsNull() {
		if *obj != nil && (*obj).SecurityRestrictions != nil {
			securityRestrictions_entry = (*obj).SecurityRestrictions
		} else {
			securityRestrictions_entry = new(gateway.SecurityRestrictions)
		}
		var object *GlobalprotectGatewayDataSourceSecurityRestrictionsObject
		diags.Append(o.SecurityRestrictions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &securityRestrictions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	sslTlsServiceProfile_value := o.SslTlsServiceProfile.ValueStringPointer()
	tunnelMode_value := o.TunnelMode.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).BlockQuarantinedDevices = blockQuarantinedDevices_value
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).ClientAuth = clientAuth_pango_entries
	(*obj).HipNotification = hipNotification_pango_entries
	(*obj).LocalAddress = localAddress_entry
	(*obj).LogFail = logFail_value
	(*obj).LogSetting = logSetting_value
	(*obj).LogSuccess = logSuccess_value
	(*obj).RemoteUserTunnel = remoteUserTunnel_value
	(*obj).RemoteUserTunnelConfigs = remoteUserTunnelConfigs_pango_entries
	(*obj).Roles = roles_pango_entries
	(*obj).SatelliteTunnel = satelliteTunnel_value
	(*obj).SecurityRestrictions = securityRestrictions_entry
	(*obj).SslTlsServiceProfile = sslTlsServiceProfile_value
	(*obj).TunnelMode = tunnelMode_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceClientAuthObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	os_value := o.Os.ValueStringPointer()
	authenticationProfile_value := o.AuthenticationProfile.ValueStringPointer()
	autoRetrievePasscode_value := o.AutoRetrievePasscode.ValueBoolPointer()
	usernameLabel_value := o.UsernameLabel.ValueStringPointer()
	passwordLabel_value := o.PasswordLabel.ValueStringPointer()
	authenticationMessage_value := o.AuthenticationMessage.ValueStringPointer()
	userCredentialOrClientCertRequired_value := o.UserCredentialOrClientCertRequired.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.ClientAuth)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Os = os_value
	(*obj).AuthenticationProfile = authenticationProfile_value
	(*obj).AutoRetrievePasscode = autoRetrievePasscode_value
	(*obj).UsernameLabel = usernameLabel_value
	(*obj).PasswordLabel = passwordLabel_value
	(*obj).AuthenticationMessage = authenticationMessage_value
	(*obj).UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceHipNotificationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.HipNotification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var matchMessage_entry *gateway.HipNotificationMatchMessage
	if !o.MatchMessage.IsUnknown() && !o.MatchMessage.IsNull() {
		if *obj != nil && (*obj).MatchMessage != nil {
			matchMessage_entry = (*obj).MatchMessage
		} else {
			matchMessage_entry = new(gateway.HipNotificationMatchMessage)
		}
		var object *GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject
		diags.Append(o.MatchMessage.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &matchMessage_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var notMatchMessage_entry *gateway.HipNotificationNotMatchMessage
	if !o.NotMatchMessage.IsUnknown() && !o.NotMatchMessage.IsNull() {
		if *obj != nil && (*obj).NotMatchMessage != nil {
			notMatchMessage_entry = (*obj).NotMatchMessage
		} else {
			notMatchMessage_entry = new(gateway.HipNotificationNotMatchMessage)
		}
		var object *GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject
		diags.Append(o.NotMatchMessage.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &notMatchMessage_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.HipNotification)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).MatchMessage = matchMessage_entry
	(*obj).NotMatchMessage = notMatchMessage_entry

	return diags
}
func (o *GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.HipNotificationMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	includeAppList_value := o.IncludeAppList.ValueBoolPointer()
	showNotificationAs_value := o.ShowNotificationAs.ValueStringPointer()
	message_value := o.Message.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.HipNotificationMatchMessage)
	}
	(*obj).IncludeAppList = includeAppList_value
	(*obj).ShowNotificationAs = showNotificationAs_value
	(*obj).Message = message_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.HipNotificationNotMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	showNotificationAs_value := o.ShowNotificationAs.ValueStringPointer()
	message_value := o.Message.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.HipNotificationNotMatchMessage)
	}
	(*obj).ShowNotificationAs = showNotificationAs_value
	(*obj).Message = message_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ipAddressFamily_value := o.IpAddressFamily.ValueStringPointer()
	var floatingIp_entry *gateway.LocalAddressFloatingIp
	if !o.FloatingIp.IsUnknown() && !o.FloatingIp.IsNull() {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(gateway.LocalAddressFloatingIp)
		}
		var object *GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject
		diags.Append(o.FloatingIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &floatingIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *gateway.LocalAddressIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(gateway.LocalAddressIp)
		}
		var object *GlobalprotectGatewayDataSourceLocalAddressIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.LocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).IpAddressFamily = ipAddressFamily_value
	(*obj).FloatingIp = floatingIp_entry
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddressFloatingIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceLocalAddressIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddressIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var os_pango_entries []string
	if !o.Os.IsUnknown() && !o.Os.IsNull() {
		object_entries := make([]types.String, 0, len(o.Os.Elements()))
		diags.Append(o.Os.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			os_pango_entries = append(os_pango_entries, elt.ValueString())
		}
	}
	var dnsServer_pango_entries []string
	if !o.DnsServer.IsUnknown() && !o.DnsServer.IsNull() {
		object_entries := make([]types.String, 0, len(o.DnsServer.Elements()))
		diags.Append(o.DnsServer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			dnsServer_pango_entries = append(dnsServer_pango_entries, elt.ValueString())
		}
	}
	var dnsSuffix_pango_entries []string
	if !o.DnsSuffix.IsUnknown() && !o.DnsSuffix.IsNull() {
		object_entries := make([]types.String, 0, len(o.DnsSuffix.Elements()))
		diags.Append(o.DnsSuffix.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			dnsSuffix_pango_entries = append(dnsSuffix_pango_entries, elt.ValueString())
		}
	}
	var ipPool_pango_entries []string
	if !o.IpPool.IsUnknown() && !o.IpPool.IsNull() {
		object_entries := make([]types.String, 0, len(o.IpPool.Elements()))
		diags.Append(o.IpPool.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ipPool_pango_entries = append(ipPool_pango_entries, elt.ValueString())
		}
	}
	var authenticationServerIpPool_pango_entries []string
	if !o.AuthenticationServerIpPool.IsUnknown() && !o.AuthenticationServerIpPool.IsNull() {
		object_entries := make([]types.String, 0, len(o.AuthenticationServerIpPool.Elements()))
		diags.Append(o.AuthenticationServerIpPool.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			authenticationServerIpPool_pango_entries = append(authenticationServerIpPool_pango_entries, elt.ValueString())
		}
	}
	var authenticationOverride_entry *gateway.RemoteUserTunnelConfigsAuthenticationOverride
	if !o.AuthenticationOverride.IsUnknown() && !o.AuthenticationOverride.IsNull() {
		if *obj != nil && (*obj).AuthenticationOverride != nil {
			authenticationOverride_entry = (*obj).AuthenticationOverride
		} else {
			authenticationOverride_entry = new(gateway.RemoteUserTunnelConfigsAuthenticationOverride)
		}
		var object *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject
		diags.Append(o.AuthenticationOverride.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authenticationOverride_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sourceAddress_entry *gateway.RemoteUserTunnelConfigsSourceAddress
	if !o.SourceAddress.IsUnknown() && !o.SourceAddress.IsNull() {
		if *obj != nil && (*obj).SourceAddress != nil {
			sourceAddress_entry = (*obj).SourceAddress
		} else {
			sourceAddress_entry = new(gateway.RemoteUserTunnelConfigsSourceAddress)
		}
		var object *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject
		diags.Append(o.SourceAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sourceAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var splitTunneling_entry *gateway.RemoteUserTunnelConfigsSplitTunneling
	if !o.SplitTunneling.IsUnknown() && !o.SplitTunneling.IsNull() {
		if *obj != nil && (*obj).SplitTunneling != nil {
			splitTunneling_entry = (*obj).SplitTunneling
		} else {
			splitTunneling_entry = new(gateway.RemoteUserTunnelConfigsSplitTunneling)
		}
		var object *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject
		diags.Append(o.SplitTunneling.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &splitTunneling_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	noDirectAccessToLocalNetwork_value := o.NoDirectAccessToLocalNetwork.ValueBoolPointer()
	retrieveFramedIpAddress_value := o.RetrieveFramedIpAddress.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigs)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).Os = os_pango_entries
	(*obj).DnsServer = dnsServer_pango_entries
	(*obj).DnsSuffix = dnsSuffix_pango_entries
	(*obj).IpPool = ipPool_pango_entries
	(*obj).AuthenticationServerIpPool = authenticationServerIpPool_pango_entries
	(*obj).AuthenticationOverride = authenticationOverride_entry
	(*obj).SourceAddress = sourceAddress_entry
	(*obj).SplitTunneling = splitTunneling_entry
	(*obj).NoDirectAccessToLocalNetwork = noDirectAccessToLocalNetwork_value
	(*obj).RetrieveFramedIpAddress = retrieveFramedIpAddress_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	generateCookie_value := o.GenerateCookie.ValueBoolPointer()
	cookieEncryptDecryptCert_value := o.CookieEncryptDecryptCert.ValueStringPointer()
	var acceptCookie_entry *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie
	if !o.AcceptCookie.IsUnknown() && !o.AcceptCookie.IsNull() {
		if *obj != nil && (*obj).AcceptCookie != nil {
			acceptCookie_entry = (*obj).AcceptCookie
		} else {
			acceptCookie_entry = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie)
		}
		var object *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject
		diags.Append(o.AcceptCookie.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &acceptCookie_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsAuthenticationOverride)
	}
	(*obj).GenerateCookie = generateCookie_value
	(*obj).CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	(*obj).AcceptCookie = acceptCookie_entry

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var cookieLifetime_entry *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime
	if !o.CookieLifetime.IsUnknown() && !o.CookieLifetime.IsNull() {
		if *obj != nil && (*obj).CookieLifetime != nil {
			cookieLifetime_entry = (*obj).CookieLifetime
		} else {
			cookieLifetime_entry = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
		}
		var object *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
		diags.Append(o.CookieLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &cookieLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie)
	}
	(*obj).CookieLifetime = cookieLifetime_entry

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetimeInDays_value := o.LifetimeInDays.ValueInt64Pointer()
	lifetimeInHours_value := o.LifetimeInHours.ValueInt64Pointer()
	lifetimeInMinutes_value := o.LifetimeInMinutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
	}
	(*obj).LifetimeInDays = lifetimeInDays_value
	(*obj).LifetimeInHours = lifetimeInHours_value
	(*obj).LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSourceAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var region_pango_entries []string
	if !o.Region.IsUnknown() && !o.Region.IsNull() {
		object_entries := make([]types.String, 0, len(o.Region.Elements()))
		diags.Append(o.Region.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			region_pango_entries = append(region_pango_entries, elt.ValueString())
		}
	}
	var ipAddress_pango_entries []string
	if !o.IpAddress.IsUnknown() && !o.IpAddress.IsNull() {
		object_entries := make([]types.String, 0, len(o.IpAddress.Elements()))
		diags.Append(o.IpAddress.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ipAddress_pango_entries = append(ipAddress_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSourceAddress)
	}
	(*obj).Region = region_pango_entries
	(*obj).IpAddress = ipAddress_pango_entries

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunneling, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var accessRoute_pango_entries []string
	if !o.AccessRoute.IsUnknown() && !o.AccessRoute.IsNull() {
		object_entries := make([]types.String, 0, len(o.AccessRoute.Elements()))
		diags.Append(o.AccessRoute.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			accessRoute_pango_entries = append(accessRoute_pango_entries, elt.ValueString())
		}
	}
	var excludeAccessRoute_pango_entries []string
	if !o.ExcludeAccessRoute.IsUnknown() && !o.ExcludeAccessRoute.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExcludeAccessRoute.Elements()))
		diags.Append(o.ExcludeAccessRoute.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			excludeAccessRoute_pango_entries = append(excludeAccessRoute_pango_entries, elt.ValueString())
		}
	}
	var includeApplications_pango_entries []string
	if !o.IncludeApplications.IsUnknown() && !o.IncludeApplications.IsNull() {
		object_entries := make([]types.String, 0, len(o.IncludeApplications.Elements()))
		diags.Append(o.IncludeApplications.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			includeApplications_pango_entries = append(includeApplications_pango_entries, elt.ValueString())
		}
	}
	var excludeApplications_pango_entries []string
	if !o.ExcludeApplications.IsUnknown() && !o.ExcludeApplications.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExcludeApplications.Elements()))
		diags.Append(o.ExcludeApplications.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			excludeApplications_pango_entries = append(excludeApplications_pango_entries, elt.ValueString())
		}
	}
	var includeDomains_entry *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains
	if !o.IncludeDomains.IsUnknown() && !o.IncludeDomains.IsNull() {
		if *obj != nil && (*obj).IncludeDomains != nil {
			includeDomains_entry = (*obj).IncludeDomains
		} else {
			includeDomains_entry = new(gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains)
		}
		var object *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject
		diags.Append(o.IncludeDomains.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &includeDomains_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var excludeDomains_entry *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains
	if !o.ExcludeDomains.IsUnknown() && !o.ExcludeDomains.IsNull() {
		if *obj != nil && (*obj).ExcludeDomains != nil {
			excludeDomains_entry = (*obj).ExcludeDomains
		} else {
			excludeDomains_entry = new(gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains)
		}
		var object *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject
		diags.Append(o.ExcludeDomains.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &excludeDomains_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunneling)
	}
	(*obj).AccessRoute = accessRoute_pango_entries
	(*obj).ExcludeAccessRoute = excludeAccessRoute_pango_entries
	(*obj).IncludeApplications = includeApplications_pango_entries
	(*obj).ExcludeApplications = excludeApplications_pango_entries
	(*obj).IncludeDomains = includeDomains_entry
	(*obj).ExcludeDomains = excludeDomains_entry

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_tf_entries []GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject
	var list_pango_entries []gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains)
	}
	(*obj).List = list_pango_entries

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_pango_entries []int64
	if !o.Ports.IsUnknown() && !o.Ports.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.Ports.Elements()))
		diags.Append(o.Ports.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ports_pango_entries = append(ports_pango_entries, elt.ValueInt64())
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ports = ports_pango_entries

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_tf_entries []GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject
	var list_pango_entries []gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains)
	}
	(*obj).List = list_pango_entries

	return diags
}
func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_pango_entries []int64
	if !o.Ports.IsUnknown() && !o.Ports.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.Ports.Elements()))
		diags.Append(o.Ports.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ports_pango_entries = append(ports_pango_entries, elt.ValueInt64())
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ports = ports_pango_entries

	return diags
}
func (o *GlobalprotectGatewayDataSourceRolesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Roles, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var loginLifetime_entry *gateway.RolesLoginLifetime
	if !o.LoginLifetime.IsUnknown() && !o.LoginLifetime.IsNull() {
		if *obj != nil && (*obj).LoginLifetime != nil {
			loginLifetime_entry = (*obj).LoginLifetime
		} else {
			loginLifetime_entry = new(gateway.RolesLoginLifetime)
		}
		var object *GlobalprotectGatewayDataSourceRolesLoginLifetimeObject
		diags.Append(o.LoginLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &loginLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	inactivityLogout_value := o.InactivityLogout.ValueInt64Pointer()
	lifetimeNotifyPrior_value := o.LifetimeNotifyPrior.ValueInt64Pointer()
	lifetimeNotifyMessage_value := o.LifetimeNotifyMessage.ValueStringPointer()
	inactivityNotifyPrior_value := o.InactivityNotifyPrior.ValueInt64Pointer()
	inactivityNotifyMessage_value := o.InactivityNotifyMessage.ValueStringPointer()
	adminLogoutNotify_value := o.AdminLogoutNotify.ValueBoolPointer()
	adminLogoutNotifyMessage_value := o.AdminLogoutNotifyMessage.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.Roles)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).LoginLifetime = loginLifetime_entry
	(*obj).InactivityLogout = inactivityLogout_value
	(*obj).LifetimeNotifyPrior = lifetimeNotifyPrior_value
	(*obj).LifetimeNotifyMessage = lifetimeNotifyMessage_value
	(*obj).InactivityNotifyPrior = inactivityNotifyPrior_value
	(*obj).InactivityNotifyMessage = inactivityNotifyMessage_value
	(*obj).AdminLogoutNotify = adminLogoutNotify_value
	(*obj).AdminLogoutNotifyMessage = adminLogoutNotifyMessage_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceRolesLoginLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RolesLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	minutes_value := o.Minutes.ValueInt64Pointer()
	hours_value := o.Hours.ValueInt64Pointer()
	days_value := o.Days.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.RolesLoginLifetime)
	}
	(*obj).Minutes = minutes_value
	(*obj).Hours = hours_value
	(*obj).Days = days_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	disallowAutomaticRestoration_value := o.DisallowAutomaticRestoration.ValueBoolPointer()
	var sourceIpEnforcement_entry *gateway.SecurityRestrictionsSourceIpEnforcement
	if !o.SourceIpEnforcement.IsUnknown() && !o.SourceIpEnforcement.IsNull() {
		if *obj != nil && (*obj).SourceIpEnforcement != nil {
			sourceIpEnforcement_entry = (*obj).SourceIpEnforcement
		} else {
			sourceIpEnforcement_entry = new(gateway.SecurityRestrictionsSourceIpEnforcement)
		}
		var object *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject
		diags.Append(o.SourceIpEnforcement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sourceIpEnforcement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictions)
	}
	(*obj).DisallowAutomaticRestoration = disallowAutomaticRestoration_value
	(*obj).SourceIpEnforcement = sourceIpEnforcement_entry

	return diags
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictionsSourceIpEnforcement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var custom_entry *gateway.SecurityRestrictionsSourceIpEnforcementCustom
	if !o.Custom.IsUnknown() && !o.Custom.IsNull() {
		if *obj != nil && (*obj).Custom != nil {
			custom_entry = (*obj).Custom
		} else {
			custom_entry = new(gateway.SecurityRestrictionsSourceIpEnforcementCustom)
		}
		var object *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject
		diags.Append(o.Custom.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &custom_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var default_entry *gateway.SecurityRestrictionsSourceIpEnforcementDefault
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(gateway.SecurityRestrictionsSourceIpEnforcementDefault)
		}
		var object *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject
		diags.Append(o.Default.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &default_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictionsSourceIpEnforcement)
	}
	(*obj).Enable = enable_value
	(*obj).Custom = custom_entry
	(*obj).Default = default_entry

	return diags
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictionsSourceIpEnforcementCustom, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceIpv4Netmask_value := o.SourceIpv4Netmask.ValueInt64Pointer()
	sourceIpv6Netmask_value := o.SourceIpv6Netmask.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictionsSourceIpEnforcementCustom)
	}
	(*obj).SourceIpv4Netmask = sourceIpv4Netmask_value
	(*obj).SourceIpv6Netmask = sourceIpv6Netmask_value

	return diags
}
func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictionsSourceIpEnforcementDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictionsSourceIpEnforcementDefault)
	}

	return diags
}

func (o *GlobalprotectGatewayDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientAuth_list types.List
	{
		var clientAuth_tf_entries []GlobalprotectGatewayDataSourceClientAuthObject
		if !o.ClientAuth.IsNull() {
			diags.Append(o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ClientAuth {
			entry := GlobalprotectGatewayDataSourceClientAuthObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(clientAuth_tf_entries) {
				entry = clientAuth_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(clientAuth_tf_entries) {
				clientAuth_tf_entries[idx] = entry
			} else {
				clientAuth_tf_entries = append(clientAuth_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("client_auth")
		clientAuth_list, list_diags = types.ListValueFrom(ctx, schemaType, clientAuth_tf_entries)
		diags.Append(list_diags...)
	}
	var hipNotification_list types.List
	{
		var hipNotification_tf_entries []GlobalprotectGatewayDataSourceHipNotificationObject
		if !o.HipNotification.IsNull() {
			diags.Append(o.HipNotification.ElementsAs(ctx, &hipNotification_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.HipNotification {
			entry := GlobalprotectGatewayDataSourceHipNotificationObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(hipNotification_tf_entries) {
				entry = hipNotification_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(hipNotification_tf_entries) {
				hipNotification_tf_entries[idx] = entry
			} else {
				hipNotification_tf_entries = append(hipNotification_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("hip_notification")
		hipNotification_list, list_diags = types.ListValueFrom(ctx, schemaType, hipNotification_tf_entries)
		diags.Append(list_diags...)
	}
	var remoteUserTunnelConfigs_list types.List
	{
		var remoteUserTunnelConfigs_tf_entries []GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject
		if !o.RemoteUserTunnelConfigs.IsNull() {
			diags.Append(o.RemoteUserTunnelConfigs.ElementsAs(ctx, &remoteUserTunnelConfigs_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RemoteUserTunnelConfigs {
			entry := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(remoteUserTunnelConfigs_tf_entries) {
				entry = remoteUserTunnelConfigs_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(remoteUserTunnelConfigs_tf_entries) {
				remoteUserTunnelConfigs_tf_entries[idx] = entry
			} else {
				remoteUserTunnelConfigs_tf_entries = append(remoteUserTunnelConfigs_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("remote_user_tunnel_configs")
		remoteUserTunnelConfigs_list, list_diags = types.ListValueFrom(ctx, schemaType, remoteUserTunnelConfigs_tf_entries)
		diags.Append(list_diags...)
	}
	var roles_list types.List
	{
		var roles_tf_entries []GlobalprotectGatewayDataSourceRolesObject
		if !o.Roles.IsNull() {
			diags.Append(o.Roles.ElementsAs(ctx, &roles_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Roles {
			entry := GlobalprotectGatewayDataSourceRolesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(roles_tf_entries) {
				entry = roles_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(roles_tf_entries) {
				roles_tf_entries[idx] = entry
			} else {
				roles_tf_entries = append(roles_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("roles")
		roles_list, list_diags = types.ListValueFrom(ctx, schemaType, roles_tf_entries)
		diags.Append(list_diags...)
	}

	var localAddress_obj *GlobalprotectGatewayDataSourceLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(GlobalprotectGatewayDataSourceLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, ancestors, obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var securityRestrictions_obj *GlobalprotectGatewayDataSourceSecurityRestrictionsObject
	if o.SecurityRestrictions.IsNull() {
		securityRestrictions_obj = new(GlobalprotectGatewayDataSourceSecurityRestrictionsObject)
	} else {
		diags.Append(o.SecurityRestrictions.As(ctx, &securityRestrictions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	securityRestrictions_object := types.ObjectNull(securityRestrictions_obj.AttributeTypes())
	if obj.SecurityRestrictions != nil {
		diags.Append(securityRestrictions_obj.CopyFromPango(ctx, client, ancestors, obj.SecurityRestrictions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		securityRestrictions_object, diags_tmp = types.ObjectValueFrom(ctx, securityRestrictions_obj.AttributeTypes(), securityRestrictions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var blockQuarantinedDevices_value types.Bool
	if obj.BlockQuarantinedDevices != nil {
		blockQuarantinedDevices_value = types.BoolValue(*obj.BlockQuarantinedDevices)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var logFail_value types.Bool
	if obj.LogFail != nil {
		logFail_value = types.BoolValue(*obj.LogFail)
	}
	var logSetting_value types.String
	if obj.LogSetting != nil {
		logSetting_value = types.StringValue(*obj.LogSetting)
	}
	var logSuccess_value types.Bool
	if obj.LogSuccess != nil {
		logSuccess_value = types.BoolValue(*obj.LogSuccess)
	}
	var remoteUserTunnel_value types.String
	if obj.RemoteUserTunnel != nil {
		remoteUserTunnel_value = types.StringValue(*obj.RemoteUserTunnel)
	}
	var satelliteTunnel_value types.String
	if obj.SatelliteTunnel != nil {
		satelliteTunnel_value = types.StringValue(*obj.SatelliteTunnel)
	}
	var sslTlsServiceProfile_value types.String
	if obj.SslTlsServiceProfile != nil {
		sslTlsServiceProfile_value = types.StringValue(*obj.SslTlsServiceProfile)
	}
	var tunnelMode_value types.Bool
	if obj.TunnelMode != nil {
		tunnelMode_value = types.BoolValue(*obj.TunnelMode)
	}
	o.Name = types.StringValue(obj.Name)
	o.BlockQuarantinedDevices = blockQuarantinedDevices_value
	o.CertificateProfile = certificateProfile_value
	o.ClientAuth = clientAuth_list
	o.HipNotification = hipNotification_list
	o.LocalAddress = localAddress_object
	o.LogFail = logFail_value
	o.LogSetting = logSetting_value
	o.LogSuccess = logSuccess_value
	o.RemoteUserTunnel = remoteUserTunnel_value
	o.RemoteUserTunnelConfigs = remoteUserTunnelConfigs_list
	o.Roles = roles_list
	o.SatelliteTunnel = satelliteTunnel_value
	o.SecurityRestrictions = securityRestrictions_object
	o.SslTlsServiceProfile = sslTlsServiceProfile_value
	o.TunnelMode = tunnelMode_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceClientAuthObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var os_value types.String
	if obj.Os != nil {
		os_value = types.StringValue(*obj.Os)
	}
	var authenticationProfile_value types.String
	if obj.AuthenticationProfile != nil {
		authenticationProfile_value = types.StringValue(*obj.AuthenticationProfile)
	}
	var autoRetrievePasscode_value types.Bool
	if obj.AutoRetrievePasscode != nil {
		autoRetrievePasscode_value = types.BoolValue(*obj.AutoRetrievePasscode)
	}
	var usernameLabel_value types.String
	if obj.UsernameLabel != nil {
		usernameLabel_value = types.StringValue(*obj.UsernameLabel)
	}
	var passwordLabel_value types.String
	if obj.PasswordLabel != nil {
		passwordLabel_value = types.StringValue(*obj.PasswordLabel)
	}
	var authenticationMessage_value types.String
	if obj.AuthenticationMessage != nil {
		authenticationMessage_value = types.StringValue(*obj.AuthenticationMessage)
	}
	var userCredentialOrClientCertRequired_value types.String
	if obj.UserCredentialOrClientCertRequired != nil {
		userCredentialOrClientCertRequired_value = types.StringValue(*obj.UserCredentialOrClientCertRequired)
	}
	o.Name = types.StringValue(obj.Name)
	o.Os = os_value
	o.AuthenticationProfile = authenticationProfile_value
	o.AutoRetrievePasscode = autoRetrievePasscode_value
	o.UsernameLabel = usernameLabel_value
	o.PasswordLabel = passwordLabel_value
	o.AuthenticationMessage = authenticationMessage_value
	o.UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceHipNotificationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.HipNotification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var matchMessage_obj *GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject
	if o.MatchMessage.IsNull() {
		matchMessage_obj = new(GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject)
	} else {
		diags.Append(o.MatchMessage.As(ctx, &matchMessage_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	matchMessage_object := types.ObjectNull(matchMessage_obj.AttributeTypes())
	if obj.MatchMessage != nil {
		diags.Append(matchMessage_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MatchMessage, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		matchMessage_object, diags_tmp = types.ObjectValueFrom(ctx, matchMessage_obj.AttributeTypes(), matchMessage_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var notMatchMessage_obj *GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject
	if o.NotMatchMessage.IsNull() {
		notMatchMessage_obj = new(GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject)
	} else {
		diags.Append(o.NotMatchMessage.As(ctx, &notMatchMessage_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	notMatchMessage_object := types.ObjectNull(notMatchMessage_obj.AttributeTypes())
	if obj.NotMatchMessage != nil {
		diags.Append(notMatchMessage_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NotMatchMessage, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		notMatchMessage_object, diags_tmp = types.ObjectValueFrom(ctx, notMatchMessage_obj.AttributeTypes(), notMatchMessage_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.MatchMessage = matchMessage_object
	o.NotMatchMessage = notMatchMessage_object

	return diags
}

func (o *GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.HipNotificationMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var includeAppList_value types.Bool
	if obj.IncludeAppList != nil {
		includeAppList_value = types.BoolValue(*obj.IncludeAppList)
	}
	var showNotificationAs_value types.String
	if obj.ShowNotificationAs != nil {
		showNotificationAs_value = types.StringValue(*obj.ShowNotificationAs)
	}
	var message_value types.String
	if obj.Message != nil {
		message_value = types.StringValue(*obj.Message)
	}
	o.IncludeAppList = includeAppList_value
	o.ShowNotificationAs = showNotificationAs_value
	o.Message = message_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.HipNotificationNotMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var showNotificationAs_value types.String
	if obj.ShowNotificationAs != nil {
		showNotificationAs_value = types.StringValue(*obj.ShowNotificationAs)
	}
	var message_value types.String
	if obj.Message != nil {
		message_value = types.StringValue(*obj.Message)
	}
	o.ShowNotificationAs = showNotificationAs_value
	o.Message = message_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var floatingIp_obj *GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject
	if o.FloatingIp.IsNull() {
		floatingIp_obj = new(GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject)
	} else {
		diags.Append(o.FloatingIp.As(ctx, &floatingIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	floatingIp_object := types.ObjectNull(floatingIp_obj.AttributeTypes())
	if obj.FloatingIp != nil {
		diags.Append(floatingIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FloatingIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		floatingIp_object, diags_tmp = types.ObjectValueFrom(ctx, floatingIp_obj.AttributeTypes(), floatingIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *GlobalprotectGatewayDataSourceLocalAddressIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectGatewayDataSourceLocalAddressIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ipAddressFamily_value types.String
	if obj.IpAddressFamily != nil {
		ipAddressFamily_value = types.StringValue(*obj.IpAddressFamily)
	}
	o.Interface = interface_value
	o.IpAddressFamily = ipAddressFamily_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceLocalAddressIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var os_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Os.IsNull() || len(obj.Os) > 0 {
			entries = obj.Os
		}

		os_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsServer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DnsServer.IsNull() || len(obj.DnsServer) > 0 {
			entries = obj.DnsServer
		}

		dnsServer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DnsSuffix.IsNull() || len(obj.DnsSuffix) > 0 {
			entries = obj.DnsSuffix
		}

		dnsSuffix_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ipPool_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.IpPool.IsNull() || len(obj.IpPool) > 0 {
			entries = obj.IpPool
		}

		ipPool_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var authenticationServerIpPool_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.AuthenticationServerIpPool.IsNull() || len(obj.AuthenticationServerIpPool) > 0 {
			entries = obj.AuthenticationServerIpPool
		}

		authenticationServerIpPool_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var authenticationOverride_obj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject
	if o.AuthenticationOverride.IsNull() {
		authenticationOverride_obj = new(GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject)
	} else {
		diags.Append(o.AuthenticationOverride.As(ctx, &authenticationOverride_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authenticationOverride_object := types.ObjectNull(authenticationOverride_obj.AttributeTypes())
	if obj.AuthenticationOverride != nil {
		diags.Append(authenticationOverride_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AuthenticationOverride, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authenticationOverride_object, diags_tmp = types.ObjectValueFrom(ctx, authenticationOverride_obj.AttributeTypes(), authenticationOverride_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sourceAddress_obj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject
	if o.SourceAddress.IsNull() {
		sourceAddress_obj = new(GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject)
	} else {
		diags.Append(o.SourceAddress.As(ctx, &sourceAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sourceAddress_object := types.ObjectNull(sourceAddress_obj.AttributeTypes())
	if obj.SourceAddress != nil {
		diags.Append(sourceAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SourceAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sourceAddress_object, diags_tmp = types.ObjectValueFrom(ctx, sourceAddress_obj.AttributeTypes(), sourceAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var splitTunneling_obj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject
	if o.SplitTunneling.IsNull() {
		splitTunneling_obj = new(GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject)
	} else {
		diags.Append(o.SplitTunneling.As(ctx, &splitTunneling_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	splitTunneling_object := types.ObjectNull(splitTunneling_obj.AttributeTypes())
	if obj.SplitTunneling != nil {
		diags.Append(splitTunneling_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SplitTunneling, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		splitTunneling_object, diags_tmp = types.ObjectValueFrom(ctx, splitTunneling_obj.AttributeTypes(), splitTunneling_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noDirectAccessToLocalNetwork_value types.Bool
	if obj.NoDirectAccessToLocalNetwork != nil {
		noDirectAccessToLocalNetwork_value = types.BoolValue(*obj.NoDirectAccessToLocalNetwork)
	}
	var retrieveFramedIpAddress_value types.Bool
	if obj.RetrieveFramedIpAddress != nil {
		retrieveFramedIpAddress_value = types.BoolValue(*obj.RetrieveFramedIpAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.SourceUser = sourceUser_list
	o.Os = os_list
	o.DnsServer = dnsServer_list
	o.DnsSuffix = dnsSuffix_list
	o.IpPool = ipPool_list
	o.AuthenticationServerIpPool = authenticationServerIpPool_list
	o.AuthenticationOverride = authenticationOverride_object
	o.SourceAddress = sourceAddress_object
	o.SplitTunneling = splitTunneling_object
	o.NoDirectAccessToLocalNetwork = noDirectAccessToLocalNetwork_value
	o.RetrieveFramedIpAddress = retrieveFramedIpAddress_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var acceptCookie_obj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject
	if o.AcceptCookie.IsNull() {
		acceptCookie_obj = new(GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject)
	} else {
		diags.Append(o.AcceptCookie.As(ctx, &acceptCookie_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	acceptCookie_object := types.ObjectNull(acceptCookie_obj.AttributeTypes())
	if obj.AcceptCookie != nil {
		diags.Append(acceptCookie_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AcceptCookie, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		acceptCookie_object, diags_tmp = types.ObjectValueFrom(ctx, acceptCookie_obj.AttributeTypes(), acceptCookie_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var generateCookie_value types.Bool
	if obj.GenerateCookie != nil {
		generateCookie_value = types.BoolValue(*obj.GenerateCookie)
	}
	var cookieEncryptDecryptCert_value types.String
	if obj.CookieEncryptDecryptCert != nil {
		cookieEncryptDecryptCert_value = types.StringValue(*obj.CookieEncryptDecryptCert)
	}
	o.GenerateCookie = generateCookie_value
	o.CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	o.AcceptCookie = acceptCookie_object

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var cookieLifetime_obj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	if o.CookieLifetime.IsNull() {
		cookieLifetime_obj = new(GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject)
	} else {
		diags.Append(o.CookieLifetime.As(ctx, &cookieLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	cookieLifetime_object := types.ObjectNull(cookieLifetime_obj.AttributeTypes())
	if obj.CookieLifetime != nil {
		diags.Append(cookieLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CookieLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		cookieLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, cookieLifetime_obj.AttributeTypes(), cookieLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.CookieLifetime = cookieLifetime_object

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetimeInDays_value types.Int64
	if obj.LifetimeInDays != nil {
		lifetimeInDays_value = types.Int64Value(*obj.LifetimeInDays)
	}
	var lifetimeInHours_value types.Int64
	if obj.LifetimeInHours != nil {
		lifetimeInHours_value = types.Int64Value(*obj.LifetimeInHours)
	}
	var lifetimeInMinutes_value types.Int64
	if obj.LifetimeInMinutes != nil {
		lifetimeInMinutes_value = types.Int64Value(*obj.LifetimeInMinutes)
	}
	o.LifetimeInDays = lifetimeInDays_value
	o.LifetimeInHours = lifetimeInHours_value
	o.LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSourceAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var region_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Region.IsNull() || len(obj.Region) > 0 {
			entries = obj.Region
		}

		region_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ipAddress_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.IpAddress.IsNull() || len(obj.IpAddress) > 0 {
			entries = obj.IpAddress
		}

		ipAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Region = region_list
	o.IpAddress = ipAddress_list

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunneling, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var accessRoute_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.AccessRoute.IsNull() || len(obj.AccessRoute) > 0 {
			entries = obj.AccessRoute
		}

		accessRoute_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var excludeAccessRoute_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExcludeAccessRoute.IsNull() || len(obj.ExcludeAccessRoute) > 0 {
			entries = obj.ExcludeAccessRoute
		}

		excludeAccessRoute_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var includeApplications_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.IncludeApplications.IsNull() || len(obj.IncludeApplications) > 0 {
			entries = obj.IncludeApplications
		}

		includeApplications_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var excludeApplications_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExcludeApplications.IsNull() || len(obj.ExcludeApplications) > 0 {
			entries = obj.ExcludeApplications
		}

		excludeApplications_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var includeDomains_obj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject
	if o.IncludeDomains.IsNull() {
		includeDomains_obj = new(GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject)
	} else {
		diags.Append(o.IncludeDomains.As(ctx, &includeDomains_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	includeDomains_object := types.ObjectNull(includeDomains_obj.AttributeTypes())
	if obj.IncludeDomains != nil {
		diags.Append(includeDomains_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IncludeDomains, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		includeDomains_object, diags_tmp = types.ObjectValueFrom(ctx, includeDomains_obj.AttributeTypes(), includeDomains_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var excludeDomains_obj *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject
	if o.ExcludeDomains.IsNull() {
		excludeDomains_obj = new(GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject)
	} else {
		diags.Append(o.ExcludeDomains.As(ctx, &excludeDomains_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	excludeDomains_object := types.ObjectNull(excludeDomains_obj.AttributeTypes())
	if obj.ExcludeDomains != nil {
		diags.Append(excludeDomains_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExcludeDomains, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		excludeDomains_object, diags_tmp = types.ObjectValueFrom(ctx, excludeDomains_obj.AttributeTypes(), excludeDomains_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.AccessRoute = accessRoute_list
	o.ExcludeAccessRoute = excludeAccessRoute_list
	o.IncludeApplications = includeApplications_list
	o.ExcludeApplications = excludeApplications_list
	o.IncludeDomains = includeDomains_object
	o.ExcludeDomains = excludeDomains_object

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}

	o.List = list_list

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.Ports.IsNull() || len(obj.Ports) > 0 {
			entries = obj.Ports
		}

		ports_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Ports = ports_list

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}

	o.List = list_list

	return diags
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.Ports.IsNull() || len(obj.Ports) > 0 {
			entries = obj.Ports
		}

		ports_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Ports = ports_list

	return diags
}

func (o *GlobalprotectGatewayDataSourceRolesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Roles, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var loginLifetime_obj *GlobalprotectGatewayDataSourceRolesLoginLifetimeObject
	if o.LoginLifetime.IsNull() {
		loginLifetime_obj = new(GlobalprotectGatewayDataSourceRolesLoginLifetimeObject)
	} else {
		diags.Append(o.LoginLifetime.As(ctx, &loginLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	loginLifetime_object := types.ObjectNull(loginLifetime_obj.AttributeTypes())
	if obj.LoginLifetime != nil {
		diags.Append(loginLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LoginLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		loginLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, loginLifetime_obj.AttributeTypes(), loginLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var inactivityLogout_value types.Int64
	if obj.InactivityLogout != nil {
		inactivityLogout_value = types.Int64Value(*obj.InactivityLogout)
	}
	var lifetimeNotifyPrior_value types.Int64
	if obj.LifetimeNotifyPrior != nil {
		lifetimeNotifyPrior_value = types.Int64Value(*obj.LifetimeNotifyPrior)
	}
	var lifetimeNotifyMessage_value types.String
	if obj.LifetimeNotifyMessage != nil {
		lifetimeNotifyMessage_value = types.StringValue(*obj.LifetimeNotifyMessage)
	}
	var inactivityNotifyPrior_value types.Int64
	if obj.InactivityNotifyPrior != nil {
		inactivityNotifyPrior_value = types.Int64Value(*obj.InactivityNotifyPrior)
	}
	var inactivityNotifyMessage_value types.String
	if obj.InactivityNotifyMessage != nil {
		inactivityNotifyMessage_value = types.StringValue(*obj.InactivityNotifyMessage)
	}
	var adminLogoutNotify_value types.Bool
	if obj.AdminLogoutNotify != nil {
		adminLogoutNotify_value = types.BoolValue(*obj.AdminLogoutNotify)
	}
	var adminLogoutNotifyMessage_value types.String
	if obj.AdminLogoutNotifyMessage != nil {
		adminLogoutNotifyMessage_value = types.StringValue(*obj.AdminLogoutNotifyMessage)
	}
	o.Name = types.StringValue(obj.Name)
	o.LoginLifetime = loginLifetime_object
	o.InactivityLogout = inactivityLogout_value
	o.LifetimeNotifyPrior = lifetimeNotifyPrior_value
	o.LifetimeNotifyMessage = lifetimeNotifyMessage_value
	o.InactivityNotifyPrior = inactivityNotifyPrior_value
	o.InactivityNotifyMessage = inactivityNotifyMessage_value
	o.AdminLogoutNotify = adminLogoutNotify_value
	o.AdminLogoutNotifyMessage = adminLogoutNotifyMessage_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceRolesLoginLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RolesLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var minutes_value types.Int64
	if obj.Minutes != nil {
		minutes_value = types.Int64Value(*obj.Minutes)
	}
	var hours_value types.Int64
	if obj.Hours != nil {
		hours_value = types.Int64Value(*obj.Hours)
	}
	var days_value types.Int64
	if obj.Days != nil {
		days_value = types.Int64Value(*obj.Days)
	}
	o.Minutes = minutes_value
	o.Hours = hours_value
	o.Days = days_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceIpEnforcement_obj *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject
	if o.SourceIpEnforcement.IsNull() {
		sourceIpEnforcement_obj = new(GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject)
	} else {
		diags.Append(o.SourceIpEnforcement.As(ctx, &sourceIpEnforcement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sourceIpEnforcement_object := types.ObjectNull(sourceIpEnforcement_obj.AttributeTypes())
	if obj.SourceIpEnforcement != nil {
		diags.Append(sourceIpEnforcement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SourceIpEnforcement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sourceIpEnforcement_object, diags_tmp = types.ObjectValueFrom(ctx, sourceIpEnforcement_obj.AttributeTypes(), sourceIpEnforcement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var disallowAutomaticRestoration_value types.Bool
	if obj.DisallowAutomaticRestoration != nil {
		disallowAutomaticRestoration_value = types.BoolValue(*obj.DisallowAutomaticRestoration)
	}
	o.DisallowAutomaticRestoration = disallowAutomaticRestoration_value
	o.SourceIpEnforcement = sourceIpEnforcement_object

	return diags
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictionsSourceIpEnforcement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var custom_obj *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject
	if o.Custom.IsNull() {
		custom_obj = new(GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject)
	} else {
		diags.Append(o.Custom.As(ctx, &custom_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	custom_object := types.ObjectNull(custom_obj.AttributeTypes())
	if obj.Custom != nil {
		diags.Append(custom_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Custom, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		custom_object, diags_tmp = types.ObjectValueFrom(ctx, custom_obj.AttributeTypes(), custom_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var default_obj *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject
	if o.Default.IsNull() {
		default_obj = new(GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject)
	} else {
		diags.Append(o.Default.As(ctx, &default_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	default_object := types.ObjectNull(default_obj.AttributeTypes())
	if obj.Default != nil {
		diags.Append(default_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Default, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		default_object, diags_tmp = types.ObjectValueFrom(ctx, default_obj.AttributeTypes(), default_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Custom = custom_object
	o.Default = default_object

	return diags
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictionsSourceIpEnforcementCustom, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceIpv4Netmask_value types.Int64
	if obj.SourceIpv4Netmask != nil {
		sourceIpv4Netmask_value = types.Int64Value(*obj.SourceIpv4Netmask)
	}
	var sourceIpv6Netmask_value types.Int64
	if obj.SourceIpv6Netmask != nil {
		sourceIpv6Netmask_value = types.Int64Value(*obj.SourceIpv6Netmask)
	}
	o.SourceIpv4Netmask = sourceIpv4Netmask_value
	o.SourceIpv6Netmask = sourceIpv6Netmask_value

	return diags
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictionsSourceIpEnforcementDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectGatewayDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func GlobalprotectGatewayDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": GlobalprotectGatewayDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"block_quarantined_devices": dsschema.BoolAttribute{
				Description: "Block login for quarantined devices",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"client_auth": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayDataSourceClientAuthSchema(),
			},

			"hip_notification": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayDataSourceHipNotificationSchema(),
			},

			"local_address": GlobalprotectGatewayDataSourceLocalAddressSchema(),

			"log_fail": dsschema.BoolAttribute{
				Description: "Log unsuccessful TLS handshakes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_setting": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_success": dsschema.BoolAttribute{
				Description: "Log successful TLS handshakes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_user_tunnel": dsschema.StringAttribute{
				Description: "GlobalProtect user tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_user_tunnel_configs": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSchema(),
			},

			"roles": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayDataSourceRolesSchema(),
			},

			"satellite_tunnel": dsschema.StringAttribute{
				Description: "GlobalProtect satellite tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"security_restrictions": GlobalprotectGatewayDataSourceSecurityRestrictionsSchema(),

			"ssl_tls_service_profile": dsschema.StringAttribute{
				Description: "SSL TLS service profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_mode": dsschema.BoolAttribute{
				Description: "Tunnel mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceModel) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceClientAuthSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"os": dsschema.StringAttribute{
				Description: "Client OS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication_profile": dsschema.StringAttribute{
				Description: "authentication profile used for this GlobalProtect",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_retrieve_passcode": dsschema.BoolAttribute{
				Description: "Automatically retrieve passcode from SoftToken application",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username_label": dsschema.StringAttribute{
				Description: "Username Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"password_label": dsschema.StringAttribute{
				Description: "Password Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication_message": dsschema.StringAttribute{
				Description: "Authentication Message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"user_credential_or_client_cert_required": dsschema.StringAttribute{
				Description: "Allow Authentication with User Credentials OR Client Certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceClientAuthObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceClientAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceHipNotificationSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"match_message": GlobalprotectGatewayDataSourceHipNotificationMatchMessageSchema(),

			"not_match_message": GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageSchema(),
		},
	}
}

func (o *GlobalprotectGatewayDataSourceHipNotificationObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceHipNotificationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceHipNotificationMatchMessageSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"include_app_list": dsschema.BoolAttribute{
				Description: "Whether include matched application list in message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"show_notification_as": dsschema.StringAttribute{
				Description: "Show notification as",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"message": dsschema.StringAttribute{
				Description: "Matched message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceHipNotificationMatchMessageObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceHipNotificationMatchMessageSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"show_notification_as": dsschema.StringAttribute{
				Description: "Show notification as",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"message": dsschema.StringAttribute{
				Description: "Not matched message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceHipNotificationNotMatchMessageSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address_family": dsschema.StringAttribute{
				Description: "specify the family of the local address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": GlobalprotectGatewayDataSourceLocalAddressFloatingIpSchema(),

			"ip": GlobalprotectGatewayDataSourceLocalAddressIpSchema(),
		},
	}
}

func (o *GlobalprotectGatewayDataSourceLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceLocalAddressFloatingIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Floating IPv4 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Floating IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceLocalAddressIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4 addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source_user": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"os": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"dns_server": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"dns_suffix": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ip_pool": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"authentication_server_ip_pool": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"authentication_override": GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideSchema(),

			"source_address": GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressSchema(),

			"split_tunneling": GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingSchema(),

			"no_direct_access_to_local_network": dsschema.BoolAttribute{
				Description: "No direct access to local network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retrieve_framed_ip_address": dsschema.BoolAttribute{
				Description: "retrieve framed ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"generate_cookie": dsschema.BoolAttribute{
				Description: "Generate cookie for authentication override",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cookie_encrypt_decrypt_cert": dsschema.StringAttribute{
				Description: "Certificate to Encrypt/Decrypt Cookie",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"accept_cookie": GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieSchema(),
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"cookie_lifetime": GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema(),
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lifetime_in_days": dsschema.Int64Attribute{
				Description: "Cookie lifetime in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_in_hours": dsschema.Int64Attribute{
				Description: "Cookie lifetime in hours",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_in_minutes": dsschema.Int64Attribute{
				Description: "Cookie lifetime in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"region": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ip_address": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSourceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_route": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"exclude_access_route": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"include_applications": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"exclude_applications": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"include_domains": GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsSchema(),

			"exclude_domains": GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsSchema(),
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"list": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListSchema(),
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ports": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"list": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListSchema(),
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ports": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRolesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"login_lifetime": GlobalprotectGatewayDataSourceRolesLoginLifetimeSchema(),

			"inactivity_logout": dsschema.Int64Attribute{
				Description: "Logout the GlobalProtect user session if the GlobalProtect app has not sent traffic in the specified amount of minutes.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_notify_prior": dsschema.Int64Attribute{
				Description: "Notify users before the lifetime expiration in the specified amount of minutes.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_notify_message": dsschema.StringAttribute{
				Description: "Lifetime expiration notification displayed on GP app",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inactivity_notify_prior": dsschema.Int64Attribute{
				Description: "Notify users before the inactivity timeout in the specified amount of minutes.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inactivity_notify_message": dsschema.StringAttribute{
				Description: "Inactivity logout notification displayed on GP app",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"admin_logout_notify": dsschema.BoolAttribute{
				Description: "Notify users on admin logout",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"admin_logout_notify_message": dsschema.StringAttribute{
				Description: "Admin logout notification displayed on GP app",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRolesObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRolesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceRolesLoginLifetimeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"minutes": dsschema.Int64Attribute{
				Description: "specify lifetime in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hours": dsschema.Int64Attribute{
				Description: "specify lifetime in hours",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"days": dsschema.Int64Attribute{
				Description: "specify lifetime in days",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceRolesLoginLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceRolesLoginLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceSecurityRestrictionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disallow_automatic_restoration": dsschema.BoolAttribute{
				Description: "Disallow Automatic Restoration of SSL VPN",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_ip_enforcement": GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementSchema(),
		},
	}
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceSecurityRestrictionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Allow Authentication Cookie Usage Only",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"custom": GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomSchema(),

			"default": GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultSchema(),
		},
	}
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("custom"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"source_ipv4_netmask": dsschema.Int64Attribute{
				Description: "Source IPv4 Netmask",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_ipv6_netmask": dsschema.Int64Attribute{
				Description: "Source IPv6 Netmask",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementCustomSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("custom"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayDataSourceSecurityRestrictionsSourceIpEnforcementDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayDataSourceLocationSchema() rsschema.Attribute {
	return GlobalprotectGatewayLocationSchema()
}

// Metadata returns the data source type name.
func (d *GlobalprotectGatewayDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_globalprotect_gateway"
}

// Schema defines the schema for this data source.
func (d *GlobalprotectGatewayDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = GlobalprotectGatewayDataSourceSchema()
}

// Configure prepares the struct.
func (d *GlobalprotectGatewayDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := gateway.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service](d.client, gateway.NewService(d.client), batchSize, specifier, gateway.SpecMatches)
}
func (o *GlobalprotectGatewayDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state GlobalprotectGatewayDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location gateway.Location

	{
		var terraformLocation GlobalprotectGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation GlobalprotectGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &gateway.TemplateVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &gateway.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &gateway.VsysLocation{}
			var innerLocation GlobalprotectGatewayVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_globalprotect_gateway_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &GlobalprotectGatewayResource{}
	_ resource.ResourceWithConfigure   = &GlobalprotectGatewayResource{}
	_ resource.ResourceWithImportState = &GlobalprotectGatewayResource{}
)

func NewGlobalprotectGatewayResource() resource.Resource {
	if _, found := resourceFuncMap["panos_globalprotect_gateway"]; !found {
		resourceFuncMap["panos_globalprotect_gateway"] = resourceFuncs{
			CreateImportId: GlobalprotectGatewayImportStateCreator,
		}
	}
	return &GlobalprotectGatewayResource{}
}

type GlobalprotectGatewayResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service]
}

func GlobalprotectGatewayResourceLocationSchema() rsschema.Attribute {
	return GlobalprotectGatewayLocationSchema()
}

type GlobalprotectGatewayResourceModel struct {
	Location                types.Object `tfsdk:"location"`
	Name                    types.String `tfsdk:"name"`
	BlockQuarantinedDevices types.Bool   `tfsdk:"block_quarantined_devices"`
	CertificateProfile      types.String `tfsdk:"certificate_profile"`
	ClientAuth              types.List   `tfsdk:"client_auth"`
	HipNotification         types.List   `tfsdk:"hip_notification"`
	LocalAddress            types.Object `tfsdk:"local_address"`
	LogFail                 types.Bool   `tfsdk:"log_fail"`
	LogSetting              types.String `tfsdk:"log_setting"`
	LogSuccess              types.Bool   `tfsdk:"log_success"`
	RemoteUserTunnel        types.String `tfsdk:"remote_user_tunnel"`
	RemoteUserTunnelConfigs types.List   `tfsdk:"remote_user_tunnel_configs"`
	Roles                   types.List   `tfsdk:"roles"`
	SatelliteTunnel         types.String `tfsdk:"satellite_tunnel"`
	SecurityRestrictions    types.Object `tfsdk:"security_restrictions"`
	SslTlsServiceProfile    types.String `tfsdk:"ssl_tls_service_profile"`
	TunnelMode              types.Bool   `tfsdk:"tunnel_mode"`
}
type GlobalprotectGatewayResourceClientAuthObject struct {
	Name                               types.String `tfsdk:"name"`
	Os                                 types.String `tfsdk:"os"`
	AuthenticationProfile              types.String `tfsdk:"authentication_profile"`
	AutoRetrievePasscode               types.Bool   `tfsdk:"auto_retrieve_passcode"`
	UsernameLabel                      types.String `tfsdk:"username_label"`
	PasswordLabel                      types.String `tfsdk:"password_label"`
	AuthenticationMessage              types.String `tfsdk:"authentication_message"`
	UserCredentialOrClientCertRequired types.String `tfsdk:"user_credential_or_client_cert_required"`
}
type GlobalprotectGatewayResourceHipNotificationObject struct {
	Name            types.String `tfsdk:"name"`
	MatchMessage    types.Object `tfsdk:"match_message"`
	NotMatchMessage types.Object `tfsdk:"not_match_message"`
}
type GlobalprotectGatewayResourceHipNotificationMatchMessageObject struct {
	IncludeAppList     types.Bool   `tfsdk:"include_app_list"`
	ShowNotificationAs types.String `tfsdk:"show_notification_as"`
	Message            types.String `tfsdk:"message"`
}
type GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject struct {
	ShowNotificationAs types.String `tfsdk:"show_notification_as"`
	Message            types.String `tfsdk:"message"`
}
type GlobalprotectGatewayResourceLocalAddressObject struct {
	Interface       types.String `tfsdk:"interface"`
	IpAddressFamily types.String `tfsdk:"ip_address_family"`
	FloatingIp      types.Object `tfsdk:"floating_ip"`
	Ip              types.Object `tfsdk:"ip"`
}
type GlobalprotectGatewayResourceLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectGatewayResourceLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject struct {
	Name                         types.String `tfsdk:"name"`
	SourceUser                   types.List   `tfsdk:"source_user"`
	Os                           types.List   `tfsdk:"os"`
	DnsServer                    types.List   `tfsdk:"dns_server"`
	DnsSuffix                    types.List   `tfsdk:"dns_suffix"`
	IpPool                       types.List   `tfsdk:"ip_pool"`
	AuthenticationServerIpPool   types.List   `tfsdk:"authentication_server_ip_pool"`
	AuthenticationOverride       types.Object `tfsdk:"authentication_override"`
	SourceAddress                types.Object `tfsdk:"source_address"`
	SplitTunneling               types.Object `tfsdk:"split_tunneling"`
	NoDirectAccessToLocalNetwork types.Bool   `tfsdk:"no_direct_access_to_local_network"`
	RetrieveFramedIpAddress      types.Bool   `tfsdk:"retrieve_framed_ip_address"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject struct {
	GenerateCookie           types.Bool   `tfsdk:"generate_cookie"`
	CookieEncryptDecryptCert types.String `tfsdk:"cookie_encrypt_decrypt_cert"`
	AcceptCookie             types.Object `tfsdk:"accept_cookie"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject struct {
	CookieLifetime types.Object `tfsdk:"cookie_lifetime"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject struct {
	LifetimeInDays    types.Int64 `tfsdk:"lifetime_in_days"`
	LifetimeInHours   types.Int64 `tfsdk:"lifetime_in_hours"`
	LifetimeInMinutes types.Int64 `tfsdk:"lifetime_in_minutes"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject struct {
	Region    types.List `tfsdk:"region"`
	IpAddress types.List `tfsdk:"ip_address"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject struct {
	AccessRoute         types.List   `tfsdk:"access_route"`
	ExcludeAccessRoute  types.List   `tfsdk:"exclude_access_route"`
	IncludeApplications types.List   `tfsdk:"include_applications"`
	ExcludeApplications types.List   `tfsdk:"exclude_applications"`
	IncludeDomains      types.Object `tfsdk:"include_domains"`
	ExcludeDomains      types.Object `tfsdk:"exclude_domains"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject struct {
	List types.List `tfsdk:"list"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject struct {
	Name  types.String `tfsdk:"name"`
	Ports types.List   `tfsdk:"ports"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject struct {
	List types.List `tfsdk:"list"`
}
type GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject struct {
	Name  types.String `tfsdk:"name"`
	Ports types.List   `tfsdk:"ports"`
}
type GlobalprotectGatewayResourceRolesObject struct {
	Name                     types.String `tfsdk:"name"`
	LoginLifetime            types.Object `tfsdk:"login_lifetime"`
	InactivityLogout         types.Int64  `tfsdk:"inactivity_logout"`
	LifetimeNotifyPrior      types.Int64  `tfsdk:"lifetime_notify_prior"`
	LifetimeNotifyMessage    types.String `tfsdk:"lifetime_notify_message"`
	InactivityNotifyPrior    types.Int64  `tfsdk:"inactivity_notify_prior"`
	InactivityNotifyMessage  types.String `tfsdk:"inactivity_notify_message"`
	AdminLogoutNotify        types.Bool   `tfsdk:"admin_logout_notify"`
	AdminLogoutNotifyMessage types.String `tfsdk:"admin_logout_notify_message"`
}
type GlobalprotectGatewayResourceRolesLoginLifetimeObject struct {
	Minutes types.Int64 `tfsdk:"minutes"`
	Hours   types.Int64 `tfsdk:"hours"`
	Days    types.Int64 `tfsdk:"days"`
}
type GlobalprotectGatewayResourceSecurityRestrictionsObject struct {
	DisallowAutomaticRestoration types.Bool   `tfsdk:"disallow_automatic_restoration"`
	SourceIpEnforcement          types.Object `tfsdk:"source_ip_enforcement"`
}
type GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject struct {
	Enable  types.Bool   `tfsdk:"enable"`
	Custom  types.Object `tfsdk:"custom"`
	Default types.Object `tfsdk:"default"`
}
type GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject struct {
	SourceIpv4Netmask types.Int64 `tfsdk:"source_ipv4_netmask"`
	SourceIpv6Netmask types.Int64 `tfsdk:"source_ipv6_netmask"`
}
type GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject struct {
}

func (o *GlobalprotectGatewayResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func GlobalprotectGatewayResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": GlobalprotectGatewayResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"block_quarantined_devices": rsschema.BoolAttribute{
				Description: "Block login for quarantined devices",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"client_auth": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayResourceClientAuthSchema(),
			},

			"hip_notification": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayResourceHipNotificationSchema(),
			},

			"local_address": GlobalprotectGatewayResourceLocalAddressSchema(),

			"log_fail": rsschema.BoolAttribute{
				Description: "Log unsuccessful TLS handshakes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_setting": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"log_success": rsschema.BoolAttribute{
				Description: "Log successful TLS handshakes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_user_tunnel": rsschema.StringAttribute{
				Description: "GlobalProtect user tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_user_tunnel_configs": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayResourceRemoteUserTunnelConfigsSchema(),
			},

			"roles": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayResourceRolesSchema(),
			},

			"satellite_tunnel": rsschema.StringAttribute{
				Description: "GlobalProtect satellite tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"security_restrictions": GlobalprotectGatewayResourceSecurityRestrictionsSchema(),

			"ssl_tls_service_profile": rsschema.StringAttribute{
				Description: "SSL TLS service profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_mode": rsschema.BoolAttribute{
				Description: "Tunnel mode",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceModel) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceClientAuthSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"os": rsschema.StringAttribute{
				Description: "Client OS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Any"),
			},

			"authentication_profile": rsschema.StringAttribute{
				Description: "authentication profile used for this GlobalProtect",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_retrieve_passcode": rsschema.BoolAttribute{
				Description: "Automatically retrieve passcode from SoftToken application",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username_label": rsschema.StringAttribute{
				Description: "Username Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Username"),
			},

			"password_label": rsschema.StringAttribute{
				Description: "Password Label",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Password"),
			},

			"authentication_message": rsschema.StringAttribute{
				Description: "Authentication Message",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Enter login credentials"),
			},

			"user_credential_or_client_cert_required": rsschema.StringAttribute{
				Description: "Allow Authentication with User Credentials OR Client Certificate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("no"),
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceClientAuthObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceClientAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceHipNotificationSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"match_message": GlobalprotectGatewayResourceHipNotificationMatchMessageSchema(),

			"not_match_message": GlobalprotectGatewayResourceHipNotificationNotMatchMessageSchema(),
		},
	}
}

func (o *GlobalprotectGatewayResourceHipNotificationObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceHipNotificationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceHipNotificationMatchMessageSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"include_app_list": rsschema.BoolAttribute{
				Description: "Whether include matched application list in message",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"show_notification_as": rsschema.StringAttribute{
				Description: "Show notification as",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("system-tray-balloon"),
			},

			"message": rsschema.StringAttribute{
				Description: "Matched message",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceHipNotificationMatchMessageObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceHipNotificationMatchMessageSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceHipNotificationNotMatchMessageSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"show_notification_as": rsschema.StringAttribute{
				Description: "Show notification as",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("system-tray-balloon"),
			},

			"message": rsschema.StringAttribute{
				Description: "Not matched message",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceHipNotificationNotMatchMessageSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "local gateway end-point",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address_family": rsschema.StringAttribute{
				Description: "specify the family of the local address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),
			},

			"floating_ip": GlobalprotectGatewayResourceLocalAddressFloatingIpSchema(),

			"ip": GlobalprotectGatewayResourceLocalAddressIpSchema(),
		},
	}
}

func (o *GlobalprotectGatewayResourceLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceLocalAddressFloatingIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Floating IPv4 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Floating IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceLocalAddressIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4 addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source_user": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"os": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"dns_server": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"dns_suffix": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ip_pool": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"authentication_server_ip_pool": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"authentication_override": GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideSchema(),

			"source_address": GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressSchema(),

			"split_tunneling": GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingSchema(),

			"no_direct_access_to_local_network": rsschema.BoolAttribute{
				Description: "No direct access to local network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retrieve_framed_ip_address": rsschema.BoolAttribute{
				Description: "retrieve framed ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"generate_cookie": rsschema.BoolAttribute{
				Description: "Generate cookie for authentication override",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cookie_encrypt_decrypt_cert": rsschema.StringAttribute{
				Description: "Certificate to Encrypt/Decrypt Cookie",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"accept_cookie": GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieSchema(),
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"cookie_lifetime": GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema(),
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lifetime_in_days": rsschema.Int64Attribute{
				Description: "Cookie lifetime in days",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("lifetime_in_days"),
						path.MatchRelative().AtParent().AtName("lifetime_in_hours"),
						path.MatchRelative().AtParent().AtName("lifetime_in_minutes"),
					}...),
				},
			},

			"lifetime_in_hours": rsschema.Int64Attribute{
				Description: "Cookie lifetime in hours",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime_in_minutes": rsschema.Int64Attribute{
				Description: "Cookie lifetime in minutes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"region": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ip_address": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_route": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"exclude_access_route": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"include_applications": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"exclude_applications": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"include_domains": GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsSchema(),

			"exclude_domains": GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsSchema(),
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"list": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListSchema(),
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ports": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"list": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListSchema(),
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ports": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRolesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"login_lifetime": GlobalprotectGatewayResourceRolesLoginLifetimeSchema(),

			"inactivity_logout": rsschema.Int64Attribute{
				Description: "Logout the GlobalProtect user session if the GlobalProtect app has not sent traffic in the specified amount of minutes.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(180),
			},

			"lifetime_notify_prior": rsschema.Int64Attribute{
				Description: "Notify users before the lifetime expiration in the specified amount of minutes.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"lifetime_notify_message": rsschema.StringAttribute{
				Description: "Lifetime expiration notification displayed on GP app",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Your GlobalProtect session will expire in 30 minutes. Please save your work before your session expires."),
			},

			"inactivity_notify_prior": rsschema.Int64Attribute{
				Description: "Notify users before the inactivity timeout in the specified amount of minutes.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"inactivity_notify_message": rsschema.StringAttribute{
				Description: "Inactivity logout notification displayed on GP app",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Your GlobalProtect session will time out in 30 minutes. Please save your work before your session times out."),
			},

			"admin_logout_notify": rsschema.BoolAttribute{
				Description: "Notify users on admin logout",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"admin_logout_notify_message": rsschema.StringAttribute{
				Description: "Admin logout notification displayed on GP app",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Your administrator has logged you out."),
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRolesObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRolesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceRolesLoginLifetimeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"minutes": rsschema.Int64Attribute{
				Description: "specify lifetime in minutes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("minutes"),
						path.MatchRelative().AtParent().AtName("hours"),
						path.MatchRelative().AtParent().AtName("days"),
					}...),
				},
			},

			"hours": rsschema.Int64Attribute{
				Description: "specify lifetime in hours",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"days": rsschema.Int64Attribute{
				Description: "specify lifetime in days",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceRolesLoginLifetimeObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceRolesLoginLifetimeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceSecurityRestrictionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disallow_automatic_restoration": rsschema.BoolAttribute{
				Description: "Disallow Automatic Restoration of SSL VPN",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_ip_enforcement": GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementSchema(),
		},
	}
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceSecurityRestrictionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Allow Authentication Cookie Usage Only",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"custom": GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomSchema(),

			"default": GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultSchema(),
		},
	}
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("custom"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"source_ipv4_netmask": rsschema.Int64Attribute{
				Description: "Source IPv4 Netmask",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_ipv6_netmask": rsschema.Int64Attribute{
				Description: "Source IPv6 Netmask",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("custom"),
				path.MatchRelative().AtParent().AtName("default"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject) getTypeFor(name string) attr.Type {
	schema := GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *GlobalprotectGatewayResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_globalprotect_gateway"
}

func (o *GlobalprotectGatewayResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = GlobalprotectGatewayResourceSchema()
}

// </ResourceSchema>

func (o *GlobalprotectGatewayResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := gateway.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*gateway.Entry, gateway.Location, *gateway.Service](o.client, gateway.NewService(o.client), batchSize, specifier, gateway.SpecMatches)
}

func (o *GlobalprotectGatewayResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj GlobalprotectGatewayLocation

	var clientAuthObj *GlobalprotectGatewayResourceClientAuthObject

	var hipNotificationObj *GlobalprotectGatewayResourceHipNotificationObject

	var localAddressObj *GlobalprotectGatewayResourceLocalAddressObject

	var remoteUserTunnelConfigsObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject

	var rolesObj *GlobalprotectGatewayResourceRolesObject

	var securityRestrictionsObj *GlobalprotectGatewayResourceSecurityRestrictionsObject

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":                      types.StringType,
		"block_quarantined_devices": types.BoolType,
		"certificate_profile":       types.StringType,
		"client_auth": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: clientAuthObj.AttributeTypes(),
			},
		},
		"hip_notification": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: hipNotificationObj.AttributeTypes(),
			},
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"log_fail":           types.BoolType,
		"log_setting":        types.StringType,
		"log_success":        types.BoolType,
		"remote_user_tunnel": types.StringType,
		"remote_user_tunnel_configs": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: remoteUserTunnelConfigsObj.AttributeTypes(),
			},
		},
		"roles": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rolesObj.AttributeTypes(),
			},
		},
		"satellite_tunnel": types.StringType,
		"security_restrictions": types.ObjectType{
			AttrTypes: securityRestrictionsObj.AttributeTypes(),
		},
		"ssl_tls_service_profile": types.StringType,
		"tunnel_mode":             types.BoolType,
	}
}

func (o GlobalprotectGatewayResourceModel) AncestorName() string {
	return ""
}

func (o GlobalprotectGatewayResourceModel) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceClientAuthObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                   types.StringType,
		"os":                     types.StringType,
		"authentication_profile": types.StringType,
		"auto_retrieve_passcode": types.BoolType,
		"username_label":         types.StringType,
		"password_label":         types.StringType,
		"authentication_message": types.StringType,
		"user_credential_or_client_cert_required": types.StringType,
	}
}

func (o GlobalprotectGatewayResourceClientAuthObject) AncestorName() string {
	return "client-auth"
}

func (o GlobalprotectGatewayResourceClientAuthObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayResourceHipNotificationObject) AttributeTypes() map[string]attr.Type {

	var matchMessageObj *GlobalprotectGatewayResourceHipNotificationMatchMessageObject

	var notMatchMessageObj *GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject
	return map[string]attr.Type{
		"name": types.StringType,
		"match_message": types.ObjectType{
			AttrTypes: matchMessageObj.AttributeTypes(),
		},
		"not_match_message": types.ObjectType{
			AttrTypes: notMatchMessageObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayResourceHipNotificationObject) AncestorName() string {
	return "hip-notification"
}

func (o GlobalprotectGatewayResourceHipNotificationObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayResourceHipNotificationMatchMessageObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"include_app_list":     types.BoolType,
		"show_notification_as": types.StringType,
		"message":              types.StringType,
	}
}

func (o GlobalprotectGatewayResourceHipNotificationMatchMessageObject) AncestorName() string {
	return "match-message"
}

func (o GlobalprotectGatewayResourceHipNotificationMatchMessageObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"show_notification_as": types.StringType,
		"message":              types.StringType,
	}
}

func (o GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject) AncestorName() string {
	return "not-match-message"
}

func (o GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceLocalAddressObject) AttributeTypes() map[string]attr.Type {

	var floatingIpObj *GlobalprotectGatewayResourceLocalAddressFloatingIpObject

	var ipObj *GlobalprotectGatewayResourceLocalAddressIpObject
	return map[string]attr.Type{
		"interface":         types.StringType,
		"ip_address_family": types.StringType,
		"floating_ip": types.ObjectType{
			AttrTypes: floatingIpObj.AttributeTypes(),
		},
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayResourceLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o GlobalprotectGatewayResourceLocalAddressObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceLocalAddressFloatingIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectGatewayResourceLocalAddressFloatingIpObject) AncestorName() string {
	return "floating-ip"
}

func (o GlobalprotectGatewayResourceLocalAddressFloatingIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceLocalAddressIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o GlobalprotectGatewayResourceLocalAddressIpObject) AncestorName() string {
	return "ip"
}

func (o GlobalprotectGatewayResourceLocalAddressIpObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject) AttributeTypes() map[string]attr.Type {

	var authenticationOverrideObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject

	var sourceAddressObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject

	var splitTunnelingObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject

	return map[string]attr.Type{
		"name": types.StringType,
		"source_user": types.ListType{
			ElemType: types.StringType,
		},
		"os": types.ListType{
			ElemType: types.StringType,
		},
		"dns_server": types.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": types.ListType{
			ElemType: types.StringType,
		},
		"ip_pool": types.ListType{
			ElemType: types.StringType,
		},
		"authentication_server_ip_pool": types.ListType{
			ElemType: types.StringType,
		},
		"authentication_override": types.ObjectType{
			AttrTypes: authenticationOverrideObj.AttributeTypes(),
		},
		"source_address": types.ObjectType{
			AttrTypes: sourceAddressObj.AttributeTypes(),
		},
		"split_tunneling": types.ObjectType{
			AttrTypes: splitTunnelingObj.AttributeTypes(),
		},
		"no_direct_access_to_local_network": types.BoolType,
		"retrieve_framed_ip_address":        types.BoolType,
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject) AncestorName() string {
	return "remote-user-tunnel-configs"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject) AttributeTypes() map[string]attr.Type {

	var acceptCookieObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject
	return map[string]attr.Type{
		"generate_cookie":             types.BoolType,
		"cookie_encrypt_decrypt_cert": types.StringType,
		"accept_cookie": types.ObjectType{
			AttrTypes: acceptCookieObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject) AncestorName() string {
	return "authentication-override"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) AttributeTypes() map[string]attr.Type {

	var cookieLifetimeObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	return map[string]attr.Type{
		"cookie_lifetime": types.ObjectType{
			AttrTypes: cookieLifetimeObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) AncestorName() string {
	return "accept-cookie"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lifetime_in_days":    types.Int64Type,
		"lifetime_in_hours":   types.Int64Type,
		"lifetime_in_minutes": types.Int64Type,
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) AncestorName() string {
	return "cookie-lifetime"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"region": types.ListType{
			ElemType: types.StringType,
		},
		"ip_address": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject) AncestorName() string {
	return "source-address"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject) AttributeTypes() map[string]attr.Type {

	var includeDomainsObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject

	var excludeDomainsObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject
	return map[string]attr.Type{
		"access_route": types.ListType{
			ElemType: types.StringType,
		},
		"exclude_access_route": types.ListType{
			ElemType: types.StringType,
		},
		"include_applications": types.ListType{
			ElemType: types.StringType,
		},
		"exclude_applications": types.ListType{
			ElemType: types.StringType,
		},
		"include_domains": types.ObjectType{
			AttrTypes: includeDomainsObj.AttributeTypes(),
		},
		"exclude_domains": types.ObjectType{
			AttrTypes: excludeDomainsObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject) AncestorName() string {
	return "split-tunneling"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject
	return map[string]attr.Type{
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) AncestorName() string {
	return "include-domains"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"ports": types.ListType{
			ElemType: types.Int64Type,
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) AttributeTypes() map[string]attr.Type {

	var listObj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject
	return map[string]attr.Type{
		"list": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: listObj.AttributeTypes(),
			},
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) AncestorName() string {
	return "exclude-domains"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"ports": types.ListType{
			ElemType: types.Int64Type,
		},
	}
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) AncestorName() string {
	return "list"
}

func (o GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayResourceRolesObject) AttributeTypes() map[string]attr.Type {

	var loginLifetimeObj *GlobalprotectGatewayResourceRolesLoginLifetimeObject

	return map[string]attr.Type{
		"name": types.StringType,
		"login_lifetime": types.ObjectType{
			AttrTypes: loginLifetimeObj.AttributeTypes(),
		},
		"inactivity_logout":           types.Int64Type,
		"lifetime_notify_prior":       types.Int64Type,
		"lifetime_notify_message":     types.StringType,
		"inactivity_notify_prior":     types.Int64Type,
		"inactivity_notify_message":   types.StringType,
		"admin_logout_notify":         types.BoolType,
		"admin_logout_notify_message": types.StringType,
	}
}

func (o GlobalprotectGatewayResourceRolesObject) AncestorName() string {
	return "roles"
}

func (o GlobalprotectGatewayResourceRolesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *GlobalprotectGatewayResourceRolesLoginLifetimeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"minutes": types.Int64Type,
		"hours":   types.Int64Type,
		"days":    types.Int64Type,
	}
}

func (o GlobalprotectGatewayResourceRolesLoginLifetimeObject) AncestorName() string {
	return "login-lifetime"
}

func (o GlobalprotectGatewayResourceRolesLoginLifetimeObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsObject) AttributeTypes() map[string]attr.Type {

	var sourceIpEnforcementObj *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject
	return map[string]attr.Type{
		"disallow_automatic_restoration": types.BoolType,
		"source_ip_enforcement": types.ObjectType{
			AttrTypes: sourceIpEnforcementObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsObject) AncestorName() string {
	return "security-restrictions"
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject) AttributeTypes() map[string]attr.Type {

	var customObj *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject

	var defaultObj *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"custom": types.ObjectType{
			AttrTypes: customObj.AttributeTypes(),
		},
		"default": types.ObjectType{
			AttrTypes: defaultObj.AttributeTypes(),
		},
	}
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject) AncestorName() string {
	return "source-ip-enforcement"
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_ipv4_netmask": types.Int64Type,
		"source_ipv6_netmask": types.Int64Type,
	}
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject) AncestorName() string {
	return "custom"
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject) EntryName() *string {
	return nil
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject) AncestorName() string {
	return "default"
}

func (o GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject) EntryName() *string {
	return nil
}

func (o *GlobalprotectGatewayResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	blockQuarantinedDevices_value := o.BlockQuarantinedDevices.ValueBoolPointer()
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	var clientAuth_tf_entries []GlobalprotectGatewayResourceClientAuthObject
	var clientAuth_pango_entries []gateway.ClientAuth
	{
		d := o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range clientAuth_tf_entries {
			var entry *gateway.ClientAuth
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			clientAuth_pango_entries = append(clientAuth_pango_entries, *entry)
		}
	}
	var hipNotification_tf_entries []GlobalprotectGatewayResourceHipNotificationObject
	var hipNotification_pango_entries []gateway.HipNotification
	{
		d := o.HipNotification.ElementsAs(ctx, &hipNotification_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range hipNotification_tf_entries {
			var entry *gateway.HipNotification
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			hipNotification_pango_entries = append(hipNotification_pango_entries, *entry)
		}
	}
	var localAddress_entry *gateway.LocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(gateway.LocalAddress)
		}
		var object *GlobalprotectGatewayResourceLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	logFail_value := o.LogFail.ValueBoolPointer()
	logSetting_value := o.LogSetting.ValueStringPointer()
	logSuccess_value := o.LogSuccess.ValueBoolPointer()
	remoteUserTunnel_value := o.RemoteUserTunnel.ValueStringPointer()
	var remoteUserTunnelConfigs_tf_entries []GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject
	var remoteUserTunnelConfigs_pango_entries []gateway.RemoteUserTunnelConfigs
	{
		d := o.RemoteUserTunnelConfigs.ElementsAs(ctx, &remoteUserTunnelConfigs_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range remoteUserTunnelConfigs_tf_entries {
			var entry *gateway.RemoteUserTunnelConfigs
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			remoteUserTunnelConfigs_pango_entries = append(remoteUserTunnelConfigs_pango_entries, *entry)
		}
	}
	var roles_tf_entries []GlobalprotectGatewayResourceRolesObject
	var roles_pango_entries []gateway.Roles
	{
		d := o.Roles.ElementsAs(ctx, &roles_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range roles_tf_entries {
			var entry *gateway.Roles
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			roles_pango_entries = append(roles_pango_entries, *entry)
		}
	}
	satelliteTunnel_value := o.SatelliteTunnel.ValueStringPointer()
	var securityRestrictions_entry *gateway.SecurityRestrictions
	if !o.SecurityRestrictions.IsUnknown() && !o.SecurityRestrictions.IsNull() {
		if *obj != nil && (*obj).SecurityRestrictions != nil {
			securityRestrictions_entry = (*obj).SecurityRestrictions
		} else {
			securityRestrictions_entry = new(gateway.SecurityRestrictions)
		}
		var object *GlobalprotectGatewayResourceSecurityRestrictionsObject
		diags.Append(o.SecurityRestrictions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &securityRestrictions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	sslTlsServiceProfile_value := o.SslTlsServiceProfile.ValueStringPointer()
	tunnelMode_value := o.TunnelMode.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).BlockQuarantinedDevices = blockQuarantinedDevices_value
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).ClientAuth = clientAuth_pango_entries
	(*obj).HipNotification = hipNotification_pango_entries
	(*obj).LocalAddress = localAddress_entry
	(*obj).LogFail = logFail_value
	(*obj).LogSetting = logSetting_value
	(*obj).LogSuccess = logSuccess_value
	(*obj).RemoteUserTunnel = remoteUserTunnel_value
	(*obj).RemoteUserTunnelConfigs = remoteUserTunnelConfigs_pango_entries
	(*obj).Roles = roles_pango_entries
	(*obj).SatelliteTunnel = satelliteTunnel_value
	(*obj).SecurityRestrictions = securityRestrictions_entry
	(*obj).SslTlsServiceProfile = sslTlsServiceProfile_value
	(*obj).TunnelMode = tunnelMode_value

	return diags
}
func (o *GlobalprotectGatewayResourceClientAuthObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.ClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	os_value := o.Os.ValueStringPointer()
	authenticationProfile_value := o.AuthenticationProfile.ValueStringPointer()
	autoRetrievePasscode_value := o.AutoRetrievePasscode.ValueBoolPointer()
	usernameLabel_value := o.UsernameLabel.ValueStringPointer()
	passwordLabel_value := o.PasswordLabel.ValueStringPointer()
	authenticationMessage_value := o.AuthenticationMessage.ValueStringPointer()
	userCredentialOrClientCertRequired_value := o.UserCredentialOrClientCertRequired.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.ClientAuth)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Os = os_value
	(*obj).AuthenticationProfile = authenticationProfile_value
	(*obj).AutoRetrievePasscode = autoRetrievePasscode_value
	(*obj).UsernameLabel = usernameLabel_value
	(*obj).PasswordLabel = passwordLabel_value
	(*obj).AuthenticationMessage = authenticationMessage_value
	(*obj).UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}
func (o *GlobalprotectGatewayResourceHipNotificationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.HipNotification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var matchMessage_entry *gateway.HipNotificationMatchMessage
	if !o.MatchMessage.IsUnknown() && !o.MatchMessage.IsNull() {
		if *obj != nil && (*obj).MatchMessage != nil {
			matchMessage_entry = (*obj).MatchMessage
		} else {
			matchMessage_entry = new(gateway.HipNotificationMatchMessage)
		}
		var object *GlobalprotectGatewayResourceHipNotificationMatchMessageObject
		diags.Append(o.MatchMessage.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &matchMessage_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var notMatchMessage_entry *gateway.HipNotificationNotMatchMessage
	if !o.NotMatchMessage.IsUnknown() && !o.NotMatchMessage.IsNull() {
		if *obj != nil && (*obj).NotMatchMessage != nil {
			notMatchMessage_entry = (*obj).NotMatchMessage
		} else {
			notMatchMessage_entry = new(gateway.HipNotificationNotMatchMessage)
		}
		var object *GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject
		diags.Append(o.NotMatchMessage.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &notMatchMessage_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.HipNotification)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).MatchMessage = matchMessage_entry
	(*obj).NotMatchMessage = notMatchMessage_entry

	return diags
}
func (o *GlobalprotectGatewayResourceHipNotificationMatchMessageObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.HipNotificationMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	includeAppList_value := o.IncludeAppList.ValueBoolPointer()
	showNotificationAs_value := o.ShowNotificationAs.ValueStringPointer()
	message_value := o.Message.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.HipNotificationMatchMessage)
	}
	(*obj).IncludeAppList = includeAppList_value
	(*obj).ShowNotificationAs = showNotificationAs_value
	(*obj).Message = message_value

	return diags
}
func (o *GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.HipNotificationNotMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	showNotificationAs_value := o.ShowNotificationAs.ValueStringPointer()
	message_value := o.Message.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.HipNotificationNotMatchMessage)
	}
	(*obj).ShowNotificationAs = showNotificationAs_value
	(*obj).Message = message_value

	return diags
}
func (o *GlobalprotectGatewayResourceLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ipAddressFamily_value := o.IpAddressFamily.ValueStringPointer()
	var floatingIp_entry *gateway.LocalAddressFloatingIp
	if !o.FloatingIp.IsUnknown() && !o.FloatingIp.IsNull() {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(gateway.LocalAddressFloatingIp)
		}
		var object *GlobalprotectGatewayResourceLocalAddressFloatingIpObject
		diags.Append(o.FloatingIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &floatingIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *gateway.LocalAddressIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(gateway.LocalAddressIp)
		}
		var object *GlobalprotectGatewayResourceLocalAddressIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.LocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).IpAddressFamily = ipAddressFamily_value
	(*obj).FloatingIp = floatingIp_entry
	(*obj).Ip = ip_entry

	return diags
}
func (o *GlobalprotectGatewayResourceLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddressFloatingIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectGatewayResourceLocalAddressIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.LocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.LocalAddressIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_pango_entries []string
	if !o.SourceUser.IsUnknown() && !o.SourceUser.IsNull() {
		object_entries := make([]types.String, 0, len(o.SourceUser.Elements()))
		diags.Append(o.SourceUser.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			sourceUser_pango_entries = append(sourceUser_pango_entries, elt.ValueString())
		}
	}
	var os_pango_entries []string
	if !o.Os.IsUnknown() && !o.Os.IsNull() {
		object_entries := make([]types.String, 0, len(o.Os.Elements()))
		diags.Append(o.Os.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			os_pango_entries = append(os_pango_entries, elt.ValueString())
		}
	}
	var dnsServer_pango_entries []string
	if !o.DnsServer.IsUnknown() && !o.DnsServer.IsNull() {
		object_entries := make([]types.String, 0, len(o.DnsServer.Elements()))
		diags.Append(o.DnsServer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			dnsServer_pango_entries = append(dnsServer_pango_entries, elt.ValueString())
		}
	}
	var dnsSuffix_pango_entries []string
	if !o.DnsSuffix.IsUnknown() && !o.DnsSuffix.IsNull() {
		object_entries := make([]types.String, 0, len(o.DnsSuffix.Elements()))
		diags.Append(o.DnsSuffix.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			dnsSuffix_pango_entries = append(dnsSuffix_pango_entries, elt.ValueString())
		}
	}
	var ipPool_pango_entries []string
	if !o.IpPool.IsUnknown() && !o.IpPool.IsNull() {
		object_entries := make([]types.String, 0, len(o.IpPool.Elements()))
		diags.Append(o.IpPool.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ipPool_pango_entries = append(ipPool_pango_entries, elt.ValueString())
		}
	}
	var authenticationServerIpPool_pango_entries []string
	if !o.AuthenticationServerIpPool.IsUnknown() && !o.AuthenticationServerIpPool.IsNull() {
		object_entries := make([]types.String, 0, len(o.AuthenticationServerIpPool.Elements()))
		diags.Append(o.AuthenticationServerIpPool.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			authenticationServerIpPool_pango_entries = append(authenticationServerIpPool_pango_entries, elt.ValueString())
		}
	}
	var authenticationOverride_entry *gateway.RemoteUserTunnelConfigsAuthenticationOverride
	if !o.AuthenticationOverride.IsUnknown() && !o.AuthenticationOverride.IsNull() {
		if *obj != nil && (*obj).AuthenticationOverride != nil {
			authenticationOverride_entry = (*obj).AuthenticationOverride
		} else {
			authenticationOverride_entry = new(gateway.RemoteUserTunnelConfigsAuthenticationOverride)
		}
		var object *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject
		diags.Append(o.AuthenticationOverride.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authenticationOverride_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sourceAddress_entry *gateway.RemoteUserTunnelConfigsSourceAddress
	if !o.SourceAddress.IsUnknown() && !o.SourceAddress.IsNull() {
		if *obj != nil && (*obj).SourceAddress != nil {
			sourceAddress_entry = (*obj).SourceAddress
		} else {
			sourceAddress_entry = new(gateway.RemoteUserTunnelConfigsSourceAddress)
		}
		var object *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject
		diags.Append(o.SourceAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sourceAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var splitTunneling_entry *gateway.RemoteUserTunnelConfigsSplitTunneling
	if !o.SplitTunneling.IsUnknown() && !o.SplitTunneling.IsNull() {
		if *obj != nil && (*obj).SplitTunneling != nil {
			splitTunneling_entry = (*obj).SplitTunneling
		} else {
			splitTunneling_entry = new(gateway.RemoteUserTunnelConfigsSplitTunneling)
		}
		var object *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject
		diags.Append(o.SplitTunneling.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &splitTunneling_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	noDirectAccessToLocalNetwork_value := o.NoDirectAccessToLocalNetwork.ValueBoolPointer()
	retrieveFramedIpAddress_value := o.RetrieveFramedIpAddress.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigs)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SourceUser = sourceUser_pango_entries
	(*obj).Os = os_pango_entries
	(*obj).DnsServer = dnsServer_pango_entries
	(*obj).DnsSuffix = dnsSuffix_pango_entries
	(*obj).IpPool = ipPool_pango_entries
	(*obj).AuthenticationServerIpPool = authenticationServerIpPool_pango_entries
	(*obj).AuthenticationOverride = authenticationOverride_entry
	(*obj).SourceAddress = sourceAddress_entry
	(*obj).SplitTunneling = splitTunneling_entry
	(*obj).NoDirectAccessToLocalNetwork = noDirectAccessToLocalNetwork_value
	(*obj).RetrieveFramedIpAddress = retrieveFramedIpAddress_value

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	generateCookie_value := o.GenerateCookie.ValueBoolPointer()
	cookieEncryptDecryptCert_value := o.CookieEncryptDecryptCert.ValueStringPointer()
	var acceptCookie_entry *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie
	if !o.AcceptCookie.IsUnknown() && !o.AcceptCookie.IsNull() {
		if *obj != nil && (*obj).AcceptCookie != nil {
			acceptCookie_entry = (*obj).AcceptCookie
		} else {
			acceptCookie_entry = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie)
		}
		var object *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject
		diags.Append(o.AcceptCookie.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &acceptCookie_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsAuthenticationOverride)
	}
	(*obj).GenerateCookie = generateCookie_value
	(*obj).CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	(*obj).AcceptCookie = acceptCookie_entry

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var cookieLifetime_entry *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime
	if !o.CookieLifetime.IsUnknown() && !o.CookieLifetime.IsNull() {
		if *obj != nil && (*obj).CookieLifetime != nil {
			cookieLifetime_entry = (*obj).CookieLifetime
		} else {
			cookieLifetime_entry = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
		}
		var object *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
		diags.Append(o.CookieLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &cookieLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie)
	}
	(*obj).CookieLifetime = cookieLifetime_entry

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetimeInDays_value := o.LifetimeInDays.ValueInt64Pointer()
	lifetimeInHours_value := o.LifetimeInHours.ValueInt64Pointer()
	lifetimeInMinutes_value := o.LifetimeInMinutes.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime)
	}
	(*obj).LifetimeInDays = lifetimeInDays_value
	(*obj).LifetimeInHours = lifetimeInHours_value
	(*obj).LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSourceAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var region_pango_entries []string
	if !o.Region.IsUnknown() && !o.Region.IsNull() {
		object_entries := make([]types.String, 0, len(o.Region.Elements()))
		diags.Append(o.Region.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			region_pango_entries = append(region_pango_entries, elt.ValueString())
		}
	}
	var ipAddress_pango_entries []string
	if !o.IpAddress.IsUnknown() && !o.IpAddress.IsNull() {
		object_entries := make([]types.String, 0, len(o.IpAddress.Elements()))
		diags.Append(o.IpAddress.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ipAddress_pango_entries = append(ipAddress_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSourceAddress)
	}
	(*obj).Region = region_pango_entries
	(*obj).IpAddress = ipAddress_pango_entries

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunneling, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var accessRoute_pango_entries []string
	if !o.AccessRoute.IsUnknown() && !o.AccessRoute.IsNull() {
		object_entries := make([]types.String, 0, len(o.AccessRoute.Elements()))
		diags.Append(o.AccessRoute.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			accessRoute_pango_entries = append(accessRoute_pango_entries, elt.ValueString())
		}
	}
	var excludeAccessRoute_pango_entries []string
	if !o.ExcludeAccessRoute.IsUnknown() && !o.ExcludeAccessRoute.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExcludeAccessRoute.Elements()))
		diags.Append(o.ExcludeAccessRoute.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			excludeAccessRoute_pango_entries = append(excludeAccessRoute_pango_entries, elt.ValueString())
		}
	}
	var includeApplications_pango_entries []string
	if !o.IncludeApplications.IsUnknown() && !o.IncludeApplications.IsNull() {
		object_entries := make([]types.String, 0, len(o.IncludeApplications.Elements()))
		diags.Append(o.IncludeApplications.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			includeApplications_pango_entries = append(includeApplications_pango_entries, elt.ValueString())
		}
	}
	var excludeApplications_pango_entries []string
	if !o.ExcludeApplications.IsUnknown() && !o.ExcludeApplications.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExcludeApplications.Elements()))
		diags.Append(o.ExcludeApplications.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			excludeApplications_pango_entries = append(excludeApplications_pango_entries, elt.ValueString())
		}
	}
	var includeDomains_entry *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains
	if !o.IncludeDomains.IsUnknown() && !o.IncludeDomains.IsNull() {
		if *obj != nil && (*obj).IncludeDomains != nil {
			includeDomains_entry = (*obj).IncludeDomains
		} else {
			includeDomains_entry = new(gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains)
		}
		var object *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject
		diags.Append(o.IncludeDomains.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &includeDomains_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var excludeDomains_entry *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains
	if !o.ExcludeDomains.IsUnknown() && !o.ExcludeDomains.IsNull() {
		if *obj != nil && (*obj).ExcludeDomains != nil {
			excludeDomains_entry = (*obj).ExcludeDomains
		} else {
			excludeDomains_entry = new(gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains)
		}
		var object *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject
		diags.Append(o.ExcludeDomains.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &excludeDomains_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunneling)
	}
	(*obj).AccessRoute = accessRoute_pango_entries
	(*obj).ExcludeAccessRoute = excludeAccessRoute_pango_entries
	(*obj).IncludeApplications = includeApplications_pango_entries
	(*obj).ExcludeApplications = excludeApplications_pango_entries
	(*obj).IncludeDomains = includeDomains_entry
	(*obj).ExcludeDomains = excludeDomains_entry

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_tf_entries []GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject
	var list_pango_entries []gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains)
	}
	(*obj).List = list_pango_entries

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_pango_entries []int64
	if !o.Ports.IsUnknown() && !o.Ports.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.Ports.Elements()))
		diags.Append(o.Ports.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ports_pango_entries = append(ports_pango_entries, elt.ValueInt64())
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ports = ports_pango_entries

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_tf_entries []GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject
	var list_pango_entries []gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList
	{
		d := o.List.ElementsAs(ctx, &list_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range list_tf_entries {
			var entry *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			list_pango_entries = append(list_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains)
	}
	(*obj).List = list_pango_entries

	return diags
}
func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_pango_entries []int64
	if !o.Ports.IsUnknown() && !o.Ports.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.Ports.Elements()))
		diags.Append(o.Ports.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ports_pango_entries = append(ports_pango_entries, elt.ValueInt64())
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ports = ports_pango_entries

	return diags
}
func (o *GlobalprotectGatewayResourceRolesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.Roles, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var loginLifetime_entry *gateway.RolesLoginLifetime
	if !o.LoginLifetime.IsUnknown() && !o.LoginLifetime.IsNull() {
		if *obj != nil && (*obj).LoginLifetime != nil {
			loginLifetime_entry = (*obj).LoginLifetime
		} else {
			loginLifetime_entry = new(gateway.RolesLoginLifetime)
		}
		var object *GlobalprotectGatewayResourceRolesLoginLifetimeObject
		diags.Append(o.LoginLifetime.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &loginLifetime_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	inactivityLogout_value := o.InactivityLogout.ValueInt64Pointer()
	lifetimeNotifyPrior_value := o.LifetimeNotifyPrior.ValueInt64Pointer()
	lifetimeNotifyMessage_value := o.LifetimeNotifyMessage.ValueStringPointer()
	inactivityNotifyPrior_value := o.InactivityNotifyPrior.ValueInt64Pointer()
	inactivityNotifyMessage_value := o.InactivityNotifyMessage.ValueStringPointer()
	adminLogoutNotify_value := o.AdminLogoutNotify.ValueBoolPointer()
	adminLogoutNotifyMessage_value := o.AdminLogoutNotifyMessage.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(gateway.Roles)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).LoginLifetime = loginLifetime_entry
	(*obj).InactivityLogout = inactivityLogout_value
	(*obj).LifetimeNotifyPrior = lifetimeNotifyPrior_value
	(*obj).LifetimeNotifyMessage = lifetimeNotifyMessage_value
	(*obj).InactivityNotifyPrior = inactivityNotifyPrior_value
	(*obj).InactivityNotifyMessage = inactivityNotifyMessage_value
	(*obj).AdminLogoutNotify = adminLogoutNotify_value
	(*obj).AdminLogoutNotifyMessage = adminLogoutNotifyMessage_value

	return diags
}
func (o *GlobalprotectGatewayResourceRolesLoginLifetimeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.RolesLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	minutes_value := o.Minutes.ValueInt64Pointer()
	hours_value := o.Hours.ValueInt64Pointer()
	days_value := o.Days.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.RolesLoginLifetime)
	}
	(*obj).Minutes = minutes_value
	(*obj).Hours = hours_value
	(*obj).Days = days_value

	return diags
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	disallowAutomaticRestoration_value := o.DisallowAutomaticRestoration.ValueBoolPointer()
	var sourceIpEnforcement_entry *gateway.SecurityRestrictionsSourceIpEnforcement
	if !o.SourceIpEnforcement.IsUnknown() && !o.SourceIpEnforcement.IsNull() {
		if *obj != nil && (*obj).SourceIpEnforcement != nil {
			sourceIpEnforcement_entry = (*obj).SourceIpEnforcement
		} else {
			sourceIpEnforcement_entry = new(gateway.SecurityRestrictionsSourceIpEnforcement)
		}
		var object *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject
		diags.Append(o.SourceIpEnforcement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sourceIpEnforcement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictions)
	}
	(*obj).DisallowAutomaticRestoration = disallowAutomaticRestoration_value
	(*obj).SourceIpEnforcement = sourceIpEnforcement_entry

	return diags
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictionsSourceIpEnforcement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var custom_entry *gateway.SecurityRestrictionsSourceIpEnforcementCustom
	if !o.Custom.IsUnknown() && !o.Custom.IsNull() {
		if *obj != nil && (*obj).Custom != nil {
			custom_entry = (*obj).Custom
		} else {
			custom_entry = new(gateway.SecurityRestrictionsSourceIpEnforcementCustom)
		}
		var object *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject
		diags.Append(o.Custom.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &custom_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var default_entry *gateway.SecurityRestrictionsSourceIpEnforcementDefault
	if !o.Default.IsUnknown() && !o.Default.IsNull() {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(gateway.SecurityRestrictionsSourceIpEnforcementDefault)
		}
		var object *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject
		diags.Append(o.Default.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &default_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictionsSourceIpEnforcement)
	}
	(*obj).Enable = enable_value
	(*obj).Custom = custom_entry
	(*obj).Default = default_entry

	return diags
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictionsSourceIpEnforcementCustom, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceIpv4Netmask_value := o.SourceIpv4Netmask.ValueInt64Pointer()
	sourceIpv6Netmask_value := o.SourceIpv6Netmask.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictionsSourceIpEnforcementCustom)
	}
	(*obj).SourceIpv4Netmask = sourceIpv4Netmask_value
	(*obj).SourceIpv6Netmask = sourceIpv6Netmask_value

	return diags
}
func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **gateway.SecurityRestrictionsSourceIpEnforcementDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(gateway.SecurityRestrictionsSourceIpEnforcementDefault)
	}

	return diags
}

func (o *GlobalprotectGatewayResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var clientAuth_list types.List
	{
		var clientAuth_tf_entries []GlobalprotectGatewayResourceClientAuthObject
		if !o.ClientAuth.IsNull() {
			diags.Append(o.ClientAuth.ElementsAs(ctx, &clientAuth_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ClientAuth {
			entry := GlobalprotectGatewayResourceClientAuthObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(clientAuth_tf_entries) {
				entry = clientAuth_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(clientAuth_tf_entries) {
				clientAuth_tf_entries[idx] = entry
			} else {
				clientAuth_tf_entries = append(clientAuth_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("client_auth")
		clientAuth_list, list_diags = types.ListValueFrom(ctx, schemaType, clientAuth_tf_entries)
		diags.Append(list_diags...)
	}
	var hipNotification_list types.List
	{
		var hipNotification_tf_entries []GlobalprotectGatewayResourceHipNotificationObject
		if !o.HipNotification.IsNull() {
			diags.Append(o.HipNotification.ElementsAs(ctx, &hipNotification_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.HipNotification {
			entry := GlobalprotectGatewayResourceHipNotificationObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(hipNotification_tf_entries) {
				entry = hipNotification_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(hipNotification_tf_entries) {
				hipNotification_tf_entries[idx] = entry
			} else {
				hipNotification_tf_entries = append(hipNotification_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("hip_notification")
		hipNotification_list, list_diags = types.ListValueFrom(ctx, schemaType, hipNotification_tf_entries)
		diags.Append(list_diags...)
	}
	var remoteUserTunnelConfigs_list types.List
	{
		var remoteUserTunnelConfigs_tf_entries []GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject
		if !o.RemoteUserTunnelConfigs.IsNull() {
			diags.Append(o.RemoteUserTunnelConfigs.ElementsAs(ctx, &remoteUserTunnelConfigs_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RemoteUserTunnelConfigs {
			entry := GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(remoteUserTunnelConfigs_tf_entries) {
				entry = remoteUserTunnelConfigs_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(remoteUserTunnelConfigs_tf_entries) {
				remoteUserTunnelConfigs_tf_entries[idx] = entry
			} else {
				remoteUserTunnelConfigs_tf_entries = append(remoteUserTunnelConfigs_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("remote_user_tunnel_configs")
		remoteUserTunnelConfigs_list, list_diags = types.ListValueFrom(ctx, schemaType, remoteUserTunnelConfigs_tf_entries)
		diags.Append(list_diags...)
	}
	var roles_list types.List
	{
		var roles_tf_entries []GlobalprotectGatewayResourceRolesObject
		if !o.Roles.IsNull() {
			diags.Append(o.Roles.ElementsAs(ctx, &roles_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Roles {
			entry := GlobalprotectGatewayResourceRolesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(roles_tf_entries) {
				entry = roles_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(roles_tf_entries) {
				roles_tf_entries[idx] = entry
			} else {
				roles_tf_entries = append(roles_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("roles")
		roles_list, list_diags = types.ListValueFrom(ctx, schemaType, roles_tf_entries)
		diags.Append(list_diags...)
	}

	var localAddress_obj *GlobalprotectGatewayResourceLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(GlobalprotectGatewayResourceLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, ancestors, obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var securityRestrictions_obj *GlobalprotectGatewayResourceSecurityRestrictionsObject
	if o.SecurityRestrictions.IsNull() {
		securityRestrictions_obj = new(GlobalprotectGatewayResourceSecurityRestrictionsObject)
	} else {
		diags.Append(o.SecurityRestrictions.As(ctx, &securityRestrictions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	securityRestrictions_object := types.ObjectNull(securityRestrictions_obj.AttributeTypes())
	if obj.SecurityRestrictions != nil {
		diags.Append(securityRestrictions_obj.CopyFromPango(ctx, client, ancestors, obj.SecurityRestrictions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		securityRestrictions_object, diags_tmp = types.ObjectValueFrom(ctx, securityRestrictions_obj.AttributeTypes(), securityRestrictions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var blockQuarantinedDevices_value types.Bool
	if obj.BlockQuarantinedDevices != nil {
		blockQuarantinedDevices_value = types.BoolValue(*obj.BlockQuarantinedDevices)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var logFail_value types.Bool
	if obj.LogFail != nil {
		logFail_value = types.BoolValue(*obj.LogFail)
	}
	var logSetting_value types.String
	if obj.LogSetting != nil {
		logSetting_value = types.StringValue(*obj.LogSetting)
	}
	var logSuccess_value types.Bool
	if obj.LogSuccess != nil {
		logSuccess_value = types.BoolValue(*obj.LogSuccess)
	}
	var remoteUserTunnel_value types.String
	if obj.RemoteUserTunnel != nil {
		remoteUserTunnel_value = types.StringValue(*obj.RemoteUserTunnel)
	}
	var satelliteTunnel_value types.String
	if obj.SatelliteTunnel != nil {
		satelliteTunnel_value = types.StringValue(*obj.SatelliteTunnel)
	}
	var sslTlsServiceProfile_value types.String
	if obj.SslTlsServiceProfile != nil {
		sslTlsServiceProfile_value = types.StringValue(*obj.SslTlsServiceProfile)
	}
	var tunnelMode_value types.Bool
	if obj.TunnelMode != nil {
		tunnelMode_value = types.BoolValue(*obj.TunnelMode)
	}
	o.Name = types.StringValue(obj.Name)
	o.BlockQuarantinedDevices = blockQuarantinedDevices_value
	o.CertificateProfile = certificateProfile_value
	o.ClientAuth = clientAuth_list
	o.HipNotification = hipNotification_list
	o.LocalAddress = localAddress_object
	o.LogFail = logFail_value
	o.LogSetting = logSetting_value
	o.LogSuccess = logSuccess_value
	o.RemoteUserTunnel = remoteUserTunnel_value
	o.RemoteUserTunnelConfigs = remoteUserTunnelConfigs_list
	o.Roles = roles_list
	o.SatelliteTunnel = satelliteTunnel_value
	o.SecurityRestrictions = securityRestrictions_object
	o.SslTlsServiceProfile = sslTlsServiceProfile_value
	o.TunnelMode = tunnelMode_value

	return diags
}

func (o *GlobalprotectGatewayResourceClientAuthObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.ClientAuth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var os_value types.String
	if obj.Os != nil {
		os_value = types.StringValue(*obj.Os)
	}
	var authenticationProfile_value types.String
	if obj.AuthenticationProfile != nil {
		authenticationProfile_value = types.StringValue(*obj.AuthenticationProfile)
	}
	var autoRetrievePasscode_value types.Bool
	if obj.AutoRetrievePasscode != nil {
		autoRetrievePasscode_value = types.BoolValue(*obj.AutoRetrievePasscode)
	}
	var usernameLabel_value types.String
	if obj.UsernameLabel != nil {
		usernameLabel_value = types.StringValue(*obj.UsernameLabel)
	}
	var passwordLabel_value types.String
	if obj.PasswordLabel != nil {
		passwordLabel_value = types.StringValue(*obj.PasswordLabel)
	}
	var authenticationMessage_value types.String
	if obj.AuthenticationMessage != nil {
		authenticationMessage_value = types.StringValue(*obj.AuthenticationMessage)
	}
	var userCredentialOrClientCertRequired_value types.String
	if obj.UserCredentialOrClientCertRequired != nil {
		userCredentialOrClientCertRequired_value = types.StringValue(*obj.UserCredentialOrClientCertRequired)
	}
	o.Name = types.StringValue(obj.Name)
	o.Os = os_value
	o.AuthenticationProfile = authenticationProfile_value
	o.AutoRetrievePasscode = autoRetrievePasscode_value
	o.UsernameLabel = usernameLabel_value
	o.PasswordLabel = passwordLabel_value
	o.AuthenticationMessage = authenticationMessage_value
	o.UserCredentialOrClientCertRequired = userCredentialOrClientCertRequired_value

	return diags
}

func (o *GlobalprotectGatewayResourceHipNotificationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.HipNotification, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var matchMessage_obj *GlobalprotectGatewayResourceHipNotificationMatchMessageObject
	if o.MatchMessage.IsNull() {
		matchMessage_obj = new(GlobalprotectGatewayResourceHipNotificationMatchMessageObject)
	} else {
		diags.Append(o.MatchMessage.As(ctx, &matchMessage_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	matchMessage_object := types.ObjectNull(matchMessage_obj.AttributeTypes())
	if obj.MatchMessage != nil {
		diags.Append(matchMessage_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MatchMessage, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		matchMessage_object, diags_tmp = types.ObjectValueFrom(ctx, matchMessage_obj.AttributeTypes(), matchMessage_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var notMatchMessage_obj *GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject
	if o.NotMatchMessage.IsNull() {
		notMatchMessage_obj = new(GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject)
	} else {
		diags.Append(o.NotMatchMessage.As(ctx, &notMatchMessage_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	notMatchMessage_object := types.ObjectNull(notMatchMessage_obj.AttributeTypes())
	if obj.NotMatchMessage != nil {
		diags.Append(notMatchMessage_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NotMatchMessage, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		notMatchMessage_object, diags_tmp = types.ObjectValueFrom(ctx, notMatchMessage_obj.AttributeTypes(), notMatchMessage_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.MatchMessage = matchMessage_object
	o.NotMatchMessage = notMatchMessage_object

	return diags
}

func (o *GlobalprotectGatewayResourceHipNotificationMatchMessageObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.HipNotificationMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var includeAppList_value types.Bool
	if obj.IncludeAppList != nil {
		includeAppList_value = types.BoolValue(*obj.IncludeAppList)
	}
	var showNotificationAs_value types.String
	if obj.ShowNotificationAs != nil {
		showNotificationAs_value = types.StringValue(*obj.ShowNotificationAs)
	}
	var message_value types.String
	if obj.Message != nil {
		message_value = types.StringValue(*obj.Message)
	}
	o.IncludeAppList = includeAppList_value
	o.ShowNotificationAs = showNotificationAs_value
	o.Message = message_value

	return diags
}

func (o *GlobalprotectGatewayResourceHipNotificationNotMatchMessageObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.HipNotificationNotMatchMessage, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var showNotificationAs_value types.String
	if obj.ShowNotificationAs != nil {
		showNotificationAs_value = types.StringValue(*obj.ShowNotificationAs)
	}
	var message_value types.String
	if obj.Message != nil {
		message_value = types.StringValue(*obj.Message)
	}
	o.ShowNotificationAs = showNotificationAs_value
	o.Message = message_value

	return diags
}

func (o *GlobalprotectGatewayResourceLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var floatingIp_obj *GlobalprotectGatewayResourceLocalAddressFloatingIpObject
	if o.FloatingIp.IsNull() {
		floatingIp_obj = new(GlobalprotectGatewayResourceLocalAddressFloatingIpObject)
	} else {
		diags.Append(o.FloatingIp.As(ctx, &floatingIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	floatingIp_object := types.ObjectNull(floatingIp_obj.AttributeTypes())
	if obj.FloatingIp != nil {
		diags.Append(floatingIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FloatingIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		floatingIp_object, diags_tmp = types.ObjectValueFrom(ctx, floatingIp_obj.AttributeTypes(), floatingIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *GlobalprotectGatewayResourceLocalAddressIpObject
	if o.Ip.IsNull() {
		ip_obj = new(GlobalprotectGatewayResourceLocalAddressIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ipAddressFamily_value types.String
	if obj.IpAddressFamily != nil {
		ipAddressFamily_value = types.StringValue(*obj.IpAddressFamily)
	}
	o.Interface = interface_value
	o.IpAddressFamily = ipAddressFamily_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *GlobalprotectGatewayResourceLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectGatewayResourceLocalAddressIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.LocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigs, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceUser_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SourceUser.IsNull() || len(obj.SourceUser) > 0 {
			entries = obj.SourceUser
		}

		sourceUser_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var os_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Os.IsNull() || len(obj.Os) > 0 {
			entries = obj.Os
		}

		os_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsServer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DnsServer.IsNull() || len(obj.DnsServer) > 0 {
			entries = obj.DnsServer
		}

		dnsServer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DnsSuffix.IsNull() || len(obj.DnsSuffix) > 0 {
			entries = obj.DnsSuffix
		}

		dnsSuffix_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ipPool_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.IpPool.IsNull() || len(obj.IpPool) > 0 {
			entries = obj.IpPool
		}

		ipPool_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var authenticationServerIpPool_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.AuthenticationServerIpPool.IsNull() || len(obj.AuthenticationServerIpPool) > 0 {
			entries = obj.AuthenticationServerIpPool
		}

		authenticationServerIpPool_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var authenticationOverride_obj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject
	if o.AuthenticationOverride.IsNull() {
		authenticationOverride_obj = new(GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject)
	} else {
		diags.Append(o.AuthenticationOverride.As(ctx, &authenticationOverride_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authenticationOverride_object := types.ObjectNull(authenticationOverride_obj.AttributeTypes())
	if obj.AuthenticationOverride != nil {
		diags.Append(authenticationOverride_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AuthenticationOverride, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authenticationOverride_object, diags_tmp = types.ObjectValueFrom(ctx, authenticationOverride_obj.AttributeTypes(), authenticationOverride_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sourceAddress_obj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject
	if o.SourceAddress.IsNull() {
		sourceAddress_obj = new(GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject)
	} else {
		diags.Append(o.SourceAddress.As(ctx, &sourceAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sourceAddress_object := types.ObjectNull(sourceAddress_obj.AttributeTypes())
	if obj.SourceAddress != nil {
		diags.Append(sourceAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SourceAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sourceAddress_object, diags_tmp = types.ObjectValueFrom(ctx, sourceAddress_obj.AttributeTypes(), sourceAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var splitTunneling_obj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject
	if o.SplitTunneling.IsNull() {
		splitTunneling_obj = new(GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject)
	} else {
		diags.Append(o.SplitTunneling.As(ctx, &splitTunneling_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	splitTunneling_object := types.ObjectNull(splitTunneling_obj.AttributeTypes())
	if obj.SplitTunneling != nil {
		diags.Append(splitTunneling_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SplitTunneling, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		splitTunneling_object, diags_tmp = types.ObjectValueFrom(ctx, splitTunneling_obj.AttributeTypes(), splitTunneling_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noDirectAccessToLocalNetwork_value types.Bool
	if obj.NoDirectAccessToLocalNetwork != nil {
		noDirectAccessToLocalNetwork_value = types.BoolValue(*obj.NoDirectAccessToLocalNetwork)
	}
	var retrieveFramedIpAddress_value types.Bool
	if obj.RetrieveFramedIpAddress != nil {
		retrieveFramedIpAddress_value = types.BoolValue(*obj.RetrieveFramedIpAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.SourceUser = sourceUser_list
	o.Os = os_list
	o.DnsServer = dnsServer_list
	o.DnsSuffix = dnsSuffix_list
	o.IpPool = ipPool_list
	o.AuthenticationServerIpPool = authenticationServerIpPool_list
	o.AuthenticationOverride = authenticationOverride_object
	o.SourceAddress = sourceAddress_object
	o.SplitTunneling = splitTunneling_object
	o.NoDirectAccessToLocalNetwork = noDirectAccessToLocalNetwork_value
	o.RetrieveFramedIpAddress = retrieveFramedIpAddress_value

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsAuthenticationOverride, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var acceptCookie_obj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject
	if o.AcceptCookie.IsNull() {
		acceptCookie_obj = new(GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject)
	} else {
		diags.Append(o.AcceptCookie.As(ctx, &acceptCookie_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	acceptCookie_object := types.ObjectNull(acceptCookie_obj.AttributeTypes())
	if obj.AcceptCookie != nil {
		diags.Append(acceptCookie_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AcceptCookie, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		acceptCookie_object, diags_tmp = types.ObjectValueFrom(ctx, acceptCookie_obj.AttributeTypes(), acceptCookie_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var generateCookie_value types.Bool
	if obj.GenerateCookie != nil {
		generateCookie_value = types.BoolValue(*obj.GenerateCookie)
	}
	var cookieEncryptDecryptCert_value types.String
	if obj.CookieEncryptDecryptCert != nil {
		cookieEncryptDecryptCert_value = types.StringValue(*obj.CookieEncryptDecryptCert)
	}
	o.GenerateCookie = generateCookie_value
	o.CookieEncryptDecryptCert = cookieEncryptDecryptCert_value
	o.AcceptCookie = acceptCookie_object

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookie, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var cookieLifetime_obj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject
	if o.CookieLifetime.IsNull() {
		cookieLifetime_obj = new(GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject)
	} else {
		diags.Append(o.CookieLifetime.As(ctx, &cookieLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	cookieLifetime_object := types.ObjectNull(cookieLifetime_obj.AttributeTypes())
	if obj.CookieLifetime != nil {
		diags.Append(cookieLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CookieLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		cookieLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, cookieLifetime_obj.AttributeTypes(), cookieLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.CookieLifetime = cookieLifetime_object

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsAuthenticationOverrideAcceptCookieCookieLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetimeInDays_value types.Int64
	if obj.LifetimeInDays != nil {
		lifetimeInDays_value = types.Int64Value(*obj.LifetimeInDays)
	}
	var lifetimeInHours_value types.Int64
	if obj.LifetimeInHours != nil {
		lifetimeInHours_value = types.Int64Value(*obj.LifetimeInHours)
	}
	var lifetimeInMinutes_value types.Int64
	if obj.LifetimeInMinutes != nil {
		lifetimeInMinutes_value = types.Int64Value(*obj.LifetimeInMinutes)
	}
	o.LifetimeInDays = lifetimeInDays_value
	o.LifetimeInHours = lifetimeInHours_value
	o.LifetimeInMinutes = lifetimeInMinutes_value

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSourceAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSourceAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var region_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Region.IsNull() || len(obj.Region) > 0 {
			entries = obj.Region
		}

		region_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ipAddress_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.IpAddress.IsNull() || len(obj.IpAddress) > 0 {
			entries = obj.IpAddress
		}

		ipAddress_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Region = region_list
	o.IpAddress = ipAddress_list

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunneling, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var accessRoute_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.AccessRoute.IsNull() || len(obj.AccessRoute) > 0 {
			entries = obj.AccessRoute
		}

		accessRoute_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var excludeAccessRoute_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExcludeAccessRoute.IsNull() || len(obj.ExcludeAccessRoute) > 0 {
			entries = obj.ExcludeAccessRoute
		}

		excludeAccessRoute_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var includeApplications_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.IncludeApplications.IsNull() || len(obj.IncludeApplications) > 0 {
			entries = obj.IncludeApplications
		}

		includeApplications_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var excludeApplications_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExcludeApplications.IsNull() || len(obj.ExcludeApplications) > 0 {
			entries = obj.ExcludeApplications
		}

		excludeApplications_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var includeDomains_obj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject
	if o.IncludeDomains.IsNull() {
		includeDomains_obj = new(GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject)
	} else {
		diags.Append(o.IncludeDomains.As(ctx, &includeDomains_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	includeDomains_object := types.ObjectNull(includeDomains_obj.AttributeTypes())
	if obj.IncludeDomains != nil {
		diags.Append(includeDomains_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IncludeDomains, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		includeDomains_object, diags_tmp = types.ObjectValueFrom(ctx, includeDomains_obj.AttributeTypes(), includeDomains_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var excludeDomains_obj *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject
	if o.ExcludeDomains.IsNull() {
		excludeDomains_obj = new(GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject)
	} else {
		diags.Append(o.ExcludeDomains.As(ctx, &excludeDomains_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	excludeDomains_object := types.ObjectNull(excludeDomains_obj.AttributeTypes())
	if obj.ExcludeDomains != nil {
		diags.Append(excludeDomains_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExcludeDomains, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		excludeDomains_object, diags_tmp = types.ObjectValueFrom(ctx, excludeDomains_obj.AttributeTypes(), excludeDomains_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.AccessRoute = accessRoute_list
	o.ExcludeAccessRoute = excludeAccessRoute_list
	o.IncludeApplications = includeApplications_list
	o.ExcludeApplications = excludeApplications_list
	o.IncludeDomains = includeDomains_object
	o.ExcludeDomains = excludeDomains_object

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}

	o.List = list_list

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingIncludeDomainsListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingIncludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.Ports.IsNull() || len(obj.Ports) > 0 {
			entries = obj.Ports
		}

		ports_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Ports = ports_list

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomains, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var list_list types.List
	{
		var list_tf_entries []GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject
		if !o.List.IsNull() {
			diags.Append(o.List.ElementsAs(ctx, &list_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.List {
			entry := GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(list_tf_entries) {
				entry = list_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(list_tf_entries) {
				list_tf_entries[idx] = entry
			} else {
				list_tf_entries = append(list_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("list")
		list_list, list_diags = types.ListValueFrom(ctx, schemaType, list_tf_entries)
		diags.Append(list_diags...)
	}

	o.List = list_list

	return diags
}

func (o *GlobalprotectGatewayResourceRemoteUserTunnelConfigsSplitTunnelingExcludeDomainsListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RemoteUserTunnelConfigsSplitTunnelingExcludeDomainsList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ports_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.Ports.IsNull() || len(obj.Ports) > 0 {
			entries = obj.Ports
		}

		ports_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Ports = ports_list

	return diags
}

func (o *GlobalprotectGatewayResourceRolesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.Roles, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var loginLifetime_obj *GlobalprotectGatewayResourceRolesLoginLifetimeObject
	if o.LoginLifetime.IsNull() {
		loginLifetime_obj = new(GlobalprotectGatewayResourceRolesLoginLifetimeObject)
	} else {
		diags.Append(o.LoginLifetime.As(ctx, &loginLifetime_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	loginLifetime_object := types.ObjectNull(loginLifetime_obj.AttributeTypes())
	if obj.LoginLifetime != nil {
		diags.Append(loginLifetime_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LoginLifetime, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		loginLifetime_object, diags_tmp = types.ObjectValueFrom(ctx, loginLifetime_obj.AttributeTypes(), loginLifetime_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var inactivityLogout_value types.Int64
	if obj.InactivityLogout != nil {
		inactivityLogout_value = types.Int64Value(*obj.InactivityLogout)
	}
	var lifetimeNotifyPrior_value types.Int64
	if obj.LifetimeNotifyPrior != nil {
		lifetimeNotifyPrior_value = types.Int64Value(*obj.LifetimeNotifyPrior)
	}
	var lifetimeNotifyMessage_value types.String
	if obj.LifetimeNotifyMessage != nil {
		lifetimeNotifyMessage_value = types.StringValue(*obj.LifetimeNotifyMessage)
	}
	var inactivityNotifyPrior_value types.Int64
	if obj.InactivityNotifyPrior != nil {
		inactivityNotifyPrior_value = types.Int64Value(*obj.InactivityNotifyPrior)
	}
	var inactivityNotifyMessage_value types.String
	if obj.InactivityNotifyMessage != nil {
		inactivityNotifyMessage_value = types.StringValue(*obj.InactivityNotifyMessage)
	}
	var adminLogoutNotify_value types.Bool
	if obj.AdminLogoutNotify != nil {
		adminLogoutNotify_value = types.BoolValue(*obj.AdminLogoutNotify)
	}
	var adminLogoutNotifyMessage_value types.String
	if obj.AdminLogoutNotifyMessage != nil {
		adminLogoutNotifyMessage_value = types.StringValue(*obj.AdminLogoutNotifyMessage)
	}
	o.Name = types.StringValue(obj.Name)
	o.LoginLifetime = loginLifetime_object
	o.InactivityLogout = inactivityLogout_value
	o.LifetimeNotifyPrior = lifetimeNotifyPrior_value
	o.LifetimeNotifyMessage = lifetimeNotifyMessage_value
	o.InactivityNotifyPrior = inactivityNotifyPrior_value
	o.InactivityNotifyMessage = inactivityNotifyMessage_value
	o.AdminLogoutNotify = adminLogoutNotify_value
	o.AdminLogoutNotifyMessage = adminLogoutNotifyMessage_value

	return diags
}

func (o *GlobalprotectGatewayResourceRolesLoginLifetimeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.RolesLoginLifetime, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var minutes_value types.Int64
	if obj.Minutes != nil {
		minutes_value = types.Int64Value(*obj.Minutes)
	}
	var hours_value types.Int64
	if obj.Hours != nil {
		hours_value = types.Int64Value(*obj.Hours)
	}
	var days_value types.Int64
	if obj.Days != nil {
		days_value = types.Int64Value(*obj.Days)
	}
	o.Minutes = minutes_value
	o.Hours = hours_value
	o.Days = days_value

	return diags
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceIpEnforcement_obj *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject
	if o.SourceIpEnforcement.IsNull() {
		sourceIpEnforcement_obj = new(GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject)
	} else {
		diags.Append(o.SourceIpEnforcement.As(ctx, &sourceIpEnforcement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sourceIpEnforcement_object := types.ObjectNull(sourceIpEnforcement_obj.AttributeTypes())
	if obj.SourceIpEnforcement != nil {
		diags.Append(sourceIpEnforcement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SourceIpEnforcement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sourceIpEnforcement_object, diags_tmp = types.ObjectValueFrom(ctx, sourceIpEnforcement_obj.AttributeTypes(), sourceIpEnforcement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var disallowAutomaticRestoration_value types.Bool
	if obj.DisallowAutomaticRestoration != nil {
		disallowAutomaticRestoration_value = types.BoolValue(*obj.DisallowAutomaticRestoration)
	}
	o.DisallowAutomaticRestoration = disallowAutomaticRestoration_value
	o.SourceIpEnforcement = sourceIpEnforcement_object

	return diags
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictionsSourceIpEnforcement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var custom_obj *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject
	if o.Custom.IsNull() {
		custom_obj = new(GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject)
	} else {
		diags.Append(o.Custom.As(ctx, &custom_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	custom_object := types.ObjectNull(custom_obj.AttributeTypes())
	if obj.Custom != nil {
		diags.Append(custom_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Custom, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		custom_object, diags_tmp = types.ObjectValueFrom(ctx, custom_obj.AttributeTypes(), custom_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var default_obj *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject
	if o.Default.IsNull() {
		default_obj = new(GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject)
	} else {
		diags.Append(o.Default.As(ctx, &default_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	default_object := types.ObjectNull(default_obj.AttributeTypes())
	if obj.Default != nil {
		diags.Append(default_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Default, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		default_object, diags_tmp = types.ObjectValueFrom(ctx, default_obj.AttributeTypes(), default_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Custom = custom_object
	o.Default = default_object

	return diags
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementCustomObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictionsSourceIpEnforcementCustom, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceIpv4Netmask_value types.Int64
	if obj.SourceIpv4Netmask != nil {
		sourceIpv4Netmask_value = types.Int64Value(*obj.SourceIpv4Netmask)
	}
	var sourceIpv6Netmask_value types.Int64
	if obj.SourceIpv6Netmask != nil {
		sourceIpv6Netmask_value = types.Int64Value(*obj.SourceIpv6Netmask)
	}
	o.SourceIpv4Netmask = sourceIpv4Netmask_value
	o.SourceIpv6Netmask = sourceIpv6Netmask_value

	return diags
}

func (o *GlobalprotectGatewayResourceSecurityRestrictionsSourceIpEnforcementDefaultObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *gateway.SecurityRestrictionsSourceIpEnforcementDefault, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *GlobalprotectGatewayResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *GlobalprotectGatewayResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state GlobalprotectGatewayResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_globalprotect_gateway_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location gateway.Location

	{
		var terraformLocation GlobalprotectGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation GlobalprotectGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &gateway.TemplateVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &gateway.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &gateway.VsysLocation{}
			var innerLocation GlobalprotectGatewayVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *gateway.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *GlobalprotectGatewayResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state GlobalprotectGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location gateway.Location

	{
		var terraformLocation GlobalprotectGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation GlobalprotectGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &gateway.TemplateVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &gateway.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &gateway.VsysLocation{}
			var innerLocation GlobalprotectGatewayVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_globalprotect_gateway_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *GlobalprotectGatewayResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state GlobalprotectGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location gateway.Location

	{
		var terraformLocation GlobalprotectGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation GlobalprotectGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &gateway.TemplateVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &gateway.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &gateway.VsysLocation{}
			var innerLocation GlobalprotectGatewayVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_globalprotect_gateway_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := o.manager.Read(ctx, location, components, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := o.manager.Update(ctx, location, components, obj, obj.Name)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *GlobalprotectGatewayResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state GlobalprotectGatewayResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_globalprotect_gateway_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location gateway.Location

	{
		var terraformLocation GlobalprotectGatewayLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &gateway.TemplateLocation{}
			var innerLocation GlobalprotectGatewayTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateVsys.IsNull() {
			location.TemplateVsys = &gateway.TemplateVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateVsys.Template = innerLocation.Template.ValueString()
			location.TemplateVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &gateway.TemplateStackLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStackVsys.IsNull() {
			location.TemplateStackVsys = &gateway.TemplateStackVsysLocation{}
			var innerLocation GlobalprotectGatewayTemplateStackVsysLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStackVsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStackVsys.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStackVsys.TemplateStack = innerLocation.TemplateStack.ValueString()
			location.TemplateStackVsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.TemplateStackVsys.Vsys = innerLocation.Vsys.ValueString()
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &gateway.VsysLocation{}
			var innerLocation GlobalprotectGatewayVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type GlobalprotectGatewayImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o GlobalprotectGatewayImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *GlobalprotectGatewayLocation `json:"location"`
		Name     *string                       `json:"name"`
	}
	var location_object *GlobalprotectGatewayLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectGatewayImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *GlobalprotectGatewayLocation `json:"location"`
		Name     *string                       `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func GlobalprotectGatewayImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := GlobalprotectGatewayImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *GlobalprotectGatewayResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj GlobalprotectGatewayImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type GlobalprotectGatewayTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type GlobalprotectGatewayTemplateVsysLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Template       types.String `tfsdk:"template"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
	Vsys           types.String `tfsdk:"vsys"`
}
type GlobalprotectGatewayTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type GlobalprotectGatewayTemplateStackVsysLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	TemplateStack  types.String `tfsdk:"template_stack"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
	Vsys           types.String `tfsdk:"vsys"`
}
type GlobalprotectGatewayVsysLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
	Name       types.String `tfsdk:"name"`
}
type GlobalprotectGatewayLocation struct {
	Template          types.Object `tfsdk:"template"`
	TemplateVsys      types.Object `tfsdk:"template_vsys"`
	TemplateStack     types.Object `tfsdk:"template_stack"`
	TemplateStackVsys types.Object `tfsdk:"template_stack_vsys"`
	Vsys              types.Object `tfsdk:"vsys"`
}

func GlobalprotectGatewayLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_vsys"),
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("template_stack_vsys"),
						path.MatchRelative().AtParent().AtName("vsys"),
					}...),
				},
			},
			"template_vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template, device and vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"template": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"vsys": rsschema.StringAttribute{
						Description: "The vsys.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack_vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template, device and vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"template_stack": rsschema.StringAttribute{
						Description: "The template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"vsys": rsschema.StringAttribute{
						Description: "The vsys.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Virtual System",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The Virtual System name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o GlobalprotectGatewayTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectGatewayTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o GlobalprotectGatewayTemplateVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Template       *string `json:"template,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Template:       o.Template.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		Vsys:           o.Vsys.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectGatewayTemplateVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Template       *string `json:"template,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Template = types.StringPointerValue(shadow.Template)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Vsys = types.StringPointerValue(shadow.Vsys)

	return nil
}
func (o GlobalprotectGatewayTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectGatewayTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o GlobalprotectGatewayTemplateStackVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		TemplateStack  *string `json:"template_stack,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		TemplateStack:  o.TemplateStack.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		Vsys:           o.Vsys.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectGatewayTemplateStackVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		TemplateStack  *string `json:"template_stack,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `json:"vsys,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.TemplateStack = types.StringPointerValue(shadow.TemplateStack)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Vsys = types.StringPointerValue(shadow.Vsys)

	return nil
}
func (o GlobalprotectGatewayVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
		Name:       o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectGatewayVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o GlobalprotectGatewayLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Template          *GlobalprotectGatewayTemplateLocation          `json:"template,omitempty"`
		TemplateVsys      *GlobalprotectGatewayTemplateVsysLocation      `json:"template_vsys,omitempty"`
		TemplateStack     *GlobalprotectGatewayTemplateStackLocation     `json:"template_stack,omitempty"`
		TemplateStackVsys *GlobalprotectGatewayTemplateStackVsysLocation `json:"template_stack_vsys,omitempty"`
		Vsys              *GlobalprotectGatewayVsysLocation              `json:"vsys,omitempty"`
	}
	var template_object *GlobalprotectGatewayTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateVsys_object *GlobalprotectGatewayTemplateVsysLocation
	{
		diags := o.TemplateVsys.As(context.TODO(), &templateVsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_vsys into JSON document", diags.Errors())
		}
	}
	var templateStack_object *GlobalprotectGatewayTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}
	var templateStackVsys_object *GlobalprotectGatewayTemplateStackVsysLocation
	{
		diags := o.TemplateStackVsys.As(context.TODO(), &templateStackVsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack_vsys into JSON document", diags.Errors())
		}
	}
	var vsys_object *GlobalprotectGatewayVsysLocation
	{
		diags := o.Vsys.As(context.TODO(), &vsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal vsys into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Template:          template_object,
		TemplateVsys:      templateVsys_object,
		TemplateStack:     templateStack_object,
		TemplateStackVsys: templateStackVsys_object,
		Vsys:              vsys_object,
	}

	return json.Marshal(obj)
}

func (o *GlobalprotectGatewayLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Template          *GlobalprotectGatewayTemplateLocation          `json:"template,omitempty"`
		TemplateVsys      *GlobalprotectGatewayTemplateVsysLocation      `json:"template_vsys,omitempty"`
		TemplateStack     *GlobalprotectGatewayTemplateStackLocation     `json:"template_stack,omitempty"`
		TemplateStackVsys *GlobalprotectGatewayTemplateStackVsysLocation `json:"template_stack_vsys,omitempty"`
		Vsys              *GlobalprotectGatewayVsysLocation              `json:"vsys,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateVsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateVsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateVsys.AttributeTypes(), shadow.TemplateVsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_vsys", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	var templateStackVsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStackVsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStackVsys.AttributeTypes(), shadow.TemplateStackVsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack_vsys", diags_tmp.Errors())
		}
	}
	var vsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		vsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Vsys.AttributeTypes(), shadow.Vsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into vsys", diags_tmp.Errors())
		}
	}
	o.Template = template_object
	o.TemplateVsys = templateVsys_object
	o.TemplateStack = templateStack_object
	o.TemplateStackVsys = templateStackVsys_object
	o.Vsys = vsys_object

	return nil
}

func (o *GlobalprotectGatewayTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *GlobalprotectGatewayTemplateVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"template":        types.StringType,
		"ngfw_device":     types.StringType,
		"vsys":            types.StringType,
	}
}
func (o *GlobalprotectGatewayTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *GlobalprotectGatewayTemplateStackVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"template_stack":  types.StringType,
		"ngfw_device":     types.StringType,
		"vsys":            types.StringType,
	}
}
func (o *GlobalprotectGatewayVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
		"name":        types.StringType,
	}
}
func (o *GlobalprotectGatewayLocation) AttributeTypes() map[string]attr.Type {
	var templateObj GlobalprotectGatewayTemplateLocation
	var templateVsysObj GlobalprotectGatewayTemplateVsysLocation
	var templateStackObj GlobalprotectGatewayTemplateStackLocation
	var templateStackVsysObj GlobalprotectGatewayTemplateStackVsysLocation
	var vsysObj GlobalprotectGatewayVsysLocation
	return map[string]attr.Type{
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_vsys": types.ObjectType{
			AttrTypes: templateVsysObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
		"template_stack_vsys": types.ObjectType{
			AttrTypes: templateStackVsysObj.AttributeTypes(),
		},
		"vsys": types.ObjectType{
			AttrTypes: vsysObj.AttributeTypes(),
		},
	}
}
