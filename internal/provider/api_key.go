package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"fmt"

	"github.com/PaloAltoNetworks/pango"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	ephschema "github.com/hashicorp/terraform-plugin-framework/ephemeral/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

import (
	"github.com/hashicorp/terraform-plugin-framework/ephemeral"
)

// Generate Terraform Ephemeral object
var (
	_ ephemeral.EphemeralResource              = &ApiKeyResource{}
	_ ephemeral.EphemeralResourceWithConfigure = &ApiKeyResource{}
)

func NewApiKeyResource() ephemeral.EphemeralResource {
	return &ApiKeyResource{}
}

type ApiKeyResource struct {
	client *pango.Client
}

type ApiKeyResourceModel struct {
	Username types.String `tfsdk:"username"`
	Password types.String `tfsdk:"password"`
	ApiKey   types.String `tfsdk:"api_key"`
}

func (r *ApiKeyResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func ApiKeyResourceSchema() ephschema.Schema {
	return ephschema.Schema{
		Attributes: map[string]ephschema.Attribute{

			"username": ephschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": ephschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   true,
			},

			"api_key": ephschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},
		},
	}
}

func (o *ApiKeyResourceModel) getTypeFor(name string) attr.Type {
	schema := ApiKeyResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case ephschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case ephschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *ApiKeyResource) Metadata(ctx context.Context, req ephemeral.MetadataRequest, resp *ephemeral.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_api_key"
}

func (r *ApiKeyResource) Schema(_ context.Context, _ ephemeral.SchemaRequest, resp *ephemeral.SchemaResponse) {
	resp.Schema = ApiKeyResourceSchema()
}

// </ResourceSchema>

func (r *ApiKeyResource) Configure(ctx context.Context, req ephemeral.ConfigureRequest, resp *ephemeral.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
}

func (r *ApiKeyResource) Open(ctx context.Context, req ephemeral.OpenRequest, resp *ephemeral.OpenResponse) {

	var data ApiKeyResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	username := data.Username.ValueString()
	password := data.Password.ValueString()

	apiKey, err := r.client.GenerateApiKey(ctx, username, password)
	if err != nil {
		resp.Diagnostics.AddError("failed to generate API key", err.Error())
		return
	}

	data.ApiKey = types.StringValue(apiKey)
	resp.Diagnostics.Append(resp.Result.Set(ctx, &data)...)

}

func (r *ApiKeyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

}
