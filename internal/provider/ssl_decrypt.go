package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/device/ssldecrypt"

	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &SslDecryptDataSource{}
	_ datasource.DataSourceWithConfigure = &SslDecryptDataSource{}
)

func NewSslDecryptDataSource() datasource.DataSource {
	return &SslDecryptDataSource{}
}

type SslDecryptDataSource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*ssldecrypt.Config, ssldecrypt.Location, *ssldecrypt.Service]
}

type SslDecryptDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type SslDecryptDataSourceModel struct {
	Location                             SslDecryptLocation `tfsdk:"location"`
	DisabledSslExcludeCertFromPredefined types.List         `tfsdk:"disabled_ssl_exclude_cert_from_predefined"`
	RootCaExcludeList                    types.List         `tfsdk:"root_ca_exclude_list"`
	SslExcludeCert                       types.List         `tfsdk:"ssl_exclude_cert"`
	TrustedRootCa                        types.List         `tfsdk:"trusted_root_ca"`
	ForwardTrustCertificateEcdsa         types.String       `tfsdk:"forward_trust_certificate_ecdsa"`
	ForwardTrustCertificateRsa           types.String       `tfsdk:"forward_trust_certificate_rsa"`
	ForwardUntrustCertificateEcdsa       types.String       `tfsdk:"forward_untrust_certificate_ecdsa"`
	ForwardUntrustCertificateRsa         types.String       `tfsdk:"forward_untrust_certificate_rsa"`
}
type SslDecryptDataSourceSslExcludeCertObject struct {
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
	Exclude     types.Bool   `tfsdk:"exclude"`
}

func (o *SslDecryptDataSourceModel) CopyToPango(ctx context.Context, obj **ssldecrypt.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	disabledSslExcludeCertFromPredefined_pango_entries := make([]string, 0)
	diags.Append(o.DisabledSslExcludeCertFromPredefined.ElementsAs(ctx, &disabledSslExcludeCertFromPredefined_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	rootCaExcludeList_pango_entries := make([]string, 0)
	diags.Append(o.RootCaExcludeList.ElementsAs(ctx, &rootCaExcludeList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var sslExcludeCert_tf_entries []SslDecryptDataSourceSslExcludeCertObject
	var sslExcludeCert_pango_entries []ssldecrypt.SslExcludeCert
	{
		d := o.SslExcludeCert.ElementsAs(ctx, &sslExcludeCert_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sslExcludeCert_tf_entries {
			var entry *ssldecrypt.SslExcludeCert
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			sslExcludeCert_pango_entries = append(sslExcludeCert_pango_entries, *entry)
		}
	}
	trustedRootCa_pango_entries := make([]string, 0)
	diags.Append(o.TrustedRootCa.ElementsAs(ctx, &trustedRootCa_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	forwardTrustCertificateEcdsa_value := o.ForwardTrustCertificateEcdsa.ValueStringPointer()
	forwardTrustCertificateRsa_value := o.ForwardTrustCertificateRsa.ValueStringPointer()
	forwardUntrustCertificateEcdsa_value := o.ForwardUntrustCertificateEcdsa.ValueStringPointer()
	forwardUntrustCertificateRsa_value := o.ForwardUntrustCertificateRsa.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ssldecrypt.Config)
	}
	(*obj).DisabledSslExcludeCertFromPredefined = disabledSslExcludeCertFromPredefined_pango_entries
	(*obj).RootCaExcludeList = rootCaExcludeList_pango_entries
	(*obj).SslExcludeCert = sslExcludeCert_pango_entries
	(*obj).TrustedRootCa = trustedRootCa_pango_entries
	(*obj).ForwardTrustCertificateEcdsa = forwardTrustCertificateEcdsa_value
	(*obj).ForwardTrustCertificateRsa = forwardTrustCertificateRsa_value
	(*obj).ForwardUntrustCertificateEcdsa = forwardUntrustCertificateEcdsa_value
	(*obj).ForwardUntrustCertificateRsa = forwardUntrustCertificateRsa_value

	return diags
}
func (o *SslDecryptDataSourceSslExcludeCertObject) CopyToPango(ctx context.Context, obj **ssldecrypt.SslExcludeCert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exclude_value := o.Exclude.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ssldecrypt.SslExcludeCert)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Exclude = exclude_value

	return diags
}

func (o *SslDecryptDataSourceModel) CopyFromPango(ctx context.Context, obj *ssldecrypt.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disabledSslExcludeCertFromPredefined_list types.List
	{
		var list_diags diag.Diagnostics
		disabledSslExcludeCertFromPredefined_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.DisabledSslExcludeCertFromPredefined)
		diags.Append(list_diags...)
	}
	var rootCaExcludeList_list types.List
	{
		var list_diags diag.Diagnostics
		rootCaExcludeList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.RootCaExcludeList)
		diags.Append(list_diags...)
	}
	var sslExcludeCert_list types.List
	{
		var sslExcludeCert_tf_entries []SslDecryptDataSourceSslExcludeCertObject
		for _, elt := range obj.SslExcludeCert {
			var entry SslDecryptDataSourceSslExcludeCertObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			sslExcludeCert_tf_entries = append(sslExcludeCert_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ssl_exclude_cert")
		sslExcludeCert_list, list_diags = types.ListValueFrom(ctx, schemaType, sslExcludeCert_tf_entries)
		diags.Append(list_diags...)
	}
	var trustedRootCa_list types.List
	{
		var list_diags diag.Diagnostics
		trustedRootCa_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TrustedRootCa)
		diags.Append(list_diags...)
	}

	var forwardTrustCertificateEcdsa_value types.String
	if obj.ForwardTrustCertificateEcdsa != nil {
		forwardTrustCertificateEcdsa_value = types.StringValue(*obj.ForwardTrustCertificateEcdsa)
	}
	var forwardTrustCertificateRsa_value types.String
	if obj.ForwardTrustCertificateRsa != nil {
		forwardTrustCertificateRsa_value = types.StringValue(*obj.ForwardTrustCertificateRsa)
	}
	var forwardUntrustCertificateEcdsa_value types.String
	if obj.ForwardUntrustCertificateEcdsa != nil {
		forwardUntrustCertificateEcdsa_value = types.StringValue(*obj.ForwardUntrustCertificateEcdsa)
	}
	var forwardUntrustCertificateRsa_value types.String
	if obj.ForwardUntrustCertificateRsa != nil {
		forwardUntrustCertificateRsa_value = types.StringValue(*obj.ForwardUntrustCertificateRsa)
	}
	o.DisabledSslExcludeCertFromPredefined = disabledSslExcludeCertFromPredefined_list
	o.RootCaExcludeList = rootCaExcludeList_list
	o.SslExcludeCert = sslExcludeCert_list
	o.TrustedRootCa = trustedRootCa_list
	o.ForwardTrustCertificateEcdsa = forwardTrustCertificateEcdsa_value
	o.ForwardTrustCertificateRsa = forwardTrustCertificateRsa_value
	o.ForwardUntrustCertificateEcdsa = forwardUntrustCertificateEcdsa_value
	o.ForwardUntrustCertificateRsa = forwardUntrustCertificateRsa_value

	return diags
}

func (o *SslDecryptDataSourceSslExcludeCertObject) CopyFromPango(ctx context.Context, obj *ssldecrypt.SslExcludeCert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var exclude_value types.Bool
	if obj.Exclude != nil {
		exclude_value = types.BoolValue(*obj.Exclude)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Exclude = exclude_value

	return diags
}

func SslDecryptDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": SslDecryptDataSourceLocationSchema(),

			"disabled_ssl_exclude_cert_from_predefined": dsschema.ListAttribute{
				Description: "List of disabled predefined exclude certificates.",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"root_ca_exclude_list": dsschema.ListAttribute{
				Description: "List of root CA excludes.",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ssl_exclude_cert": dsschema.ListNestedAttribute{
				Description:  "List of SSL decrypt exclude certificates specs (specified below).",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: SslDecryptDataSourceSslExcludeCertSchema(),
			},

			"trusted_root_ca": dsschema.ListAttribute{
				Description: "List of trusted root CAs.",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"forward_trust_certificate_ecdsa": dsschema.StringAttribute{
				Description: "Forward trust ECDSA certificate.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"forward_trust_certificate_rsa": dsschema.StringAttribute{
				Description: "Forward trust RSA certificate.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"forward_untrust_certificate_ecdsa": dsschema.StringAttribute{
				Description: "Forward untrust ECDSA certificate.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"forward_untrust_certificate_rsa": dsschema.StringAttribute{
				Description: "Forward untrust RSA certificate.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *SslDecryptDataSourceModel) getTypeFor(name string) attr.Type {
	schema := SslDecryptDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func SslDecryptDataSourceSslExcludeCertSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "The description.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exclude": dsschema.BoolAttribute{
				Description: "Exclude or not.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *SslDecryptDataSourceSslExcludeCertObject) getTypeFor(name string) attr.Type {
	schema := SslDecryptDataSourceSslExcludeCertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func SslDecryptDataSourceLocationSchema() rsschema.Attribute {
	return SslDecryptLocationSchema()
}

// Metadata returns the data source type name.
func (d *SslDecryptDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ssl_decrypt"
}

// Schema defines the schema for this data source.
func (d *SslDecryptDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = SslDecryptDataSourceSchema()
}

// Configure prepares the struct.
func (d *SslDecryptDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := ssldecrypt.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewConfigObjectManager(d.client, ssldecrypt.NewService(d.client), specifier)
}
func (o *SslDecryptDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state SslDecryptDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location ssldecrypt.Location

	if !savestate.Location.Panorama.IsNull() && savestate.Location.Panorama.ValueBool() {
		location.Panorama = true
	}
	if savestate.Location.Template != nil {
		location.Template = &ssldecrypt.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
		}
	}
	if savestate.Location.TemplateVsys != nil {
		location.TemplateVsys = &ssldecrypt.TemplateVsysLocation{

			PanoramaDevice: savestate.Location.TemplateVsys.PanoramaDevice.ValueString(),
			Template:       savestate.Location.TemplateVsys.Template.ValueString(),
			NgfwDevice:     savestate.Location.TemplateVsys.NgfwDevice.ValueString(),
			Vsys:           savestate.Location.TemplateVsys.Vsys.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &ssldecrypt.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
		}
	}
	if savestate.Location.TemplateStackVsys != nil {
		location.TemplateStackVsys = &ssldecrypt.TemplateStackVsysLocation{

			PanoramaDevice: savestate.Location.TemplateStackVsys.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStackVsys.TemplateStack.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStackVsys.NgfwDevice.ValueString(),
			Vsys:           savestate.Location.TemplateStackVsys.Vsys.ValueString(),
		}
	}
	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ssl_decrypt_resource",
		"function":      "Read",
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &SslDecryptResource{}
	_ resource.ResourceWithConfigure   = &SslDecryptResource{}
	_ resource.ResourceWithImportState = &SslDecryptResource{}
)

func NewSslDecryptResource() resource.Resource {
	return &SslDecryptResource{}
}

type SslDecryptResource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*ssldecrypt.Config, ssldecrypt.Location, *ssldecrypt.Service]
}

func SslDecryptResourceLocationSchema() rsschema.Attribute {
	return SslDecryptLocationSchema()
}

type SslDecryptResourceModel struct {
	Location                             SslDecryptLocation `tfsdk:"location"`
	DisabledSslExcludeCertFromPredefined types.List         `tfsdk:"disabled_ssl_exclude_cert_from_predefined"`
	RootCaExcludeList                    types.List         `tfsdk:"root_ca_exclude_list"`
	SslExcludeCert                       types.List         `tfsdk:"ssl_exclude_cert"`
	TrustedRootCa                        types.List         `tfsdk:"trusted_root_ca"`
	ForwardTrustCertificateEcdsa         types.String       `tfsdk:"forward_trust_certificate_ecdsa"`
	ForwardTrustCertificateRsa           types.String       `tfsdk:"forward_trust_certificate_rsa"`
	ForwardUntrustCertificateEcdsa       types.String       `tfsdk:"forward_untrust_certificate_ecdsa"`
	ForwardUntrustCertificateRsa         types.String       `tfsdk:"forward_untrust_certificate_rsa"`
}
type SslDecryptResourceSslExcludeCertObject struct {
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
	Exclude     types.Bool   `tfsdk:"exclude"`
}

func (r *SslDecryptResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func SslDecryptResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": SslDecryptResourceLocationSchema(),

			"disabled_ssl_exclude_cert_from_predefined": rsschema.ListAttribute{
				Description: "List of disabled predefined exclude certificates.",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"root_ca_exclude_list": rsschema.ListAttribute{
				Description: "List of root CA excludes.",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ssl_exclude_cert": rsschema.ListNestedAttribute{
				Description:  "List of SSL decrypt exclude certificates specs (specified below).",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: SslDecryptResourceSslExcludeCertSchema(),
			},

			"trusted_root_ca": rsschema.ListAttribute{
				Description: "List of trusted root CAs.",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"forward_trust_certificate_ecdsa": rsschema.StringAttribute{
				Description: "Forward trust ECDSA certificate.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"forward_trust_certificate_rsa": rsschema.StringAttribute{
				Description: "Forward trust RSA certificate.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"forward_untrust_certificate_ecdsa": rsschema.StringAttribute{
				Description: "Forward untrust ECDSA certificate.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"forward_untrust_certificate_rsa": rsschema.StringAttribute{
				Description: "Forward untrust RSA certificate.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *SslDecryptResourceModel) getTypeFor(name string) attr.Type {
	schema := SslDecryptResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func SslDecryptResourceSslExcludeCertSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "The description.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exclude": rsschema.BoolAttribute{
				Description: "Exclude or not.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *SslDecryptResourceSslExcludeCertObject) getTypeFor(name string) attr.Type {
	schema := SslDecryptResourceSslExcludeCertSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *SslDecryptResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ssl_decrypt"
}

func (r *SslDecryptResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = SslDecryptResourceSchema()
}

// </ResourceSchema>

func (r *SslDecryptResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := ssldecrypt.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewConfigObjectManager(r.client, ssldecrypt.NewService(r.client), specifier)
}

func (o *SslDecryptResourceModel) CopyToPango(ctx context.Context, obj **ssldecrypt.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	disabledSslExcludeCertFromPredefined_pango_entries := make([]string, 0)
	diags.Append(o.DisabledSslExcludeCertFromPredefined.ElementsAs(ctx, &disabledSslExcludeCertFromPredefined_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	rootCaExcludeList_pango_entries := make([]string, 0)
	diags.Append(o.RootCaExcludeList.ElementsAs(ctx, &rootCaExcludeList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var sslExcludeCert_tf_entries []SslDecryptResourceSslExcludeCertObject
	var sslExcludeCert_pango_entries []ssldecrypt.SslExcludeCert
	{
		d := o.SslExcludeCert.ElementsAs(ctx, &sslExcludeCert_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sslExcludeCert_tf_entries {
			var entry *ssldecrypt.SslExcludeCert
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			sslExcludeCert_pango_entries = append(sslExcludeCert_pango_entries, *entry)
		}
	}
	trustedRootCa_pango_entries := make([]string, 0)
	diags.Append(o.TrustedRootCa.ElementsAs(ctx, &trustedRootCa_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	forwardTrustCertificateEcdsa_value := o.ForwardTrustCertificateEcdsa.ValueStringPointer()
	forwardTrustCertificateRsa_value := o.ForwardTrustCertificateRsa.ValueStringPointer()
	forwardUntrustCertificateEcdsa_value := o.ForwardUntrustCertificateEcdsa.ValueStringPointer()
	forwardUntrustCertificateRsa_value := o.ForwardUntrustCertificateRsa.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ssldecrypt.Config)
	}
	(*obj).DisabledSslExcludeCertFromPredefined = disabledSslExcludeCertFromPredefined_pango_entries
	(*obj).RootCaExcludeList = rootCaExcludeList_pango_entries
	(*obj).SslExcludeCert = sslExcludeCert_pango_entries
	(*obj).TrustedRootCa = trustedRootCa_pango_entries
	(*obj).ForwardTrustCertificateEcdsa = forwardTrustCertificateEcdsa_value
	(*obj).ForwardTrustCertificateRsa = forwardTrustCertificateRsa_value
	(*obj).ForwardUntrustCertificateEcdsa = forwardUntrustCertificateEcdsa_value
	(*obj).ForwardUntrustCertificateRsa = forwardUntrustCertificateRsa_value

	return diags
}
func (o *SslDecryptResourceSslExcludeCertObject) CopyToPango(ctx context.Context, obj **ssldecrypt.SslExcludeCert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exclude_value := o.Exclude.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ssldecrypt.SslExcludeCert)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Exclude = exclude_value

	return diags
}

func (o *SslDecryptResourceModel) CopyFromPango(ctx context.Context, obj *ssldecrypt.Config, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disabledSslExcludeCertFromPredefined_list types.List
	{
		var list_diags diag.Diagnostics
		disabledSslExcludeCertFromPredefined_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.DisabledSslExcludeCertFromPredefined)
		diags.Append(list_diags...)
	}
	var rootCaExcludeList_list types.List
	{
		var list_diags diag.Diagnostics
		rootCaExcludeList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.RootCaExcludeList)
		diags.Append(list_diags...)
	}
	var sslExcludeCert_list types.List
	{
		var sslExcludeCert_tf_entries []SslDecryptResourceSslExcludeCertObject
		for _, elt := range obj.SslExcludeCert {
			var entry SslDecryptResourceSslExcludeCertObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			sslExcludeCert_tf_entries = append(sslExcludeCert_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ssl_exclude_cert")
		sslExcludeCert_list, list_diags = types.ListValueFrom(ctx, schemaType, sslExcludeCert_tf_entries)
		diags.Append(list_diags...)
	}
	var trustedRootCa_list types.List
	{
		var list_diags diag.Diagnostics
		trustedRootCa_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.TrustedRootCa)
		diags.Append(list_diags...)
	}

	var forwardTrustCertificateEcdsa_value types.String
	if obj.ForwardTrustCertificateEcdsa != nil {
		forwardTrustCertificateEcdsa_value = types.StringValue(*obj.ForwardTrustCertificateEcdsa)
	}
	var forwardTrustCertificateRsa_value types.String
	if obj.ForwardTrustCertificateRsa != nil {
		forwardTrustCertificateRsa_value = types.StringValue(*obj.ForwardTrustCertificateRsa)
	}
	var forwardUntrustCertificateEcdsa_value types.String
	if obj.ForwardUntrustCertificateEcdsa != nil {
		forwardUntrustCertificateEcdsa_value = types.StringValue(*obj.ForwardUntrustCertificateEcdsa)
	}
	var forwardUntrustCertificateRsa_value types.String
	if obj.ForwardUntrustCertificateRsa != nil {
		forwardUntrustCertificateRsa_value = types.StringValue(*obj.ForwardUntrustCertificateRsa)
	}
	o.DisabledSslExcludeCertFromPredefined = disabledSslExcludeCertFromPredefined_list
	o.RootCaExcludeList = rootCaExcludeList_list
	o.SslExcludeCert = sslExcludeCert_list
	o.TrustedRootCa = trustedRootCa_list
	o.ForwardTrustCertificateEcdsa = forwardTrustCertificateEcdsa_value
	o.ForwardTrustCertificateRsa = forwardTrustCertificateRsa_value
	o.ForwardUntrustCertificateEcdsa = forwardUntrustCertificateEcdsa_value
	o.ForwardUntrustCertificateRsa = forwardUntrustCertificateRsa_value

	return diags
}

func (o *SslDecryptResourceSslExcludeCertObject) CopyFromPango(ctx context.Context, obj *ssldecrypt.SslExcludeCert, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var exclude_value types.Bool
	if obj.Exclude != nil {
		exclude_value = types.BoolValue(*obj.Exclude)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Exclude = exclude_value

	return diags
}

func (r *SslDecryptResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state SslDecryptResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_ssl_decrypt_resource",
		"function":      "Create",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location ssldecrypt.Location

	if !state.Location.Panorama.IsNull() && state.Location.Panorama.ValueBool() {
		location.Panorama = true
	}
	if state.Location.Template != nil {
		location.Template = &ssldecrypt.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
		}
	}
	if state.Location.TemplateVsys != nil {
		location.TemplateVsys = &ssldecrypt.TemplateVsysLocation{

			PanoramaDevice: state.Location.TemplateVsys.PanoramaDevice.ValueString(),
			Template:       state.Location.TemplateVsys.Template.ValueString(),
			NgfwDevice:     state.Location.TemplateVsys.NgfwDevice.ValueString(),
			Vsys:           state.Location.TemplateVsys.Vsys.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &ssldecrypt.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
		}
	}
	if state.Location.TemplateStackVsys != nil {
		location.TemplateStackVsys = &ssldecrypt.TemplateStackVsysLocation{

			PanoramaDevice: state.Location.TemplateStackVsys.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStackVsys.TemplateStack.ValueString(),
			NgfwDevice:     state.Location.TemplateStackVsys.NgfwDevice.ValueString(),
			Vsys:           state.Location.TemplateStackVsys.Vsys.ValueString(),
		}
	}
	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *ssldecrypt.Config

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *SslDecryptResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state SslDecryptResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location ssldecrypt.Location

	if !savestate.Location.Panorama.IsNull() && savestate.Location.Panorama.ValueBool() {
		location.Panorama = true
	}
	if savestate.Location.Template != nil {
		location.Template = &ssldecrypt.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
		}
	}
	if savestate.Location.TemplateVsys != nil {
		location.TemplateVsys = &ssldecrypt.TemplateVsysLocation{

			PanoramaDevice: savestate.Location.TemplateVsys.PanoramaDevice.ValueString(),
			Template:       savestate.Location.TemplateVsys.Template.ValueString(),
			NgfwDevice:     savestate.Location.TemplateVsys.NgfwDevice.ValueString(),
			Vsys:           savestate.Location.TemplateVsys.Vsys.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &ssldecrypt.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
		}
	}
	if savestate.Location.TemplateStackVsys != nil {
		location.TemplateStackVsys = &ssldecrypt.TemplateStackVsysLocation{

			PanoramaDevice: savestate.Location.TemplateStackVsys.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStackVsys.TemplateStack.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStackVsys.NgfwDevice.ValueString(),
			Vsys:           savestate.Location.TemplateStackVsys.Vsys.ValueString(),
		}
	}
	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ssl_decrypt_resource",
		"function":      "Read",
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *SslDecryptResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state SslDecryptResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location ssldecrypt.Location

	if !state.Location.Panorama.IsNull() && state.Location.Panorama.ValueBool() {
		location.Panorama = true
	}
	if state.Location.Template != nil {
		location.Template = &ssldecrypt.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
		}
	}
	if state.Location.TemplateVsys != nil {
		location.TemplateVsys = &ssldecrypt.TemplateVsysLocation{

			PanoramaDevice: state.Location.TemplateVsys.PanoramaDevice.ValueString(),
			Template:       state.Location.TemplateVsys.Template.ValueString(),
			NgfwDevice:     state.Location.TemplateVsys.NgfwDevice.ValueString(),
			Vsys:           state.Location.TemplateVsys.Vsys.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &ssldecrypt.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
		}
	}
	if state.Location.TemplateStackVsys != nil {
		location.TemplateStackVsys = &ssldecrypt.TemplateStackVsysLocation{

			PanoramaDevice: state.Location.TemplateStackVsys.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStackVsys.TemplateStack.ValueString(),
			NgfwDevice:     state.Location.TemplateStackVsys.NgfwDevice.ValueString(),
			Vsys:           state.Location.TemplateStackVsys.Vsys.ValueString(),
		}
	}
	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_ssl_decrypt_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *SslDecryptResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state SslDecryptResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_ssl_decrypt_resource",
		"function":      "Delete",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location ssldecrypt.Location

	if !state.Location.Panorama.IsNull() && state.Location.Panorama.ValueBool() {
		location.Panorama = true
	}
	if state.Location.Template != nil {
		location.Template = &ssldecrypt.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
		}
	}
	if state.Location.TemplateVsys != nil {
		location.TemplateVsys = &ssldecrypt.TemplateVsysLocation{

			PanoramaDevice: state.Location.TemplateVsys.PanoramaDevice.ValueString(),
			Template:       state.Location.TemplateVsys.Template.ValueString(),
			NgfwDevice:     state.Location.TemplateVsys.NgfwDevice.ValueString(),
			Vsys:           state.Location.TemplateVsys.Vsys.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &ssldecrypt.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
		}
	}
	if state.Location.TemplateStackVsys != nil {
		location.TemplateStackVsys = &ssldecrypt.TemplateStackVsysLocation{

			PanoramaDevice: state.Location.TemplateStackVsys.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStackVsys.TemplateStack.ValueString(),
			NgfwDevice:     state.Location.TemplateStackVsys.NgfwDevice.ValueString(),
			Vsys:           state.Location.TemplateStackVsys.Vsys.ValueString(),
		}
	}
	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}

	var obj *ssldecrypt.Config
	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	err := r.manager.Delete(ctx, location, obj)
	if err != nil && errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

func (r *SslDecryptResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

}

type SslDecryptTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
}
type SslDecryptTemplateVsysLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Template       types.String `tfsdk:"template"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
	Vsys           types.String `tfsdk:"vsys"`
}
type SslDecryptTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
}
type SslDecryptTemplateStackVsysLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	TemplateStack  types.String `tfsdk:"template_stack"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
	Vsys           types.String `tfsdk:"vsys"`
}
type SslDecryptLocation struct {
	Panorama          types.Bool                           `tfsdk:"panorama"`
	Template          *SslDecryptTemplateLocation          `tfsdk:"template"`
	TemplateVsys      *SslDecryptTemplateVsysLocation      `tfsdk:"template_vsys"`
	TemplateStack     *SslDecryptTemplateStackLocation     `tfsdk:"template_stack"`
	TemplateStackVsys *SslDecryptTemplateStackVsysLocation `tfsdk:"template_stack_vsys"`
	Shared            types.Bool                           `tfsdk:"shared"`
}

func SslDecryptLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"panorama": rsschema.BoolAttribute{
				Description: "Located in a panorama.",
				Optional:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Bool{
					boolvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("panorama"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_vsys"),
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("template_stack_vsys"),
						path.MatchRelative().AtParent().AtName("shared"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template, device and vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"template": rsschema.StringAttribute{
						Description: "The template.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"vsys": rsschema.StringAttribute{
						Description: "The vsys.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The template stack.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack_vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack, device and vsys.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"template_stack": rsschema.StringAttribute{
						Description: "The template stack.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"vsys": rsschema.StringAttribute{
						Description: "The vsys.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"shared": rsschema.BoolAttribute{
				Description: "Located in shared.",
				Optional:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o SslDecryptTemplateLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *SslDecryptTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o SslDecryptTemplateVsysLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Template       *string `json:"template"`
		NgfwDevice     *string `json:"ngfw_device"`
		Vsys           *string `json:"vsys"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Template:       o.Template.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		Vsys:           o.Vsys.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *SslDecryptTemplateVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Template       *string `json:"template"`
		NgfwDevice     *string `json:"ngfw_device"`
		Vsys           *string `json:"vsys"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Template = types.StringPointerValue(shadow.Template)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Vsys = types.StringPointerValue(shadow.Vsys)

	return nil
}
func (o SslDecryptTemplateStackLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *SslDecryptTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o SslDecryptTemplateStackVsysLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		TemplateStack  *string `json:"template_stack"`
		NgfwDevice     *string `json:"ngfw_device"`
		Vsys           *string `json:"vsys"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		TemplateStack:  o.TemplateStack.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		Vsys:           o.Vsys.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *SslDecryptTemplateStackVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		TemplateStack  *string `json:"template_stack"`
		NgfwDevice     *string `json:"ngfw_device"`
		Vsys           *string `json:"vsys"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.TemplateStack = types.StringPointerValue(shadow.TemplateStack)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Vsys = types.StringPointerValue(shadow.Vsys)

	return nil
}
func (o SslDecryptLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Panorama          *bool                                `json:"panorama"`
		Template          *SslDecryptTemplateLocation          `json:"template"`
		TemplateVsys      *SslDecryptTemplateVsysLocation      `json:"template_vsys"`
		TemplateStack     *SslDecryptTemplateStackLocation     `json:"template_stack"`
		TemplateStackVsys *SslDecryptTemplateStackVsysLocation `json:"template_stack_vsys"`
		Shared            *bool                                `json:"shared"`
	}{
		Panorama:          o.Panorama.ValueBoolPointer(),
		Template:          o.Template,
		TemplateVsys:      o.TemplateVsys,
		TemplateStack:     o.TemplateStack,
		TemplateStackVsys: o.TemplateStackVsys,
		Shared:            o.Shared.ValueBoolPointer(),
	}

	return json.Marshal(obj)
}

func (o *SslDecryptLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Panorama          *bool                                `json:"panorama"`
		Template          *SslDecryptTemplateLocation          `json:"template"`
		TemplateVsys      *SslDecryptTemplateVsysLocation      `json:"template_vsys"`
		TemplateStack     *SslDecryptTemplateStackLocation     `json:"template_stack"`
		TemplateStackVsys *SslDecryptTemplateStackVsysLocation `json:"template_stack_vsys"`
		Shared            *bool                                `json:"shared"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Panorama = types.BoolPointerValue(shadow.Panorama)
	o.Template = shadow.Template
	o.TemplateVsys = shadow.TemplateVsys
	o.TemplateStack = shadow.TemplateStack
	o.TemplateStackVsys = shadow.TemplateStackVsys
	o.Shared = types.BoolPointerValue(shadow.Shared)

	return nil
}
