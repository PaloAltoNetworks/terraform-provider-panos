package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/dhcp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &DhcpDataSource{}
	_ datasource.DataSourceWithConfigure = &DhcpDataSource{}
)

func NewDhcpDataSource() datasource.DataSource {
	return &DhcpDataSource{}
}

type DhcpDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*dhcp.Entry, dhcp.Location, *dhcp.Service]
}

type DhcpDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type DhcpDataSourceModel struct {
	Location types.Object                `tfsdk:"location"`
	Name     types.String                `tfsdk:"name"`
	Relay    *DhcpDataSourceRelayObject  `tfsdk:"relay"`
	Server   *DhcpDataSourceServerObject `tfsdk:"server"`
}
type DhcpDataSourceRelayObject struct {
	Ip   *DhcpDataSourceRelayIpObject   `tfsdk:"ip"`
	Ipv6 *DhcpDataSourceRelayIpv6Object `tfsdk:"ipv6"`
}
type DhcpDataSourceRelayIpObject struct {
	Enabled types.Bool `tfsdk:"enabled"`
	Server  types.List `tfsdk:"server"`
}
type DhcpDataSourceRelayIpv6Object struct {
	Enabled types.Bool `tfsdk:"enabled"`
	Server  types.List `tfsdk:"server"`
}
type DhcpDataSourceRelayIpv6ServerObject struct {
	Name      types.String `tfsdk:"name"`
	Interface types.String `tfsdk:"interface"`
}
type DhcpDataSourceServerObject struct {
	IpPool   types.List                        `tfsdk:"ip_pool"`
	Mode     types.String                      `tfsdk:"mode"`
	Option   *DhcpDataSourceServerOptionObject `tfsdk:"option"`
	ProbeIp  types.Bool                        `tfsdk:"probe_ip"`
	Reserved types.List                        `tfsdk:"reserved"`
}
type DhcpDataSourceServerOptionObject struct {
	Dns         *DhcpDataSourceServerOptionDnsObject         `tfsdk:"dns"`
	DnsSuffix   types.String                                 `tfsdk:"dns_suffix"`
	Gateway     types.String                                 `tfsdk:"gateway"`
	Inheritance *DhcpDataSourceServerOptionInheritanceObject `tfsdk:"inheritance"`
	Lease       *DhcpDataSourceServerOptionLeaseObject       `tfsdk:"lease"`
	Nis         *DhcpDataSourceServerOptionNisObject         `tfsdk:"nis"`
	Ntp         *DhcpDataSourceServerOptionNtpObject         `tfsdk:"ntp"`
	Pop3Server  types.String                                 `tfsdk:"pop3_server"`
	SmtpServer  types.String                                 `tfsdk:"smtp_server"`
	SubnetMask  types.String                                 `tfsdk:"subnet_mask"`
	UserDefined types.List                                   `tfsdk:"user_defined"`
	Wins        *DhcpDataSourceServerOptionWinsObject        `tfsdk:"wins"`
}
type DhcpDataSourceServerOptionDnsObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpDataSourceServerOptionInheritanceObject struct {
	Source types.String `tfsdk:"source"`
}
type DhcpDataSourceServerOptionLeaseObject struct {
	Timeout   types.Int64                                     `tfsdk:"timeout"`
	Unlimited *DhcpDataSourceServerOptionLeaseUnlimitedObject `tfsdk:"unlimited"`
}
type DhcpDataSourceServerOptionLeaseUnlimitedObject struct {
}
type DhcpDataSourceServerOptionNisObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpDataSourceServerOptionNtpObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpDataSourceServerOptionUserDefinedObject struct {
	Name                  types.String `tfsdk:"name"`
	Code                  types.Int64  `tfsdk:"code"`
	VendorClassIdentifier types.String `tfsdk:"vendor_class_identifier"`
	Inherited             types.Bool   `tfsdk:"inherited"`
	Ip                    types.List   `tfsdk:"ip"`
	Ascii                 types.List   `tfsdk:"ascii"`
	Hex                   types.List   `tfsdk:"hex"`
}
type DhcpDataSourceServerOptionWinsObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpDataSourceServerReservedObject struct {
	Name        types.String `tfsdk:"name"`
	Mac         types.String `tfsdk:"mac"`
	Description types.String `tfsdk:"description"`
}

func (o *DhcpDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj DhcpLocation

	var relayObj *DhcpDataSourceRelayObject

	var serverObj *DhcpDataSourceServerObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"relay": types.ObjectType{
			AttrTypes: relayObj.AttributeTypes(),
		},
		"server": types.ObjectType{
			AttrTypes: serverObj.AttributeTypes(),
		},
	}
}

func (o DhcpDataSourceModel) AncestorName() string {
	return ""
}

func (o DhcpDataSourceModel) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceRelayObject) AttributeTypes() map[string]attr.Type {

	var ipObj *DhcpDataSourceRelayIpObject

	var ipv6Obj *DhcpDataSourceRelayIpv6Object
	return map[string]attr.Type{
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o DhcpDataSourceRelayObject) AncestorName() string {
	return "relay"
}

func (o DhcpDataSourceRelayObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceRelayIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enabled": types.BoolType,
		"server":  types.ListType{},
	}
}

func (o DhcpDataSourceRelayIpObject) AncestorName() string {
	return "ip"
}

func (o DhcpDataSourceRelayIpObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceRelayIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enabled": types.BoolType,
		"server":  types.ListType{},
	}
}

func (o DhcpDataSourceRelayIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o DhcpDataSourceRelayIpv6Object) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceRelayIpv6ServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"interface": types.StringType,
	}
}

func (o DhcpDataSourceRelayIpv6ServerObject) AncestorName() string {
	return "server"
}

func (o DhcpDataSourceRelayIpv6ServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *DhcpDataSourceServerObject) AttributeTypes() map[string]attr.Type {

	var optionObj *DhcpDataSourceServerOptionObject

	return map[string]attr.Type{
		"ip_pool": types.ListType{},
		"mode":    types.StringType,
		"option": types.ObjectType{
			AttrTypes: optionObj.AttributeTypes(),
		},
		"probe_ip": types.BoolType,
		"reserved": types.ListType{},
	}
}

func (o DhcpDataSourceServerObject) AncestorName() string {
	return "server"
}

func (o DhcpDataSourceServerObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionObject) AttributeTypes() map[string]attr.Type {

	var dnsObj *DhcpDataSourceServerOptionDnsObject

	var inheritanceObj *DhcpDataSourceServerOptionInheritanceObject

	var leaseObj *DhcpDataSourceServerOptionLeaseObject

	var nisObj *DhcpDataSourceServerOptionNisObject

	var ntpObj *DhcpDataSourceServerOptionNtpObject

	var winsObj *DhcpDataSourceServerOptionWinsObject
	return map[string]attr.Type{
		"dns": types.ObjectType{
			AttrTypes: dnsObj.AttributeTypes(),
		},
		"dns_suffix": types.StringType,
		"gateway":    types.StringType,
		"inheritance": types.ObjectType{
			AttrTypes: inheritanceObj.AttributeTypes(),
		},
		"lease": types.ObjectType{
			AttrTypes: leaseObj.AttributeTypes(),
		},
		"nis": types.ObjectType{
			AttrTypes: nisObj.AttributeTypes(),
		},
		"ntp": types.ObjectType{
			AttrTypes: ntpObj.AttributeTypes(),
		},
		"pop3_server":  types.StringType,
		"smtp_server":  types.StringType,
		"subnet_mask":  types.StringType,
		"user_defined": types.ListType{},
		"wins": types.ObjectType{
			AttrTypes: winsObj.AttributeTypes(),
		},
	}
}

func (o DhcpDataSourceServerOptionObject) AncestorName() string {
	return "option"
}

func (o DhcpDataSourceServerOptionObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionDnsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpDataSourceServerOptionDnsObject) AncestorName() string {
	return "dns"
}

func (o DhcpDataSourceServerOptionDnsObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionInheritanceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source": types.StringType,
	}
}

func (o DhcpDataSourceServerOptionInheritanceObject) AncestorName() string {
	return "inheritance"
}

func (o DhcpDataSourceServerOptionInheritanceObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionLeaseObject) AttributeTypes() map[string]attr.Type {

	var unlimitedObj *DhcpDataSourceServerOptionLeaseUnlimitedObject
	return map[string]attr.Type{
		"timeout": types.Int64Type,
		"unlimited": types.ObjectType{
			AttrTypes: unlimitedObj.AttributeTypes(),
		},
	}
}

func (o DhcpDataSourceServerOptionLeaseObject) AncestorName() string {
	return "lease"
}

func (o DhcpDataSourceServerOptionLeaseObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionLeaseUnlimitedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DhcpDataSourceServerOptionLeaseUnlimitedObject) AncestorName() string {
	return "unlimited"
}

func (o DhcpDataSourceServerOptionLeaseUnlimitedObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionNisObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpDataSourceServerOptionNisObject) AncestorName() string {
	return "nis"
}

func (o DhcpDataSourceServerOptionNisObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionNtpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpDataSourceServerOptionNtpObject) AncestorName() string {
	return "ntp"
}

func (o DhcpDataSourceServerOptionNtpObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerOptionUserDefinedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                    types.StringType,
		"code":                    types.Int64Type,
		"vendor_class_identifier": types.StringType,
		"inherited":               types.BoolType,
		"ip":                      types.ListType{},
		"ascii":                   types.ListType{},
		"hex":                     types.ListType{},
	}
}

func (o DhcpDataSourceServerOptionUserDefinedObject) AncestorName() string {
	return "user-defined"
}

func (o DhcpDataSourceServerOptionUserDefinedObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *DhcpDataSourceServerOptionWinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpDataSourceServerOptionWinsObject) AncestorName() string {
	return "wins"
}

func (o DhcpDataSourceServerOptionWinsObject) EntryName() *string {
	return nil
}
func (o *DhcpDataSourceServerReservedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"mac":         types.StringType,
		"description": types.StringType,
	}
}

func (o DhcpDataSourceServerReservedObject) AncestorName() string {
	return "reserved"
}

func (o DhcpDataSourceServerReservedObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}

func (o *DhcpDataSourceModel) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var relay_entry *dhcp.Relay
	if o.Relay != nil {
		if *obj != nil && (*obj).Relay != nil {
			relay_entry = (*obj).Relay
		} else {
			relay_entry = new(dhcp.Relay)
		}
		// ModelOrObject: Model
		diags.Append(o.Relay.CopyToPango(ctx, ancestors, &relay_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var server_entry *dhcp.Server
	if o.Server != nil {
		if *obj != nil && (*obj).Server != nil {
			server_entry = (*obj).Server
		} else {
			server_entry = new(dhcp.Server)
		}
		// ModelOrObject: Model
		diags.Append(o.Server.CopyToPango(ctx, ancestors, &server_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Relay = relay_entry
	(*obj).Server = server_entry

	return diags
}
func (o *DhcpDataSourceRelayObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.Relay, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *dhcp.RelayIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(dhcp.RelayIp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ip.CopyToPango(ctx, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *dhcp.RelayIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(dhcp.RelayIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.Relay)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *DhcpDataSourceRelayIpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.RelayIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enabled_value := o.Enabled.ValueBoolPointer()
	server_pango_entries := make([]string, 0)
	diags.Append(o.Server.ElementsAs(ctx, &server_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(dhcp.RelayIp)
	}
	(*obj).Enabled = enabled_value
	(*obj).Server = server_pango_entries

	return diags
}
func (o *DhcpDataSourceRelayIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.RelayIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enabled_value := o.Enabled.ValueBoolPointer()
	var server_tf_entries []DhcpDataSourceRelayIpv6ServerObject
	var server_pango_entries []dhcp.RelayIpv6Server
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *dhcp.RelayIpv6Server
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.RelayIpv6)
	}
	(*obj).Enabled = enabled_value
	(*obj).Server = server_pango_entries

	return diags
}
func (o *DhcpDataSourceRelayIpv6ServerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.RelayIpv6Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.RelayIpv6Server)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_value

	return diags
}
func (o *DhcpDataSourceServerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipPool_pango_entries := make([]string, 0)
	diags.Append(o.IpPool.ElementsAs(ctx, &ipPool_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	mode_value := o.Mode.ValueStringPointer()
	var option_entry *dhcp.ServerOption
	if o.Option != nil {
		if *obj != nil && (*obj).Option != nil {
			option_entry = (*obj).Option
		} else {
			option_entry = new(dhcp.ServerOption)
		}
		// ModelOrObject: Object
		diags.Append(o.Option.CopyToPango(ctx, append(ancestors, o), &option_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	probeIp_value := o.ProbeIp.ValueBoolPointer()
	var reserved_tf_entries []DhcpDataSourceServerReservedObject
	var reserved_pango_entries []dhcp.ServerReserved
	{
		d := o.Reserved.ElementsAs(ctx, &reserved_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range reserved_tf_entries {
			var entry *dhcp.ServerReserved
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			reserved_pango_entries = append(reserved_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.Server)
	}
	(*obj).IpPool = ipPool_pango_entries
	(*obj).Mode = mode_value
	(*obj).Option = option_entry
	(*obj).ProbeIp = probeIp_value
	(*obj).Reserved = reserved_pango_entries

	return diags
}
func (o *DhcpDataSourceServerOptionObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dns_entry *dhcp.ServerOptionDns
	if o.Dns != nil {
		if *obj != nil && (*obj).Dns != nil {
			dns_entry = (*obj).Dns
		} else {
			dns_entry = new(dhcp.ServerOptionDns)
		}
		// ModelOrObject: Object
		diags.Append(o.Dns.CopyToPango(ctx, append(ancestors, o), &dns_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSuffix_value := o.DnsSuffix.ValueStringPointer()
	gateway_value := o.Gateway.ValueStringPointer()
	var inheritance_entry *dhcp.ServerOptionInheritance
	if o.Inheritance != nil {
		if *obj != nil && (*obj).Inheritance != nil {
			inheritance_entry = (*obj).Inheritance
		} else {
			inheritance_entry = new(dhcp.ServerOptionInheritance)
		}
		// ModelOrObject: Object
		diags.Append(o.Inheritance.CopyToPango(ctx, append(ancestors, o), &inheritance_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lease_entry *dhcp.ServerOptionLease
	if o.Lease != nil {
		if *obj != nil && (*obj).Lease != nil {
			lease_entry = (*obj).Lease
		} else {
			lease_entry = new(dhcp.ServerOptionLease)
		}
		// ModelOrObject: Object
		diags.Append(o.Lease.CopyToPango(ctx, append(ancestors, o), &lease_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nis_entry *dhcp.ServerOptionNis
	if o.Nis != nil {
		if *obj != nil && (*obj).Nis != nil {
			nis_entry = (*obj).Nis
		} else {
			nis_entry = new(dhcp.ServerOptionNis)
		}
		// ModelOrObject: Object
		diags.Append(o.Nis.CopyToPango(ctx, append(ancestors, o), &nis_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ntp_entry *dhcp.ServerOptionNtp
	if o.Ntp != nil {
		if *obj != nil && (*obj).Ntp != nil {
			ntp_entry = (*obj).Ntp
		} else {
			ntp_entry = new(dhcp.ServerOptionNtp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ntp.CopyToPango(ctx, append(ancestors, o), &ntp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	pop3Server_value := o.Pop3Server.ValueStringPointer()
	smtpServer_value := o.SmtpServer.ValueStringPointer()
	subnetMask_value := o.SubnetMask.ValueStringPointer()
	var userDefined_tf_entries []DhcpDataSourceServerOptionUserDefinedObject
	var userDefined_pango_entries []dhcp.ServerOptionUserDefined
	{
		d := o.UserDefined.ElementsAs(ctx, &userDefined_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range userDefined_tf_entries {
			var entry *dhcp.ServerOptionUserDefined
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			userDefined_pango_entries = append(userDefined_pango_entries, *entry)
		}
	}
	var wins_entry *dhcp.ServerOptionWins
	if o.Wins != nil {
		if *obj != nil && (*obj).Wins != nil {
			wins_entry = (*obj).Wins
		} else {
			wins_entry = new(dhcp.ServerOptionWins)
		}
		// ModelOrObject: Object
		diags.Append(o.Wins.CopyToPango(ctx, append(ancestors, o), &wins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.ServerOption)
	}
	(*obj).Dns = dns_entry
	(*obj).DnsSuffix = dnsSuffix_value
	(*obj).Gateway = gateway_value
	(*obj).Inheritance = inheritance_entry
	(*obj).Lease = lease_entry
	(*obj).Nis = nis_entry
	(*obj).Ntp = ntp_entry
	(*obj).Pop3Server = pop3Server_value
	(*obj).SmtpServer = smtpServer_value
	(*obj).SubnetMask = subnetMask_value
	(*obj).UserDefined = userDefined_pango_entries
	(*obj).Wins = wins_entry

	return diags
}
func (o *DhcpDataSourceServerOptionDnsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionDns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionDns)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpDataSourceServerOptionInheritanceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionInheritance, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	source_value := o.Source.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionInheritance)
	}
	(*obj).Source = source_value

	return diags
}
func (o *DhcpDataSourceServerOptionLeaseObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionLease, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timeout_value := o.Timeout.ValueInt64Pointer()
	var unlimited_entry *dhcp.ServerOptionLeaseUnlimited
	if o.Unlimited != nil {
		if *obj != nil && (*obj).Unlimited != nil {
			unlimited_entry = (*obj).Unlimited
		} else {
			unlimited_entry = new(dhcp.ServerOptionLeaseUnlimited)
		}
		// ModelOrObject: Object
		diags.Append(o.Unlimited.CopyToPango(ctx, append(ancestors, o), &unlimited_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionLease)
	}
	(*obj).Timeout = timeout_value
	(*obj).Unlimited = unlimited_entry

	return diags
}
func (o *DhcpDataSourceServerOptionLeaseUnlimitedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionLeaseUnlimited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionLeaseUnlimited)
	}

	return diags
}
func (o *DhcpDataSourceServerOptionNisObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionNis, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionNis)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpDataSourceServerOptionNtpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionNtp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionNtp)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpDataSourceServerOptionUserDefinedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionUserDefined, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	code_value := o.Code.ValueInt64Pointer()
	vendorClassIdentifier_value := o.VendorClassIdentifier.ValueStringPointer()
	inherited_value := o.Inherited.ValueBoolPointer()
	ip_pango_entries := make([]string, 0)
	diags.Append(o.Ip.ElementsAs(ctx, &ip_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	ascii_pango_entries := make([]string, 0)
	diags.Append(o.Ascii.ElementsAs(ctx, &ascii_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	hex_pango_entries := make([]string, 0)
	diags.Append(o.Hex.ElementsAs(ctx, &hex_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionUserDefined)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Code = code_value
	(*obj).VendorClassIdentifier = vendorClassIdentifier_value
	(*obj).Inherited = inherited_value
	(*obj).Ip = ip_pango_entries
	(*obj).Ascii = ascii_pango_entries
	(*obj).Hex = hex_pango_entries

	return diags
}
func (o *DhcpDataSourceServerOptionWinsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionWins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionWins)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpDataSourceServerReservedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerReserved, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	mac_value := o.Mac.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerReserved)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Mac = mac_value
	(*obj).Description = description_value

	return diags
}

func (o *DhcpDataSourceModel) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var relay_object *DhcpDataSourceRelayObject
	if obj.Relay != nil {
		relay_object = new(DhcpDataSourceRelayObject)
		diags.Append(relay_object.CopyFromPango(ctx, ancestors, obj.Relay, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var server_object *DhcpDataSourceServerObject
	if obj.Server != nil {
		server_object = new(DhcpDataSourceServerObject)
		diags.Append(server_object.CopyFromPango(ctx, ancestors, obj.Server, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Relay = relay_object
	o.Server = server_object

	return diags
}

func (o *DhcpDataSourceRelayObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.Relay, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *DhcpDataSourceRelayIpObject
	if obj.Ip != nil {
		ip_object = new(DhcpDataSourceRelayIpObject)
		diags.Append(ip_object.CopyFromPango(ctx, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *DhcpDataSourceRelayIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(DhcpDataSourceRelayIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *DhcpDataSourceRelayIpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.RelayIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var list_diags diag.Diagnostics
		server_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Server)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Enabled = enabled_value
	o.Server = server_list

	return diags
}

func (o *DhcpDataSourceRelayIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.RelayIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []DhcpDataSourceRelayIpv6ServerObject
		for _, elt := range obj.Server {
			entry := DhcpDataSourceRelayIpv6ServerObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Enabled = enabled_value
	o.Server = server_list

	return diags
}

func (o *DhcpDataSourceRelayIpv6ServerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.RelayIpv6Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_value

	return diags
}

func (o *DhcpDataSourceServerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipPool_list types.List
	{
		var list_diags diag.Diagnostics
		ipPool_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.IpPool)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var reserved_list types.List
	{
		var reserved_tf_entries []DhcpDataSourceServerReservedObject
		for _, elt := range obj.Reserved {
			entry := DhcpDataSourceServerReservedObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			reserved_tf_entries = append(reserved_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("reserved")
		reserved_list, list_diags = types.ListValueFrom(ctx, schemaType, reserved_tf_entries)
		diags.Append(list_diags...)
	}
	var option_object *DhcpDataSourceServerOptionObject
	if obj.Option != nil {
		option_object = new(DhcpDataSourceServerOptionObject)
		diags.Append(option_object.CopyFromPango(ctx, append(ancestors, o), obj.Option, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var probeIp_value types.Bool
	if obj.ProbeIp != nil {
		probeIp_value = types.BoolValue(*obj.ProbeIp)
	}
	o.IpPool = ipPool_list
	o.Mode = mode_value
	o.Option = option_object
	o.ProbeIp = probeIp_value
	o.Reserved = reserved_list

	return diags
}

func (o *DhcpDataSourceServerOptionObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var userDefined_list types.List
	{
		var userDefined_tf_entries []DhcpDataSourceServerOptionUserDefinedObject
		for _, elt := range obj.UserDefined {
			entry := DhcpDataSourceServerOptionUserDefinedObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			userDefined_tf_entries = append(userDefined_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("user_defined")
		userDefined_list, list_diags = types.ListValueFrom(ctx, schemaType, userDefined_tf_entries)
		diags.Append(list_diags...)
	}
	var dns_object *DhcpDataSourceServerOptionDnsObject
	if obj.Dns != nil {
		dns_object = new(DhcpDataSourceServerOptionDnsObject)
		diags.Append(dns_object.CopyFromPango(ctx, append(ancestors, o), obj.Dns, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var inheritance_object *DhcpDataSourceServerOptionInheritanceObject
	if obj.Inheritance != nil {
		inheritance_object = new(DhcpDataSourceServerOptionInheritanceObject)
		diags.Append(inheritance_object.CopyFromPango(ctx, append(ancestors, o), obj.Inheritance, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lease_object *DhcpDataSourceServerOptionLeaseObject
	if obj.Lease != nil {
		lease_object = new(DhcpDataSourceServerOptionLeaseObject)
		diags.Append(lease_object.CopyFromPango(ctx, append(ancestors, o), obj.Lease, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nis_object *DhcpDataSourceServerOptionNisObject
	if obj.Nis != nil {
		nis_object = new(DhcpDataSourceServerOptionNisObject)
		diags.Append(nis_object.CopyFromPango(ctx, append(ancestors, o), obj.Nis, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ntp_object *DhcpDataSourceServerOptionNtpObject
	if obj.Ntp != nil {
		ntp_object = new(DhcpDataSourceServerOptionNtpObject)
		diags.Append(ntp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ntp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var wins_object *DhcpDataSourceServerOptionWinsObject
	if obj.Wins != nil {
		wins_object = new(DhcpDataSourceServerOptionWinsObject)
		diags.Append(wins_object.CopyFromPango(ctx, append(ancestors, o), obj.Wins, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsSuffix_value types.String
	if obj.DnsSuffix != nil {
		dnsSuffix_value = types.StringValue(*obj.DnsSuffix)
	}
	var gateway_value types.String
	if obj.Gateway != nil {
		gateway_value = types.StringValue(*obj.Gateway)
	}
	var pop3Server_value types.String
	if obj.Pop3Server != nil {
		pop3Server_value = types.StringValue(*obj.Pop3Server)
	}
	var smtpServer_value types.String
	if obj.SmtpServer != nil {
		smtpServer_value = types.StringValue(*obj.SmtpServer)
	}
	var subnetMask_value types.String
	if obj.SubnetMask != nil {
		subnetMask_value = types.StringValue(*obj.SubnetMask)
	}
	o.Dns = dns_object
	o.DnsSuffix = dnsSuffix_value
	o.Gateway = gateway_value
	o.Inheritance = inheritance_object
	o.Lease = lease_object
	o.Nis = nis_object
	o.Ntp = ntp_object
	o.Pop3Server = pop3Server_value
	o.SmtpServer = smtpServer_value
	o.SubnetMask = subnetMask_value
	o.UserDefined = userDefined_list
	o.Wins = wins_object

	return diags
}

func (o *DhcpDataSourceServerOptionDnsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionDns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpDataSourceServerOptionInheritanceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionInheritance, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	o.Source = source_value

	return diags
}

func (o *DhcpDataSourceServerOptionLeaseObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionLease, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var unlimited_object *DhcpDataSourceServerOptionLeaseUnlimitedObject
	if obj.Unlimited != nil {
		unlimited_object = new(DhcpDataSourceServerOptionLeaseUnlimitedObject)
		diags.Append(unlimited_object.CopyFromPango(ctx, append(ancestors, o), obj.Unlimited, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var timeout_value types.Int64
	if obj.Timeout != nil {
		timeout_value = types.Int64Value(*obj.Timeout)
	}
	o.Timeout = timeout_value
	o.Unlimited = unlimited_object

	return diags
}

func (o *DhcpDataSourceServerOptionLeaseUnlimitedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionLeaseUnlimited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DhcpDataSourceServerOptionNisObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionNis, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpDataSourceServerOptionNtpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionNtp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpDataSourceServerOptionUserDefinedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionUserDefined, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_list types.List
	{
		var list_diags diag.Diagnostics
		ip_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Ip)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ascii_list types.List
	{
		var list_diags diag.Diagnostics
		ascii_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Ascii)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var hex_list types.List
	{
		var list_diags diag.Diagnostics
		hex_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Hex)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var code_value types.Int64
	if obj.Code != nil {
		code_value = types.Int64Value(*obj.Code)
	}
	var vendorClassIdentifier_value types.String
	if obj.VendorClassIdentifier != nil {
		vendorClassIdentifier_value = types.StringValue(*obj.VendorClassIdentifier)
	}
	var inherited_value types.Bool
	if obj.Inherited != nil {
		inherited_value = types.BoolValue(*obj.Inherited)
	}
	o.Name = types.StringValue(obj.Name)
	o.Code = code_value
	o.VendorClassIdentifier = vendorClassIdentifier_value
	o.Inherited = inherited_value
	o.Ip = ip_list
	o.Ascii = ascii_list
	o.Hex = hex_list

	return diags
}

func (o *DhcpDataSourceServerOptionWinsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionWins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpDataSourceServerReservedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerReserved, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var mac_value types.String
	if obj.Mac != nil {
		mac_value = types.StringValue(*obj.Mac)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Mac = mac_value
	o.Description = description_value

	return diags
}

func (o *DhcpDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func DhcpDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": DhcpDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"relay": DhcpDataSourceRelaySchema(),

			"server": DhcpDataSourceServerSchema(),
		},
	}
}

func (o *DhcpDataSourceModel) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceRelaySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": DhcpDataSourceRelayIpSchema(),

			"ipv6": DhcpDataSourceRelayIpv6Schema(),
		},
	}
}

func (o *DhcpDataSourceRelayObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceRelaySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceRelayIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enabled": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *DhcpDataSourceRelayIpObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceRelayIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceRelayIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enabled": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: DhcpDataSourceRelayIpv6ServerSchema(),
			},
		},
	}
}

func (o *DhcpDataSourceRelayIpv6Object) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceRelayIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceRelayIpv6ServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "Specify outgoing interface when using an IPv6 multicast address for your DHCPv6 server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpDataSourceRelayIpv6ServerObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceRelayIpv6ServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_pool": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"mode": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"option": DhcpDataSourceServerOptionSchema(),

			"probe_ip": dsschema.BoolAttribute{
				Description: "Ping IP when allocating a new IP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reserved": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: DhcpDataSourceServerReservedSchema(),
			},
		},
	}
}

func (o *DhcpDataSourceServerObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dns": DhcpDataSourceServerOptionDnsSchema(),

			"dns_suffix": dsschema.StringAttribute{
				Description: "domain name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gateway": dsschema.StringAttribute{
				Description: "default gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inheritance": DhcpDataSourceServerOptionInheritanceSchema(),

			"lease": DhcpDataSourceServerOptionLeaseSchema(),

			"nis": DhcpDataSourceServerOptionNisSchema(),

			"ntp": DhcpDataSourceServerOptionNtpSchema(),

			"pop3_server": dsschema.StringAttribute{
				Description: "POP3 server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"smtp_server": dsschema.StringAttribute{
				Description: "SMTP server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"subnet_mask": dsschema.StringAttribute{
				Description: "ip pool subnet mask",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"user_defined": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: DhcpDataSourceServerOptionUserDefinedSchema(),
			},

			"wins": DhcpDataSourceServerOptionWinsSchema(),
		},
	}
}

func (o *DhcpDataSourceServerOptionObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionDnsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"primary": dsschema.StringAttribute{
				Description: "DNS primary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": dsschema.StringAttribute{
				Description: "DNS secondary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpDataSourceServerOptionDnsObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionDnsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionInheritanceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source": dsschema.StringAttribute{
				Description: "Dynamic interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpDataSourceServerOptionInheritanceObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionInheritanceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionLeaseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"timeout": dsschema.Int64Attribute{
				Description: "lease(minute)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"unlimited": DhcpDataSourceServerOptionLeaseUnlimitedSchema(),
		},
	}
}

func (o *DhcpDataSourceServerOptionLeaseObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionLeaseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionLeaseUnlimitedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("timeout"),
				path.MatchRelative().AtParent().AtName("unlimited"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *DhcpDataSourceServerOptionLeaseUnlimitedObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionLeaseUnlimitedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionNisSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"primary": dsschema.StringAttribute{
				Description: "NIS primary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": dsschema.StringAttribute{
				Description: "NIS secondary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpDataSourceServerOptionNisObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionNisSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionNtpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"primary": dsschema.StringAttribute{
				Description: "NTP primary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": dsschema.StringAttribute{
				Description: "NTP secondary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpDataSourceServerOptionNtpObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionNtpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionUserDefinedSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"code": dsschema.Int64Attribute{
				Description: "option code",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"vendor_class_identifier": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherited": dsschema.BoolAttribute{
				Description: "Inherited from DHCP server inheritance source",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ascii": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"hex": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *DhcpDataSourceServerOptionUserDefinedObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionUserDefinedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerOptionWinsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"primary": dsschema.StringAttribute{
				Description: "WINS primary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": dsschema.StringAttribute{
				Description: "WINS secondary server ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpDataSourceServerOptionWinsObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerOptionWinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceServerReservedSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"mac": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Description of reserved entry, e.g. host name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpDataSourceServerReservedObject) getTypeFor(name string) attr.Type {
	schema := DhcpDataSourceServerReservedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpDataSourceLocationSchema() rsschema.Attribute {
	return DhcpLocationSchema()
}

// Metadata returns the data source type name.
func (d *DhcpDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dhcp"
}

// Schema defines the schema for this data source.
func (d *DhcpDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = DhcpDataSourceSchema()
}

// Configure prepares the struct.
func (d *DhcpDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := dhcp.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*dhcp.Entry, dhcp.Location, *dhcp.Service](d.client, dhcp.NewService(d.client), batchSize, specifier, dhcp.SpecMatches)
}
func (o *DhcpDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state DhcpDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location dhcp.Location

	{
		var terraformLocation DhcpLocation
		resp.Diagnostics.Append(savestate.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dhcp.TemplateLocation{}
			var innerLocation DhcpTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dhcp.TemplateStackLocation{}
			var innerLocation DhcpTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &dhcp.NgfwLocation{}
			var innerLocation DhcpNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_dhcp_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	components, err := savestate.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &DhcpResource{}
	_ resource.ResourceWithConfigure   = &DhcpResource{}
	_ resource.ResourceWithImportState = &DhcpResource{}
)

func NewDhcpResource() resource.Resource {
	if _, found := resourceFuncMap["panos_dhcp"]; !found {
		resourceFuncMap["panos_dhcp"] = resourceFuncs{
			CreateImportId: DhcpImportStateCreator,
		}
	}
	return &DhcpResource{}
}

type DhcpResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*dhcp.Entry, dhcp.Location, *dhcp.Service]
}

func DhcpResourceLocationSchema() rsschema.Attribute {
	return DhcpLocationSchema()
}

type DhcpResourceModel struct {
	Location types.Object              `tfsdk:"location"`
	Name     types.String              `tfsdk:"name"`
	Relay    *DhcpResourceRelayObject  `tfsdk:"relay"`
	Server   *DhcpResourceServerObject `tfsdk:"server"`
}
type DhcpResourceRelayObject struct {
	Ip   *DhcpResourceRelayIpObject   `tfsdk:"ip"`
	Ipv6 *DhcpResourceRelayIpv6Object `tfsdk:"ipv6"`
}
type DhcpResourceRelayIpObject struct {
	Enabled types.Bool `tfsdk:"enabled"`
	Server  types.List `tfsdk:"server"`
}
type DhcpResourceRelayIpv6Object struct {
	Enabled types.Bool `tfsdk:"enabled"`
	Server  types.List `tfsdk:"server"`
}
type DhcpResourceRelayIpv6ServerObject struct {
	Name      types.String `tfsdk:"name"`
	Interface types.String `tfsdk:"interface"`
}
type DhcpResourceServerObject struct {
	IpPool   types.List                      `tfsdk:"ip_pool"`
	Mode     types.String                    `tfsdk:"mode"`
	Option   *DhcpResourceServerOptionObject `tfsdk:"option"`
	ProbeIp  types.Bool                      `tfsdk:"probe_ip"`
	Reserved types.List                      `tfsdk:"reserved"`
}
type DhcpResourceServerOptionObject struct {
	Dns         *DhcpResourceServerOptionDnsObject         `tfsdk:"dns"`
	DnsSuffix   types.String                               `tfsdk:"dns_suffix"`
	Gateway     types.String                               `tfsdk:"gateway"`
	Inheritance *DhcpResourceServerOptionInheritanceObject `tfsdk:"inheritance"`
	Lease       *DhcpResourceServerOptionLeaseObject       `tfsdk:"lease"`
	Nis         *DhcpResourceServerOptionNisObject         `tfsdk:"nis"`
	Ntp         *DhcpResourceServerOptionNtpObject         `tfsdk:"ntp"`
	Pop3Server  types.String                               `tfsdk:"pop3_server"`
	SmtpServer  types.String                               `tfsdk:"smtp_server"`
	SubnetMask  types.String                               `tfsdk:"subnet_mask"`
	UserDefined types.List                                 `tfsdk:"user_defined"`
	Wins        *DhcpResourceServerOptionWinsObject        `tfsdk:"wins"`
}
type DhcpResourceServerOptionDnsObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpResourceServerOptionInheritanceObject struct {
	Source types.String `tfsdk:"source"`
}
type DhcpResourceServerOptionLeaseObject struct {
	Timeout   types.Int64                                   `tfsdk:"timeout"`
	Unlimited *DhcpResourceServerOptionLeaseUnlimitedObject `tfsdk:"unlimited"`
}
type DhcpResourceServerOptionLeaseUnlimitedObject struct {
}
type DhcpResourceServerOptionNisObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpResourceServerOptionNtpObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpResourceServerOptionUserDefinedObject struct {
	Name                  types.String `tfsdk:"name"`
	Code                  types.Int64  `tfsdk:"code"`
	VendorClassIdentifier types.String `tfsdk:"vendor_class_identifier"`
	Inherited             types.Bool   `tfsdk:"inherited"`
	Ip                    types.List   `tfsdk:"ip"`
	Ascii                 types.List   `tfsdk:"ascii"`
	Hex                   types.List   `tfsdk:"hex"`
}
type DhcpResourceServerOptionWinsObject struct {
	Primary   types.String `tfsdk:"primary"`
	Secondary types.String `tfsdk:"secondary"`
}
type DhcpResourceServerReservedObject struct {
	Name        types.String `tfsdk:"name"`
	Mac         types.String `tfsdk:"mac"`
	Description types.String `tfsdk:"description"`
}

func (r *DhcpResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func DhcpResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": DhcpResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"relay": DhcpResourceRelaySchema(),

			"server": DhcpResourceServerSchema(),
		},
	}
}

func (o *DhcpResourceModel) getTypeFor(name string) attr.Type {
	schema := DhcpResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceRelaySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("relay"),
				path.MatchRelative().AtParent().AtName("server"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ip": DhcpResourceRelayIpSchema(),

			"ipv6": DhcpResourceRelayIpv6Schema(),
		},
	}
}

func (o *DhcpResourceRelayObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceRelaySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceRelayIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enabled": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *DhcpResourceRelayIpObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceRelayIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceRelayIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enabled": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: DhcpResourceRelayIpv6ServerSchema(),
			},
		},
	}
}

func (o *DhcpResourceRelayIpv6Object) getTypeFor(name string) attr.Type {
	schema := DhcpResourceRelayIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceRelayIpv6ServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "Specify outgoing interface when using an IPv6 multicast address for your DHCPv6 server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpResourceRelayIpv6ServerObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceRelayIpv6ServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_pool": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"mode": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"option": DhcpResourceServerOptionSchema(),

			"probe_ip": rsschema.BoolAttribute{
				Description: "Ping IP when allocating a new IP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reserved": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: DhcpResourceServerReservedSchema(),
			},
		},
	}
}

func (o *DhcpResourceServerObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dns": DhcpResourceServerOptionDnsSchema(),

			"dns_suffix": rsschema.StringAttribute{
				Description: "domain name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gateway": rsschema.StringAttribute{
				Description: "default gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inheritance": DhcpResourceServerOptionInheritanceSchema(),

			"lease": DhcpResourceServerOptionLeaseSchema(),

			"nis": DhcpResourceServerOptionNisSchema(),

			"ntp": DhcpResourceServerOptionNtpSchema(),

			"pop3_server": rsschema.StringAttribute{
				Description: "POP3 server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"smtp_server": rsschema.StringAttribute{
				Description: "SMTP server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"subnet_mask": rsschema.StringAttribute{
				Description: "ip pool subnet mask",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"user_defined": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: DhcpResourceServerOptionUserDefinedSchema(),
			},

			"wins": DhcpResourceServerOptionWinsSchema(),
		},
	}
}

func (o *DhcpResourceServerOptionObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionDnsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"primary": rsschema.StringAttribute{
				Description: "DNS primary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": rsschema.StringAttribute{
				Description: "DNS secondary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpResourceServerOptionDnsObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionDnsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionInheritanceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source": rsschema.StringAttribute{
				Description: "Dynamic interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpResourceServerOptionInheritanceObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionInheritanceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionLeaseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"timeout": rsschema.Int64Attribute{
				Description: "lease(minute)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("timeout"),
						path.MatchRelative().AtParent().AtName("unlimited"),
					}...),
				},
			},

			"unlimited": DhcpResourceServerOptionLeaseUnlimitedSchema(),
		},
	}
}

func (o *DhcpResourceServerOptionLeaseObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionLeaseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionLeaseUnlimitedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("timeout"),
				path.MatchRelative().AtParent().AtName("unlimited"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *DhcpResourceServerOptionLeaseUnlimitedObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionLeaseUnlimitedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionNisSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"primary": rsschema.StringAttribute{
				Description: "NIS primary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": rsschema.StringAttribute{
				Description: "NIS secondary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpResourceServerOptionNisObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionNisSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionNtpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"primary": rsschema.StringAttribute{
				Description: "NTP primary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": rsschema.StringAttribute{
				Description: "NTP secondary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpResourceServerOptionNtpObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionNtpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionUserDefinedSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"code": rsschema.Int64Attribute{
				Description: "option code",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"vendor_class_identifier": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherited": rsschema.BoolAttribute{
				Description: "Inherited from DHCP server inheritance source",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,

				Validators: []validator.List{
					listvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("ascii"),
						path.MatchRelative().AtParent().AtName("hex"),
					}...),
				},
			},

			"ascii": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"hex": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *DhcpResourceServerOptionUserDefinedObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionUserDefinedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerOptionWinsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"primary": rsschema.StringAttribute{
				Description: "WINS primary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"secondary": rsschema.StringAttribute{
				Description: "WINS secondary server ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpResourceServerOptionWinsObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerOptionWinsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DhcpResourceServerReservedSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"mac": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "Description of reserved entry, e.g. host name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *DhcpResourceServerReservedObject) getTypeFor(name string) attr.Type {
	schema := DhcpResourceServerReservedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *DhcpResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dhcp"
}

func (r *DhcpResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = DhcpResourceSchema()
}

// </ResourceSchema>

func (r *DhcpResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	r.client = providerData.Client
	specifier, _, err := dhcp.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	r.manager = sdkmanager.NewEntryObjectManager[*dhcp.Entry, dhcp.Location, *dhcp.Service](r.client, dhcp.NewService(r.client), batchSize, specifier, dhcp.SpecMatches)
}

func (o *DhcpResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj DhcpLocation

	var relayObj *DhcpResourceRelayObject

	var serverObj *DhcpResourceServerObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"relay": types.ObjectType{
			AttrTypes: relayObj.AttributeTypes(),
		},
		"server": types.ObjectType{
			AttrTypes: serverObj.AttributeTypes(),
		},
	}
}

func (o DhcpResourceModel) AncestorName() string {
	return ""
}

func (o DhcpResourceModel) EntryName() *string {
	return nil
}
func (o *DhcpResourceRelayObject) AttributeTypes() map[string]attr.Type {

	var ipObj *DhcpResourceRelayIpObject

	var ipv6Obj *DhcpResourceRelayIpv6Object
	return map[string]attr.Type{
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o DhcpResourceRelayObject) AncestorName() string {
	return "relay"
}

func (o DhcpResourceRelayObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceRelayIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enabled": types.BoolType,
		"server":  types.ListType{},
	}
}

func (o DhcpResourceRelayIpObject) AncestorName() string {
	return "ip"
}

func (o DhcpResourceRelayIpObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceRelayIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enabled": types.BoolType,
		"server":  types.ListType{},
	}
}

func (o DhcpResourceRelayIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o DhcpResourceRelayIpv6Object) EntryName() *string {
	return nil
}
func (o *DhcpResourceRelayIpv6ServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"interface": types.StringType,
	}
}

func (o DhcpResourceRelayIpv6ServerObject) AncestorName() string {
	return "server"
}

func (o DhcpResourceRelayIpv6ServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *DhcpResourceServerObject) AttributeTypes() map[string]attr.Type {

	var optionObj *DhcpResourceServerOptionObject

	return map[string]attr.Type{
		"ip_pool": types.ListType{},
		"mode":    types.StringType,
		"option": types.ObjectType{
			AttrTypes: optionObj.AttributeTypes(),
		},
		"probe_ip": types.BoolType,
		"reserved": types.ListType{},
	}
}

func (o DhcpResourceServerObject) AncestorName() string {
	return "server"
}

func (o DhcpResourceServerObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionObject) AttributeTypes() map[string]attr.Type {

	var dnsObj *DhcpResourceServerOptionDnsObject

	var inheritanceObj *DhcpResourceServerOptionInheritanceObject

	var leaseObj *DhcpResourceServerOptionLeaseObject

	var nisObj *DhcpResourceServerOptionNisObject

	var ntpObj *DhcpResourceServerOptionNtpObject

	var winsObj *DhcpResourceServerOptionWinsObject
	return map[string]attr.Type{
		"dns": types.ObjectType{
			AttrTypes: dnsObj.AttributeTypes(),
		},
		"dns_suffix": types.StringType,
		"gateway":    types.StringType,
		"inheritance": types.ObjectType{
			AttrTypes: inheritanceObj.AttributeTypes(),
		},
		"lease": types.ObjectType{
			AttrTypes: leaseObj.AttributeTypes(),
		},
		"nis": types.ObjectType{
			AttrTypes: nisObj.AttributeTypes(),
		},
		"ntp": types.ObjectType{
			AttrTypes: ntpObj.AttributeTypes(),
		},
		"pop3_server":  types.StringType,
		"smtp_server":  types.StringType,
		"subnet_mask":  types.StringType,
		"user_defined": types.ListType{},
		"wins": types.ObjectType{
			AttrTypes: winsObj.AttributeTypes(),
		},
	}
}

func (o DhcpResourceServerOptionObject) AncestorName() string {
	return "option"
}

func (o DhcpResourceServerOptionObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionDnsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpResourceServerOptionDnsObject) AncestorName() string {
	return "dns"
}

func (o DhcpResourceServerOptionDnsObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionInheritanceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source": types.StringType,
	}
}

func (o DhcpResourceServerOptionInheritanceObject) AncestorName() string {
	return "inheritance"
}

func (o DhcpResourceServerOptionInheritanceObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionLeaseObject) AttributeTypes() map[string]attr.Type {

	var unlimitedObj *DhcpResourceServerOptionLeaseUnlimitedObject
	return map[string]attr.Type{
		"timeout": types.Int64Type,
		"unlimited": types.ObjectType{
			AttrTypes: unlimitedObj.AttributeTypes(),
		},
	}
}

func (o DhcpResourceServerOptionLeaseObject) AncestorName() string {
	return "lease"
}

func (o DhcpResourceServerOptionLeaseObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionLeaseUnlimitedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o DhcpResourceServerOptionLeaseUnlimitedObject) AncestorName() string {
	return "unlimited"
}

func (o DhcpResourceServerOptionLeaseUnlimitedObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionNisObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpResourceServerOptionNisObject) AncestorName() string {
	return "nis"
}

func (o DhcpResourceServerOptionNisObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionNtpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpResourceServerOptionNtpObject) AncestorName() string {
	return "ntp"
}

func (o DhcpResourceServerOptionNtpObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerOptionUserDefinedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                    types.StringType,
		"code":                    types.Int64Type,
		"vendor_class_identifier": types.StringType,
		"inherited":               types.BoolType,
		"ip":                      types.ListType{},
		"ascii":                   types.ListType{},
		"hex":                     types.ListType{},
	}
}

func (o DhcpResourceServerOptionUserDefinedObject) AncestorName() string {
	return "user-defined"
}

func (o DhcpResourceServerOptionUserDefinedObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *DhcpResourceServerOptionWinsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"primary":   types.StringType,
		"secondary": types.StringType,
	}
}

func (o DhcpResourceServerOptionWinsObject) AncestorName() string {
	return "wins"
}

func (o DhcpResourceServerOptionWinsObject) EntryName() *string {
	return nil
}
func (o *DhcpResourceServerReservedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"mac":         types.StringType,
		"description": types.StringType,
	}
}

func (o DhcpResourceServerReservedObject) AncestorName() string {
	return "reserved"
}

func (o DhcpResourceServerReservedObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}

func (o *DhcpResourceModel) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var relay_entry *dhcp.Relay
	if o.Relay != nil {
		if *obj != nil && (*obj).Relay != nil {
			relay_entry = (*obj).Relay
		} else {
			relay_entry = new(dhcp.Relay)
		}
		// ModelOrObject: Model
		diags.Append(o.Relay.CopyToPango(ctx, ancestors, &relay_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var server_entry *dhcp.Server
	if o.Server != nil {
		if *obj != nil && (*obj).Server != nil {
			server_entry = (*obj).Server
		} else {
			server_entry = new(dhcp.Server)
		}
		// ModelOrObject: Model
		diags.Append(o.Server.CopyToPango(ctx, ancestors, &server_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Relay = relay_entry
	(*obj).Server = server_entry

	return diags
}
func (o *DhcpResourceRelayObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.Relay, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *dhcp.RelayIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(dhcp.RelayIp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ip.CopyToPango(ctx, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *dhcp.RelayIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(dhcp.RelayIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.Relay)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *DhcpResourceRelayIpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.RelayIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enabled_value := o.Enabled.ValueBoolPointer()
	server_pango_entries := make([]string, 0)
	diags.Append(o.Server.ElementsAs(ctx, &server_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(dhcp.RelayIp)
	}
	(*obj).Enabled = enabled_value
	(*obj).Server = server_pango_entries

	return diags
}
func (o *DhcpResourceRelayIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.RelayIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enabled_value := o.Enabled.ValueBoolPointer()
	var server_tf_entries []DhcpResourceRelayIpv6ServerObject
	var server_pango_entries []dhcp.RelayIpv6Server
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *dhcp.RelayIpv6Server
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.RelayIpv6)
	}
	(*obj).Enabled = enabled_value
	(*obj).Server = server_pango_entries

	return diags
}
func (o *DhcpResourceRelayIpv6ServerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.RelayIpv6Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.RelayIpv6Server)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_value

	return diags
}
func (o *DhcpResourceServerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipPool_pango_entries := make([]string, 0)
	diags.Append(o.IpPool.ElementsAs(ctx, &ipPool_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	mode_value := o.Mode.ValueStringPointer()
	var option_entry *dhcp.ServerOption
	if o.Option != nil {
		if *obj != nil && (*obj).Option != nil {
			option_entry = (*obj).Option
		} else {
			option_entry = new(dhcp.ServerOption)
		}
		// ModelOrObject: Object
		diags.Append(o.Option.CopyToPango(ctx, append(ancestors, o), &option_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	probeIp_value := o.ProbeIp.ValueBoolPointer()
	var reserved_tf_entries []DhcpResourceServerReservedObject
	var reserved_pango_entries []dhcp.ServerReserved
	{
		d := o.Reserved.ElementsAs(ctx, &reserved_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range reserved_tf_entries {
			var entry *dhcp.ServerReserved
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			reserved_pango_entries = append(reserved_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.Server)
	}
	(*obj).IpPool = ipPool_pango_entries
	(*obj).Mode = mode_value
	(*obj).Option = option_entry
	(*obj).ProbeIp = probeIp_value
	(*obj).Reserved = reserved_pango_entries

	return diags
}
func (o *DhcpResourceServerOptionObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dns_entry *dhcp.ServerOptionDns
	if o.Dns != nil {
		if *obj != nil && (*obj).Dns != nil {
			dns_entry = (*obj).Dns
		} else {
			dns_entry = new(dhcp.ServerOptionDns)
		}
		// ModelOrObject: Object
		diags.Append(o.Dns.CopyToPango(ctx, append(ancestors, o), &dns_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSuffix_value := o.DnsSuffix.ValueStringPointer()
	gateway_value := o.Gateway.ValueStringPointer()
	var inheritance_entry *dhcp.ServerOptionInheritance
	if o.Inheritance != nil {
		if *obj != nil && (*obj).Inheritance != nil {
			inheritance_entry = (*obj).Inheritance
		} else {
			inheritance_entry = new(dhcp.ServerOptionInheritance)
		}
		// ModelOrObject: Object
		diags.Append(o.Inheritance.CopyToPango(ctx, append(ancestors, o), &inheritance_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lease_entry *dhcp.ServerOptionLease
	if o.Lease != nil {
		if *obj != nil && (*obj).Lease != nil {
			lease_entry = (*obj).Lease
		} else {
			lease_entry = new(dhcp.ServerOptionLease)
		}
		// ModelOrObject: Object
		diags.Append(o.Lease.CopyToPango(ctx, append(ancestors, o), &lease_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nis_entry *dhcp.ServerOptionNis
	if o.Nis != nil {
		if *obj != nil && (*obj).Nis != nil {
			nis_entry = (*obj).Nis
		} else {
			nis_entry = new(dhcp.ServerOptionNis)
		}
		// ModelOrObject: Object
		diags.Append(o.Nis.CopyToPango(ctx, append(ancestors, o), &nis_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ntp_entry *dhcp.ServerOptionNtp
	if o.Ntp != nil {
		if *obj != nil && (*obj).Ntp != nil {
			ntp_entry = (*obj).Ntp
		} else {
			ntp_entry = new(dhcp.ServerOptionNtp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ntp.CopyToPango(ctx, append(ancestors, o), &ntp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	pop3Server_value := o.Pop3Server.ValueStringPointer()
	smtpServer_value := o.SmtpServer.ValueStringPointer()
	subnetMask_value := o.SubnetMask.ValueStringPointer()
	var userDefined_tf_entries []DhcpResourceServerOptionUserDefinedObject
	var userDefined_pango_entries []dhcp.ServerOptionUserDefined
	{
		d := o.UserDefined.ElementsAs(ctx, &userDefined_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range userDefined_tf_entries {
			var entry *dhcp.ServerOptionUserDefined
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			userDefined_pango_entries = append(userDefined_pango_entries, *entry)
		}
	}
	var wins_entry *dhcp.ServerOptionWins
	if o.Wins != nil {
		if *obj != nil && (*obj).Wins != nil {
			wins_entry = (*obj).Wins
		} else {
			wins_entry = new(dhcp.ServerOptionWins)
		}
		// ModelOrObject: Object
		diags.Append(o.Wins.CopyToPango(ctx, append(ancestors, o), &wins_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.ServerOption)
	}
	(*obj).Dns = dns_entry
	(*obj).DnsSuffix = dnsSuffix_value
	(*obj).Gateway = gateway_value
	(*obj).Inheritance = inheritance_entry
	(*obj).Lease = lease_entry
	(*obj).Nis = nis_entry
	(*obj).Ntp = ntp_entry
	(*obj).Pop3Server = pop3Server_value
	(*obj).SmtpServer = smtpServer_value
	(*obj).SubnetMask = subnetMask_value
	(*obj).UserDefined = userDefined_pango_entries
	(*obj).Wins = wins_entry

	return diags
}
func (o *DhcpResourceServerOptionDnsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionDns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionDns)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpResourceServerOptionInheritanceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionInheritance, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	source_value := o.Source.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionInheritance)
	}
	(*obj).Source = source_value

	return diags
}
func (o *DhcpResourceServerOptionLeaseObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionLease, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timeout_value := o.Timeout.ValueInt64Pointer()
	var unlimited_entry *dhcp.ServerOptionLeaseUnlimited
	if o.Unlimited != nil {
		if *obj != nil && (*obj).Unlimited != nil {
			unlimited_entry = (*obj).Unlimited
		} else {
			unlimited_entry = new(dhcp.ServerOptionLeaseUnlimited)
		}
		// ModelOrObject: Object
		diags.Append(o.Unlimited.CopyToPango(ctx, append(ancestors, o), &unlimited_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionLease)
	}
	(*obj).Timeout = timeout_value
	(*obj).Unlimited = unlimited_entry

	return diags
}
func (o *DhcpResourceServerOptionLeaseUnlimitedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionLeaseUnlimited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionLeaseUnlimited)
	}

	return diags
}
func (o *DhcpResourceServerOptionNisObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionNis, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionNis)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpResourceServerOptionNtpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionNtp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionNtp)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpResourceServerOptionUserDefinedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionUserDefined, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	code_value := o.Code.ValueInt64Pointer()
	vendorClassIdentifier_value := o.VendorClassIdentifier.ValueStringPointer()
	inherited_value := o.Inherited.ValueBoolPointer()
	ip_pango_entries := make([]string, 0)
	diags.Append(o.Ip.ElementsAs(ctx, &ip_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	ascii_pango_entries := make([]string, 0)
	diags.Append(o.Ascii.ElementsAs(ctx, &ascii_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	hex_pango_entries := make([]string, 0)
	diags.Append(o.Hex.ElementsAs(ctx, &hex_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionUserDefined)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Code = code_value
	(*obj).VendorClassIdentifier = vendorClassIdentifier_value
	(*obj).Inherited = inherited_value
	(*obj).Ip = ip_pango_entries
	(*obj).Ascii = ascii_pango_entries
	(*obj).Hex = hex_pango_entries

	return diags
}
func (o *DhcpResourceServerOptionWinsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerOptionWins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	primary_value := o.Primary.ValueStringPointer()
	secondary_value := o.Secondary.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerOptionWins)
	}
	(*obj).Primary = primary_value
	(*obj).Secondary = secondary_value

	return diags
}
func (o *DhcpResourceServerReservedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **dhcp.ServerReserved, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	mac_value := o.Mac.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(dhcp.ServerReserved)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Mac = mac_value
	(*obj).Description = description_value

	return diags
}

func (o *DhcpResourceModel) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var relay_object *DhcpResourceRelayObject
	if obj.Relay != nil {
		relay_object = new(DhcpResourceRelayObject)
		diags.Append(relay_object.CopyFromPango(ctx, ancestors, obj.Relay, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var server_object *DhcpResourceServerObject
	if obj.Server != nil {
		server_object = new(DhcpResourceServerObject)
		diags.Append(server_object.CopyFromPango(ctx, ancestors, obj.Server, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Relay = relay_object
	o.Server = server_object

	return diags
}

func (o *DhcpResourceRelayObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.Relay, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *DhcpResourceRelayIpObject
	if obj.Ip != nil {
		ip_object = new(DhcpResourceRelayIpObject)
		diags.Append(ip_object.CopyFromPango(ctx, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *DhcpResourceRelayIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(DhcpResourceRelayIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *DhcpResourceRelayIpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.RelayIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var list_diags diag.Diagnostics
		server_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Server)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Enabled = enabled_value
	o.Server = server_list

	return diags
}

func (o *DhcpResourceRelayIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.RelayIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []DhcpResourceRelayIpv6ServerObject
		for _, elt := range obj.Server {
			entry := DhcpResourceRelayIpv6ServerObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Enabled = enabled_value
	o.Server = server_list

	return diags
}

func (o *DhcpResourceRelayIpv6ServerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.RelayIpv6Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_value

	return diags
}

func (o *DhcpResourceServerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.Server, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipPool_list types.List
	{
		var list_diags diag.Diagnostics
		ipPool_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.IpPool)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var reserved_list types.List
	{
		var reserved_tf_entries []DhcpResourceServerReservedObject
		for _, elt := range obj.Reserved {
			entry := DhcpResourceServerReservedObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			reserved_tf_entries = append(reserved_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("reserved")
		reserved_list, list_diags = types.ListValueFrom(ctx, schemaType, reserved_tf_entries)
		diags.Append(list_diags...)
	}
	var option_object *DhcpResourceServerOptionObject
	if obj.Option != nil {
		option_object = new(DhcpResourceServerOptionObject)
		diags.Append(option_object.CopyFromPango(ctx, append(ancestors, o), obj.Option, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var probeIp_value types.Bool
	if obj.ProbeIp != nil {
		probeIp_value = types.BoolValue(*obj.ProbeIp)
	}
	o.IpPool = ipPool_list
	o.Mode = mode_value
	o.Option = option_object
	o.ProbeIp = probeIp_value
	o.Reserved = reserved_list

	return diags
}

func (o *DhcpResourceServerOptionObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var userDefined_list types.List
	{
		var userDefined_tf_entries []DhcpResourceServerOptionUserDefinedObject
		for _, elt := range obj.UserDefined {
			entry := DhcpResourceServerOptionUserDefinedObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			userDefined_tf_entries = append(userDefined_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("user_defined")
		userDefined_list, list_diags = types.ListValueFrom(ctx, schemaType, userDefined_tf_entries)
		diags.Append(list_diags...)
	}
	var dns_object *DhcpResourceServerOptionDnsObject
	if obj.Dns != nil {
		dns_object = new(DhcpResourceServerOptionDnsObject)
		diags.Append(dns_object.CopyFromPango(ctx, append(ancestors, o), obj.Dns, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var inheritance_object *DhcpResourceServerOptionInheritanceObject
	if obj.Inheritance != nil {
		inheritance_object = new(DhcpResourceServerOptionInheritanceObject)
		diags.Append(inheritance_object.CopyFromPango(ctx, append(ancestors, o), obj.Inheritance, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lease_object *DhcpResourceServerOptionLeaseObject
	if obj.Lease != nil {
		lease_object = new(DhcpResourceServerOptionLeaseObject)
		diags.Append(lease_object.CopyFromPango(ctx, append(ancestors, o), obj.Lease, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nis_object *DhcpResourceServerOptionNisObject
	if obj.Nis != nil {
		nis_object = new(DhcpResourceServerOptionNisObject)
		diags.Append(nis_object.CopyFromPango(ctx, append(ancestors, o), obj.Nis, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ntp_object *DhcpResourceServerOptionNtpObject
	if obj.Ntp != nil {
		ntp_object = new(DhcpResourceServerOptionNtpObject)
		diags.Append(ntp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ntp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var wins_object *DhcpResourceServerOptionWinsObject
	if obj.Wins != nil {
		wins_object = new(DhcpResourceServerOptionWinsObject)
		diags.Append(wins_object.CopyFromPango(ctx, append(ancestors, o), obj.Wins, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsSuffix_value types.String
	if obj.DnsSuffix != nil {
		dnsSuffix_value = types.StringValue(*obj.DnsSuffix)
	}
	var gateway_value types.String
	if obj.Gateway != nil {
		gateway_value = types.StringValue(*obj.Gateway)
	}
	var pop3Server_value types.String
	if obj.Pop3Server != nil {
		pop3Server_value = types.StringValue(*obj.Pop3Server)
	}
	var smtpServer_value types.String
	if obj.SmtpServer != nil {
		smtpServer_value = types.StringValue(*obj.SmtpServer)
	}
	var subnetMask_value types.String
	if obj.SubnetMask != nil {
		subnetMask_value = types.StringValue(*obj.SubnetMask)
	}
	o.Dns = dns_object
	o.DnsSuffix = dnsSuffix_value
	o.Gateway = gateway_value
	o.Inheritance = inheritance_object
	o.Lease = lease_object
	o.Nis = nis_object
	o.Ntp = ntp_object
	o.Pop3Server = pop3Server_value
	o.SmtpServer = smtpServer_value
	o.SubnetMask = subnetMask_value
	o.UserDefined = userDefined_list
	o.Wins = wins_object

	return diags
}

func (o *DhcpResourceServerOptionDnsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionDns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpResourceServerOptionInheritanceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionInheritance, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	o.Source = source_value

	return diags
}

func (o *DhcpResourceServerOptionLeaseObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionLease, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var unlimited_object *DhcpResourceServerOptionLeaseUnlimitedObject
	if obj.Unlimited != nil {
		unlimited_object = new(DhcpResourceServerOptionLeaseUnlimitedObject)
		diags.Append(unlimited_object.CopyFromPango(ctx, append(ancestors, o), obj.Unlimited, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var timeout_value types.Int64
	if obj.Timeout != nil {
		timeout_value = types.Int64Value(*obj.Timeout)
	}
	o.Timeout = timeout_value
	o.Unlimited = unlimited_object

	return diags
}

func (o *DhcpResourceServerOptionLeaseUnlimitedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionLeaseUnlimited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *DhcpResourceServerOptionNisObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionNis, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpResourceServerOptionNtpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionNtp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpResourceServerOptionUserDefinedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionUserDefined, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_list types.List
	{
		var list_diags diag.Diagnostics
		ip_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Ip)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ascii_list types.List
	{
		var list_diags diag.Diagnostics
		ascii_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Ascii)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var hex_list types.List
	{
		var list_diags diag.Diagnostics
		hex_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Hex)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var code_value types.Int64
	if obj.Code != nil {
		code_value = types.Int64Value(*obj.Code)
	}
	var vendorClassIdentifier_value types.String
	if obj.VendorClassIdentifier != nil {
		vendorClassIdentifier_value = types.StringValue(*obj.VendorClassIdentifier)
	}
	var inherited_value types.Bool
	if obj.Inherited != nil {
		inherited_value = types.BoolValue(*obj.Inherited)
	}
	o.Name = types.StringValue(obj.Name)
	o.Code = code_value
	o.VendorClassIdentifier = vendorClassIdentifier_value
	o.Inherited = inherited_value
	o.Ip = ip_list
	o.Ascii = ascii_list
	o.Hex = hex_list

	return diags
}

func (o *DhcpResourceServerOptionWinsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerOptionWins, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var primary_value types.String
	if obj.Primary != nil {
		primary_value = types.StringValue(*obj.Primary)
	}
	var secondary_value types.String
	if obj.Secondary != nil {
		secondary_value = types.StringValue(*obj.Secondary)
	}
	o.Primary = primary_value
	o.Secondary = secondary_value

	return diags
}

func (o *DhcpResourceServerReservedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *dhcp.ServerReserved, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var mac_value types.String
	if obj.Mac != nil {
		mac_value = types.StringValue(*obj.Mac)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Mac = mac_value
	o.Description = description_value

	return diags
}

func (o *DhcpResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (r *DhcpResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state DhcpResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_dhcp_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location dhcp.Location

	{
		var terraformLocation DhcpLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dhcp.TemplateLocation{}
			var innerLocation DhcpTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dhcp.TemplateStackLocation{}
			var innerLocation DhcpTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &dhcp.NgfwLocation{}
			var innerLocation DhcpNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *dhcp.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := r.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *DhcpResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state DhcpResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location dhcp.Location

	{
		var terraformLocation DhcpLocation
		resp.Diagnostics.Append(savestate.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dhcp.TemplateLocation{}
			var innerLocation DhcpTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dhcp.TemplateStackLocation{}
			var innerLocation DhcpTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &dhcp.NgfwLocation{}
			var innerLocation DhcpNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_dhcp_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	components, err := savestate.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *DhcpResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state DhcpResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location dhcp.Location

	{
		var terraformLocation DhcpLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dhcp.TemplateLocation{}
			var innerLocation DhcpTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dhcp.TemplateStackLocation{}
			var innerLocation DhcpTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &dhcp.NgfwLocation{}
			var innerLocation DhcpNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_dhcp_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := r.manager.Read(ctx, location, components, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := r.manager.Update(ctx, location, components, obj, obj.Name)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *DhcpResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state DhcpResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_dhcp_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location dhcp.Location

	{
		var terraformLocation DhcpLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &dhcp.TemplateLocation{}
			var innerLocation DhcpTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &dhcp.TemplateStackLocation{}
			var innerLocation DhcpTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &dhcp.NgfwLocation{}
			var innerLocation DhcpNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = r.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type DhcpImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o DhcpImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *DhcpLocation `json:"location"`
		Name     *string       `json:"name"`
	}
	var location_object *DhcpLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DhcpImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *DhcpLocation `json:"location"`
		Name     *string       `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func DhcpImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := DhcpImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *DhcpResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj DhcpImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type DhcpTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type DhcpTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type DhcpNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type DhcpLocation struct {
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
	Ngfw          types.Object `tfsdk:"ngfw"`
}

func DhcpLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("ngfw"),
					}...),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o DhcpTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DhcpTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DhcpTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DhcpTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DhcpNgfwLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DhcpNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o DhcpLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Template      *DhcpTemplateLocation      `json:"template,omitempty"`
		TemplateStack *DhcpTemplateStackLocation `json:"template_stack,omitempty"`
		Ngfw          *DhcpNgfwLocation          `json:"ngfw,omitempty"`
	}
	var template_object *DhcpTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *DhcpTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}
	var ngfw_object *DhcpNgfwLocation
	{
		diags := o.Ngfw.As(context.TODO(), &ngfw_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal ngfw into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Template:      template_object,
		TemplateStack: templateStack_object,
		Ngfw:          ngfw_object,
	}

	return json.Marshal(obj)
}

func (o *DhcpLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Template      *DhcpTemplateLocation      `json:"template,omitempty"`
		TemplateStack *DhcpTemplateStackLocation `json:"template_stack,omitempty"`
		Ngfw          *DhcpNgfwLocation          `json:"ngfw,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	var ngfw_object types.Object
	{
		var diags_tmp diag.Diagnostics
		ngfw_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Ngfw.AttributeTypes(), shadow.Ngfw)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into ngfw", diags_tmp.Errors())
		}
	}
	o.Template = template_object
	o.TemplateStack = templateStack_object
	o.Ngfw = ngfw_object

	return nil
}

func (o *DhcpTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *DhcpTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *DhcpNgfwLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *DhcpLocation) AttributeTypes() map[string]attr.Type {
	var templateObj DhcpTemplateLocation
	var templateStackObj DhcpTemplateStackLocation
	var ngfwObj DhcpNgfwLocation
	return map[string]attr.Type{
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
		"ngfw": types.ObjectType{
			AttrTypes: ngfwObj.AttributeTypes(),
		},
	}
}
