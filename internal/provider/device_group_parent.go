package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/PaloAltoNetworks/pango"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &DeviceGroupParentDataSource{}
	_ datasource.DataSourceWithConfigure = &DeviceGroupParentDataSource{}
)

func NewDeviceGroupParentDataSource() datasource.DataSource {
	return &DeviceGroupParentDataSource{}
}

type DeviceGroupParentDataSource struct {
	client *pango.Client
	custom *DeviceGroupParentCustom
}

type DeviceGroupParentDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type DeviceGroupParentDataSourceModel struct {
	Location    types.Object `tfsdk:"location"`
	DeviceGroup types.String `tfsdk:"device_group"`
	Parent      types.String `tfsdk:"parent"`
}

func (o *DeviceGroupParentDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj DeviceGroupParentLocation

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"device_group": types.StringType,
		"parent":       types.StringType,
	}
}

func (o DeviceGroupParentDataSourceModel) AncestorName() string {
	return ""
}

func (o DeviceGroupParentDataSourceModel) EntryName() *string {
	return nil
}

func (o *DeviceGroupParentDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func DeviceGroupParentDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": DeviceGroupParentDataSourceLocationSchema(),

			"device_group": dsschema.StringAttribute{
				Description: "The device group whose parent is being set",
				Optional:    true,
				Computed:    true,
			},

			"parent": dsschema.StringAttribute{
				Description: "The parent device group. Leaving it empty moves 'device-group' under 'shared'.",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

func (o *DeviceGroupParentDataSourceModel) getTypeFor(name string) attr.Type {
	schema := DeviceGroupParentDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func DeviceGroupParentDataSourceLocationSchema() rsschema.Attribute {
	return DeviceGroupParentLocationSchema()
}

// Metadata returns the data source type name.
func (d *DeviceGroupParentDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_device_group_parent"
}

// Schema defines the schema for this data source.
func (d *DeviceGroupParentDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = DeviceGroupParentDataSourceSchema()
}

// Configure prepares the struct.
func (d *DeviceGroupParentDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	custom, err := NewDeviceGroupParentCustom(providerData)
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.custom = custom
}
func (o *DeviceGroupParentDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	o.ReadCustom(ctx, req, resp)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &DeviceGroupParentResource{}
	_ resource.ResourceWithConfigure   = &DeviceGroupParentResource{}
	_ resource.ResourceWithImportState = &DeviceGroupParentResource{}
)

func NewDeviceGroupParentResource() resource.Resource {
	return &DeviceGroupParentResource{}
}

type DeviceGroupParentResource struct {
	client *pango.Client
	custom *DeviceGroupParentCustom
}

func DeviceGroupParentResourceLocationSchema() rsschema.Attribute {
	return DeviceGroupParentLocationSchema()
}

type DeviceGroupParentResourceModel struct {
	Location    types.Object `tfsdk:"location"`
	DeviceGroup types.String `tfsdk:"device_group"`
	Parent      types.String `tfsdk:"parent"`
}

func (o *DeviceGroupParentResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {

	var resource DeviceGroupParentResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &resource)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// <ResourceSchema>

func DeviceGroupParentResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": DeviceGroupParentResourceLocationSchema(),

			"device_group": rsschema.StringAttribute{
				Description: "The device group whose parent is being set",
				Optional:    true,
			},

			"parent": rsschema.StringAttribute{
				Description: "The parent device group. Leaving it empty moves 'device-group' under 'shared'.",
				Optional:    true,
			},
		},
	}
}

func (o *DeviceGroupParentResourceModel) getTypeFor(name string) attr.Type {
	schema := DeviceGroupParentResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *DeviceGroupParentResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_device_group_parent"
}

func (o *DeviceGroupParentResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = DeviceGroupParentResourceSchema()
}

// </ResourceSchema>

func (o *DeviceGroupParentResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	custom, err := NewDeviceGroupParentCustom(providerData)
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	o.custom = custom
}

func (o *DeviceGroupParentResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj DeviceGroupParentLocation

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"device_group": types.StringType,
		"parent":       types.StringType,
	}
}

func (o DeviceGroupParentResourceModel) AncestorName() string {
	return ""
}

func (o DeviceGroupParentResourceModel) EntryName() *string {
	return nil
}

func (o *DeviceGroupParentResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *DeviceGroupParentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	o.CreateCustom(ctx, req, resp)

}
func (o *DeviceGroupParentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	o.ReadCustom(ctx, req, resp)

}
func (o *DeviceGroupParentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	o.UpdateCustom(ctx, req, resp)

}
func (o *DeviceGroupParentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	o.DeleteCustom(ctx, req, resp)

}

func (o *DeviceGroupParentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

}

type DeviceGroupParentPanoramaLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
}
type DeviceGroupParentLocation struct {
	Panorama types.Object `tfsdk:"panorama"`
}

func DeviceGroupParentLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"panorama": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Panorama.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "The Panorama device.",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o DeviceGroupParentPanoramaLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *DeviceGroupParentPanoramaLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)

	return nil
}
func (o DeviceGroupParentLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Panorama *DeviceGroupParentPanoramaLocation `json:"panorama,omitempty"`
	}
	var panorama_object *DeviceGroupParentPanoramaLocation
	{
		diags := o.Panorama.As(context.TODO(), &panorama_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal panorama into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Panorama: panorama_object,
	}

	return json.Marshal(obj)
}

func (o *DeviceGroupParentLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Panorama *DeviceGroupParentPanoramaLocation `json:"panorama,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var panorama_object types.Object
	{
		var diags_tmp diag.Diagnostics
		panorama_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Panorama.AttributeTypes(), shadow.Panorama)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into panorama", diags_tmp.Errors())
		}
	}
	o.Panorama = panorama_object

	return nil
}

func (o *DeviceGroupParentPanoramaLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
	}
}
func (o *DeviceGroupParentLocation) AttributeTypes() map[string]attr.Type {
	var panoramaObj DeviceGroupParentPanoramaLocation
	return map[string]attr.Type{
		"panorama": types.ObjectType{
			AttrTypes: panoramaObj.AttributeTypes(),
		},
	}
}
