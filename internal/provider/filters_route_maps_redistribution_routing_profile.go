package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/routing-profile/filters/routemapsredistribution"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &FiltersRouteMapsRedistributionRoutingProfileDataSource{}
	_ datasource.DataSourceWithConfigure = &FiltersRouteMapsRedistributionRoutingProfileDataSource{}
)

func NewFiltersRouteMapsRedistributionRoutingProfileDataSource() datasource.DataSource {
	return &FiltersRouteMapsRedistributionRoutingProfileDataSource{}
}

type FiltersRouteMapsRedistributionRoutingProfileDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*routemapsredistribution.Entry, routemapsredistribution.Location, *routemapsredistribution.Service]
}

type FiltersRouteMapsRedistributionRoutingProfileDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type FiltersRouteMapsRedistributionRoutingProfileDataSourceModel struct {
	Location        types.Object `tfsdk:"location"`
	Name            types.String `tfsdk:"name"`
	Description     types.String `tfsdk:"description"`
	Bgp             types.Object `tfsdk:"bgp"`
	ConnectedStatic types.Object `tfsdk:"connected_static"`
	Ospf            types.Object `tfsdk:"ospf"`
	Ospfv3          types.Object `tfsdk:"ospfv3"`
	Rip             types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject struct {
	Ospf   types.Object `tfsdk:"ospf"`
	Ospfv3 types.Object `tfsdk:"ospfv3"`
	Rib    types.Object `tfsdk:"rib"`
	Rip    types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv4                types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object struct {
	Address     types.Object `tfsdk:"address"`
	NextHop     types.Object `tfsdk:"next_hop"`
	RouteSource types.Object `tfsdk:"route_source"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv6                types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Ipv6                types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object struct {
	Address     types.Object `tfsdk:"address"`
	NextHop     types.Object `tfsdk:"next_hop"`
	RouteSource types.Object `tfsdk:"route_source"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv4                types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object struct {
	Address     types.Object `tfsdk:"address"`
	NextHop     types.Object `tfsdk:"next_hop"`
	RouteSource types.Object `tfsdk:"route_source"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject struct {
	Metric  types.Object `tfsdk:"metric"`
	NextHop types.String `tfsdk:"next_hop"`
	Tag     types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject struct {
	Bgp    types.Object `tfsdk:"bgp"`
	Ospf   types.Object `tfsdk:"ospf"`
	Ospfv3 types.Object `tfsdk:"ospfv3"`
	Rib    types.Object `tfsdk:"rib"`
	Rip    types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
	Ipv6      types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Ipv6                types.Object `tfsdk:"ipv6"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv6      types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
	Ipv6      types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject struct {
	Metric  types.Object `tfsdk:"metric"`
	NextHop types.String `tfsdk:"next_hop"`
	Tag     types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject struct {
	Bgp types.Object `tfsdk:"bgp"`
	Rib types.Object `tfsdk:"rib"`
	Rip types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject struct {
	Metric  types.Object `tfsdk:"metric"`
	NextHop types.String `tfsdk:"next_hop"`
	Tag     types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object struct {
	Bgp types.Object `tfsdk:"bgp"`
	Rib types.Object `tfsdk:"rib"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject struct {
	PrefixList types.String `tfsdk:"prefix_list"`
	AccessList types.String `tfsdk:"access_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv6                types.Object `tfsdk:"ipv6"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject struct {
	PrefixList types.String `tfsdk:"prefix_list"`
	AccessList types.String `tfsdk:"access_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject struct {
	Bgp  types.Object `tfsdk:"bgp"`
	Ospf types.Object `tfsdk:"ospf"`
	Rib  types.Object `tfsdk:"rib"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj FiltersRouteMapsRedistributionRoutingProfileLocation

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject

	var connectedStaticObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject

	var ospfv3Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":        types.StringType,
		"description": types.StringType,
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"connected_static": types.ObjectType{
			AttrTypes: connectedStaticObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceModel) AncestorName() string {
	return ""
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceModel) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject) AttributeTypes() map[string]attr.Type {

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject

	var ospfv3Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject
	return map[string]attr.Type{
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject

	var routeSourceObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"route_source": types.ObjectType{
			AttrTypes: routeSourceObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject) AncestorName() string {
	return "route-source"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject

	var routeSourceObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"route_source": types.ObjectType{
			AttrTypes: routeSourceObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject) AncestorName() string {
	return "route-source"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject

	var routeSourceObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"route_source": types.ObjectType{
			AttrTypes: routeSourceObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject) AncestorName() string {
	return "route-source"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"next_hop": types.StringType,
		"tag":      types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject

	var ospfv3Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject) AncestorName() string {
	return "connected-static"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"next_hop": types.StringType,
		"tag":      types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"next_hop": types.StringType,
		"tag":      types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_list": types.StringType,
		"access_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_list": types.StringType,
		"access_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject) EntryName() *string {
	return nil
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	var bgp_entry *routemapsredistribution.Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.Bgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectedStatic_entry *routemapsredistribution.ConnectedStatic
	if !o.ConnectedStatic.IsUnknown() && !o.ConnectedStatic.IsNull() {
		if *obj != nil && (*obj).ConnectedStatic != nil {
			connectedStatic_entry = (*obj).ConnectedStatic
		} else {
			connectedStatic_entry = new(routemapsredistribution.ConnectedStatic)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject
		diags.Append(o.ConnectedStatic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &connectedStatic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *routemapsredistribution.Ospf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.Ospf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *routemapsredistribution.Ospfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(routemapsredistribution.Ospfv3)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.Rip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.Rip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Bgp = bgp_entry
	(*obj).ConnectedStatic = connectedStatic_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospf_entry *routemapsredistribution.BgpOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.BgpOspf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *routemapsredistribution.BgpOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(routemapsredistribution.BgpOspfv3)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.BgpRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.BgpRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.BgpRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.BgpRip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Bgp)
	}
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Rib = rib_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpOspfRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpOspfRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspf)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpOspfRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpOspfRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpOspfRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpOspfRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv4_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeSource_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource
	if !o.RouteSource.IsUnknown() && !o.RouteSource.IsNull() {
		if *obj != nil && (*obj).RouteSource != nil {
			routeSource_entry = (*obj).RouteSource
		} else {
			routeSource_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject
		diags.Append(o.RouteSource.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routeSource_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry
	(*obj).RouteSource = routeSource_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.BgpOspfRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.BgpOspfRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpOspfv3RouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpOspfv3RouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpOspfv3RouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpOspfv3RouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpOspfv3RouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv6_entry *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.BgpOspfv3RouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.BgpOspfv3RouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv4_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.BgpRibRouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeSource_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource
	if !o.RouteSource.IsUnknown() && !o.RouteSource.IsNull() {
		if *obj != nil && (*obj).RouteSource != nil {
			routeSource_entry = (*obj).RouteSource
		} else {
			routeSource_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject
		diags.Append(o.RouteSource.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routeSource_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry
	(*obj).RouteSource = routeSource_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpRibRouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpRipRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpRipRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRip)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpRipRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpRipRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpRipRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpRipRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv4_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeSource_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource
	if !o.RouteSource.IsUnknown() && !o.RouteSource.IsNull() {
		if *obj != nil && (*obj).RouteSource != nil {
			routeSource_entry = (*obj).RouteSource
		} else {
			routeSource_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject
		diags.Append(o.RouteSource.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routeSource_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry
	(*obj).RouteSource = routeSource_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.BgpRipRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.BgpRipRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_value := o.NextHop.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).NextHop = nextHop_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.ConnectedStaticBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.ConnectedStaticBgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *routemapsredistribution.ConnectedStaticOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.ConnectedStaticOspf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *routemapsredistribution.ConnectedStaticOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(routemapsredistribution.ConnectedStaticOspfv3)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.ConnectedStaticRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.ConnectedStaticRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.ConnectedStaticRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.ConnectedStaticRip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStatic)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Rib = rib_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticBgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticBgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv4_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticOspfRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticOspfRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspf)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticOspfRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticOspfv3RouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticOspfv3RouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv6_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticRipRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticRipRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRip)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticRipRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.ConnectedStaticRipRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_value := o.NextHop.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).NextHop = nextHop_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.OspfBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.OspfBgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.OspfRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.OspfRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.OspfRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.OspfRip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospf)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Rib = rib_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.OspfBgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.OspfBgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.OspfBgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.OspfBgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.OspfBgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.OspfBgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.OspfBgpRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.OspfBgpRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.OspfBgpRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.OspfBgpRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.OspfBgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.OspfBgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.OspfBgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.OspfBgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv4_entry *routemapsredistribution.OspfBgpRouteMapSetIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.OspfBgpRouteMapSetIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv4 = ipv4_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSetIpv4)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.OspfRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.OspfRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.OspfRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.OspfRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.OspfRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.OspfRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.OspfRibRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.OspfRibRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.OspfRibRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.OspfRibRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.OspfRipRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.OspfRipRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRip)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.OspfRipRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.OspfRipRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.OspfRipRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.OspfRipRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.OspfRipRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.OspfRipRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.OspfRipRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.OspfRipRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.OspfRipRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.OspfRipRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_value := o.NextHop.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).NextHop = nextHop_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.Ospfv3Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.Ospfv3Bgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.Ospfv3Rib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.Ospfv3Rib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Rib = rib_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.Ospfv3BgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.Ospfv3BgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3Bgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.Ospfv3BgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.Ospfv3BgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.Ospfv3BgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.Ospfv3BgpRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.Ospfv3BgpRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixList_value := o.PrefixList.ValueStringPointer()
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapMatchAddress)
	}
	(*obj).PrefixList = prefixList_value
	(*obj).AccessList = accessList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.Ospfv3BgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.Ospfv3BgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.Ospfv3BgpRouteMapSetIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSetIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv6 = ipv6_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSetIpv6)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3Rib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.Ospfv3RibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.Ospfv3RibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3Rib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.Ospfv3RibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.Ospfv3RibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.Ospfv3RibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.Ospfv3RibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.Ospfv3RibRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.Ospfv3RibRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.Ospfv3RibRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.Ospfv3RibRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixList_value := o.PrefixList.ValueStringPointer()
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapMatchAddress)
	}
	(*obj).PrefixList = prefixList_value
	(*obj).AccessList = accessList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.RipBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.RipBgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *routemapsredistribution.RipOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.RipOspf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.RipRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.RipRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Rip)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Rib = rib_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.RipBgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.RipBgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.RipBgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.RipBgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.RipBgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.RipBgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.RipBgpRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.RipBgpRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.RipBgpRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.RipBgpRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.RipBgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.RipBgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.RipBgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.RipBgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv4_entry *routemapsredistribution.RipBgpRouteMapSetIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.RipBgpRouteMapSetIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv4 = ipv4_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSetIpv4)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.RipOspfRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.RipOspfRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspf)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.RipOspfRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.RipOspfRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.RipOspfRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.RipOspfRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.RipOspfRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.RipOspfRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.RipOspfRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.RipOspfRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.RipOspfRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.RipOspfRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.RipRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.RipRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.RipRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.RipRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.RipRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.RipRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.RipRibRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.RipRibRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.RipRibRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.RipRibRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, ancestors, obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectedStatic_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject
	if o.ConnectedStatic.IsNull() {
		connectedStatic_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject)
	} else {
		diags.Append(o.ConnectedStatic.As(ctx, &connectedStatic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectedStatic_object := types.ObjectNull(connectedStatic_obj.AttributeTypes())
	if obj.ConnectedStatic != nil {
		diags.Append(connectedStatic_obj.CopyFromPango(ctx, client, ancestors, obj.ConnectedStatic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectedStatic_object, diags_tmp = types.ObjectValueFrom(ctx, connectedStatic_obj.AttributeTypes(), connectedStatic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, ancestors, obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, ancestors, obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, ancestors, obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Bgp = bgp_object
	o.ConnectedStatic = connectedStatic_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Rib = rib_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeSource_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject
	if o.RouteSource.IsNull() {
		routeSource_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject)
	} else {
		diags.Append(o.RouteSource.As(ctx, &routeSource_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routeSource_object := types.ObjectNull(routeSource_obj.AttributeTypes())
	if obj.RouteSource != nil {
		diags.Append(routeSource_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouteSource, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routeSource_object, diags_tmp = types.ObjectValueFrom(ctx, routeSource_obj.AttributeTypes(), routeSource_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object
	o.RouteSource = routeSource_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeSource_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject
	if o.RouteSource.IsNull() {
		routeSource_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject)
	} else {
		diags.Append(o.RouteSource.As(ctx, &routeSource_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routeSource_object := types.ObjectNull(routeSource_obj.AttributeTypes())
	if obj.RouteSource != nil {
		diags.Append(routeSource_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouteSource, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routeSource_object, diags_tmp = types.ObjectValueFrom(ctx, routeSource_obj.AttributeTypes(), routeSource_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object
	o.RouteSource = routeSource_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeSource_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject
	if o.RouteSource.IsNull() {
		routeSource_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject)
	} else {
		diags.Append(o.RouteSource.As(ctx, &routeSource_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routeSource_object := types.ObjectNull(routeSource_obj.AttributeTypes())
	if obj.RouteSource != nil {
		diags.Append(routeSource_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouteSource, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routeSource_object, diags_tmp = types.ObjectValueFrom(ctx, routeSource_obj.AttributeTypes(), routeSource_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object
	o.RouteSource = routeSource_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.NextHop = nextHop_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Rib = rib_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.NextHop = nextHop_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Rib = rib_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv4 = ipv4_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.NextHop = nextHop_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Rib = rib_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.PrefixList = prefixList_value
	o.AccessList = accessList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv6 = ipv6_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3Rib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.PrefixList = prefixList_value
	o.AccessList = accessList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Rib = rib_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv4 = ipv4_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": FiltersRouteMapsRedistributionRoutingProfileDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Redistribution Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpSchema(),

			"connected_static": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticSchema(),

			"ospf": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfSchema(),

			"ospfv3": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Schema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceModel) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ospf": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfSchema(),

			"ospfv3": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Schema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibSchema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as_path_access_list": dsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": dsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": dsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": dsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Match origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": dsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopSchema(),

			"route_source": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapMatchIpv4RouteSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricSchema(),

			"metric_type": dsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as_path_access_list": dsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": dsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": dsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": dsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Match origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": dsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricSchema(),

			"metric_type": dsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpOspfv3RouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as_path_access_list": dsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": dsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": dsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": dsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Match origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": dsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopSchema(),

			"route_source": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv4RouteSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as_path_access_list": dsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": dsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": dsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": dsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Match origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": dsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopSchema(),

			"route_source": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapMatchIpv4RouteSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricSchema(),

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceBgpRipRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpSchema(),

			"ospf": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfSchema(),

			"ospfv3": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Schema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibSchema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricSchema(),

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Schema(),

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": dsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": dsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as": dsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv6 Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv6 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticBgpRouteMapSetIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricSchema(),

			"metric_type": dsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricSchema(),

			"metric_type": dsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticOspfv3RouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricSchema(),

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceConnectedStaticRipRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpSchema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibSchema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricSchema(),

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Schema(),

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": dsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": dsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as": dsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfBgpRouteMapSetIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricSchema(),

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfRipRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpSchema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricSchema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Schema(),

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": dsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": dsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as": dsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv6 Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv6 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3BgpRouteMapSetIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceOspfv3RibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpSchema(),

			"ospf": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfSchema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricSchema(),

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Schema(),

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": dsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": dsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as": dsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": dsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipBgpRouteMapSetIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricSchema(),

			"metric_type": dsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipOspfRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": dsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": dsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": dsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"source_address": dsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileDataSourceRipRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileDataSourceLocationSchema() rsschema.Attribute {
	return FiltersRouteMapsRedistributionRoutingProfileLocationSchema()
}

// Metadata returns the data source type name.
func (d *FiltersRouteMapsRedistributionRoutingProfileDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_filters_route_maps_redistribution_routing_profile"
}

// Schema defines the schema for this data source.
func (d *FiltersRouteMapsRedistributionRoutingProfileDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = FiltersRouteMapsRedistributionRoutingProfileDataSourceSchema()
}

// Configure prepares the struct.
func (d *FiltersRouteMapsRedistributionRoutingProfileDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := routemapsredistribution.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*routemapsredistribution.Entry, routemapsredistribution.Location, *routemapsredistribution.Service](d.client, routemapsredistribution.NewService(d.client), batchSize, specifier, routemapsredistribution.SpecMatches)
}
func (o *FiltersRouteMapsRedistributionRoutingProfileDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state FiltersRouteMapsRedistributionRoutingProfileDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location routemapsredistribution.Location

	{
		var terraformLocation FiltersRouteMapsRedistributionRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &routemapsredistribution.NgfwLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &routemapsredistribution.TemplateLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &routemapsredistribution.TemplateStackLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_filters_route_maps_redistribution_routing_profile_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &FiltersRouteMapsRedistributionRoutingProfileResource{}
	_ resource.ResourceWithConfigure   = &FiltersRouteMapsRedistributionRoutingProfileResource{}
	_ resource.ResourceWithImportState = &FiltersRouteMapsRedistributionRoutingProfileResource{}
)

func NewFiltersRouteMapsRedistributionRoutingProfileResource() resource.Resource {
	if _, found := resourceFuncMap["panos_filters_route_maps_redistribution_routing_profile"]; !found {
		resourceFuncMap["panos_filters_route_maps_redistribution_routing_profile"] = resourceFuncs{
			CreateImportId: FiltersRouteMapsRedistributionRoutingProfileImportStateCreator,
		}
	}
	return &FiltersRouteMapsRedistributionRoutingProfileResource{}
}

type FiltersRouteMapsRedistributionRoutingProfileResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*routemapsredistribution.Entry, routemapsredistribution.Location, *routemapsredistribution.Service]
}

func FiltersRouteMapsRedistributionRoutingProfileResourceLocationSchema() rsschema.Attribute {
	return FiltersRouteMapsRedistributionRoutingProfileLocationSchema()
}

type FiltersRouteMapsRedistributionRoutingProfileResourceModel struct {
	Location        types.Object `tfsdk:"location"`
	Name            types.String `tfsdk:"name"`
	Description     types.String `tfsdk:"description"`
	Bgp             types.Object `tfsdk:"bgp"`
	ConnectedStatic types.Object `tfsdk:"connected_static"`
	Ospf            types.Object `tfsdk:"ospf"`
	Ospfv3          types.Object `tfsdk:"ospfv3"`
	Rip             types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject struct {
	Ospf   types.Object `tfsdk:"ospf"`
	Ospfv3 types.Object `tfsdk:"ospfv3"`
	Rib    types.Object `tfsdk:"rib"`
	Rip    types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv4                types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object struct {
	Address     types.Object `tfsdk:"address"`
	NextHop     types.Object `tfsdk:"next_hop"`
	RouteSource types.Object `tfsdk:"route_source"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv6                types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Ipv6                types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object struct {
	Address     types.Object `tfsdk:"address"`
	NextHop     types.Object `tfsdk:"next_hop"`
	RouteSource types.Object `tfsdk:"route_source"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject struct {
	AsPathAccessList    types.String `tfsdk:"as_path_access_list"`
	RegularCommunities  types.String `tfsdk:"regular_communities"`
	LargeCommunities    types.String `tfsdk:"large_communities"`
	ExtendedCommunities types.String `tfsdk:"extended_communities"`
	Interface           types.String `tfsdk:"interface"`
	Origin              types.String `tfsdk:"origin"`
	Metric              types.Int64  `tfsdk:"metric"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Peer                types.String `tfsdk:"peer"`
	Ipv4                types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object struct {
	Address     types.Object `tfsdk:"address"`
	NextHop     types.Object `tfsdk:"next_hop"`
	RouteSource types.Object `tfsdk:"route_source"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject struct {
	Metric  types.Object `tfsdk:"metric"`
	NextHop types.String `tfsdk:"next_hop"`
	Tag     types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject struct {
	Bgp    types.Object `tfsdk:"bgp"`
	Ospf   types.Object `tfsdk:"ospf"`
	Ospfv3 types.Object `tfsdk:"ospfv3"`
	Rib    types.Object `tfsdk:"rib"`
	Rip    types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
	Ipv6      types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Ipv6                types.Object `tfsdk:"ipv6"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv6      types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
	Ipv6      types.Object `tfsdk:"ipv6"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Ipv4      types.Object `tfsdk:"ipv4"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object struct {
	Address types.Object `tfsdk:"address"`
	NextHop types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject struct {
	Metric  types.Object `tfsdk:"metric"`
	NextHop types.String `tfsdk:"next_hop"`
	Tag     types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject struct {
	Bgp types.Object `tfsdk:"bgp"`
	Rib types.Object `tfsdk:"rib"`
	Rip types.Object `tfsdk:"rip"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject struct {
	Metric  types.Object `tfsdk:"metric"`
	NextHop types.String `tfsdk:"next_hop"`
	Tag     types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object struct {
	Bgp types.Object `tfsdk:"bgp"`
	Rib types.Object `tfsdk:"rib"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject struct {
	PrefixList types.String `tfsdk:"prefix_list"`
	AccessList types.String `tfsdk:"access_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv6                types.Object `tfsdk:"ipv6"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject struct {
	PrefixList types.String `tfsdk:"prefix_list"`
	AccessList types.String `tfsdk:"access_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipObject struct {
	Bgp  types.Object `tfsdk:"bgp"`
	Ospf types.Object `tfsdk:"ospf"`
	Rib  types.Object `tfsdk:"rib"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject struct {
	Aggregator          types.Object `tfsdk:"aggregator"`
	Metric              types.Object `tfsdk:"metric"`
	Ipv4                types.Object `tfsdk:"ipv4"`
	Tag                 types.Int64  `tfsdk:"tag"`
	LocalPreference     types.Int64  `tfsdk:"local_preference"`
	Weight              types.Int64  `tfsdk:"weight"`
	Origin              types.String `tfsdk:"origin"`
	AtomicAggregate     types.Bool   `tfsdk:"atomic_aggregate"`
	OriginatorId        types.String `tfsdk:"originator_id"`
	AspathPrepends      types.List   `tfsdk:"aspath_prepends"`
	RegularCommunities  types.List   `tfsdk:"regular_communities"`
	LargeCommunities    types.List   `tfsdk:"large_communities"`
	ExtendedCommunities types.List   `tfsdk:"extended_communities"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject struct {
	As       types.Int64  `tfsdk:"as"`
	RouterId types.String `tfsdk:"router_id"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object struct {
	SourceAddress types.String `tfsdk:"source_address"`
	NextHop       types.String `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject struct {
	Metric     types.Object `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
	Tag        types.Int64  `tfsdk:"tag"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject struct {
	Value  types.Int64  `tfsdk:"value"`
	Action types.String `tfsdk:"action"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject struct {
	RouteMap types.List `tfsdk:"route_map"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject struct {
	Name        types.String `tfsdk:"name"`
	Action      types.String `tfsdk:"action"`
	Description types.String `tfsdk:"description"`
	Match       types.Object `tfsdk:"match"`
	Set         types.Object `tfsdk:"set"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject struct {
	Interface types.String `tfsdk:"interface"`
	Metric    types.Int64  `tfsdk:"metric"`
	Tag       types.Int64  `tfsdk:"tag"`
	Address   types.Object `tfsdk:"address"`
	NextHop   types.Object `tfsdk:"next_hop"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject struct {
	AccessList types.String `tfsdk:"access_list"`
	PrefixList types.String `tfsdk:"prefix_list"`
}
type FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject struct {
	SourceAddress types.String `tfsdk:"source_address"`
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func FiltersRouteMapsRedistributionRoutingProfileResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": FiltersRouteMapsRedistributionRoutingProfileResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Redistribution Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp": FiltersRouteMapsRedistributionRoutingProfileResourceBgpSchema(),

			"connected_static": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticSchema(),

			"ospf": FiltersRouteMapsRedistributionRoutingProfileResourceOspfSchema(),

			"ospfv3": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Schema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileResourceRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceModel) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("connected_static"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ospf": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfSchema(),

			"ospfv3": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Schema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibSchema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as_path_access_list": rsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": rsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": rsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": rsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Match origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": rsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopSchema(),

			"route_source": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricSchema(),

			"metric_type": rsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as_path_access_list": rsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": rsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": rsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": rsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Match origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": rsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricSchema(),

			"metric_type": rsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as_path_access_list": rsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": rsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": rsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": rsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Match origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": rsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopSchema(),

			"route_source": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as_path_access_list": rsschema.StringAttribute{
				Description: "AS Path Access List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"regular_communities": rsschema.StringAttribute{
				Description: "Regular Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"large_communities": rsschema.StringAttribute{
				Description: "Large Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"extended_communities": rsschema.StringAttribute{
				Description: "Extended Community Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Match origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Match Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer": rsschema.StringAttribute{
				Description: "Match Peer Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopSchema(),

			"route_source": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricSchema(),

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpSchema(),

			"ospf": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfSchema(),

			"ospfv3": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Schema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibSchema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricSchema(),

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Schema(),

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": rsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": rsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as": rsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv6 Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv6 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricSchema(),

			"metric_type": rsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricSchema(),

			"metric_type": rsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Schema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("ospfv3"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Schema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricSchema(),

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpSchema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibSchema(),

			"rip": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricSchema(),

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Schema(),

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": rsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": rsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as": rsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
				path.MatchRelative().AtParent().AtName("rip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricSchema(),

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpSchema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricSchema(),

			"ipv6": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Schema(),

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": rsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": rsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as": rsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv6 Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv6 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"bgp": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpSchema(),

			"ospf": FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfSchema(),

			"rib": FiltersRouteMapsRedistributionRoutingProfileResourceRipRibSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregator": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorSchema(),

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricSchema(),

			"ipv4": FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Schema(),

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": rsschema.Int64Attribute{
				Description: "Set Local Preference of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "Set BGP weight of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "Set BGP origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"atomic_aggregate": rsschema.BoolAttribute{
				Description: "Enable BGP atomic aggregate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": rsschema.StringAttribute{
				Description: "Set BGP Originator Id",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aspath_prepends": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.Int64Type,
			},

			"regular_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"large_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_communities": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as": rsschema.Int64Attribute{
				Description: "Set BGP Aggregator AS <1-4294967295>",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "Set BGP Aggregator Router ID",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action (BGP MED) of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_hop": rsschema.StringAttribute{
				Description: "Set IPv4 Next-Hop Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricSchema(),

			"metric_type": rsschema.StringAttribute{
				Description: "Set Metric-Type of route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},

			"tag": rsschema.Int64Attribute{
				Description: "Set Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"value": rsschema.Int64Attribute{
				Description: "Set Metric value of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Set Metric action of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipRibSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("bgp"),
				path.MatchRelative().AtParent().AtName("ospf"),
				path.MatchRelative().AtParent().AtName("rib"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSchema(),
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipRibSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": rsschema.StringAttribute{
				Description: "Permit or Deny (default) Route Map",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("deny"),
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Route Map",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchSchema(),

			"set": FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Match Interface of the route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Match Metric of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tag": rsschema.Int64Attribute{
				Description: "Match Tag of route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressSchema(),

			"next_hop": FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopSchema(),
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "Access-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_list": rsschema.StringAttribute{
				Description: "Prefix-List Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"source_address": rsschema.StringAttribute{
				Description: "Set Source IPv4 or IPv6 address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject) getTypeFor(name string) attr.Type {
	schema := FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_filters_route_maps_redistribution_routing_profile"
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = FiltersRouteMapsRedistributionRoutingProfileResourceSchema()
}

// </ResourceSchema>

func (o *FiltersRouteMapsRedistributionRoutingProfileResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := routemapsredistribution.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*routemapsredistribution.Entry, routemapsredistribution.Location, *routemapsredistribution.Service](o.client, routemapsredistribution.NewService(o.client), batchSize, specifier, routemapsredistribution.SpecMatches)
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj FiltersRouteMapsRedistributionRoutingProfileLocation

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject

	var connectedStaticObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject

	var ospfv3Obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":        types.StringType,
		"description": types.StringType,
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"connected_static": types.ObjectType{
			AttrTypes: connectedStaticObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceModel) AncestorName() string {
	return ""
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceModel) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject) AttributeTypes() map[string]attr.Type {

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject

	var ospfv3Obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject
	return map[string]attr.Type{
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject

	var routeSourceObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"route_source": types.ObjectType{
			AttrTypes: routeSourceObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject) AncestorName() string {
	return "route-source"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject

	var routeSourceObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"route_source": types.ObjectType{
			AttrTypes: routeSourceObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject) AncestorName() string {
	return "route-source"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"as_path_access_list":  types.StringType,
		"regular_communities":  types.StringType,
		"large_communities":    types.StringType,
		"extended_communities": types.StringType,
		"interface":            types.StringType,
		"origin":               types.StringType,
		"metric":               types.Int64Type,
		"tag":                  types.Int64Type,
		"local_preference":     types.Int64Type,
		"peer":                 types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject

	var routeSourceObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"route_source": types.ObjectType{
			AttrTypes: routeSourceObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject) AncestorName() string {
	return "route-source"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"next_hop": types.StringType,
		"tag":      types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject

	var ospfv3Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject) AncestorName() string {
	return "connected-static"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject
	return map[string]attr.Type{
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"next_hop": types.StringType,
		"tag":      types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject

	var ripObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"next_hop": types.StringType,
		"tag":      types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_list": types.StringType,
		"access_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject

	var ipv6Obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_list": types.StringType,
		"access_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject

	var ospfObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject

	var ribObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"rib": types.ObjectType{
			AttrTypes: ribObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipObject) AncestorName() string {
	return "rip"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject) AncestorName() string {
	return "bgp"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var aggregatorObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject

	var ipv4Obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object

	return map[string]attr.Type{
		"aggregator": types.ObjectType{
			AttrTypes: aggregatorObj.AttributeTypes(),
		},
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"tag":              types.Int64Type,
		"local_preference": types.Int64Type,
		"weight":           types.Int64Type,
		"origin":           types.StringType,
		"atomic_aggregate": types.BoolType,
		"originator_id":    types.StringType,
		"aspath_prepends": types.ListType{
			ElemType: types.Int64Type,
		},
		"regular_communities": types.ListType{
			ElemType: types.StringType,
		},
		"large_communities": types.ListType{
			ElemType: types.StringType,
		},
		"extended_communities": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"as":        types.Int64Type,
		"router_id": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject) AncestorName() string {
	return "aggregator"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
		"next_hop":       types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject) AncestorName() string {
	return "ospf"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	var metricObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject

	return map[string]attr.Type{
		"metric": types.ObjectType{
			AttrTypes: metricObj.AttributeTypes(),
		},
		"metric_type": types.StringType,
		"tag":         types.Int64Type,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"value":  types.Int64Type,
		"action": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject) AncestorName() string {
	return "metric"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject) AttributeTypes() map[string]attr.Type {

	var routeMapObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject
	return map[string]attr.Type{
		"route_map": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: routeMapObj.AttributeTypes(),
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject) AncestorName() string {
	return "rib"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject) AttributeTypes() map[string]attr.Type {

	var matchObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject

	var setObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"action":      types.StringType,
		"description": types.StringType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"set": types.ObjectType{
			AttrTypes: setObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject) AncestorName() string {
	return "route-map"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject) AttributeTypes() map[string]attr.Type {

	var addressObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject

	var nextHopObj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"metric":    types.Int64Type,
		"tag":       types.Int64Type,
		"address": types.ObjectType{
			AttrTypes: addressObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject) AncestorName() string {
	return "match"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject) AncestorName() string {
	return "address"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"prefix_list": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject) EntryName() *string {
	return nil
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"source_address": types.StringType,
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject) AncestorName() string {
	return "set"
}

func (o FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject) EntryName() *string {
	return nil
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	var bgp_entry *routemapsredistribution.Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.Bgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectedStatic_entry *routemapsredistribution.ConnectedStatic
	if !o.ConnectedStatic.IsUnknown() && !o.ConnectedStatic.IsNull() {
		if *obj != nil && (*obj).ConnectedStatic != nil {
			connectedStatic_entry = (*obj).ConnectedStatic
		} else {
			connectedStatic_entry = new(routemapsredistribution.ConnectedStatic)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject
		diags.Append(o.ConnectedStatic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &connectedStatic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *routemapsredistribution.Ospf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.Ospf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *routemapsredistribution.Ospfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(routemapsredistribution.Ospfv3)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.Rip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.Rip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Bgp = bgp_entry
	(*obj).ConnectedStatic = connectedStatic_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospf_entry *routemapsredistribution.BgpOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.BgpOspf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *routemapsredistribution.BgpOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(routemapsredistribution.BgpOspfv3)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.BgpRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.BgpRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.BgpRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.BgpRip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Bgp)
	}
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Rib = rib_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpOspfRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpOspfRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspf)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpOspfRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpOspfRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpOspfRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpOspfRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv4_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeSource_entry *routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource
	if !o.RouteSource.IsUnknown() && !o.RouteSource.IsNull() {
		if *obj != nil && (*obj).RouteSource != nil {
			routeSource_entry = (*obj).RouteSource
		} else {
			routeSource_entry = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject
		diags.Append(o.RouteSource.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routeSource_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry
	(*obj).RouteSource = routeSource_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.BgpOspfRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.BgpOspfRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpOspfv3RouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpOspfv3RouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpOspfv3RouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpOspfv3RouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpOspfv3RouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv6_entry *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.BgpOspfv3RouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.BgpOspfv3RouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpOspfv3RouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv4_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.BgpRibRouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeSource_entry *routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource
	if !o.RouteSource.IsUnknown() && !o.RouteSource.IsNull() {
		if *obj != nil && (*obj).RouteSource != nil {
			routeSource_entry = (*obj).RouteSource
		} else {
			routeSource_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject
		diags.Append(o.RouteSource.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routeSource_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry
	(*obj).RouteSource = routeSource_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpRibRouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.BgpRipRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.BgpRipRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRip)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.BgpRipRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.BgpRipRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.BgpRipRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.BgpRipRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathAccessList_value := o.AsPathAccessList.ValueStringPointer()
	regularCommunities_value := o.RegularCommunities.ValueStringPointer()
	largeCommunities_value := o.LargeCommunities.ValueStringPointer()
	extendedCommunities_value := o.ExtendedCommunities.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	peer_value := o.Peer.ValueStringPointer()
	var ipv4_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatch)
	}
	(*obj).AsPathAccessList = asPathAccessList_value
	(*obj).RegularCommunity = regularCommunities_value
	(*obj).LargeCommunity = largeCommunities_value
	(*obj).ExtendedCommunity = extendedCommunities_value
	(*obj).Interface = interface_value
	(*obj).Origin = origin_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Peer = peer_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeSource_entry *routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource
	if !o.RouteSource.IsUnknown() && !o.RouteSource.IsNull() {
		if *obj != nil && (*obj).RouteSource != nil {
			routeSource_entry = (*obj).RouteSource
		} else {
			routeSource_entry = new(routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject
		diags.Append(o.RouteSource.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routeSource_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry
	(*obj).RouteSource = routeSource_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.BgpRipRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.BgpRipRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_value := o.NextHop.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).NextHop = nextHop_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.BgpRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.BgpRipRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.ConnectedStaticBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.ConnectedStaticBgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *routemapsredistribution.ConnectedStaticOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.ConnectedStaticOspf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *routemapsredistribution.ConnectedStaticOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(routemapsredistribution.ConnectedStaticOspfv3)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.ConnectedStaticRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.ConnectedStaticRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.ConnectedStaticRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.ConnectedStaticRip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStatic)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Rib = rib_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticBgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticBgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv4_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticOspfRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticOspfRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspf)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticOspfRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticOspfv3RouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticOspfv3RouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv6_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.ConnectedStaticRipRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.ConnectedStaticRipRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRip)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.ConnectedStaticRipRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var ipv4_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Ipv4 = ipv4_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4)
	}
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.ConnectedStaticRipRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.ConnectedStaticRipRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_value := o.NextHop.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).NextHop = nextHop_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.ConnectedStaticRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.ConnectedStaticRipRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.OspfBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.OspfBgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.OspfRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.OspfRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *routemapsredistribution.OspfRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(routemapsredistribution.OspfRip)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospf)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Rib = rib_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.OspfBgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.OspfBgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.OspfBgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.OspfBgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.OspfBgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.OspfBgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.OspfBgpRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.OspfBgpRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.OspfBgpRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.OspfBgpRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.OspfBgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.OspfBgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.OspfBgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.OspfBgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv4_entry *routemapsredistribution.OspfBgpRouteMapSetIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.OspfBgpRouteMapSetIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv4 = ipv4_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfBgpRouteMapSetIpv4)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.OspfRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.OspfRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.OspfRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.OspfRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.OspfRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.OspfRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.OspfRibRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.OspfRibRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.OspfRibRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.OspfRibRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.OspfRipRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.OspfRipRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRip)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.OspfRipRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.OspfRipRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.OspfRipRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.OspfRipRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.OspfRipRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.OspfRipRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.OspfRipRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.OspfRipRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.OspfRipRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.OspfRipRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_value := o.NextHop.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).NextHop = nextHop_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.OspfRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.OspfRipRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.Ospfv3Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.Ospfv3Bgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.Ospfv3Rib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.Ospfv3Rib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Rib = rib_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.Ospfv3BgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.Ospfv3BgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3Bgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.Ospfv3BgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.Ospfv3BgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.Ospfv3BgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.Ospfv3BgpRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.Ospfv3BgpRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixList_value := o.PrefixList.ValueStringPointer()
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapMatchAddress)
	}
	(*obj).PrefixList = prefixList_value
	(*obj).AccessList = accessList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.Ospfv3BgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.Ospfv3BgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *routemapsredistribution.Ospfv3BgpRouteMapSetIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(routemapsredistribution.Ospfv3BgpRouteMapSetIpv6)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv6 = ipv6_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3BgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3BgpRouteMapSetIpv6)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3Rib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.Ospfv3RibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.Ospfv3RibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3Rib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.Ospfv3RibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.Ospfv3RibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.Ospfv3RibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.Ospfv3RibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.Ospfv3RibRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.Ospfv3RibRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.Ospfv3RibRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.Ospfv3RibRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixList_value := o.PrefixList.ValueStringPointer()
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapMatchAddress)
	}
	(*obj).PrefixList = prefixList_value
	(*obj).AccessList = accessList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Ospfv3RibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Ospfv3RibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *routemapsredistribution.RipBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(routemapsredistribution.RipBgp)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *routemapsredistribution.RipOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(routemapsredistribution.RipOspf)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rib_entry *routemapsredistribution.RipRib
	if !o.Rib.IsUnknown() && !o.Rib.IsNull() {
		if *obj != nil && (*obj).Rib != nil {
			rib_entry = (*obj).Rib
		} else {
			rib_entry = new(routemapsredistribution.RipRib)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject
		diags.Append(o.Rib.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rib_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.Rip)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Rib = rib_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.RipBgpRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.RipBgpRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgp)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.RipBgpRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.RipBgpRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.RipBgpRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.RipBgpRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.RipBgpRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.RipBgpRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.RipBgpRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.RipBgpRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregator_entry *routemapsredistribution.RipBgpRouteMapSetAggregator
	if !o.Aggregator.IsUnknown() && !o.Aggregator.IsNull() {
		if *obj != nil && (*obj).Aggregator != nil {
			aggregator_entry = (*obj).Aggregator
		} else {
			aggregator_entry = new(routemapsredistribution.RipBgpRouteMapSetAggregator)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject
		diags.Append(o.Aggregator.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregator_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var metric_entry *routemapsredistribution.RipBgpRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.RipBgpRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv4_entry *routemapsredistribution.RipBgpRouteMapSetIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(routemapsredistribution.RipBgpRouteMapSetIpv4)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	tag_value := o.Tag.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	atomicAggregate_value := o.AtomicAggregate.ValueBoolPointer()
	originatorId_value := o.OriginatorId.ValueStringPointer()
	var aspathPrepends_pango_entries []int64
	if !o.AspathPrepends.IsUnknown() && !o.AspathPrepends.IsNull() {
		object_entries := make([]types.Int64, 0, len(o.AspathPrepends.Elements()))
		diags.Append(o.AspathPrepends.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			aspathPrepends_pango_entries = append(aspathPrepends_pango_entries, elt.ValueInt64())
		}
	}
	var regularCommunities_pango_entries []string
	if !o.RegularCommunities.IsUnknown() && !o.RegularCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.RegularCommunities.Elements()))
		diags.Append(o.RegularCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			regularCommunities_pango_entries = append(regularCommunities_pango_entries, elt.ValueString())
		}
	}
	var largeCommunities_pango_entries []string
	if !o.LargeCommunities.IsUnknown() && !o.LargeCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.LargeCommunities.Elements()))
		diags.Append(o.LargeCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			largeCommunities_pango_entries = append(largeCommunities_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunities_pango_entries []string
	if !o.ExtendedCommunities.IsUnknown() && !o.ExtendedCommunities.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunities.Elements()))
		diags.Append(o.ExtendedCommunities.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunities_pango_entries = append(extendedCommunities_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSet)
	}
	(*obj).Aggregator = aggregator_entry
	(*obj).Metric = metric_entry
	(*obj).Ipv4 = ipv4_entry
	(*obj).Tag = tag_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AtomicAggregate = atomicAggregate_value
	(*obj).OriginatorId = originatorId_value
	(*obj).AspathPrepend = aspathPrepends_pango_entries
	(*obj).RegularCommunity = regularCommunities_pango_entries
	(*obj).LargeCommunity = largeCommunities_pango_entries
	(*obj).ExtendedCommunity = extendedCommunities_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	as_value := o.As.ValueInt64Pointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSetAggregator)
	}
	(*obj).As = as_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	nextHop_value := o.NextHop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipBgpRouteMapSetIpv4)
	}
	(*obj).SourceAddress = sourceAddress_value
	(*obj).NextHop = nextHop_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.RipOspfRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.RipOspfRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspf)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.RipOspfRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.RipOspfRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.RipOspfRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.RipOspfRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.RipOspfRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.RipOspfRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.RipOspfRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.RipOspfRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var metric_entry *routemapsredistribution.RipOspfRouteMapSetMetric
	if !o.Metric.IsUnknown() && !o.Metric.IsNull() {
		if *obj != nil && (*obj).Metric != nil {
			metric_entry = (*obj).Metric
		} else {
			metric_entry = new(routemapsredistribution.RipOspfRouteMapSetMetric)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject
		diags.Append(o.Metric.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &metric_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	metricType_value := o.MetricType.ValueStringPointer()
	tag_value := o.Tag.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapSet)
	}
	(*obj).Metric = metric_entry
	(*obj).MetricType = metricType_value
	(*obj).Tag = tag_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueInt64Pointer()
	action_value := o.Action.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipOspfRouteMapSetMetric)
	}
	(*obj).Value = value_value
	(*obj).Action = action_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject
	var routeMap_pango_entries []routemapsredistribution.RipRibRouteMap
	{
		d := o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range routeMap_tf_entries {
			var entry *routemapsredistribution.RipRibRouteMap
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			routeMap_pango_entries = append(routeMap_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRib)
	}
	(*obj).RouteMap = routeMap_pango_entries

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	action_value := o.Action.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	var match_entry *routemapsredistribution.RipRibRouteMapMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(routemapsredistribution.RipRibRouteMapMatch)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var set_entry *routemapsredistribution.RipRibRouteMapSet
	if !o.Set.IsUnknown() && !o.Set.IsNull() {
		if *obj != nil && (*obj).Set != nil {
			set_entry = (*obj).Set
		} else {
			set_entry = new(routemapsredistribution.RipRibRouteMapSet)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject
		diags.Append(o.Set.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &set_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMap)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_value
	(*obj).Description = description_value
	(*obj).Match = match_entry
	(*obj).Set = set_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	tag_value := o.Tag.ValueInt64Pointer()
	var address_entry *routemapsredistribution.RipRibRouteMapMatchAddress
	if !o.Address.IsUnknown() && !o.Address.IsNull() {
		if *obj != nil && (*obj).Address != nil {
			address_entry = (*obj).Address
		} else {
			address_entry = new(routemapsredistribution.RipRibRouteMapMatchAddress)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject
		diags.Append(o.Address.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &address_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *routemapsredistribution.RipRibRouteMapMatchNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(routemapsredistribution.RipRibRouteMapMatchNextHop)
		}
		var object *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapMatch)
	}
	(*obj).Interface = interface_value
	(*obj).Metric = metric_value
	(*obj).Tag = tag_value
	(*obj).Address = address_entry
	(*obj).NextHop = nextHop_entry

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapMatchAddress)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	prefixList_value := o.PrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapMatchNextHop)
	}
	(*obj).AccessList = accessList_value
	(*obj).PrefixList = prefixList_value

	return diags
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **routemapsredistribution.RipRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(routemapsredistribution.RipRibRouteMapSet)
	}
	(*obj).SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, ancestors, obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectedStatic_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject
	if o.ConnectedStatic.IsNull() {
		connectedStatic_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject)
	} else {
		diags.Append(o.ConnectedStatic.As(ctx, &connectedStatic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectedStatic_object := types.ObjectNull(connectedStatic_obj.AttributeTypes())
	if obj.ConnectedStatic != nil {
		diags.Append(connectedStatic_obj.CopyFromPango(ctx, client, ancestors, obj.ConnectedStatic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectedStatic_object, diags_tmp = types.ObjectValueFrom(ctx, connectedStatic_obj.AttributeTypes(), connectedStatic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, ancestors, obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, ancestors, obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, ancestors, obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Bgp = bgp_object
	o.ConnectedStatic = connectedStatic_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Rib = rib_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeSource_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject
	if o.RouteSource.IsNull() {
		routeSource_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject)
	} else {
		diags.Append(o.RouteSource.As(ctx, &routeSource_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routeSource_object := types.ObjectNull(routeSource_obj.AttributeTypes())
	if obj.RouteSource != nil {
		diags.Append(routeSource_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouteSource, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routeSource_object, diags_tmp = types.ObjectValueFrom(ctx, routeSource_obj.AttributeTypes(), routeSource_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object
	o.RouteSource = routeSource_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapMatchIpv4RouteSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpOspfv3RouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeSource_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject
	if o.RouteSource.IsNull() {
		routeSource_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject)
	} else {
		diags.Append(o.RouteSource.As(ctx, &routeSource_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routeSource_object := types.ObjectNull(routeSource_obj.AttributeTypes())
	if obj.RouteSource != nil {
		diags.Append(routeSource_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouteSource, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routeSource_object, diags_tmp = types.ObjectValueFrom(ctx, routeSource_obj.AttributeTypes(), routeSource_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object
	o.RouteSource = routeSource_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv4RouteSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathAccessList_value types.String
	if obj.AsPathAccessList != nil {
		asPathAccessList_value = types.StringValue(*obj.AsPathAccessList)
	}
	var regularCommunities_value types.String
	if obj.RegularCommunity != nil {
		regularCommunities_value = types.StringValue(*obj.RegularCommunity)
	}
	var largeCommunities_value types.String
	if obj.LargeCommunity != nil {
		largeCommunities_value = types.StringValue(*obj.LargeCommunity)
	}
	var extendedCommunities_value types.String
	if obj.ExtendedCommunity != nil {
		extendedCommunities_value = types.StringValue(*obj.ExtendedCommunity)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var peer_value types.String
	if obj.Peer != nil {
		peer_value = types.StringValue(*obj.Peer)
	}
	o.AsPathAccessList = asPathAccessList_value
	o.RegularCommunities = regularCommunities_value
	o.LargeCommunities = largeCommunities_value
	o.ExtendedCommunities = extendedCommunities_value
	o.Interface = interface_value
	o.Origin = origin_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Peer = peer_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeSource_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject
	if o.RouteSource.IsNull() {
		routeSource_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject)
	} else {
		diags.Append(o.RouteSource.As(ctx, &routeSource_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routeSource_object := types.ObjectNull(routeSource_obj.AttributeTypes())
	if obj.RouteSource != nil {
		diags.Append(routeSource_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouteSource, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routeSource_object, diags_tmp = types.ObjectValueFrom(ctx, routeSource_obj.AttributeTypes(), routeSource_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object
	o.RouteSource = routeSource_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapMatchIpv4RouteSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapMatchIpv4RouteSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.NextHop = nextHop_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceBgpRipRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.BgpRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Rib = rib_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticBgpRouteMapSetIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticBgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticOspfv3RouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticOspfv3RouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapMatchIpv6NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapMatchIpv6NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Ipv4 = ipv4_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4AddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapMatchIpv4NextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapMatchIpv4NextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.NextHop = nextHop_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceConnectedStaticRipRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.ConnectedStaticRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject
	if o.Rip.IsNull() {
		rip_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Rib = rib_object
	o.Rip = rip_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv4 = ipv4_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfBgpRouteMapSetIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.NextHop = nextHop_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfRipRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.OspfRipRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Rib = rib_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.PrefixList = prefixList_value
	o.AccessList = accessList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv6 = ipv6_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3BgpRouteMapSetIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3BgpRouteMapSetIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3Rib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.PrefixList = prefixList_value
	o.AccessList = accessList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceOspfv3RibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Ospfv3RibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bgp_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rib_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject
	if o.Rib.IsNull() {
		rib_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject)
	} else {
		diags.Append(o.Rib.As(ctx, &rib_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rib_object := types.ObjectNull(rib_obj.AttributeTypes())
	if obj.Rib != nil {
		diags.Append(rib_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rib, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rib_object, diags_tmp = types.ObjectValueFrom(ctx, rib_obj.AttributeTypes(), rib_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Rib = rib_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aspathPrepends_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]int64, 0)
		if o.AspathPrepends.IsNull() || len(obj.AspathPrepend) > 0 {
			entries = obj.AspathPrepend
		}

		aspathPrepends_list, list_diags = types.ListValueFrom(ctx, types.Int64Type, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var regularCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.RegularCommunities.IsNull() || len(obj.RegularCommunity) > 0 {
			entries = obj.RegularCommunity
		}

		regularCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var largeCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.LargeCommunities.IsNull() || len(obj.LargeCommunity) > 0 {
			entries = obj.LargeCommunity
		}

		largeCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunities_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunities.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunities_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var aggregator_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject
	if o.Aggregator.IsNull() {
		aggregator_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject)
	} else {
		diags.Append(o.Aggregator.As(ctx, &aggregator_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregator_object := types.ObjectNull(aggregator_obj.AttributeTypes())
	if obj.Aggregator != nil {
		diags.Append(aggregator_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregator, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregator_object, diags_tmp = types.ObjectValueFrom(ctx, aggregator_obj.AttributeTypes(), aggregator_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv4_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var atomicAggregate_value types.Bool
	if obj.AtomicAggregate != nil {
		atomicAggregate_value = types.BoolValue(*obj.AtomicAggregate)
	}
	var originatorId_value types.String
	if obj.OriginatorId != nil {
		originatorId_value = types.StringValue(*obj.OriginatorId)
	}
	o.Aggregator = aggregator_object
	o.Metric = metric_object
	o.Ipv4 = ipv4_object
	o.Tag = tag_value
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AtomicAggregate = atomicAggregate_value
	o.OriginatorId = originatorId_value
	o.AspathPrepends = aspathPrepends_list
	o.RegularCommunities = regularCommunities_list
	o.LargeCommunities = largeCommunities_list
	o.ExtendedCommunities = extendedCommunities_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetAggregatorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSetAggregator, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var as_value types.Int64
	if obj.As != nil {
		as_value = types.Int64Value(*obj.As)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.As = as_value
	o.RouterId = routerId_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipBgpRouteMapSetIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipBgpRouteMapSetIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var nextHop_value types.String
	if obj.NextHop != nil {
		nextHop_value = types.StringValue(*obj.NextHop)
	}
	o.SourceAddress = sourceAddress_value
	o.NextHop = nextHop_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject
	if o.Metric.IsNull() {
		metric_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject)
	} else {
		diags.Append(o.Metric.As(ctx, &metric_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	metric_object := types.ObjectNull(metric_obj.AttributeTypes())
	if obj.Metric != nil {
		diags.Append(metric_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Metric, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		metric_object, diags_tmp = types.ObjectValueFrom(ctx, metric_obj.AttributeTypes(), metric_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Metric = metric_object
	o.MetricType = metricType_value
	o.Tag = tag_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipOspfRouteMapSetMetricObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipOspfRouteMapSetMetric, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	o.Value = value_value
	o.Action = action_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRib, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeMap_list types.List
	{
		var routeMap_tf_entries []FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject
		if !o.RouteMap.IsNull() {
			diags.Append(o.RouteMap.ElementsAs(ctx, &routeMap_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RouteMap {
			entry := FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(routeMap_tf_entries) {
				entry = routeMap_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(routeMap_tf_entries) {
				routeMap_tf_entries[idx] = entry
			} else {
				routeMap_tf_entries = append(routeMap_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("route_map")
		routeMap_list, list_diags = types.ListValueFrom(ctx, schemaType, routeMap_tf_entries)
		diags.Append(list_diags...)
	}

	o.RouteMap = routeMap_list

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject
	if o.Match.IsNull() {
		match_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var set_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject
	if o.Set.IsNull() {
		set_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject)
	} else {
		diags.Append(o.Set.As(ctx, &set_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	set_object := types.ObjectNull(set_obj.AttributeTypes())
	if obj.Set != nil {
		diags.Append(set_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Set, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		set_object, diags_tmp = types.ObjectValueFrom(ctx, set_obj.AttributeTypes(), set_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_value types.String
	if obj.Action != nil {
		action_value = types.StringValue(*obj.Action)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_value
	o.Description = description_value
	o.Match = match_object
	o.Set = set_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var address_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject
	if o.Address.IsNull() {
		address_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject)
	} else {
		diags.Append(o.Address.As(ctx, &address_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	address_object := types.ObjectNull(address_obj.AttributeTypes())
	if obj.Address != nil {
		diags.Append(address_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Address, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		address_object, diags_tmp = types.ObjectValueFrom(ctx, address_obj.AttributeTypes(), address_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var tag_value types.Int64
	if obj.Tag != nil {
		tag_value = types.Int64Value(*obj.Tag)
	}
	o.Interface = interface_value
	o.Metric = metric_value
	o.Tag = tag_value
	o.Address = address_object
	o.NextHop = nextHop_object

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapMatchAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapMatchNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapMatchNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var prefixList_value types.String
	if obj.PrefixList != nil {
		prefixList_value = types.StringValue(*obj.PrefixList)
	}
	o.AccessList = accessList_value
	o.PrefixList = prefixList_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceRipRibRouteMapSetObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *routemapsredistribution.RipRibRouteMapSet, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state FiltersRouteMapsRedistributionRoutingProfileResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_filters_route_maps_redistribution_routing_profile_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location routemapsredistribution.Location

	{
		var terraformLocation FiltersRouteMapsRedistributionRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &routemapsredistribution.NgfwLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &routemapsredistribution.TemplateLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &routemapsredistribution.TemplateStackLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *routemapsredistribution.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *FiltersRouteMapsRedistributionRoutingProfileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state FiltersRouteMapsRedistributionRoutingProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location routemapsredistribution.Location

	{
		var terraformLocation FiltersRouteMapsRedistributionRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &routemapsredistribution.NgfwLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &routemapsredistribution.TemplateLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &routemapsredistribution.TemplateStackLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_filters_route_maps_redistribution_routing_profile_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *FiltersRouteMapsRedistributionRoutingProfileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state FiltersRouteMapsRedistributionRoutingProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location routemapsredistribution.Location

	{
		var terraformLocation FiltersRouteMapsRedistributionRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &routemapsredistribution.NgfwLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &routemapsredistribution.TemplateLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &routemapsredistribution.TemplateStackLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_filters_route_maps_redistribution_routing_profile_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var obj *routemapsredistribution.Entry
	if state.Name.ValueString() != plan.Name.ValueString() {
		obj, err = o.manager.Read(ctx, location, components, state.Name.ValueString())
	} else {
		obj, err = o.manager.Read(ctx, location, components, plan.Name.ValueString())
	}
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	// If name differs between plan and state, we need to set old name for the object
	// before calling SDK Update() function to properly handle rename + edit cycle.
	var newName string
	if state.Name.ValueString() != plan.Name.ValueString() {
		newName = plan.Name.ValueString()
		obj.Name = state.Name.ValueString()
	}

	updated, err := o.manager.Update(ctx, location, components, obj, newName)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *FiltersRouteMapsRedistributionRoutingProfileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state FiltersRouteMapsRedistributionRoutingProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_filters_route_maps_redistribution_routing_profile_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location routemapsredistribution.Location

	{
		var terraformLocation FiltersRouteMapsRedistributionRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &routemapsredistribution.NgfwLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &routemapsredistribution.TemplateLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &routemapsredistribution.TemplateStackLocation{}
			var innerLocation FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type FiltersRouteMapsRedistributionRoutingProfileImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o FiltersRouteMapsRedistributionRoutingProfileImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *FiltersRouteMapsRedistributionRoutingProfileLocation `json:"location"`
		Name     *string                                               `json:"name"`
	}
	var location_object *FiltersRouteMapsRedistributionRoutingProfileLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *FiltersRouteMapsRedistributionRoutingProfileImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *FiltersRouteMapsRedistributionRoutingProfileLocation `json:"location"`
		Name     *string                                               `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func FiltersRouteMapsRedistributionRoutingProfileImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := FiltersRouteMapsRedistributionRoutingProfileImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *FiltersRouteMapsRedistributionRoutingProfileResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj FiltersRouteMapsRedistributionRoutingProfileImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type FiltersRouteMapsRedistributionRoutingProfileNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type FiltersRouteMapsRedistributionRoutingProfileTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type FiltersRouteMapsRedistributionRoutingProfileLocation struct {
	Ngfw          types.Object `tfsdk:"ngfw"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func FiltersRouteMapsRedistributionRoutingProfileLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o FiltersRouteMapsRedistributionRoutingProfileNgfwLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *FiltersRouteMapsRedistributionRoutingProfileNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o FiltersRouteMapsRedistributionRoutingProfileTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *FiltersRouteMapsRedistributionRoutingProfileTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o FiltersRouteMapsRedistributionRoutingProfileLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Ngfw          *FiltersRouteMapsRedistributionRoutingProfileNgfwLocation          `json:"ngfw,omitempty"`
		Template      *FiltersRouteMapsRedistributionRoutingProfileTemplateLocation      `json:"template,omitempty"`
		TemplateStack *FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var ngfw_object *FiltersRouteMapsRedistributionRoutingProfileNgfwLocation
	{
		diags := o.Ngfw.As(context.TODO(), &ngfw_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal ngfw into JSON document", diags.Errors())
		}
	}
	var template_object *FiltersRouteMapsRedistributionRoutingProfileTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Ngfw:          ngfw_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *FiltersRouteMapsRedistributionRoutingProfileLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Ngfw          *FiltersRouteMapsRedistributionRoutingProfileNgfwLocation          `json:"ngfw,omitempty"`
		Template      *FiltersRouteMapsRedistributionRoutingProfileTemplateLocation      `json:"template,omitempty"`
		TemplateStack *FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var ngfw_object types.Object
	{
		var diags_tmp diag.Diagnostics
		ngfw_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Ngfw.AttributeTypes(), shadow.Ngfw)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into ngfw", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.Ngfw = ngfw_object
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *FiltersRouteMapsRedistributionRoutingProfileNgfwLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *FiltersRouteMapsRedistributionRoutingProfileTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *FiltersRouteMapsRedistributionRoutingProfileLocation) AttributeTypes() map[string]attr.Type {
	var ngfwObj FiltersRouteMapsRedistributionRoutingProfileNgfwLocation
	var templateObj FiltersRouteMapsRedistributionRoutingProfileTemplateLocation
	var templateStackObj FiltersRouteMapsRedistributionRoutingProfileTemplateStackLocation
	return map[string]attr.Type{
		"ngfw": types.ObjectType{
			AttrTypes: ngfwObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
