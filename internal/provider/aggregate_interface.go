package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/interface/aggregate"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &AggregateInterfaceDataSource{}
	_ datasource.DataSourceWithConfigure = &AggregateInterfaceDataSource{}
)

func NewAggregateInterfaceDataSource() datasource.DataSource {
	return &AggregateInterfaceDataSource{}
}

type AggregateInterfaceDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*aggregate.Entry, aggregate.Location, *aggregate.Service]
}

type AggregateInterfaceDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type AggregateInterfaceDataSourceModel struct {
	Location      AggregateInterfaceLocation                       `tfsdk:"location"`
	Name          types.String                                     `tfsdk:"name"`
	Comment       types.String                                     `tfsdk:"comment"`
	DecryptMirror *AggregateInterfaceDataSourceDecryptMirrorObject `tfsdk:"decrypt_mirror"`
	Ha            *AggregateInterfaceDataSourceHaObject            `tfsdk:"ha"`
	Layer2        *AggregateInterfaceDataSourceLayer2Object        `tfsdk:"layer2"`
	Layer3        *AggregateInterfaceDataSourceLayer3Object        `tfsdk:"layer3"`
	VirtualWire   *AggregateInterfaceDataSourceVirtualWireObject   `tfsdk:"virtual_wire"`
}
type AggregateInterfaceDataSourceDecryptMirrorObject struct {
}
type AggregateInterfaceDataSourceHaObject struct {
	Lacp *AggregateInterfaceDataSourceHaLacpObject `tfsdk:"lacp"`
}
type AggregateInterfaceDataSourceHaLacpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	FastFailover     types.Bool   `tfsdk:"fast_failover"`
	MaxPorts         types.Int64  `tfsdk:"max_ports"`
	Mode             types.String `tfsdk:"mode"`
	SystemPriority   types.Int64  `tfsdk:"system_priority"`
	TransmissionRate types.String `tfsdk:"transmission_rate"`
}
type AggregateInterfaceDataSourceLayer2Object struct {
	Lacp           *AggregateInterfaceDataSourceLayer2LacpObject `tfsdk:"lacp"`
	Lldp           *AggregateInterfaceDataSourceLayer2LldpObject `tfsdk:"lldp"`
	NetflowProfile types.String                                  `tfsdk:"netflow_profile"`
}
type AggregateInterfaceDataSourceLayer2LacpObject struct {
	Enable           types.Bool                                                    `tfsdk:"enable"`
	FastFailover     types.Bool                                                    `tfsdk:"fast_failover"`
	HighAvailability *AggregateInterfaceDataSourceLayer2LacpHighAvailabilityObject `tfsdk:"high_availability"`
	MaxPorts         types.Int64                                                   `tfsdk:"max_ports"`
	Mode             types.String                                                  `tfsdk:"mode"`
	SystemPriority   types.Int64                                                   `tfsdk:"system_priority"`
	TransmissionRate types.String                                                  `tfsdk:"transmission_rate"`
}
type AggregateInterfaceDataSourceLayer2LacpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceDataSourceLayer2LldpObject struct {
	Enable           types.Bool                                                    `tfsdk:"enable"`
	HighAvailability *AggregateInterfaceDataSourceLayer2LldpHighAvailabilityObject `tfsdk:"high_availability"`
	Profile          types.String                                                  `tfsdk:"profile"`
}
type AggregateInterfaceDataSourceLayer2LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceDataSourceLayer3Object struct {
	AdjustTcpMss               *AggregateInterfaceDataSourceLayer3AdjustTcpMssObject      `tfsdk:"adjust_tcp_mss"`
	Arp                        types.List                                                 `tfsdk:"arp"`
	Bonjour                    *AggregateInterfaceDataSourceLayer3BonjourObject           `tfsdk:"bonjour"`
	DdnsConfig                 *AggregateInterfaceDataSourceLayer3DdnsConfigObject        `tfsdk:"ddns_config"`
	DecryptForward             types.Bool                                                 `tfsdk:"decrypt_forward"`
	DfIgnore                   types.Bool                                                 `tfsdk:"df_ignore"`
	DhcpClient                 *AggregateInterfaceDataSourceLayer3DhcpClientObject        `tfsdk:"dhcp_client"`
	InterfaceManagementProfile types.String                                               `tfsdk:"interface_management_profile"`
	Ip                         types.List                                                 `tfsdk:"ip"`
	Ipv6                       *AggregateInterfaceDataSourceLayer3Ipv6Object              `tfsdk:"ipv6"`
	Lacp                       *AggregateInterfaceDataSourceLayer3LacpObject              `tfsdk:"lacp"`
	Lldp                       *AggregateInterfaceDataSourceLayer3LldpObject              `tfsdk:"lldp"`
	Mtu                        types.Int64                                                `tfsdk:"mtu"`
	NdpProxy                   *AggregateInterfaceDataSourceLayer3NdpProxyObject          `tfsdk:"ndp_proxy"`
	NetflowProfile             types.String                                               `tfsdk:"netflow_profile"`
	SdwanLinkSettings          *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsObject `tfsdk:"sdwan_link_settings"`
	UntaggedSubInterface       types.Bool                                                 `tfsdk:"untagged_sub_interface"`
}
type AggregateInterfaceDataSourceLayer3AdjustTcpMssObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	Ipv4MssAdjustment types.Int64 `tfsdk:"ipv4_mss_adjustment"`
	Ipv6MssAdjustment types.Int64 `tfsdk:"ipv6_mss_adjustment"`
}
type AggregateInterfaceDataSourceLayer3ArpObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceDataSourceLayer3BonjourObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	GroupId  types.Int64 `tfsdk:"group_id"`
	TtlCheck types.Bool  `tfsdk:"ttl_check"`
}
type AggregateInterfaceDataSourceLayer3DdnsConfigObject struct {
	DdnsCertProfile    types.String `tfsdk:"ddns_cert_profile"`
	DdnsEnabled        types.Bool   `tfsdk:"ddns_enabled"`
	DdnsHostname       types.String `tfsdk:"ddns_hostname"`
	DdnsIp             types.List   `tfsdk:"ddns_ip"`
	DdnsIpv6           types.List   `tfsdk:"ddns_ipv6"`
	DdnsUpdateInterval types.Int64  `tfsdk:"ddns_update_interval"`
	DdnsVendor         types.String `tfsdk:"ddns_vendor"`
	DdnsVendorConfig   types.List   `tfsdk:"ddns_vendor_config"`
}
type AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type AggregateInterfaceDataSourceLayer3DhcpClientObject struct {
	CreateDefaultRoute types.Bool                                                      `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64                                                     `tfsdk:"default_route_metric"`
	Enable             types.Bool                                                      `tfsdk:"enable"`
	SendHostname       *AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameObject `tfsdk:"send_hostname"`
}
type AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	Hostname types.String `tfsdk:"hostname"`
}
type AggregateInterfaceDataSourceLayer3IpObject struct {
	Name         types.String `tfsdk:"name"`
	SdwanGateway types.String `tfsdk:"sdwan_gateway"`
}
type AggregateInterfaceDataSourceLayer3Ipv6Object struct {
	Address           types.List                                                     `tfsdk:"address"`
	Enabled           types.Bool                                                     `tfsdk:"enabled"`
	InterfaceId       types.String                                                   `tfsdk:"interface_id"`
	NeighborDiscovery *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
	DhcpClient        *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientObject        `tfsdk:"dhcp_client"`
	Inherited         *AggregateInterfaceDataSourceLayer3Ipv6InheritedObject         `tfsdk:"inherited"`
}
type AggregateInterfaceDataSourceLayer3Ipv6AddressObject struct {
	Name              types.String                                                  `tfsdk:"name"`
	EnableOnInterface types.Bool                                                    `tfsdk:"enable_on_interface"`
	Prefix            *AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixObject    `tfsdk:"prefix"`
	Anycast           *AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastObject   `tfsdk:"anycast"`
	Advertise         *AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseObject `tfsdk:"advertise"`
}
type AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixObject struct {
}
type AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastObject struct {
}
type AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject struct {
	DadAttempts         types.Int64                                                                       `tfsdk:"dad_attempts"`
	EnableDad           types.Bool                                                                        `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool                                                                        `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List                                                                        `tfsdk:"neighbor"`
	NsInterval          types.Int64                                                                       `tfsdk:"ns_interval"`
	ReachableTime       types.Int64                                                                       `tfsdk:"reachable_time"`
	RouterAdvertisement *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject `tfsdk:"router_advertisement"`
}
type AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject struct {
	DnsSupport             *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject `tfsdk:"dns_support"`
	Enable                 types.Bool                                                                                  `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool                                                                                  `tfsdk:"enable_consistency_check"`
	HopLimit               types.String                                                                                `tfsdk:"hop_limit"`
	Lifetime               types.Int64                                                                                 `tfsdk:"lifetime"`
	LinkMtu                types.String                                                                                `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool                                                                                  `tfsdk:"managed_flag"`
	MaxInterval            types.Int64                                                                                 `tfsdk:"max_interval"`
	MinInterval            types.Int64                                                                                 `tfsdk:"min_interval"`
	OtherFlag              types.Bool                                                                                  `tfsdk:"other_flag"`
	ReachableTime          types.String                                                                                `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String                                                                                `tfsdk:"retransmission_timer"`
	RouterPreference       types.String                                                                                `tfsdk:"router_preference"`
}
type AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject struct {
	Enable types.Bool `tfsdk:"enable"`
	Server types.List `tfsdk:"server"`
	Suffix types.List `tfsdk:"suffix"`
}
type AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientObject struct {
	AcceptRaRoute      types.Bool                                                               `tfsdk:"accept_ra_route"`
	DefaultRouteMetric types.Int64                                                              `tfsdk:"default_route_metric"`
	Enable             types.Bool                                                               `tfsdk:"enable"`
	NeighborDiscovery  *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
	Preference         types.String                                                             `tfsdk:"preference"`
	PrefixDelegation   *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject  `tfsdk:"prefix_delegation"`
	V6Options          *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject         `tfsdk:"v6_options"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject struct {
	DadAttempts      types.Int64                                                                       `tfsdk:"dad_attempts"`
	DnsServer        *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject `tfsdk:"dns_server"`
	DnsSuffix        *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject `tfsdk:"dns_suffix"`
	EnableDad        types.Bool                                                                        `tfsdk:"enable_dad"`
	EnableNdpMonitor types.Bool                                                                        `tfsdk:"enable_ndp_monitor"`
	Neighbor         types.List                                                                        `tfsdk:"neighbor"`
	NsInterval       types.Int64                                                                       `tfsdk:"ns_interval"`
	ReachableTime    types.Int64                                                                       `tfsdk:"reachable_time"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool                                                                              `tfsdk:"enable"`
	Source *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject `tfsdk:"source"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool                                                                              `tfsdk:"enable"`
	Source *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject `tfsdk:"source"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject struct {
	Enable *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject `tfsdk:"enable"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject struct {
	No  *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject  `tfsdk:"no"`
	Yes *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject `tfsdk:"yes"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject struct {
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject struct {
	PfxPoolName   types.String `tfsdk:"pfx_pool_name"`
	PrefixLen     types.Int64  `tfsdk:"prefix_len"`
	PrefixLenHint types.Bool   `tfsdk:"prefix_len_hint"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject struct {
	DuidType            types.String                                                           `tfsdk:"duid_type"`
	Enable              *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject `tfsdk:"enable"`
	RapidCommit         types.Bool                                                             `tfsdk:"rapid_commit"`
	SupportSrvrReconfig types.Bool                                                             `tfsdk:"support_srvr_reconfig"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject struct {
	No  *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject  `tfsdk:"no"`
	Yes *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject `tfsdk:"yes"`
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject struct {
}
type AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject struct {
	NonTempAddr types.Bool `tfsdk:"non_temp_addr"`
	TempAddr    types.Bool `tfsdk:"temp_addr"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedObject struct {
	AssignAddr        types.List                                                              `tfsdk:"assign_addr"`
	Enable            types.Bool                                                              `tfsdk:"enable"`
	NeighborDiscovery *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject struct {
	Name types.String                                                         `tfsdk:"name"`
	Type *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject `tfsdk:"type"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject struct {
	Gua *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject `tfsdk:"gua"`
	Ula *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject `tfsdk:"ula"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject struct {
	EnableOnInterface types.Bool                                                                       `tfsdk:"enable_on_interface"`
	PrefixPool        types.String                                                                     `tfsdk:"prefix_pool"`
	PoolType          *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject  `tfsdk:"pool_type"`
	Advertise         *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject `tfsdk:"advertise"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject struct {
	Dynamic   *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject   `tfsdk:"dynamic"`
	DynamicId *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject `tfsdk:"dynamic_id"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject struct {
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject struct {
	Identifier types.Int64 `tfsdk:"identifier"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject struct {
	Enable         types.Bool `tfsdk:"enable"`
	OnlinkFlag     types.Bool `tfsdk:"onlink_flag"`
	AutoConfigFlag types.Bool `tfsdk:"auto_config_flag"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject struct {
	EnableOnInterface types.Bool                                                                       `tfsdk:"enable_on_interface"`
	Address           types.String                                                                     `tfsdk:"address"`
	Prefix            types.Bool                                                                       `tfsdk:"prefix"`
	Anycast           types.Bool                                                                       `tfsdk:"anycast"`
	Advertise         *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject `tfsdk:"advertise"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject struct {
	DadAttempts         types.Int64                                                                                `tfsdk:"dad_attempts"`
	DnsServer           *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject           `tfsdk:"dns_server"`
	DnsSuffix           *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject           `tfsdk:"dns_suffix"`
	EnableDad           types.Bool                                                                                 `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool                                                                                 `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List                                                                                 `tfsdk:"neighbor"`
	NsInterval          types.Int64                                                                                `tfsdk:"ns_interval"`
	ReachableTime       types.Int64                                                                                `tfsdk:"reachable_time"`
	RouterAdvertisement *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject `tfsdk:"router_advertisement"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool                                                                             `tfsdk:"enable"`
	Source *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject `tfsdk:"source"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool                                                                             `tfsdk:"enable"`
	Source *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject `tfsdk:"source"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject struct {
	Enable                 types.Bool   `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	RouterPreference       types.String `tfsdk:"router_preference"`
}
type AggregateInterfaceDataSourceLayer3LacpObject struct {
	Enable           types.Bool                                                    `tfsdk:"enable"`
	FastFailover     types.Bool                                                    `tfsdk:"fast_failover"`
	HighAvailability *AggregateInterfaceDataSourceLayer3LacpHighAvailabilityObject `tfsdk:"high_availability"`
	MaxPorts         types.Int64                                                   `tfsdk:"max_ports"`
	Mode             types.String                                                  `tfsdk:"mode"`
	SystemPriority   types.Int64                                                   `tfsdk:"system_priority"`
	TransmissionRate types.String                                                  `tfsdk:"transmission_rate"`
}
type AggregateInterfaceDataSourceLayer3LacpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceDataSourceLayer3LldpObject struct {
	Enable           types.Bool                                                    `tfsdk:"enable"`
	HighAvailability *AggregateInterfaceDataSourceLayer3LldpHighAvailabilityObject `tfsdk:"high_availability"`
	Profile          types.String                                                  `tfsdk:"profile"`
}
type AggregateInterfaceDataSourceLayer3LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceDataSourceLayer3NdpProxyObject struct {
	Address types.List `tfsdk:"address"`
	Enabled types.Bool `tfsdk:"enabled"`
}
type AggregateInterfaceDataSourceLayer3NdpProxyAddressObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
}
type AggregateInterfaceDataSourceLayer3SdwanLinkSettingsObject struct {
	Enable                types.Bool                                                            `tfsdk:"enable"`
	SdwanInterfaceProfile types.String                                                          `tfsdk:"sdwan_interface_profile"`
	UpstreamNat           *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject `tfsdk:"upstream_nat"`
}
type AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject struct {
	Enable   types.Bool                                                                    `tfsdk:"enable"`
	Ddns     *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject     `tfsdk:"ddns"`
	StaticIp *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject `tfsdk:"static_ip"`
}
type AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject struct {
}
type AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject struct {
	Fqdn      types.String `tfsdk:"fqdn"`
	IpAddress types.String `tfsdk:"ip_address"`
}
type AggregateInterfaceDataSourceVirtualWireObject struct {
	Lldp           *AggregateInterfaceDataSourceVirtualWireLldpObject `tfsdk:"lldp"`
	NetflowProfile types.String                                       `tfsdk:"netflow_profile"`
}
type AggregateInterfaceDataSourceVirtualWireLldpObject struct {
	Enable           types.Bool                                                         `tfsdk:"enable"`
	HighAvailability *AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilityObject `tfsdk:"high_availability"`
	Profile          types.String                                                       `tfsdk:"profile"`
}
type AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}

func (o *AggregateInterfaceDataSourceModel) CopyToPango(ctx context.Context, obj **aggregate.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	comment_value := o.Comment.ValueStringPointer()
	var decryptMirror_entry *aggregate.DecryptMirror
	if o.DecryptMirror != nil {
		if *obj != nil && (*obj).DecryptMirror != nil {
			decryptMirror_entry = (*obj).DecryptMirror
		} else {
			decryptMirror_entry = new(aggregate.DecryptMirror)
		}

		diags.Append(o.DecryptMirror.CopyToPango(ctx, &decryptMirror_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_entry *aggregate.Ha
	if o.Ha != nil {
		if *obj != nil && (*obj).Ha != nil {
			ha_entry = (*obj).Ha
		} else {
			ha_entry = new(aggregate.Ha)
		}

		diags.Append(o.Ha.CopyToPango(ctx, &ha_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer2_entry *aggregate.Layer2
	if o.Layer2 != nil {
		if *obj != nil && (*obj).Layer2 != nil {
			layer2_entry = (*obj).Layer2
		} else {
			layer2_entry = new(aggregate.Layer2)
		}

		diags.Append(o.Layer2.CopyToPango(ctx, &layer2_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_entry *aggregate.Layer3
	if o.Layer3 != nil {
		if *obj != nil && (*obj).Layer3 != nil {
			layer3_entry = (*obj).Layer3
		} else {
			layer3_entry = new(aggregate.Layer3)
		}

		diags.Append(o.Layer3.CopyToPango(ctx, &layer3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var virtualWire_entry *aggregate.VirtualWire
	if o.VirtualWire != nil {
		if *obj != nil && (*obj).VirtualWire != nil {
			virtualWire_entry = (*obj).VirtualWire
		} else {
			virtualWire_entry = new(aggregate.VirtualWire)
		}

		diags.Append(o.VirtualWire.CopyToPango(ctx, &virtualWire_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Comment = comment_value
	(*obj).DecryptMirror = decryptMirror_entry
	(*obj).Ha = ha_entry
	(*obj).Layer2 = layer2_entry
	(*obj).Layer3 = layer3_entry
	(*obj).VirtualWire = virtualWire_entry

	return diags
}
func (o *AggregateInterfaceDataSourceDecryptMirrorObject) CopyToPango(ctx context.Context, obj **aggregate.DecryptMirror, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.DecryptMirror)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceHaObject) CopyToPango(ctx context.Context, obj **aggregate.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_entry *aggregate.HaLacp
	if o.Lacp != nil {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(aggregate.HaLacp)
		}

		diags.Append(o.Lacp.CopyToPango(ctx, &lacp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Ha)
	}
	(*obj).Lacp = lacp_entry

	return diags
}
func (o *AggregateInterfaceDataSourceHaLacpObject) CopyToPango(ctx context.Context, obj **aggregate.HaLacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	fastFailover_value := o.FastFailover.ValueBoolPointer()
	maxPorts_value := o.MaxPorts.ValueInt64Pointer()
	mode_value := o.Mode.ValueStringPointer()
	systemPriority_value := o.SystemPriority.ValueInt64Pointer()
	transmissionRate_value := o.TransmissionRate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.HaLacp)
	}
	(*obj).Enable = enable_value
	(*obj).FastFailover = fastFailover_value
	(*obj).MaxPorts = maxPorts_value
	(*obj).Mode = mode_value
	(*obj).SystemPriority = systemPriority_value
	(*obj).TransmissionRate = transmissionRate_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer2Object) CopyToPango(ctx context.Context, obj **aggregate.Layer2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_entry *aggregate.Layer2Lacp
	if o.Lacp != nil {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(aggregate.Layer2Lacp)
		}

		diags.Append(o.Lacp.CopyToPango(ctx, &lacp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *aggregate.Layer2Lldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(aggregate.Layer2Lldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2)
	}
	(*obj).Lacp = lacp_entry
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer2LacpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	fastFailover_value := o.FastFailover.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer2LacpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer2LacpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPorts_value := o.MaxPorts.ValueInt64Pointer()
	mode_value := o.Mode.ValueStringPointer()
	systemPriority_value := o.SystemPriority.ValueInt64Pointer()
	transmissionRate_value := o.TransmissionRate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2Lacp)
	}
	(*obj).Enable = enable_value
	(*obj).FastFailover = fastFailover_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).MaxPorts = maxPorts_value
	(*obj).Mode = mode_value
	(*obj).SystemPriority = systemPriority_value
	(*obj).TransmissionRate = transmissionRate_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer2LacpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2LacpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer2LldpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer2LldpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer2LldpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer2LldpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var adjustTcpMss_entry *aggregate.Layer3AdjustTcpMss
	if o.AdjustTcpMss != nil {
		if *obj != nil && (*obj).AdjustTcpMss != nil {
			adjustTcpMss_entry = (*obj).AdjustTcpMss
		} else {
			adjustTcpMss_entry = new(aggregate.Layer3AdjustTcpMss)
		}

		diags.Append(o.AdjustTcpMss.CopyToPango(ctx, &adjustTcpMss_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var arp_tf_entries []AggregateInterfaceDataSourceLayer3ArpObject
	var arp_pango_entries []aggregate.Layer3Arp
	{
		d := o.Arp.ElementsAs(ctx, &arp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range arp_tf_entries {
			var entry *aggregate.Layer3Arp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			arp_pango_entries = append(arp_pango_entries, *entry)
		}
	}
	var bonjour_entry *aggregate.Layer3Bonjour
	if o.Bonjour != nil {
		if *obj != nil && (*obj).Bonjour != nil {
			bonjour_entry = (*obj).Bonjour
		} else {
			bonjour_entry = new(aggregate.Layer3Bonjour)
		}

		diags.Append(o.Bonjour.CopyToPango(ctx, &bonjour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsConfig_entry *aggregate.Layer3DdnsConfig
	if o.DdnsConfig != nil {
		if *obj != nil && (*obj).DdnsConfig != nil {
			ddnsConfig_entry = (*obj).DdnsConfig
		} else {
			ddnsConfig_entry = new(aggregate.Layer3DdnsConfig)
		}

		diags.Append(o.DdnsConfig.CopyToPango(ctx, &ddnsConfig_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	decryptForward_value := o.DecryptForward.ValueBoolPointer()
	dfIgnore_value := o.DfIgnore.ValueBoolPointer()
	var dhcpClient_entry *aggregate.Layer3DhcpClient
	if o.DhcpClient != nil {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(aggregate.Layer3DhcpClient)
		}

		diags.Append(o.DhcpClient.CopyToPango(ctx, &dhcpClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceManagementProfile_value := o.InterfaceManagementProfile.ValueStringPointer()
	var ip_tf_entries []AggregateInterfaceDataSourceLayer3IpObject
	var ip_pango_entries []aggregate.Layer3Ip
	{
		d := o.Ip.ElementsAs(ctx, &ip_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ip_tf_entries {
			var entry *aggregate.Layer3Ip
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ip_pango_entries = append(ip_pango_entries, *entry)
		}
	}
	var ipv6_entry *aggregate.Layer3Ipv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(aggregate.Layer3Ipv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lacp_entry *aggregate.Layer3Lacp
	if o.Lacp != nil {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(aggregate.Layer3Lacp)
		}

		diags.Append(o.Lacp.CopyToPango(ctx, &lacp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *aggregate.Layer3Lldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(aggregate.Layer3Lldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	mtu_value := o.Mtu.ValueInt64Pointer()
	var ndpProxy_entry *aggregate.Layer3NdpProxy
	if o.NdpProxy != nil {
		if *obj != nil && (*obj).NdpProxy != nil {
			ndpProxy_entry = (*obj).NdpProxy
		} else {
			ndpProxy_entry = new(aggregate.Layer3NdpProxy)
		}

		diags.Append(o.NdpProxy.CopyToPango(ctx, &ndpProxy_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()
	var sdwanLinkSettings_entry *aggregate.Layer3SdwanLinkSettings
	if o.SdwanLinkSettings != nil {
		if *obj != nil && (*obj).SdwanLinkSettings != nil {
			sdwanLinkSettings_entry = (*obj).SdwanLinkSettings
		} else {
			sdwanLinkSettings_entry = new(aggregate.Layer3SdwanLinkSettings)
		}

		diags.Append(o.SdwanLinkSettings.CopyToPango(ctx, &sdwanLinkSettings_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	untaggedSubInterface_value := o.UntaggedSubInterface.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3)
	}
	(*obj).AdjustTcpMss = adjustTcpMss_entry
	(*obj).Arp = arp_pango_entries
	(*obj).Bonjour = bonjour_entry
	(*obj).DdnsConfig = ddnsConfig_entry
	(*obj).DecryptForward = decryptForward_value
	(*obj).DfIgnore = dfIgnore_value
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).InterfaceManagementProfile = interfaceManagementProfile_value
	(*obj).Ip = ip_pango_entries
	(*obj).Ipv6 = ipv6_entry
	(*obj).Lacp = lacp_entry
	(*obj).Lldp = lldp_entry
	(*obj).Mtu = mtu_value
	(*obj).NdpProxy = ndpProxy_entry
	(*obj).NetflowProfile = netflowProfile_value
	(*obj).SdwanLinkSettings = sdwanLinkSettings_entry
	(*obj).UntaggedSubInterface = untaggedSubInterface_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3AdjustTcpMssObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	ipv4MssAdjustment_value := o.Ipv4MssAdjustment.ValueInt64Pointer()
	ipv6MssAdjustment_value := o.Ipv6MssAdjustment.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3AdjustTcpMss)
	}
	(*obj).Enable = enable_value
	(*obj).Ipv4MssAdjustment = ipv4MssAdjustment_value
	(*obj).Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3ArpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Arp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3BonjourObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	groupId_value := o.GroupId.ValueInt64Pointer()
	ttlCheck_value := o.TtlCheck.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Bonjour)
	}
	(*obj).Enable = enable_value
	(*obj).GroupId = groupId_value
	(*obj).TtlCheck = ttlCheck_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3DdnsConfigObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DdnsConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ddnsCertProfile_value := o.DdnsCertProfile.ValueStringPointer()
	ddnsEnabled_value := o.DdnsEnabled.ValueBoolPointer()
	ddnsHostname_value := o.DdnsHostname.ValueStringPointer()
	ddnsIp_pango_entries := make([]string, 0)
	diags.Append(o.DdnsIp.ElementsAs(ctx, &ddnsIp_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	ddnsIpv6_pango_entries := make([]string, 0)
	diags.Append(o.DdnsIpv6.ElementsAs(ctx, &ddnsIpv6_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	ddnsUpdateInterval_value := o.DdnsUpdateInterval.ValueInt64Pointer()
	ddnsVendor_value := o.DdnsVendor.ValueStringPointer()
	var ddnsVendorConfig_tf_entries []AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject
	var ddnsVendorConfig_pango_entries []aggregate.Layer3DdnsConfigDdnsVendorConfig
	{
		d := o.DdnsVendorConfig.ElementsAs(ctx, &ddnsVendorConfig_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ddnsVendorConfig_tf_entries {
			var entry *aggregate.Layer3DdnsConfigDdnsVendorConfig
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ddnsVendorConfig_pango_entries = append(ddnsVendorConfig_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DdnsConfig)
	}
	(*obj).DdnsCertProfile = ddnsCertProfile_value
	(*obj).DdnsEnabled = ddnsEnabled_value
	(*obj).DdnsHostname = ddnsHostname_value
	(*obj).DdnsIp = ddnsIp_pango_entries
	(*obj).DdnsIpv6 = ddnsIpv6_pango_entries
	(*obj).DdnsUpdateInterval = ddnsUpdateInterval_value
	(*obj).DdnsVendor = ddnsVendor_value
	(*obj).DdnsVendorConfig = ddnsVendorConfig_pango_entries

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DdnsConfigDdnsVendorConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DdnsConfigDdnsVendorConfig)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3DhcpClientObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var sendHostname_entry *aggregate.Layer3DhcpClientSendHostname
	if o.SendHostname != nil {
		if *obj != nil && (*obj).SendHostname != nil {
			sendHostname_entry = (*obj).SendHostname
		} else {
			sendHostname_entry = new(aggregate.Layer3DhcpClientSendHostname)
		}

		diags.Append(o.SendHostname.CopyToPango(ctx, &sendHostname_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DhcpClient)
	}
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).SendHostname = sendHostname_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DhcpClientSendHostname)
	}
	(*obj).Enable = enable_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3IpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	sdwanGateway_value := o.SdwanGateway.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ip)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SdwanGateway = sdwanGateway_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6AddressObject
	var address_pango_entries []aggregate.Layer3Ipv6Address
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *aggregate.Layer3Ipv6Address
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()
	interfaceId_value := o.InterfaceId.ValueStringPointer()
	var neighborDiscovery_entry *aggregate.Layer3Ipv6NeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(aggregate.Layer3Ipv6NeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_entry *aggregate.Layer3Ipv6DhcpClient
	if o.DhcpClient != nil {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(aggregate.Layer3Ipv6DhcpClient)
		}

		diags.Append(o.DhcpClient.CopyToPango(ctx, &dhcpClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var inherited_entry *aggregate.Layer3Ipv6Inherited
	if o.Inherited != nil {
		if *obj != nil && (*obj).Inherited != nil {
			inherited_entry = (*obj).Inherited
		} else {
			inherited_entry = new(aggregate.Layer3Ipv6Inherited)
		}

		diags.Append(o.Inherited.CopyToPango(ctx, &inherited_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6)
	}
	(*obj).Address = address_pango_entries
	(*obj).Enabled = enabled_value
	(*obj).InterfaceId = interfaceId_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).Inherited = inherited_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6Address, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	var prefix_entry *aggregate.Layer3Ipv6AddressPrefix
	if o.Prefix != nil {
		if *obj != nil && (*obj).Prefix != nil {
			prefix_entry = (*obj).Prefix
		} else {
			prefix_entry = new(aggregate.Layer3Ipv6AddressPrefix)
		}

		diags.Append(o.Prefix.CopyToPango(ctx, &prefix_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var anycast_entry *aggregate.Layer3Ipv6AddressAnycast
	if o.Anycast != nil {
		if *obj != nil && (*obj).Anycast != nil {
			anycast_entry = (*obj).Anycast
		} else {
			anycast_entry = new(aggregate.Layer3Ipv6AddressAnycast)
		}

		diags.Append(o.Anycast.CopyToPango(ctx, &anycast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *aggregate.Layer3Ipv6AddressAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(aggregate.Layer3Ipv6AddressAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6Address)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Prefix = prefix_entry
	(*obj).Anycast = anycast_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6AddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6AddressPrefix)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6AddressAnycast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6AddressAnycast)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6AddressAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6AddressAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
	var neighbor_pango_entries []aggregate.Layer3Ipv6NeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *aggregate.Layer3Ipv6NeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement
	if o.RouterAdvertisement != nil {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
		}

		diags.Append(o.RouterAdvertisement.CopyToPango(ctx, &routerAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport
	if o.DnsSupport != nil {
		if *obj != nil && (*obj).DnsSupport != nil {
			dnsSupport_entry = (*obj).DnsSupport
		} else {
			dnsSupport_entry = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
		}

		diags.Append(o.DnsSupport.CopyToPango(ctx, &dnsSupport_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
	}
	(*obj).DnsSupport = dnsSupport_entry
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var server_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
	var server_pango_entries []aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}
	var suffix_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
	var suffix_pango_entries []aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
	}
	(*obj).Enable = enable_value
	(*obj).Server = server_pango_entries
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptRaRoute_value := o.AcceptRaRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	preference_value := o.Preference.ValueStringPointer()
	var prefixDelegation_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegation
	if o.PrefixDelegation != nil {
		if *obj != nil && (*obj).PrefixDelegation != nil {
			prefixDelegation_entry = (*obj).PrefixDelegation
		} else {
			prefixDelegation_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegation)
		}

		diags.Append(o.PrefixDelegation.CopyToPango(ctx, &prefixDelegation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var v6Options_entry *aggregate.Layer3Ipv6DhcpClientV6Options
	if o.V6Options != nil {
		if *obj != nil && (*obj).V6Options != nil {
			v6Options_entry = (*obj).V6Options
		} else {
			v6Options_entry = new(aggregate.Layer3Ipv6DhcpClientV6Options)
		}

		diags.Append(o.V6Options.CopyToPango(ctx, &v6Options_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClient)
	}
	(*obj).AcceptRaRoute = acceptRaRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).Preference = preference_value
	(*obj).PrefixDelegation = prefixDelegation_entry
	(*obj).V6Options = v6Options_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer
	if o.DnsServer != nil {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
		}

		diags.Append(o.DnsServer.CopyToPango(ctx, &dnsServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix
	if o.DnsSuffix != nil {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
		}

		diags.Append(o.DnsSuffix.CopyToPango(ctx, &dnsSuffix_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable
	if o.Enable != nil {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable)
		}

		diags.Append(o.Enable.CopyToPango(ctx, &enable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegation)
	}
	(*obj).Enable = enable_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo
	if o.No != nil {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
		}

		diags.Append(o.No.CopyToPango(ctx, &no_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes
	if o.Yes != nil {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
		}

		diags.Append(o.Yes.CopyToPango(ctx, &yes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	pfxPoolName_value := o.PfxPoolName.ValueStringPointer()
	prefixLen_value := o.PrefixLen.ValueInt64Pointer()
	prefixLenHint_value := o.PrefixLenHint.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
	}
	(*obj).PfxPoolName = pfxPoolName_value
	(*obj).PrefixLen = prefixLen_value
	(*obj).PrefixLenHint = prefixLenHint_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6Options, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	duidType_value := o.DuidType.ValueStringPointer()
	var enable_entry *aggregate.Layer3Ipv6DhcpClientV6OptionsEnable
	if o.Enable != nil {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnable)
		}

		diags.Append(o.Enable.CopyToPango(ctx, &enable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	rapidCommit_value := o.RapidCommit.ValueBoolPointer()
	supportSrvrReconfig_value := o.SupportSrvrReconfig.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6Options)
	}
	(*obj).DuidType = duidType_value
	(*obj).Enable = enable_entry
	(*obj).RapidCommit = rapidCommit_value
	(*obj).SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6OptionsEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo
	if o.No != nil {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo)
		}

		diags.Append(o.No.CopyToPango(ctx, &no_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes
	if o.Yes != nil {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes)
		}

		diags.Append(o.Yes.CopyToPango(ctx, &yes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	nonTempAddr_value := o.NonTempAddr.ValueBoolPointer()
	tempAddr_value := o.TempAddr.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes)
	}
	(*obj).NonTempAddr = nonTempAddr_value
	(*obj).TempAddr = tempAddr_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6Inherited, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject
	var assignAddr_pango_entries []aggregate.Layer3Ipv6InheritedAssignAddr
	{
		d := o.AssignAddr.ElementsAs(ctx, &assignAddr_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range assignAddr_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedAssignAddr
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			assignAddr_pango_entries = append(assignAddr_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *aggregate.Layer3Ipv6InheritedNeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6Inherited)
	}
	(*obj).AssignAddr = assignAddr_pango_entries
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddr, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *aggregate.Layer3Ipv6InheritedAssignAddrType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddr)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var gua_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGua
	if o.Gua != nil {
		if *obj != nil && (*obj).Gua != nil {
			gua_entry = (*obj).Gua
		} else {
			gua_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGua)
		}

		diags.Append(o.Gua.CopyToPango(ctx, &gua_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ula_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeUla
	if o.Ula != nil {
		if *obj != nil && (*obj).Ula != nil {
			ula_entry = (*obj).Ula
		} else {
			ula_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUla)
		}

		diags.Append(o.Ula.CopyToPango(ctx, &ula_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrType)
	}
	(*obj).Gua = gua_entry
	(*obj).Ula = ula_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGua, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	prefixPool_value := o.PrefixPool.ValueStringPointer()
	var poolType_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType
	if o.PoolType != nil {
		if *obj != nil && (*obj).PoolType != nil {
			poolType_entry = (*obj).PoolType
		} else {
			poolType_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
		}

		diags.Append(o.PoolType.CopyToPango(ctx, &poolType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGua)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).PrefixPool = prefixPool_value
	(*obj).PoolType = poolType_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic
	if o.Dynamic != nil {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
		}

		diags.Append(o.Dynamic.CopyToPango(ctx, &dynamic_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicId_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId
	if o.DynamicId != nil {
		if *obj != nil && (*obj).DynamicId != nil {
			dynamicId_entry = (*obj).DynamicId
		} else {
			dynamicId_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
		}

		diags.Append(o.DynamicId.CopyToPango(ctx, &dynamicId_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).DynamicId = dynamicId_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	identifier_value := o.Identifier.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
	}
	(*obj).Identifier = identifier_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeUla, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	address_value := o.Address.ValueStringPointer()
	prefix_value := o.Prefix.ValueBoolPointer()
	anycast_value := o.Anycast.ValueBoolPointer()
	var advertise_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUla)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Address = address_value
	(*obj).Prefix = prefix_value
	(*obj).Anycast = anycast_value
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer
	if o.DnsServer != nil {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
		}

		diags.Append(o.DnsServer.CopyToPango(ctx, &dnsServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix
	if o.DnsSuffix != nil {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
		}

		diags.Append(o.DnsSuffix.CopyToPango(ctx, &dnsSuffix_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement
	if o.RouterAdvertisement != nil {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
		}

		diags.Append(o.RouterAdvertisement.CopyToPango(ctx, &routerAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
	}
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3LacpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	fastFailover_value := o.FastFailover.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer3LacpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer3LacpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPorts_value := o.MaxPorts.ValueInt64Pointer()
	mode_value := o.Mode.ValueStringPointer()
	systemPriority_value := o.SystemPriority.ValueInt64Pointer()
	transmissionRate_value := o.TransmissionRate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Lacp)
	}
	(*obj).Enable = enable_value
	(*obj).FastFailover = fastFailover_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).MaxPorts = maxPorts_value
	(*obj).Mode = mode_value
	(*obj).SystemPriority = systemPriority_value
	(*obj).TransmissionRate = transmissionRate_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3LacpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3LacpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3LldpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer3LldpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer3LldpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3LldpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3NdpProxyObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3NdpProxy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []AggregateInterfaceDataSourceLayer3NdpProxyAddressObject
	var address_pango_entries []aggregate.Layer3NdpProxyAddress
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *aggregate.Layer3NdpProxyAddress
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3NdpProxy)
	}
	(*obj).Address = address_pango_entries
	(*obj).Enabled = enabled_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3NdpProxyAddressObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3NdpProxyAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3NdpProxyAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Negate = negate_value

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	sdwanInterfaceProfile_value := o.SdwanInterfaceProfile.ValueStringPointer()
	var upstreamNat_entry *aggregate.Layer3SdwanLinkSettingsUpstreamNat
	if o.UpstreamNat != nil {
		if *obj != nil && (*obj).UpstreamNat != nil {
			upstreamNat_entry = (*obj).UpstreamNat
		} else {
			upstreamNat_entry = new(aggregate.Layer3SdwanLinkSettingsUpstreamNat)
		}

		diags.Append(o.UpstreamNat.CopyToPango(ctx, &upstreamNat_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettings)
	}
	(*obj).Enable = enable_value
	(*obj).SdwanInterfaceProfile = sdwanInterfaceProfile_value
	(*obj).UpstreamNat = upstreamNat_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var ddns_entry *aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns
	if o.Ddns != nil {
		if *obj != nil && (*obj).Ddns != nil {
			ddns_entry = (*obj).Ddns
		} else {
			ddns_entry = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns)
		}

		diags.Append(o.Ddns.CopyToPango(ctx, &ddns_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp
	if o.StaticIp != nil {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
		}

		diags.Append(o.StaticIp.CopyToPango(ctx, &staticIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettingsUpstreamNat)
	}
	(*obj).Enable = enable_value
	(*obj).Ddns = ddns_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns)
	}

	return diags
}
func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	fqdn_value := o.Fqdn.ValueStringPointer()
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
	}
	(*obj).Fqdn = fqdn_value
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *AggregateInterfaceDataSourceVirtualWireObject) CopyToPango(ctx context.Context, obj **aggregate.VirtualWire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lldp_entry *aggregate.VirtualWireLldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(aggregate.VirtualWireLldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.VirtualWire)
	}
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *AggregateInterfaceDataSourceVirtualWireLldpObject) CopyToPango(ctx context.Context, obj **aggregate.VirtualWireLldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *aggregate.VirtualWireLldpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.VirtualWireLldpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.VirtualWireLldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.VirtualWireLldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.VirtualWireLldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceDataSourceModel) CopyFromPango(ctx context.Context, obj *aggregate.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var decryptMirror_object *AggregateInterfaceDataSourceDecryptMirrorObject
	if obj.DecryptMirror != nil {
		decryptMirror_object = new(AggregateInterfaceDataSourceDecryptMirrorObject)

		diags.Append(decryptMirror_object.CopyFromPango(ctx, obj.DecryptMirror, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_object *AggregateInterfaceDataSourceHaObject
	if obj.Ha != nil {
		ha_object = new(AggregateInterfaceDataSourceHaObject)

		diags.Append(ha_object.CopyFromPango(ctx, obj.Ha, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer2_object *AggregateInterfaceDataSourceLayer2Object
	if obj.Layer2 != nil {
		layer2_object = new(AggregateInterfaceDataSourceLayer2Object)

		diags.Append(layer2_object.CopyFromPango(ctx, obj.Layer2, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_object *AggregateInterfaceDataSourceLayer3Object
	if obj.Layer3 != nil {
		layer3_object = new(AggregateInterfaceDataSourceLayer3Object)

		diags.Append(layer3_object.CopyFromPango(ctx, obj.Layer3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var virtualWire_object *AggregateInterfaceDataSourceVirtualWireObject
	if obj.VirtualWire != nil {
		virtualWire_object = new(AggregateInterfaceDataSourceVirtualWireObject)

		diags.Append(virtualWire_object.CopyFromPango(ctx, obj.VirtualWire, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	o.Name = types.StringValue(obj.Name)
	o.Comment = comment_value
	o.DecryptMirror = decryptMirror_object
	o.Ha = ha_object
	o.Layer2 = layer2_object
	o.Layer3 = layer3_object
	o.VirtualWire = virtualWire_object

	return diags
}

func (o *AggregateInterfaceDataSourceDecryptMirrorObject) CopyFromPango(ctx context.Context, obj *aggregate.DecryptMirror, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceHaObject) CopyFromPango(ctx context.Context, obj *aggregate.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_object *AggregateInterfaceDataSourceHaLacpObject
	if obj.Lacp != nil {
		lacp_object = new(AggregateInterfaceDataSourceHaLacpObject)

		diags.Append(lacp_object.CopyFromPango(ctx, obj.Lacp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Lacp = lacp_object

	return diags
}

func (o *AggregateInterfaceDataSourceHaLacpObject) CopyFromPango(ctx context.Context, obj *aggregate.HaLacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var fastFailover_value types.Bool
	if obj.FastFailover != nil {
		fastFailover_value = types.BoolValue(*obj.FastFailover)
	}
	var maxPorts_value types.Int64
	if obj.MaxPorts != nil {
		maxPorts_value = types.Int64Value(*obj.MaxPorts)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var systemPriority_value types.Int64
	if obj.SystemPriority != nil {
		systemPriority_value = types.Int64Value(*obj.SystemPriority)
	}
	var transmissionRate_value types.String
	if obj.TransmissionRate != nil {
		transmissionRate_value = types.StringValue(*obj.TransmissionRate)
	}
	o.Enable = enable_value
	o.FastFailover = fastFailover_value
	o.MaxPorts = maxPorts_value
	o.Mode = mode_value
	o.SystemPriority = systemPriority_value
	o.TransmissionRate = transmissionRate_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer2Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_object *AggregateInterfaceDataSourceLayer2LacpObject
	if obj.Lacp != nil {
		lacp_object = new(AggregateInterfaceDataSourceLayer2LacpObject)

		diags.Append(lacp_object.CopyFromPango(ctx, obj.Lacp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_object *AggregateInterfaceDataSourceLayer2LldpObject
	if obj.Lldp != nil {
		lldp_object = new(AggregateInterfaceDataSourceLayer2LldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lacp = lacp_object
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer2LacpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceDataSourceLayer2LacpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceDataSourceLayer2LacpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var fastFailover_value types.Bool
	if obj.FastFailover != nil {
		fastFailover_value = types.BoolValue(*obj.FastFailover)
	}
	var maxPorts_value types.Int64
	if obj.MaxPorts != nil {
		maxPorts_value = types.Int64Value(*obj.MaxPorts)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var systemPriority_value types.Int64
	if obj.SystemPriority != nil {
		systemPriority_value = types.Int64Value(*obj.SystemPriority)
	}
	var transmissionRate_value types.String
	if obj.TransmissionRate != nil {
		transmissionRate_value = types.StringValue(*obj.TransmissionRate)
	}
	o.Enable = enable_value
	o.FastFailover = fastFailover_value
	o.HighAvailability = highAvailability_object
	o.MaxPorts = maxPorts_value
	o.Mode = mode_value
	o.SystemPriority = systemPriority_value
	o.TransmissionRate = transmissionRate_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer2LacpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer2LldpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceDataSourceLayer2LldpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceDataSourceLayer2LldpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer2LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var arp_list types.List
	{
		var arp_tf_entries []AggregateInterfaceDataSourceLayer3ArpObject
		for _, elt := range obj.Arp {
			var entry AggregateInterfaceDataSourceLayer3ArpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			arp_tf_entries = append(arp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("arp")
		arp_list, list_diags = types.ListValueFrom(ctx, schemaType, arp_tf_entries)
		diags.Append(list_diags...)
	}
	var ip_list types.List
	{
		var ip_tf_entries []AggregateInterfaceDataSourceLayer3IpObject
		for _, elt := range obj.Ip {
			var entry AggregateInterfaceDataSourceLayer3IpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ip_tf_entries = append(ip_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ip")
		ip_list, list_diags = types.ListValueFrom(ctx, schemaType, ip_tf_entries)
		diags.Append(list_diags...)
	}
	var adjustTcpMss_object *AggregateInterfaceDataSourceLayer3AdjustTcpMssObject
	if obj.AdjustTcpMss != nil {
		adjustTcpMss_object = new(AggregateInterfaceDataSourceLayer3AdjustTcpMssObject)

		diags.Append(adjustTcpMss_object.CopyFromPango(ctx, obj.AdjustTcpMss, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bonjour_object *AggregateInterfaceDataSourceLayer3BonjourObject
	if obj.Bonjour != nil {
		bonjour_object = new(AggregateInterfaceDataSourceLayer3BonjourObject)

		diags.Append(bonjour_object.CopyFromPango(ctx, obj.Bonjour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsConfig_object *AggregateInterfaceDataSourceLayer3DdnsConfigObject
	if obj.DdnsConfig != nil {
		ddnsConfig_object = new(AggregateInterfaceDataSourceLayer3DdnsConfigObject)

		diags.Append(ddnsConfig_object.CopyFromPango(ctx, obj.DdnsConfig, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_object *AggregateInterfaceDataSourceLayer3DhcpClientObject
	if obj.DhcpClient != nil {
		dhcpClient_object = new(AggregateInterfaceDataSourceLayer3DhcpClientObject)

		diags.Append(dhcpClient_object.CopyFromPango(ctx, obj.DhcpClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *AggregateInterfaceDataSourceLayer3Ipv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(AggregateInterfaceDataSourceLayer3Ipv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lacp_object *AggregateInterfaceDataSourceLayer3LacpObject
	if obj.Lacp != nil {
		lacp_object = new(AggregateInterfaceDataSourceLayer3LacpObject)

		diags.Append(lacp_object.CopyFromPango(ctx, obj.Lacp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_object *AggregateInterfaceDataSourceLayer3LldpObject
	if obj.Lldp != nil {
		lldp_object = new(AggregateInterfaceDataSourceLayer3LldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ndpProxy_object *AggregateInterfaceDataSourceLayer3NdpProxyObject
	if obj.NdpProxy != nil {
		ndpProxy_object = new(AggregateInterfaceDataSourceLayer3NdpProxyObject)

		diags.Append(ndpProxy_object.CopyFromPango(ctx, obj.NdpProxy, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_object *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsObject
	if obj.SdwanLinkSettings != nil {
		sdwanLinkSettings_object = new(AggregateInterfaceDataSourceLayer3SdwanLinkSettingsObject)

		diags.Append(sdwanLinkSettings_object.CopyFromPango(ctx, obj.SdwanLinkSettings, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var decryptForward_value types.Bool
	if obj.DecryptForward != nil {
		decryptForward_value = types.BoolValue(*obj.DecryptForward)
	}
	var dfIgnore_value types.Bool
	if obj.DfIgnore != nil {
		dfIgnore_value = types.BoolValue(*obj.DfIgnore)
	}
	var interfaceManagementProfile_value types.String
	if obj.InterfaceManagementProfile != nil {
		interfaceManagementProfile_value = types.StringValue(*obj.InterfaceManagementProfile)
	}
	var mtu_value types.Int64
	if obj.Mtu != nil {
		mtu_value = types.Int64Value(*obj.Mtu)
	}
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	var untaggedSubInterface_value types.Bool
	if obj.UntaggedSubInterface != nil {
		untaggedSubInterface_value = types.BoolValue(*obj.UntaggedSubInterface)
	}
	o.AdjustTcpMss = adjustTcpMss_object
	o.Arp = arp_list
	o.Bonjour = bonjour_object
	o.DdnsConfig = ddnsConfig_object
	o.DecryptForward = decryptForward_value
	o.DfIgnore = dfIgnore_value
	o.DhcpClient = dhcpClient_object
	o.InterfaceManagementProfile = interfaceManagementProfile_value
	o.Ip = ip_list
	o.Ipv6 = ipv6_object
	o.Lacp = lacp_object
	o.Lldp = lldp_object
	o.Mtu = mtu_value
	o.NdpProxy = ndpProxy_object
	o.NetflowProfile = netflowProfile_value
	o.SdwanLinkSettings = sdwanLinkSettings_object
	o.UntaggedSubInterface = untaggedSubInterface_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3AdjustTcpMssObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var ipv4MssAdjustment_value types.Int64
	if obj.Ipv4MssAdjustment != nil {
		ipv4MssAdjustment_value = types.Int64Value(*obj.Ipv4MssAdjustment)
	}
	var ipv6MssAdjustment_value types.Int64
	if obj.Ipv6MssAdjustment != nil {
		ipv6MssAdjustment_value = types.Int64Value(*obj.Ipv6MssAdjustment)
	}
	o.Enable = enable_value
	o.Ipv4MssAdjustment = ipv4MssAdjustment_value
	o.Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3ArpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3BonjourObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var groupId_value types.Int64
	if obj.GroupId != nil {
		groupId_value = types.Int64Value(*obj.GroupId)
	}
	var ttlCheck_value types.Bool
	if obj.TtlCheck != nil {
		ttlCheck_value = types.BoolValue(*obj.TtlCheck)
	}
	o.Enable = enable_value
	o.GroupId = groupId_value
	o.TtlCheck = ttlCheck_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3DdnsConfigObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DdnsConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ddnsIp_list types.List
	{
		var list_diags diag.Diagnostics
		ddnsIp_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.DdnsIp)
		diags.Append(list_diags...)
	}
	var ddnsIpv6_list types.List
	{
		var list_diags diag.Diagnostics
		ddnsIpv6_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.DdnsIpv6)
		diags.Append(list_diags...)
	}
	var ddnsVendorConfig_list types.List
	{
		var ddnsVendorConfig_tf_entries []AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject
		for _, elt := range obj.DdnsVendorConfig {
			var entry AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ddnsVendorConfig_tf_entries = append(ddnsVendorConfig_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ddns_vendor_config")
		ddnsVendorConfig_list, list_diags = types.ListValueFrom(ctx, schemaType, ddnsVendorConfig_tf_entries)
		diags.Append(list_diags...)
	}

	var ddnsCertProfile_value types.String
	if obj.DdnsCertProfile != nil {
		ddnsCertProfile_value = types.StringValue(*obj.DdnsCertProfile)
	}
	var ddnsEnabled_value types.Bool
	if obj.DdnsEnabled != nil {
		ddnsEnabled_value = types.BoolValue(*obj.DdnsEnabled)
	}
	var ddnsHostname_value types.String
	if obj.DdnsHostname != nil {
		ddnsHostname_value = types.StringValue(*obj.DdnsHostname)
	}
	var ddnsUpdateInterval_value types.Int64
	if obj.DdnsUpdateInterval != nil {
		ddnsUpdateInterval_value = types.Int64Value(*obj.DdnsUpdateInterval)
	}
	var ddnsVendor_value types.String
	if obj.DdnsVendor != nil {
		ddnsVendor_value = types.StringValue(*obj.DdnsVendor)
	}
	o.DdnsCertProfile = ddnsCertProfile_value
	o.DdnsEnabled = ddnsEnabled_value
	o.DdnsHostname = ddnsHostname_value
	o.DdnsIp = ddnsIp_list
	o.DdnsIpv6 = ddnsIpv6_list
	o.DdnsUpdateInterval = ddnsUpdateInterval_value
	o.DdnsVendor = ddnsVendor_value
	o.DdnsVendorConfig = ddnsVendorConfig_list

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DdnsConfigDdnsVendorConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3DhcpClientObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sendHostname_object *AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameObject
	if obj.SendHostname != nil {
		sendHostname_object = new(AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameObject)

		diags.Append(sendHostname_object.CopyFromPango(ctx, obj.SendHostname, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.SendHostname = sendHostname_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.Enable = enable_value
	o.Hostname = hostname_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3IpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var sdwanGateway_value types.String
	if obj.SdwanGateway != nil {
		sdwanGateway_value = types.StringValue(*obj.SdwanGateway)
	}
	o.Name = types.StringValue(obj.Name)
	o.SdwanGateway = sdwanGateway_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6AddressObject
		for _, elt := range obj.Address {
			var entry AggregateInterfaceDataSourceLayer3Ipv6AddressObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			address_tf_entries = append(address_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}
	var neighborDiscovery_object *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientObject
	if obj.DhcpClient != nil {
		dhcpClient_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientObject)

		diags.Append(dhcpClient_object.CopyFromPango(ctx, obj.DhcpClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var inherited_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedObject
	if obj.Inherited != nil {
		inherited_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedObject)

		diags.Append(inherited_object.CopyFromPango(ctx, obj.Inherited, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	var interfaceId_value types.String
	if obj.InterfaceId != nil {
		interfaceId_value = types.StringValue(*obj.InterfaceId)
	}
	o.Address = address_list
	o.Enabled = enabled_value
	o.InterfaceId = interfaceId_value
	o.NeighborDiscovery = neighborDiscovery_object
	o.DhcpClient = dhcpClient_object
	o.Inherited = inherited_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6Address, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var prefix_object *AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixObject
	if obj.Prefix != nil {
		prefix_object = new(AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixObject)

		diags.Append(prefix_object.CopyFromPango(ctx, obj.Prefix, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var anycast_object *AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastObject
	if obj.Anycast != nil {
		anycast_object = new(AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastObject)

		diags.Append(anycast_object.CopyFromPango(ctx, obj.Anycast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.EnableOnInterface = enableOnInterface_value
	o.Prefix = prefix_object
	o.Anycast = anycast_object
	o.Advertise = advertise_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6AddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6AddressAnycast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6AddressAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var routerAdvertisement_object *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	if obj.RouterAdvertisement != nil {
		routerAdvertisement_object = new(AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject)

		diags.Append(routerAdvertisement_object.CopyFromPango(ctx, obj.RouterAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_object *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject
	if obj.DnsSupport != nil {
		dnsSupport_object = new(AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject)

		diags.Append(dnsSupport_object.CopyFromPango(ctx, obj.DnsSupport, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.DnsSupport = dnsSupport_object
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
		for _, elt := range obj.Server {
			var entry AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}
	var suffix_list types.List
	{
		var suffix_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
		for _, elt := range obj.Suffix {
			var entry AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Server = server_list
	o.Suffix = suffix_list

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighborDiscovery_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var prefixDelegation_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject
	if obj.PrefixDelegation != nil {
		prefixDelegation_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject)

		diags.Append(prefixDelegation_object.CopyFromPango(ctx, obj.PrefixDelegation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var v6Options_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject
	if obj.V6Options != nil {
		v6Options_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject)

		diags.Append(v6Options_object.CopyFromPango(ctx, obj.V6Options, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptRaRoute_value types.Bool
	if obj.AcceptRaRoute != nil {
		acceptRaRoute_value = types.BoolValue(*obj.AcceptRaRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var preference_value types.String
	if obj.Preference != nil {
		preference_value = types.StringValue(*obj.Preference)
	}
	o.AcceptRaRoute = acceptRaRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object
	o.Preference = preference_value
	o.PrefixDelegation = prefixDelegation_object
	o.V6Options = v6Options_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var dnsServer_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject
	if obj.DnsServer != nil {
		dnsServer_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject)

		diags.Append(dnsServer_object.CopyFromPango(ctx, obj.DnsServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject
	if obj.DnsSuffix != nil {
		dnsSuffix_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject)

		diags.Append(dnsSuffix_object.CopyFromPango(ctx, obj.DnsSuffix, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
		for _, elt := range obj.Server {
			var entry AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		for _, elt := range obj.Suffix {
			var entry AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
	if obj.Enable != nil {
		enable_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject)

		diags.Append(enable_object.CopyFromPango(ctx, obj.Enable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Enable = enable_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject
	if obj.No != nil {
		no_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject)

		diags.Append(no_object.CopyFromPango(ctx, obj.No, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
	if obj.Yes != nil {
		yes_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject)

		diags.Append(yes_object.CopyFromPango(ctx, obj.Yes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var pfxPoolName_value types.String
	if obj.PfxPoolName != nil {
		pfxPoolName_value = types.StringValue(*obj.PfxPoolName)
	}
	var prefixLen_value types.Int64
	if obj.PrefixLen != nil {
		prefixLen_value = types.Int64Value(*obj.PrefixLen)
	}
	var prefixLenHint_value types.Bool
	if obj.PrefixLenHint != nil {
		prefixLenHint_value = types.BoolValue(*obj.PrefixLenHint)
	}
	o.PfxPoolName = pfxPoolName_value
	o.PrefixLen = prefixLen_value
	o.PrefixLenHint = prefixLenHint_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6Options, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject
	if obj.Enable != nil {
		enable_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject)

		diags.Append(enable_object.CopyFromPango(ctx, obj.Enable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var duidType_value types.String
	if obj.DuidType != nil {
		duidType_value = types.StringValue(*obj.DuidType)
	}
	var rapidCommit_value types.Bool
	if obj.RapidCommit != nil {
		rapidCommit_value = types.BoolValue(*obj.RapidCommit)
	}
	var supportSrvrReconfig_value types.Bool
	if obj.SupportSrvrReconfig != nil {
		supportSrvrReconfig_value = types.BoolValue(*obj.SupportSrvrReconfig)
	}
	o.DuidType = duidType_value
	o.Enable = enable_object
	o.RapidCommit = rapidCommit_value
	o.SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6OptionsEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject
	if obj.No != nil {
		no_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject)

		diags.Append(no_object.CopyFromPango(ctx, obj.No, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_object *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
	if obj.Yes != nil {
		yes_object = new(AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject)

		diags.Append(yes_object.CopyFromPango(ctx, obj.Yes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var nonTempAddr_value types.Bool
	if obj.NonTempAddr != nil {
		nonTempAddr_value = types.BoolValue(*obj.NonTempAddr)
	}
	var tempAddr_value types.Bool
	if obj.TempAddr != nil {
		tempAddr_value = types.BoolValue(*obj.TempAddr)
	}
	o.NonTempAddr = nonTempAddr_value
	o.TempAddr = tempAddr_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6Inherited, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_list types.List
	{
		var assignAddr_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject
		for _, elt := range obj.AssignAddr {
			var entry AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			assignAddr_tf_entries = append(assignAddr_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("assign_addr")
		assignAddr_list, list_diags = types.ListValueFrom(ctx, schemaType, assignAddr_tf_entries)
		diags.Append(list_diags...)
	}
	var neighborDiscovery_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.AssignAddr = assignAddr_list
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddr, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject
	if obj.Type != nil {
		type_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Type = type_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var gua_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject
	if obj.Gua != nil {
		gua_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject)

		diags.Append(gua_object.CopyFromPango(ctx, obj.Gua, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ula_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
	if obj.Ula != nil {
		ula_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject)

		diags.Append(ula_object.CopyFromPango(ctx, obj.Ula, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Gua = gua_object
	o.Ula = ula_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGua, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var poolType_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject
	if obj.PoolType != nil {
		poolType_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject)

		diags.Append(poolType_object.CopyFromPango(ctx, obj.PoolType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.PrefixPool = prefixPool_value
	o.PoolType = poolType_object
	o.Advertise = advertise_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject
	if obj.Dynamic != nil {
		dynamic_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject)

		diags.Append(dynamic_object.CopyFromPango(ctx, obj.Dynamic, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicId_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
	if obj.DynamicId != nil {
		dynamicId_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject)

		diags.Append(dynamicId_object.CopyFromPango(ctx, obj.DynamicId, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dynamic = dynamic_object
	o.DynamicId = dynamicId_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var identifier_value types.Int64
	if obj.Identifier != nil {
		identifier_value = types.Int64Value(*obj.Identifier)
	}
	o.Identifier = identifier_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeUla, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var prefix_value types.Bool
	if obj.Prefix != nil {
		prefix_value = types.BoolValue(*obj.Prefix)
	}
	var anycast_value types.Bool
	if obj.Anycast != nil {
		anycast_value = types.BoolValue(*obj.Anycast)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.Address = address_value
	o.Prefix = prefix_value
	o.Anycast = anycast_value
	o.Advertise = advertise_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var dnsServer_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject
	if obj.DnsServer != nil {
		dnsServer_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject)

		diags.Append(dnsServer_object.CopyFromPango(ctx, obj.DnsServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject
	if obj.DnsSuffix != nil {
		dnsSuffix_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject)

		diags.Append(dnsSuffix_object.CopyFromPango(ctx, obj.DnsSuffix, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routerAdvertisement_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
	if obj.RouterAdvertisement != nil {
		routerAdvertisement_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject)

		diags.Append(routerAdvertisement_object.CopyFromPango(ctx, obj.RouterAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
		for _, elt := range obj.Server {
			var entry AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		for _, elt := range obj.Suffix {
			var entry AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3LacpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceDataSourceLayer3LacpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceDataSourceLayer3LacpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var fastFailover_value types.Bool
	if obj.FastFailover != nil {
		fastFailover_value = types.BoolValue(*obj.FastFailover)
	}
	var maxPorts_value types.Int64
	if obj.MaxPorts != nil {
		maxPorts_value = types.Int64Value(*obj.MaxPorts)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var systemPriority_value types.Int64
	if obj.SystemPriority != nil {
		systemPriority_value = types.Int64Value(*obj.SystemPriority)
	}
	var transmissionRate_value types.String
	if obj.TransmissionRate != nil {
		transmissionRate_value = types.StringValue(*obj.TransmissionRate)
	}
	o.Enable = enable_value
	o.FastFailover = fastFailover_value
	o.HighAvailability = highAvailability_object
	o.MaxPorts = maxPorts_value
	o.Mode = mode_value
	o.SystemPriority = systemPriority_value
	o.TransmissionRate = transmissionRate_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3LacpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3LldpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceDataSourceLayer3LldpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceDataSourceLayer3LldpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3NdpProxyObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3NdpProxy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []AggregateInterfaceDataSourceLayer3NdpProxyAddressObject
		for _, elt := range obj.Address {
			var entry AggregateInterfaceDataSourceLayer3NdpProxyAddressObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			address_tf_entries = append(address_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Address = address_list
	o.Enabled = enabled_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3NdpProxyAddressObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3NdpProxyAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Negate = negate_value

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var upstreamNat_object *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject
	if obj.UpstreamNat != nil {
		upstreamNat_object = new(AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject)

		diags.Append(upstreamNat_object.CopyFromPango(ctx, obj.UpstreamNat, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var sdwanInterfaceProfile_value types.String
	if obj.SdwanInterfaceProfile != nil {
		sdwanInterfaceProfile_value = types.StringValue(*obj.SdwanInterfaceProfile)
	}
	o.Enable = enable_value
	o.SdwanInterfaceProfile = sdwanInterfaceProfile_value
	o.UpstreamNat = upstreamNat_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ddns_object *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject
	if obj.Ddns != nil {
		ddns_object = new(AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject)

		diags.Append(ddns_object.CopyFromPango(ctx, obj.Ddns, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_object *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
	if obj.StaticIp != nil {
		staticIp_object = new(AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject)

		diags.Append(staticIp_object.CopyFromPango(ctx, obj.StaticIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Ddns = ddns_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.Fqdn = fqdn_value
	o.IpAddress = ipAddress_value

	return diags
}

func (o *AggregateInterfaceDataSourceVirtualWireObject) CopyFromPango(ctx context.Context, obj *aggregate.VirtualWire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lldp_object *AggregateInterfaceDataSourceVirtualWireLldpObject
	if obj.Lldp != nil {
		lldp_object = new(AggregateInterfaceDataSourceVirtualWireLldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *AggregateInterfaceDataSourceVirtualWireLldpObject) CopyFromPango(ctx context.Context, obj *aggregate.VirtualWireLldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.VirtualWireLldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func AggregateInterfaceDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": AggregateInterfaceDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"decrypt_mirror": AggregateInterfaceDataSourceDecryptMirrorSchema(),

			"ha": AggregateInterfaceDataSourceHaSchema(),

			"layer2": AggregateInterfaceDataSourceLayer2Schema(),

			"layer3": AggregateInterfaceDataSourceLayer3Schema(),

			"virtual_wire": AggregateInterfaceDataSourceVirtualWireSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceModel) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceDecryptMirrorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceDecryptMirrorObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceDecryptMirrorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceHaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lacp": AggregateInterfaceDataSourceHaLacpSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceHaObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceHaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceHaLacpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_failover": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_ports": dsschema.Int64Attribute{
				Description: "maximum number of physical ports bundled in the LAG",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": dsschema.StringAttribute{
				Description: "LACP mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"system_priority": dsschema.Int64Attribute{
				Description: "LACP system priority in system ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transmission_rate": dsschema.StringAttribute{
				Description: "periodic transition rate. N/A in passive mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceHaLacpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceHaLacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer2Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lacp": AggregateInterfaceDataSourceLayer2LacpSchema(),

			"lldp": AggregateInterfaceDataSourceLayer2LldpSchema(),

			"netflow_profile": dsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer2Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer2LacpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_failover": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceDataSourceLayer2LacpHighAvailabilitySchema(),

			"max_ports": dsschema.Int64Attribute{
				Description: "maximum number of physical ports bundled in the LAG",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": dsschema.StringAttribute{
				Description: "LACP mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"system_priority": dsschema.Int64Attribute{
				Description: "LACP system priority in system ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transmission_rate": dsschema.StringAttribute{
				Description: "periodic transition rate. N/A in passive mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer2LacpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer2LacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer2LacpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LACP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer2LacpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer2LacpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer2LldpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceDataSourceLayer2LldpHighAvailabilitySchema(),

			"profile": dsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer2LldpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer2LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer2LldpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer2LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer2LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"adjust_tcp_mss": AggregateInterfaceDataSourceLayer3AdjustTcpMssSchema(),

			"arp": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3ArpSchema(),
			},

			"bonjour": AggregateInterfaceDataSourceLayer3BonjourSchema(),

			"ddns_config": AggregateInterfaceDataSourceLayer3DdnsConfigSchema(),

			"decrypt_forward": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"df_ignore": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dhcp_client": AggregateInterfaceDataSourceLayer3DhcpClientSchema(),

			"interface_management_profile": dsschema.StringAttribute{
				Description: "Interface management profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3IpSchema(),
			},

			"ipv6": AggregateInterfaceDataSourceLayer3Ipv6Schema(),

			"lacp": AggregateInterfaceDataSourceLayer3LacpSchema(),

			"lldp": AggregateInterfaceDataSourceLayer3LldpSchema(),

			"mtu": dsschema.Int64Attribute{
				Description: "Maximum Transfer Unit, up to 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ndp_proxy": AggregateInterfaceDataSourceLayer3NdpProxySchema(),

			"netflow_profile": dsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_link_settings": AggregateInterfaceDataSourceLayer3SdwanLinkSettingsSchema(),

			"untagged_sub_interface": dsschema.BoolAttribute{
				Description: "Enable untagged sub-interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3AdjustTcpMssSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Set if TCP MSS value should be reduced based on mtu",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4_mss_adjustment": dsschema.Int64Attribute{
				Description: "IPv4 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_mss_adjustment": dsschema.Int64Attribute{
				Description: "IPv6 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3AdjustTcpMssObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3AdjustTcpMssSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3ArpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3ArpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3ArpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3BonjourSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Set to support Bonjour service",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_id": dsschema.Int64Attribute{
				Description: "default 0: NO-Group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ttl_check": dsschema.BoolAttribute{
				Description: "Set to check and update TTL",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3BonjourObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3BonjourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3DdnsConfigSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ddns_cert_profile": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_enabled": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_hostname": dsschema.StringAttribute{
				Description: "ddns hostname variable or real address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_ip": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_ipv6": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_update_interval": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_vendor": dsschema.StringAttribute{
				Description: "Vendor and product type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_vendor_config": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3DdnsConfigObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3DdnsConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3DhcpClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"create_default_route": dsschema.BoolAttribute{
				Description: "Automatically create default route pointing to default gateway provided by server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": dsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_hostname": AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": dsschema.StringAttribute{
				Description: "Set Interface Hostname",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3DhcpClientSendHostnameSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3IpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"sdwan_gateway": dsschema.StringAttribute{
				Description: "Gateway IPv4 Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3IpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3IpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6AddressSchema(),
			},

			"enabled": dsschema.BoolAttribute{
				Description: "Enable IPv6 on the interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface_id": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema(),

			"dhcp_client": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientSchema(),

			"inherited": AggregateInterfaceDataSourceLayer3Ipv6InheritedSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6AddressSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable_on_interface": dsschema.BoolAttribute{
				Description: "configure this address on interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixSchema(),

			"anycast": AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastSchema(),

			"advertise": AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6AddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6AddressAnycastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": dsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred_lifetime": dsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": dsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": dsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6AddressAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dad_attempts": dsschema.Int64Attribute{
				Description: "number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_dad": dsschema.BoolAttribute{
				Description: "enable duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": dsschema.BoolAttribute{
				Description: "enable ndp monitoring",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": dsschema.Int64Attribute{
				Description: "interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.Int64Attribute{
				Description: "time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_advertisement": AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dns_support": AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema(),

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": dsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": dsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_mtu": dsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"managed_flag": dsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": dsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_interval": dsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"other_flag": dsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmission_timer": dsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_preference": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema(),
			},

			"suffix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"accept_ra_route": dsschema.BoolAttribute{
				Description: "Accept Router Advertised Default Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": dsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable DHCPv6 Client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoverySchema(),

			"preference": dsschema.StringAttribute{
				Description: "Select Low/Medium/High",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_delegation": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationSchema(),

			"v6_options": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoverySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dad_attempts": dsschema.Int64Attribute{
				Description: "number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_server": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": dsschema.BoolAttribute{
				Description: "Enable Duplicate Address Detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": dsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": dsschema.Int64Attribute{
				Description: "interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.Int64Attribute{
				Description: "time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"server": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"suffix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema(),

			"yes": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"pfx_pool_name": dsschema.StringAttribute{
				Description: "Configure unique Prefix Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_len": dsschema.Int64Attribute{
				Description: "Hint DHCP Prefix Length (bits)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_len_hint": dsschema.BoolAttribute{
				Description: "Send prefix length hint to server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"duid_type": dsschema.StringAttribute{
				Description: "Select DUID-LLT/DUID-LL",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableSchema(),

			"rapid_commit": dsschema.BoolAttribute{
				Description: "Enable Rapid Commit",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"support_srvr_reconfig": dsschema.BoolAttribute{
				Description: "Enable DHCPv6 Server Re-Configuration Support",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema(),

			"yes": AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"non_temp_addr": dsschema.BoolAttribute{
				Description: "Request Non-Temporary Address Type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"temp_addr": dsschema.BoolAttribute{
				Description: "Request Temporary Address Type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"assign_addr": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable Inherited Interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoverySchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"gua": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema(),

			"ula": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"enable_on_interface": dsschema.BoolAttribute{
				Description: "Enable on Interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_pool": dsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pool_type": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema(),

			"advertise": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dynamic": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema(),

			"dynamic_id": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"identifier": dsschema.Int64Attribute{
				Description: "Range [0-4095] must be unqiue for this prefix-pool",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable advertising this prefix in router advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": dsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": dsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"enable_on_interface": dsschema.BoolAttribute{
				Description: "Configure this address on Interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": dsschema.StringAttribute{
				Description: "Configure ULA (Unique Local Address)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": dsschema.BoolAttribute{
				Description: "Use this as prefix to form full address with interface id/EUI-64",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anycast": dsschema.BoolAttribute{
				Description: "Anycast Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertise": AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": dsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred_lifetime": dsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": dsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": dsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoverySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dad_attempts": dsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_server": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": dsschema.BoolAttribute{
				Description: "Enable Duplicate Address Detection (DAD)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": dsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_advertisement": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"prefix_pool": dsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"server": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"prefix_pool": dsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"suffix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": dsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": dsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_mtu": dsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"managed_flag": dsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": dsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_interval": dsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"other_flag": dsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmission_timer": dsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_preference": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3LacpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_failover": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceDataSourceLayer3LacpHighAvailabilitySchema(),

			"max_ports": dsschema.Int64Attribute{
				Description: "maximum number of physical ports bundled in the LAG",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": dsschema.StringAttribute{
				Description: "LACP mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"system_priority": dsschema.Int64Attribute{
				Description: "LACP system priority in system ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transmission_rate": dsschema.StringAttribute{
				Description: "periodic transition rate. N/A in passive mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3LacpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3LacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3LacpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LACP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3LacpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3LacpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3LldpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceDataSourceLayer3LldpHighAvailabilitySchema(),

			"profile": dsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3LldpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3LldpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3NdpProxySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: AggregateInterfaceDataSourceLayer3NdpProxyAddressSchema(),
			},

			"enabled": dsschema.BoolAttribute{
				Description: "Enable proxy NDP on the interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3NdpProxyObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3NdpProxySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3NdpProxyAddressSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"negate": dsschema.BoolAttribute{
				Description: "put the prefix or address on a block list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3NdpProxyAddressObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3NdpProxyAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3SdwanLinkSettingsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable sdwan on this ethernet interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_interface_profile": dsschema.StringAttribute{
				Description: "Sdwan link characteristics",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"upstream_nat": AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3SdwanLinkSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable upstream NAT IP config",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns": AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema(),

			"static_ip": AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema(),
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"fqdn": dsschema.StringAttribute{
				Description: "Upstream NAT address FQDN name configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address": dsschema.StringAttribute{
				Description: "Upstream NAT IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceVirtualWireSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lldp": AggregateInterfaceDataSourceVirtualWireLldpSchema(),

			"netflow_profile": dsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceVirtualWireObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceVirtualWireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceVirtualWireLldpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilitySchema(),

			"profile": dsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceVirtualWireLldpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceVirtualWireLldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceDataSourceVirtualWireLldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceDataSourceLocationSchema() rsschema.Attribute {
	return AggregateInterfaceLocationSchema()
}

// Metadata returns the data source type name.
func (d *AggregateInterfaceDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aggregate_interface"
}

// Schema defines the schema for this data source.
func (d *AggregateInterfaceDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = AggregateInterfaceDataSourceSchema()
}

// Configure prepares the struct.
func (d *AggregateInterfaceDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := aggregate.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager(d.client, aggregate.NewService(d.client), batchSize, specifier, aggregate.SpecMatches)
}
func (o *AggregateInterfaceDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state AggregateInterfaceDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location aggregate.Location

	if savestate.Location.Shared != nil {
		location.Shared = &aggregate.SharedLocation{}
	}
	if savestate.Location.Template != nil {
		location.Template = &aggregate.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &aggregate.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Ngfw != nil {
		location.Ngfw = &aggregate.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_aggregate_interface_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &AggregateInterfaceResource{}
	_ resource.ResourceWithConfigure   = &AggregateInterfaceResource{}
	_ resource.ResourceWithImportState = &AggregateInterfaceResource{}
)

func NewAggregateInterfaceResource() resource.Resource {
	if _, found := resourceFuncMap["panos_aggregate_interface"]; !found {
		resourceFuncMap["panos_aggregate_interface"] = resourceFuncs{
			CreateImportId: AggregateInterfaceImportStateCreator,
		}
	}
	return &AggregateInterfaceResource{}
}

type AggregateInterfaceResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*aggregate.Entry, aggregate.Location, *aggregate.Service]
}

func AggregateInterfaceResourceLocationSchema() rsschema.Attribute {
	return AggregateInterfaceLocationSchema()
}

type AggregateInterfaceResourceModel struct {
	Location      AggregateInterfaceLocation                     `tfsdk:"location"`
	Name          types.String                                   `tfsdk:"name"`
	Comment       types.String                                   `tfsdk:"comment"`
	DecryptMirror *AggregateInterfaceResourceDecryptMirrorObject `tfsdk:"decrypt_mirror"`
	Ha            *AggregateInterfaceResourceHaObject            `tfsdk:"ha"`
	Layer2        *AggregateInterfaceResourceLayer2Object        `tfsdk:"layer2"`
	Layer3        *AggregateInterfaceResourceLayer3Object        `tfsdk:"layer3"`
	VirtualWire   *AggregateInterfaceResourceVirtualWireObject   `tfsdk:"virtual_wire"`
}
type AggregateInterfaceResourceDecryptMirrorObject struct {
}
type AggregateInterfaceResourceHaObject struct {
	Lacp *AggregateInterfaceResourceHaLacpObject `tfsdk:"lacp"`
}
type AggregateInterfaceResourceHaLacpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	FastFailover     types.Bool   `tfsdk:"fast_failover"`
	MaxPorts         types.Int64  `tfsdk:"max_ports"`
	Mode             types.String `tfsdk:"mode"`
	SystemPriority   types.Int64  `tfsdk:"system_priority"`
	TransmissionRate types.String `tfsdk:"transmission_rate"`
}
type AggregateInterfaceResourceLayer2Object struct {
	Lacp           *AggregateInterfaceResourceLayer2LacpObject `tfsdk:"lacp"`
	Lldp           *AggregateInterfaceResourceLayer2LldpObject `tfsdk:"lldp"`
	NetflowProfile types.String                                `tfsdk:"netflow_profile"`
}
type AggregateInterfaceResourceLayer2LacpObject struct {
	Enable           types.Bool                                                  `tfsdk:"enable"`
	FastFailover     types.Bool                                                  `tfsdk:"fast_failover"`
	HighAvailability *AggregateInterfaceResourceLayer2LacpHighAvailabilityObject `tfsdk:"high_availability"`
	MaxPorts         types.Int64                                                 `tfsdk:"max_ports"`
	Mode             types.String                                                `tfsdk:"mode"`
	SystemPriority   types.Int64                                                 `tfsdk:"system_priority"`
	TransmissionRate types.String                                                `tfsdk:"transmission_rate"`
}
type AggregateInterfaceResourceLayer2LacpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceResourceLayer2LldpObject struct {
	Enable           types.Bool                                                  `tfsdk:"enable"`
	HighAvailability *AggregateInterfaceResourceLayer2LldpHighAvailabilityObject `tfsdk:"high_availability"`
	Profile          types.String                                                `tfsdk:"profile"`
}
type AggregateInterfaceResourceLayer2LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceResourceLayer3Object struct {
	AdjustTcpMss               *AggregateInterfaceResourceLayer3AdjustTcpMssObject      `tfsdk:"adjust_tcp_mss"`
	Arp                        types.List                                               `tfsdk:"arp"`
	Bonjour                    *AggregateInterfaceResourceLayer3BonjourObject           `tfsdk:"bonjour"`
	DdnsConfig                 *AggregateInterfaceResourceLayer3DdnsConfigObject        `tfsdk:"ddns_config"`
	DecryptForward             types.Bool                                               `tfsdk:"decrypt_forward"`
	DfIgnore                   types.Bool                                               `tfsdk:"df_ignore"`
	DhcpClient                 *AggregateInterfaceResourceLayer3DhcpClientObject        `tfsdk:"dhcp_client"`
	InterfaceManagementProfile types.String                                             `tfsdk:"interface_management_profile"`
	Ip                         types.List                                               `tfsdk:"ip"`
	Ipv6                       *AggregateInterfaceResourceLayer3Ipv6Object              `tfsdk:"ipv6"`
	Lacp                       *AggregateInterfaceResourceLayer3LacpObject              `tfsdk:"lacp"`
	Lldp                       *AggregateInterfaceResourceLayer3LldpObject              `tfsdk:"lldp"`
	Mtu                        types.Int64                                              `tfsdk:"mtu"`
	NdpProxy                   *AggregateInterfaceResourceLayer3NdpProxyObject          `tfsdk:"ndp_proxy"`
	NetflowProfile             types.String                                             `tfsdk:"netflow_profile"`
	SdwanLinkSettings          *AggregateInterfaceResourceLayer3SdwanLinkSettingsObject `tfsdk:"sdwan_link_settings"`
	UntaggedSubInterface       types.Bool                                               `tfsdk:"untagged_sub_interface"`
}
type AggregateInterfaceResourceLayer3AdjustTcpMssObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	Ipv4MssAdjustment types.Int64 `tfsdk:"ipv4_mss_adjustment"`
	Ipv6MssAdjustment types.Int64 `tfsdk:"ipv6_mss_adjustment"`
}
type AggregateInterfaceResourceLayer3ArpObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceResourceLayer3BonjourObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	GroupId  types.Int64 `tfsdk:"group_id"`
	TtlCheck types.Bool  `tfsdk:"ttl_check"`
}
type AggregateInterfaceResourceLayer3DdnsConfigObject struct {
	DdnsCertProfile    types.String `tfsdk:"ddns_cert_profile"`
	DdnsEnabled        types.Bool   `tfsdk:"ddns_enabled"`
	DdnsHostname       types.String `tfsdk:"ddns_hostname"`
	DdnsIp             types.List   `tfsdk:"ddns_ip"`
	DdnsIpv6           types.List   `tfsdk:"ddns_ipv6"`
	DdnsUpdateInterval types.Int64  `tfsdk:"ddns_update_interval"`
	DdnsVendor         types.String `tfsdk:"ddns_vendor"`
	DdnsVendorConfig   types.List   `tfsdk:"ddns_vendor_config"`
}
type AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type AggregateInterfaceResourceLayer3DhcpClientObject struct {
	CreateDefaultRoute types.Bool                                                    `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64                                                   `tfsdk:"default_route_metric"`
	Enable             types.Bool                                                    `tfsdk:"enable"`
	SendHostname       *AggregateInterfaceResourceLayer3DhcpClientSendHostnameObject `tfsdk:"send_hostname"`
}
type AggregateInterfaceResourceLayer3DhcpClientSendHostnameObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	Hostname types.String `tfsdk:"hostname"`
}
type AggregateInterfaceResourceLayer3IpObject struct {
	Name         types.String `tfsdk:"name"`
	SdwanGateway types.String `tfsdk:"sdwan_gateway"`
}
type AggregateInterfaceResourceLayer3Ipv6Object struct {
	Address           types.List                                                   `tfsdk:"address"`
	Enabled           types.Bool                                                   `tfsdk:"enabled"`
	InterfaceId       types.String                                                 `tfsdk:"interface_id"`
	NeighborDiscovery *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
	DhcpClient        *AggregateInterfaceResourceLayer3Ipv6DhcpClientObject        `tfsdk:"dhcp_client"`
	Inherited         *AggregateInterfaceResourceLayer3Ipv6InheritedObject         `tfsdk:"inherited"`
}
type AggregateInterfaceResourceLayer3Ipv6AddressObject struct {
	Name              types.String                                                `tfsdk:"name"`
	EnableOnInterface types.Bool                                                  `tfsdk:"enable_on_interface"`
	Prefix            *AggregateInterfaceResourceLayer3Ipv6AddressPrefixObject    `tfsdk:"prefix"`
	Anycast           *AggregateInterfaceResourceLayer3Ipv6AddressAnycastObject   `tfsdk:"anycast"`
	Advertise         *AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseObject `tfsdk:"advertise"`
}
type AggregateInterfaceResourceLayer3Ipv6AddressPrefixObject struct {
}
type AggregateInterfaceResourceLayer3Ipv6AddressAnycastObject struct {
}
type AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryObject struct {
	DadAttempts         types.Int64                                                                     `tfsdk:"dad_attempts"`
	EnableDad           types.Bool                                                                      `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool                                                                      `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List                                                                      `tfsdk:"neighbor"`
	NsInterval          types.Int64                                                                     `tfsdk:"ns_interval"`
	ReachableTime       types.Int64                                                                     `tfsdk:"reachable_time"`
	RouterAdvertisement *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject `tfsdk:"router_advertisement"`
}
type AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject struct {
	DnsSupport             *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject `tfsdk:"dns_support"`
	Enable                 types.Bool                                                                                `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool                                                                                `tfsdk:"enable_consistency_check"`
	HopLimit               types.String                                                                              `tfsdk:"hop_limit"`
	Lifetime               types.Int64                                                                               `tfsdk:"lifetime"`
	LinkMtu                types.String                                                                              `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool                                                                                `tfsdk:"managed_flag"`
	MaxInterval            types.Int64                                                                               `tfsdk:"max_interval"`
	MinInterval            types.Int64                                                                               `tfsdk:"min_interval"`
	OtherFlag              types.Bool                                                                                `tfsdk:"other_flag"`
	ReachableTime          types.String                                                                              `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String                                                                              `tfsdk:"retransmission_timer"`
	RouterPreference       types.String                                                                              `tfsdk:"router_preference"`
}
type AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject struct {
	Enable types.Bool `tfsdk:"enable"`
	Server types.List `tfsdk:"server"`
	Suffix types.List `tfsdk:"suffix"`
}
type AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientObject struct {
	AcceptRaRoute      types.Bool                                                             `tfsdk:"accept_ra_route"`
	DefaultRouteMetric types.Int64                                                            `tfsdk:"default_route_metric"`
	Enable             types.Bool                                                             `tfsdk:"enable"`
	NeighborDiscovery  *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
	Preference         types.String                                                           `tfsdk:"preference"`
	PrefixDelegation   *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject  `tfsdk:"prefix_delegation"`
	V6Options          *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject         `tfsdk:"v6_options"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject struct {
	DadAttempts      types.Int64                                                                     `tfsdk:"dad_attempts"`
	DnsServer        *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject `tfsdk:"dns_server"`
	DnsSuffix        *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject `tfsdk:"dns_suffix"`
	EnableDad        types.Bool                                                                      `tfsdk:"enable_dad"`
	EnableNdpMonitor types.Bool                                                                      `tfsdk:"enable_ndp_monitor"`
	Neighbor         types.List                                                                      `tfsdk:"neighbor"`
	NsInterval       types.Int64                                                                     `tfsdk:"ns_interval"`
	ReachableTime    types.Int64                                                                     `tfsdk:"reachable_time"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool                                                                            `tfsdk:"enable"`
	Source *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject `tfsdk:"source"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool                                                                            `tfsdk:"enable"`
	Source *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject `tfsdk:"source"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject struct {
	Enable *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject `tfsdk:"enable"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject struct {
	No  *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject  `tfsdk:"no"`
	Yes *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject `tfsdk:"yes"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject struct {
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject struct {
	PfxPoolName   types.String `tfsdk:"pfx_pool_name"`
	PrefixLen     types.Int64  `tfsdk:"prefix_len"`
	PrefixLenHint types.Bool   `tfsdk:"prefix_len_hint"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject struct {
	DuidType            types.String                                                         `tfsdk:"duid_type"`
	Enable              *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject `tfsdk:"enable"`
	RapidCommit         types.Bool                                                           `tfsdk:"rapid_commit"`
	SupportSrvrReconfig types.Bool                                                           `tfsdk:"support_srvr_reconfig"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject struct {
	No  *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject  `tfsdk:"no"`
	Yes *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject `tfsdk:"yes"`
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject struct {
}
type AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject struct {
	NonTempAddr types.Bool `tfsdk:"non_temp_addr"`
	TempAddr    types.Bool `tfsdk:"temp_addr"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedObject struct {
	AssignAddr        types.List                                                            `tfsdk:"assign_addr"`
	Enable            types.Bool                                                            `tfsdk:"enable"`
	NeighborDiscovery *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject `tfsdk:"neighbor_discovery"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrObject struct {
	Name types.String                                                       `tfsdk:"name"`
	Type *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject `tfsdk:"type"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject struct {
	Gua *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject `tfsdk:"gua"`
	Ula *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject `tfsdk:"ula"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject struct {
	EnableOnInterface types.Bool                                                                     `tfsdk:"enable_on_interface"`
	PrefixPool        types.String                                                                   `tfsdk:"prefix_pool"`
	PoolType          *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject  `tfsdk:"pool_type"`
	Advertise         *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject `tfsdk:"advertise"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject struct {
	Dynamic   *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject   `tfsdk:"dynamic"`
	DynamicId *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject `tfsdk:"dynamic_id"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject struct {
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject struct {
	Identifier types.Int64 `tfsdk:"identifier"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject struct {
	Enable         types.Bool `tfsdk:"enable"`
	OnlinkFlag     types.Bool `tfsdk:"onlink_flag"`
	AutoConfigFlag types.Bool `tfsdk:"auto_config_flag"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject struct {
	EnableOnInterface types.Bool                                                                     `tfsdk:"enable_on_interface"`
	Address           types.String                                                                   `tfsdk:"address"`
	Prefix            types.Bool                                                                     `tfsdk:"prefix"`
	Anycast           types.Bool                                                                     `tfsdk:"anycast"`
	Advertise         *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject `tfsdk:"advertise"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject struct {
	DadAttempts         types.Int64                                                                              `tfsdk:"dad_attempts"`
	DnsServer           *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject           `tfsdk:"dns_server"`
	DnsSuffix           *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject           `tfsdk:"dns_suffix"`
	EnableDad           types.Bool                                                                               `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool                                                                               `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List                                                                               `tfsdk:"neighbor"`
	NsInterval          types.Int64                                                                              `tfsdk:"ns_interval"`
	ReachableTime       types.Int64                                                                              `tfsdk:"reachable_time"`
	RouterAdvertisement *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject `tfsdk:"router_advertisement"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool                                                                           `tfsdk:"enable"`
	Source *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject `tfsdk:"source"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool                                                                           `tfsdk:"enable"`
	Source *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject `tfsdk:"source"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object `tfsdk:"dhcpv6"`
	Manual *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject `tfsdk:"manual"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject struct {
	Enable                 types.Bool   `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	RouterPreference       types.String `tfsdk:"router_preference"`
}
type AggregateInterfaceResourceLayer3LacpObject struct {
	Enable           types.Bool                                                  `tfsdk:"enable"`
	FastFailover     types.Bool                                                  `tfsdk:"fast_failover"`
	HighAvailability *AggregateInterfaceResourceLayer3LacpHighAvailabilityObject `tfsdk:"high_availability"`
	MaxPorts         types.Int64                                                 `tfsdk:"max_ports"`
	Mode             types.String                                                `tfsdk:"mode"`
	SystemPriority   types.Int64                                                 `tfsdk:"system_priority"`
	TransmissionRate types.String                                                `tfsdk:"transmission_rate"`
}
type AggregateInterfaceResourceLayer3LacpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceResourceLayer3LldpObject struct {
	Enable           types.Bool                                                  `tfsdk:"enable"`
	HighAvailability *AggregateInterfaceResourceLayer3LldpHighAvailabilityObject `tfsdk:"high_availability"`
	Profile          types.String                                                `tfsdk:"profile"`
}
type AggregateInterfaceResourceLayer3LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type AggregateInterfaceResourceLayer3NdpProxyObject struct {
	Address types.List `tfsdk:"address"`
	Enabled types.Bool `tfsdk:"enabled"`
}
type AggregateInterfaceResourceLayer3NdpProxyAddressObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
}
type AggregateInterfaceResourceLayer3SdwanLinkSettingsObject struct {
	Enable                types.Bool                                                          `tfsdk:"enable"`
	SdwanInterfaceProfile types.String                                                        `tfsdk:"sdwan_interface_profile"`
	UpstreamNat           *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject `tfsdk:"upstream_nat"`
}
type AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject struct {
	Enable   types.Bool                                                                  `tfsdk:"enable"`
	Ddns     *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject     `tfsdk:"ddns"`
	StaticIp *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject `tfsdk:"static_ip"`
}
type AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject struct {
}
type AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject struct {
	Fqdn      types.String `tfsdk:"fqdn"`
	IpAddress types.String `tfsdk:"ip_address"`
}
type AggregateInterfaceResourceVirtualWireObject struct {
	Lldp           *AggregateInterfaceResourceVirtualWireLldpObject `tfsdk:"lldp"`
	NetflowProfile types.String                                     `tfsdk:"netflow_profile"`
}
type AggregateInterfaceResourceVirtualWireLldpObject struct {
	Enable           types.Bool                                                       `tfsdk:"enable"`
	HighAvailability *AggregateInterfaceResourceVirtualWireLldpHighAvailabilityObject `tfsdk:"high_availability"`
	Profile          types.String                                                     `tfsdk:"profile"`
}
type AggregateInterfaceResourceVirtualWireLldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}

func (r *AggregateInterfaceResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func AggregateInterfaceResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": AggregateInterfaceResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"decrypt_mirror": AggregateInterfaceResourceDecryptMirrorSchema(),

			"ha": AggregateInterfaceResourceHaSchema(),

			"layer2": AggregateInterfaceResourceLayer2Schema(),

			"layer3": AggregateInterfaceResourceLayer3Schema(),

			"virtual_wire": AggregateInterfaceResourceVirtualWireSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceModel) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceDecryptMirrorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("decrypt_mirror"),
				path.MatchRelative().AtParent().AtName("ha"),
				path.MatchRelative().AtParent().AtName("layer2"),
				path.MatchRelative().AtParent().AtName("layer3"),
				path.MatchRelative().AtParent().AtName("virtual_wire"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceDecryptMirrorObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceDecryptMirrorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceHaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lacp": AggregateInterfaceResourceHaLacpSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceHaObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceHaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceHaLacpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_failover": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_ports": rsschema.Int64Attribute{
				Description: "maximum number of physical ports bundled in the LAG",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(8),
			},

			"mode": rsschema.StringAttribute{
				Description: "LACP mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("passive"),
			},

			"system_priority": rsschema.Int64Attribute{
				Description: "LACP system priority in system ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(32768),
			},

			"transmission_rate": rsschema.StringAttribute{
				Description: "periodic transition rate. N/A in passive mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("slow"),
			},
		},
	}
}

func (o *AggregateInterfaceResourceHaLacpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceHaLacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer2Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lacp": AggregateInterfaceResourceLayer2LacpSchema(),

			"lldp": AggregateInterfaceResourceLayer2LldpSchema(),

			"netflow_profile": rsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer2Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer2LacpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_failover": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceResourceLayer2LacpHighAvailabilitySchema(),

			"max_ports": rsschema.Int64Attribute{
				Description: "maximum number of physical ports bundled in the LAG",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(8),
			},

			"mode": rsschema.StringAttribute{
				Description: "LACP mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("passive"),
			},

			"system_priority": rsschema.Int64Attribute{
				Description: "LACP system priority in system ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(32768),
			},

			"transmission_rate": rsschema.StringAttribute{
				Description: "periodic transition rate. N/A in passive mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("slow"),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer2LacpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer2LacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer2LacpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LACP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer2LacpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer2LacpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer2LldpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceResourceLayer2LldpHighAvailabilitySchema(),

			"profile": rsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer2LldpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer2LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer2LldpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer2LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer2LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"adjust_tcp_mss": AggregateInterfaceResourceLayer3AdjustTcpMssSchema(),

			"arp": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3ArpSchema(),
			},

			"bonjour": AggregateInterfaceResourceLayer3BonjourSchema(),

			"ddns_config": AggregateInterfaceResourceLayer3DdnsConfigSchema(),

			"decrypt_forward": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"df_ignore": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dhcp_client": AggregateInterfaceResourceLayer3DhcpClientSchema(),

			"interface_management_profile": rsschema.StringAttribute{
				Description: "Interface management profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3IpSchema(),
			},

			"ipv6": AggregateInterfaceResourceLayer3Ipv6Schema(),

			"lacp": AggregateInterfaceResourceLayer3LacpSchema(),

			"lldp": AggregateInterfaceResourceLayer3LldpSchema(),

			"mtu": rsschema.Int64Attribute{
				Description: "Maximum Transfer Unit, up to 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ndp_proxy": AggregateInterfaceResourceLayer3NdpProxySchema(),

			"netflow_profile": rsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_link_settings": AggregateInterfaceResourceLayer3SdwanLinkSettingsSchema(),

			"untagged_sub_interface": rsschema.BoolAttribute{
				Description: "Enable untagged sub-interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3AdjustTcpMssSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Set if TCP MSS value should be reduced based on mtu",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4_mss_adjustment": rsschema.Int64Attribute{
				Description: "IPv4 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(40),
			},

			"ipv6_mss_adjustment": rsschema.Int64Attribute{
				Description: "IPv6 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3AdjustTcpMssObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3AdjustTcpMssSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3ArpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3ArpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3ArpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3BonjourSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Set to support Bonjour service",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_id": rsschema.Int64Attribute{
				Description: "default 0: NO-Group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(40),
			},

			"ttl_check": rsschema.BoolAttribute{
				Description: "Set to check and update TTL",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3BonjourObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3BonjourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3DdnsConfigSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ddns_cert_profile": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_enabled": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_hostname": rsschema.StringAttribute{
				Description: "ddns hostname variable or real address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_ip": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_ipv6": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_update_interval": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"ddns_vendor": rsschema.StringAttribute{
				Description: "Vendor and product type",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_vendor_config": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3DdnsConfigObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3DdnsConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3DhcpClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"create_default_route": rsschema.BoolAttribute{
				Description: "Automatically create default route pointing to default gateway provided by server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": rsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_hostname": AggregateInterfaceResourceLayer3DhcpClientSendHostnameSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3DhcpClientSendHostnameSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": rsschema.StringAttribute{
				Description: "Set Interface Hostname",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("system-hostname"),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3DhcpClientSendHostnameObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3DhcpClientSendHostnameSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3IpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"sdwan_gateway": rsschema.StringAttribute{
				Description: "Gateway IPv4 Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3IpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3IpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6AddressSchema(),
			},

			"enabled": rsschema.BoolAttribute{
				Description: "Enable IPv6 on the interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface_id": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("EUI-64"),
			},

			"neighbor_discovery": AggregateInterfaceResourceLayer3Ipv6NeighborDiscoverySchema(),

			"dhcp_client": AggregateInterfaceResourceLayer3Ipv6DhcpClientSchema(),

			"inherited": AggregateInterfaceResourceLayer3Ipv6InheritedSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6AddressSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable_on_interface": rsschema.BoolAttribute{
				Description: "configure this address on interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": AggregateInterfaceResourceLayer3Ipv6AddressPrefixSchema(),

			"anycast": AggregateInterfaceResourceLayer3Ipv6AddressAnycastSchema(),

			"advertise": AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6AddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6AddressPrefixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6AddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6AddressAnycastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressAnycastObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6AddressAnycastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": rsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2592000"),
			},

			"preferred_lifetime": rsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("604800"),
			},

			"onlink_flag": rsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": rsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6NeighborDiscoverySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dad_attempts": rsschema.Int64Attribute{
				Description: "number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"enable_dad": rsschema.BoolAttribute{
				Description: "enable duplicate address detection",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": rsschema.BoolAttribute{
				Description: "enable ndp monitoring",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": rsschema.Int64Attribute{
				Description: "interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"reachable_time": rsschema.Int64Attribute{
				Description: "time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"router_advertisement": AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6NeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dns_support": AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": rsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": rsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("64"),
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1800),
			},

			"link_mtu": rsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"managed_flag": rsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": rsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(600),
			},

			"min_interval": rsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"other_flag": rsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": rsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"retransmission_timer": rsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"router_preference": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Medium"),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema(),
			},

			"suffix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"accept_ra_route": rsschema.BoolAttribute{
				Description: "Accept Router Advertised Default Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": rsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable DHCPv6 Client",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoverySchema(),

			"preference": rsschema.StringAttribute{
				Description: "Select Low/Medium/High",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("high"),
			},

			"prefix_delegation": AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationSchema(),

			"v6_options": AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoverySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dad_attempts": rsschema.Int64Attribute{
				Description: "number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"dns_server": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": rsschema.BoolAttribute{
				Description: "Enable Duplicate Address Detection",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": rsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": rsschema.Int64Attribute{
				Description: "interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"reachable_time": rsschema.Int64Attribute{
				Description: "time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"server": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"suffix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no": AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema(),

			"yes": AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"pfx_pool_name": rsschema.StringAttribute{
				Description: "Configure unique Prefix Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_len": rsschema.Int64Attribute{
				Description: "Hint DHCP Prefix Length (bits)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(48),
			},

			"prefix_len_hint": rsschema.BoolAttribute{
				Description: "Send prefix length hint to server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"duid_type": rsschema.StringAttribute{
				Description: "Select DUID-LLT/DUID-LL",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("duid-type-llt"),
			},

			"enable": AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableSchema(),

			"rapid_commit": rsschema.BoolAttribute{
				Description: "Enable Rapid Commit",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"support_srvr_reconfig": rsschema.BoolAttribute{
				Description: "Enable DHCPv6 Server Re-Configuration Support",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no": AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema(),

			"yes": AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"non_temp_addr": rsschema.BoolAttribute{
				Description: "Request Non-Temporary Address Type",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"temp_addr": rsschema.BoolAttribute{
				Description: "Request Temporary Address Type",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"assign_addr": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable Inherited Interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoverySchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"gua": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema(),

			"ula": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"enable_on_interface": rsschema.BoolAttribute{
				Description: "Enable on Interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_pool": rsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pool_type": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema(),

			"advertise": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dynamic": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema(),

			"dynamic_id": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"identifier": rsschema.Int64Attribute{
				Description: "Range [0-4095] must be unqiue for this prefix-pool",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable advertising this prefix in router advertisements",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": rsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": rsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"enable_on_interface": rsschema.BoolAttribute{
				Description: "Configure this address on Interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": rsschema.StringAttribute{
				Description: "Configure ULA (Unique Local Address)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": rsschema.BoolAttribute{
				Description: "Use this as prefix to form full address with interface id/EUI-64",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anycast": rsschema.BoolAttribute{
				Description: "Anycast Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertise": AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": rsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2592000"),
			},

			"preferred_lifetime": rsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("604800"),
			},

			"onlink_flag": rsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": rsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoverySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dad_attempts": rsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"dns_server": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": rsschema.BoolAttribute{
				Description: "Enable Duplicate Address Detection (DAD)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": rsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"reachable_time": rsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"router_advertisement": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"prefix_pool": rsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"server": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"prefix_pool": rsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"suffix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": rsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": rsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("64"),
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1800),
			},

			"link_mtu": rsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"managed_flag": rsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": rsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(600),
			},

			"min_interval": rsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"other_flag": rsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": rsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"retransmission_timer": rsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"router_preference": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Medium"),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3LacpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_failover": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceResourceLayer3LacpHighAvailabilitySchema(),

			"max_ports": rsschema.Int64Attribute{
				Description: "maximum number of physical ports bundled in the LAG",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(8),
			},

			"mode": rsschema.StringAttribute{
				Description: "LACP mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("passive"),
			},

			"system_priority": rsschema.Int64Attribute{
				Description: "LACP system priority in system ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(32768),
			},

			"transmission_rate": rsschema.StringAttribute{
				Description: "periodic transition rate. N/A in passive mode",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("slow"),
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3LacpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3LacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3LacpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LACP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3LacpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3LacpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3LldpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceResourceLayer3LldpHighAvailabilitySchema(),

			"profile": rsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3LldpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3LldpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3NdpProxySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: AggregateInterfaceResourceLayer3NdpProxyAddressSchema(),
			},

			"enabled": rsschema.BoolAttribute{
				Description: "Enable proxy NDP on the interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3NdpProxyObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3NdpProxySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3NdpProxyAddressSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"negate": rsschema.BoolAttribute{
				Description: "put the prefix or address on a block list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3NdpProxyAddressObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3NdpProxyAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3SdwanLinkSettingsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable sdwan on this ethernet interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_interface_profile": rsschema.StringAttribute{
				Description: "Sdwan link characteristics",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"upstream_nat": AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3SdwanLinkSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable upstream NAT IP config",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns": AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema(),

			"static_ip": AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema(),
		},
	}
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"fqdn": rsschema.StringAttribute{
				Description: "Upstream NAT address FQDN name configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("fqdn"),
						path.MatchRelative().AtParent().AtName("ip_address"),
					}...),
				},
			},

			"ip_address": rsschema.StringAttribute{
				Description: "Upstream NAT IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceVirtualWireSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lldp": AggregateInterfaceResourceVirtualWireLldpSchema(),

			"netflow_profile": rsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceVirtualWireObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceVirtualWireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceVirtualWireLldpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": AggregateInterfaceResourceVirtualWireLldpHighAvailabilitySchema(),

			"profile": rsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceVirtualWireLldpObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceVirtualWireLldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func AggregateInterfaceResourceVirtualWireLldpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *AggregateInterfaceResourceVirtualWireLldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := AggregateInterfaceResourceVirtualWireLldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *AggregateInterfaceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_aggregate_interface"
}

func (r *AggregateInterfaceResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = AggregateInterfaceResourceSchema()
}

// </ResourceSchema>

func (r *AggregateInterfaceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	r.client = providerData.Client
	specifier, _, err := aggregate.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	r.manager = sdkmanager.NewEntryObjectManager(r.client, aggregate.NewService(r.client), batchSize, specifier, aggregate.SpecMatches)
}

func (o *AggregateInterfaceResourceModel) CopyToPango(ctx context.Context, obj **aggregate.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	comment_value := o.Comment.ValueStringPointer()
	var decryptMirror_entry *aggregate.DecryptMirror
	if o.DecryptMirror != nil {
		if *obj != nil && (*obj).DecryptMirror != nil {
			decryptMirror_entry = (*obj).DecryptMirror
		} else {
			decryptMirror_entry = new(aggregate.DecryptMirror)
		}

		diags.Append(o.DecryptMirror.CopyToPango(ctx, &decryptMirror_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_entry *aggregate.Ha
	if o.Ha != nil {
		if *obj != nil && (*obj).Ha != nil {
			ha_entry = (*obj).Ha
		} else {
			ha_entry = new(aggregate.Ha)
		}

		diags.Append(o.Ha.CopyToPango(ctx, &ha_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer2_entry *aggregate.Layer2
	if o.Layer2 != nil {
		if *obj != nil && (*obj).Layer2 != nil {
			layer2_entry = (*obj).Layer2
		} else {
			layer2_entry = new(aggregate.Layer2)
		}

		diags.Append(o.Layer2.CopyToPango(ctx, &layer2_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_entry *aggregate.Layer3
	if o.Layer3 != nil {
		if *obj != nil && (*obj).Layer3 != nil {
			layer3_entry = (*obj).Layer3
		} else {
			layer3_entry = new(aggregate.Layer3)
		}

		diags.Append(o.Layer3.CopyToPango(ctx, &layer3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var virtualWire_entry *aggregate.VirtualWire
	if o.VirtualWire != nil {
		if *obj != nil && (*obj).VirtualWire != nil {
			virtualWire_entry = (*obj).VirtualWire
		} else {
			virtualWire_entry = new(aggregate.VirtualWire)
		}

		diags.Append(o.VirtualWire.CopyToPango(ctx, &virtualWire_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Comment = comment_value
	(*obj).DecryptMirror = decryptMirror_entry
	(*obj).Ha = ha_entry
	(*obj).Layer2 = layer2_entry
	(*obj).Layer3 = layer3_entry
	(*obj).VirtualWire = virtualWire_entry

	return diags
}
func (o *AggregateInterfaceResourceDecryptMirrorObject) CopyToPango(ctx context.Context, obj **aggregate.DecryptMirror, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.DecryptMirror)
	}

	return diags
}
func (o *AggregateInterfaceResourceHaObject) CopyToPango(ctx context.Context, obj **aggregate.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_entry *aggregate.HaLacp
	if o.Lacp != nil {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(aggregate.HaLacp)
		}

		diags.Append(o.Lacp.CopyToPango(ctx, &lacp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Ha)
	}
	(*obj).Lacp = lacp_entry

	return diags
}
func (o *AggregateInterfaceResourceHaLacpObject) CopyToPango(ctx context.Context, obj **aggregate.HaLacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	fastFailover_value := o.FastFailover.ValueBoolPointer()
	maxPorts_value := o.MaxPorts.ValueInt64Pointer()
	mode_value := o.Mode.ValueStringPointer()
	systemPriority_value := o.SystemPriority.ValueInt64Pointer()
	transmissionRate_value := o.TransmissionRate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.HaLacp)
	}
	(*obj).Enable = enable_value
	(*obj).FastFailover = fastFailover_value
	(*obj).MaxPorts = maxPorts_value
	(*obj).Mode = mode_value
	(*obj).SystemPriority = systemPriority_value
	(*obj).TransmissionRate = transmissionRate_value

	return diags
}
func (o *AggregateInterfaceResourceLayer2Object) CopyToPango(ctx context.Context, obj **aggregate.Layer2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_entry *aggregate.Layer2Lacp
	if o.Lacp != nil {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(aggregate.Layer2Lacp)
		}

		diags.Append(o.Lacp.CopyToPango(ctx, &lacp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *aggregate.Layer2Lldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(aggregate.Layer2Lldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2)
	}
	(*obj).Lacp = lacp_entry
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *AggregateInterfaceResourceLayer2LacpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	fastFailover_value := o.FastFailover.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer2LacpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer2LacpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPorts_value := o.MaxPorts.ValueInt64Pointer()
	mode_value := o.Mode.ValueStringPointer()
	systemPriority_value := o.SystemPriority.ValueInt64Pointer()
	transmissionRate_value := o.TransmissionRate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2Lacp)
	}
	(*obj).Enable = enable_value
	(*obj).FastFailover = fastFailover_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).MaxPorts = maxPorts_value
	(*obj).Mode = mode_value
	(*obj).SystemPriority = systemPriority_value
	(*obj).TransmissionRate = transmissionRate_value

	return diags
}
func (o *AggregateInterfaceResourceLayer2LacpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2LacpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceResourceLayer2LldpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer2LldpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer2LldpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *AggregateInterfaceResourceLayer2LldpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer2LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer2LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var adjustTcpMss_entry *aggregate.Layer3AdjustTcpMss
	if o.AdjustTcpMss != nil {
		if *obj != nil && (*obj).AdjustTcpMss != nil {
			adjustTcpMss_entry = (*obj).AdjustTcpMss
		} else {
			adjustTcpMss_entry = new(aggregate.Layer3AdjustTcpMss)
		}

		diags.Append(o.AdjustTcpMss.CopyToPango(ctx, &adjustTcpMss_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var arp_tf_entries []AggregateInterfaceResourceLayer3ArpObject
	var arp_pango_entries []aggregate.Layer3Arp
	{
		d := o.Arp.ElementsAs(ctx, &arp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range arp_tf_entries {
			var entry *aggregate.Layer3Arp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			arp_pango_entries = append(arp_pango_entries, *entry)
		}
	}
	var bonjour_entry *aggregate.Layer3Bonjour
	if o.Bonjour != nil {
		if *obj != nil && (*obj).Bonjour != nil {
			bonjour_entry = (*obj).Bonjour
		} else {
			bonjour_entry = new(aggregate.Layer3Bonjour)
		}

		diags.Append(o.Bonjour.CopyToPango(ctx, &bonjour_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsConfig_entry *aggregate.Layer3DdnsConfig
	if o.DdnsConfig != nil {
		if *obj != nil && (*obj).DdnsConfig != nil {
			ddnsConfig_entry = (*obj).DdnsConfig
		} else {
			ddnsConfig_entry = new(aggregate.Layer3DdnsConfig)
		}

		diags.Append(o.DdnsConfig.CopyToPango(ctx, &ddnsConfig_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	decryptForward_value := o.DecryptForward.ValueBoolPointer()
	dfIgnore_value := o.DfIgnore.ValueBoolPointer()
	var dhcpClient_entry *aggregate.Layer3DhcpClient
	if o.DhcpClient != nil {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(aggregate.Layer3DhcpClient)
		}

		diags.Append(o.DhcpClient.CopyToPango(ctx, &dhcpClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceManagementProfile_value := o.InterfaceManagementProfile.ValueStringPointer()
	var ip_tf_entries []AggregateInterfaceResourceLayer3IpObject
	var ip_pango_entries []aggregate.Layer3Ip
	{
		d := o.Ip.ElementsAs(ctx, &ip_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ip_tf_entries {
			var entry *aggregate.Layer3Ip
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ip_pango_entries = append(ip_pango_entries, *entry)
		}
	}
	var ipv6_entry *aggregate.Layer3Ipv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(aggregate.Layer3Ipv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lacp_entry *aggregate.Layer3Lacp
	if o.Lacp != nil {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(aggregate.Layer3Lacp)
		}

		diags.Append(o.Lacp.CopyToPango(ctx, &lacp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *aggregate.Layer3Lldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(aggregate.Layer3Lldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	mtu_value := o.Mtu.ValueInt64Pointer()
	var ndpProxy_entry *aggregate.Layer3NdpProxy
	if o.NdpProxy != nil {
		if *obj != nil && (*obj).NdpProxy != nil {
			ndpProxy_entry = (*obj).NdpProxy
		} else {
			ndpProxy_entry = new(aggregate.Layer3NdpProxy)
		}

		diags.Append(o.NdpProxy.CopyToPango(ctx, &ndpProxy_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()
	var sdwanLinkSettings_entry *aggregate.Layer3SdwanLinkSettings
	if o.SdwanLinkSettings != nil {
		if *obj != nil && (*obj).SdwanLinkSettings != nil {
			sdwanLinkSettings_entry = (*obj).SdwanLinkSettings
		} else {
			sdwanLinkSettings_entry = new(aggregate.Layer3SdwanLinkSettings)
		}

		diags.Append(o.SdwanLinkSettings.CopyToPango(ctx, &sdwanLinkSettings_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	untaggedSubInterface_value := o.UntaggedSubInterface.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3)
	}
	(*obj).AdjustTcpMss = adjustTcpMss_entry
	(*obj).Arp = arp_pango_entries
	(*obj).Bonjour = bonjour_entry
	(*obj).DdnsConfig = ddnsConfig_entry
	(*obj).DecryptForward = decryptForward_value
	(*obj).DfIgnore = dfIgnore_value
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).InterfaceManagementProfile = interfaceManagementProfile_value
	(*obj).Ip = ip_pango_entries
	(*obj).Ipv6 = ipv6_entry
	(*obj).Lacp = lacp_entry
	(*obj).Lldp = lldp_entry
	(*obj).Mtu = mtu_value
	(*obj).NdpProxy = ndpProxy_entry
	(*obj).NetflowProfile = netflowProfile_value
	(*obj).SdwanLinkSettings = sdwanLinkSettings_entry
	(*obj).UntaggedSubInterface = untaggedSubInterface_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3AdjustTcpMssObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	ipv4MssAdjustment_value := o.Ipv4MssAdjustment.ValueInt64Pointer()
	ipv6MssAdjustment_value := o.Ipv6MssAdjustment.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3AdjustTcpMss)
	}
	(*obj).Enable = enable_value
	(*obj).Ipv4MssAdjustment = ipv4MssAdjustment_value
	(*obj).Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3ArpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Arp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3BonjourObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	groupId_value := o.GroupId.ValueInt64Pointer()
	ttlCheck_value := o.TtlCheck.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Bonjour)
	}
	(*obj).Enable = enable_value
	(*obj).GroupId = groupId_value
	(*obj).TtlCheck = ttlCheck_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3DdnsConfigObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DdnsConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ddnsCertProfile_value := o.DdnsCertProfile.ValueStringPointer()
	ddnsEnabled_value := o.DdnsEnabled.ValueBoolPointer()
	ddnsHostname_value := o.DdnsHostname.ValueStringPointer()
	ddnsIp_pango_entries := make([]string, 0)
	diags.Append(o.DdnsIp.ElementsAs(ctx, &ddnsIp_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	ddnsIpv6_pango_entries := make([]string, 0)
	diags.Append(o.DdnsIpv6.ElementsAs(ctx, &ddnsIpv6_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	ddnsUpdateInterval_value := o.DdnsUpdateInterval.ValueInt64Pointer()
	ddnsVendor_value := o.DdnsVendor.ValueStringPointer()
	var ddnsVendorConfig_tf_entries []AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject
	var ddnsVendorConfig_pango_entries []aggregate.Layer3DdnsConfigDdnsVendorConfig
	{
		d := o.DdnsVendorConfig.ElementsAs(ctx, &ddnsVendorConfig_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ddnsVendorConfig_tf_entries {
			var entry *aggregate.Layer3DdnsConfigDdnsVendorConfig
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ddnsVendorConfig_pango_entries = append(ddnsVendorConfig_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DdnsConfig)
	}
	(*obj).DdnsCertProfile = ddnsCertProfile_value
	(*obj).DdnsEnabled = ddnsEnabled_value
	(*obj).DdnsHostname = ddnsHostname_value
	(*obj).DdnsIp = ddnsIp_pango_entries
	(*obj).DdnsIpv6 = ddnsIpv6_pango_entries
	(*obj).DdnsUpdateInterval = ddnsUpdateInterval_value
	(*obj).DdnsVendor = ddnsVendor_value
	(*obj).DdnsVendorConfig = ddnsVendorConfig_pango_entries

	return diags
}
func (o *AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DdnsConfigDdnsVendorConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DdnsConfigDdnsVendorConfig)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3DhcpClientObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var sendHostname_entry *aggregate.Layer3DhcpClientSendHostname
	if o.SendHostname != nil {
		if *obj != nil && (*obj).SendHostname != nil {
			sendHostname_entry = (*obj).SendHostname
		} else {
			sendHostname_entry = new(aggregate.Layer3DhcpClientSendHostname)
		}

		diags.Append(o.SendHostname.CopyToPango(ctx, &sendHostname_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DhcpClient)
	}
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).SendHostname = sendHostname_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3DhcpClientSendHostnameObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3DhcpClientSendHostname)
	}
	(*obj).Enable = enable_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3IpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	sdwanGateway_value := o.SdwanGateway.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ip)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SdwanGateway = sdwanGateway_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []AggregateInterfaceResourceLayer3Ipv6AddressObject
	var address_pango_entries []aggregate.Layer3Ipv6Address
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *aggregate.Layer3Ipv6Address
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()
	interfaceId_value := o.InterfaceId.ValueStringPointer()
	var neighborDiscovery_entry *aggregate.Layer3Ipv6NeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(aggregate.Layer3Ipv6NeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_entry *aggregate.Layer3Ipv6DhcpClient
	if o.DhcpClient != nil {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(aggregate.Layer3Ipv6DhcpClient)
		}

		diags.Append(o.DhcpClient.CopyToPango(ctx, &dhcpClient_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var inherited_entry *aggregate.Layer3Ipv6Inherited
	if o.Inherited != nil {
		if *obj != nil && (*obj).Inherited != nil {
			inherited_entry = (*obj).Inherited
		} else {
			inherited_entry = new(aggregate.Layer3Ipv6Inherited)
		}

		diags.Append(o.Inherited.CopyToPango(ctx, &inherited_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6)
	}
	(*obj).Address = address_pango_entries
	(*obj).Enabled = enabled_value
	(*obj).InterfaceId = interfaceId_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).Inherited = inherited_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6AddressObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6Address, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	var prefix_entry *aggregate.Layer3Ipv6AddressPrefix
	if o.Prefix != nil {
		if *obj != nil && (*obj).Prefix != nil {
			prefix_entry = (*obj).Prefix
		} else {
			prefix_entry = new(aggregate.Layer3Ipv6AddressPrefix)
		}

		diags.Append(o.Prefix.CopyToPango(ctx, &prefix_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var anycast_entry *aggregate.Layer3Ipv6AddressAnycast
	if o.Anycast != nil {
		if *obj != nil && (*obj).Anycast != nil {
			anycast_entry = (*obj).Anycast
		} else {
			anycast_entry = new(aggregate.Layer3Ipv6AddressAnycast)
		}

		diags.Append(o.Anycast.CopyToPango(ctx, &anycast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *aggregate.Layer3Ipv6AddressAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(aggregate.Layer3Ipv6AddressAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6Address)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Prefix = prefix_entry
	(*obj).Anycast = anycast_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6AddressPrefixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6AddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6AddressPrefix)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6AddressAnycastObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6AddressAnycast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6AddressAnycast)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6AddressAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6AddressAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
	var neighbor_pango_entries []aggregate.Layer3Ipv6NeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *aggregate.Layer3Ipv6NeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement
	if o.RouterAdvertisement != nil {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
		}

		diags.Append(o.RouterAdvertisement.CopyToPango(ctx, &routerAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport
	if o.DnsSupport != nil {
		if *obj != nil && (*obj).DnsSupport != nil {
			dnsSupport_entry = (*obj).DnsSupport
		} else {
			dnsSupport_entry = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
		}

		diags.Append(o.DnsSupport.CopyToPango(ctx, &dnsSupport_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
	}
	(*obj).DnsSupport = dnsSupport_entry
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var server_tf_entries []AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
	var server_pango_entries []aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}
	var suffix_tf_entries []AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
	var suffix_pango_entries []aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
	}
	(*obj).Enable = enable_value
	(*obj).Server = server_pango_entries
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptRaRoute_value := o.AcceptRaRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	preference_value := o.Preference.ValueStringPointer()
	var prefixDelegation_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegation
	if o.PrefixDelegation != nil {
		if *obj != nil && (*obj).PrefixDelegation != nil {
			prefixDelegation_entry = (*obj).PrefixDelegation
		} else {
			prefixDelegation_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegation)
		}

		diags.Append(o.PrefixDelegation.CopyToPango(ctx, &prefixDelegation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var v6Options_entry *aggregate.Layer3Ipv6DhcpClientV6Options
	if o.V6Options != nil {
		if *obj != nil && (*obj).V6Options != nil {
			v6Options_entry = (*obj).V6Options
		} else {
			v6Options_entry = new(aggregate.Layer3Ipv6DhcpClientV6Options)
		}

		diags.Append(o.V6Options.CopyToPango(ctx, &v6Options_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClient)
	}
	(*obj).AcceptRaRoute = acceptRaRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).Preference = preference_value
	(*obj).PrefixDelegation = prefixDelegation_entry
	(*obj).V6Options = v6Options_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer
	if o.DnsServer != nil {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
		}

		diags.Append(o.DnsServer.CopyToPango(ctx, &dnsServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix
	if o.DnsSuffix != nil {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
		}

		diags.Append(o.DnsSuffix.CopyToPango(ctx, &dnsSuffix_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable
	if o.Enable != nil {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable)
		}

		diags.Append(o.Enable.CopyToPango(ctx, &enable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegation)
	}
	(*obj).Enable = enable_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo
	if o.No != nil {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
		}

		diags.Append(o.No.CopyToPango(ctx, &no_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes
	if o.Yes != nil {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
		}

		diags.Append(o.Yes.CopyToPango(ctx, &yes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	pfxPoolName_value := o.PfxPoolName.ValueStringPointer()
	prefixLen_value := o.PrefixLen.ValueInt64Pointer()
	prefixLenHint_value := o.PrefixLenHint.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
	}
	(*obj).PfxPoolName = pfxPoolName_value
	(*obj).PrefixLen = prefixLen_value
	(*obj).PrefixLenHint = prefixLenHint_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6Options, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	duidType_value := o.DuidType.ValueStringPointer()
	var enable_entry *aggregate.Layer3Ipv6DhcpClientV6OptionsEnable
	if o.Enable != nil {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnable)
		}

		diags.Append(o.Enable.CopyToPango(ctx, &enable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	rapidCommit_value := o.RapidCommit.ValueBoolPointer()
	supportSrvrReconfig_value := o.SupportSrvrReconfig.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6Options)
	}
	(*obj).DuidType = duidType_value
	(*obj).Enable = enable_entry
	(*obj).RapidCommit = rapidCommit_value
	(*obj).SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6OptionsEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo
	if o.No != nil {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo)
		}

		diags.Append(o.No.CopyToPango(ctx, &no_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes
	if o.Yes != nil {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes)
		}

		diags.Append(o.Yes.CopyToPango(ctx, &yes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	nonTempAddr_value := o.NonTempAddr.ValueBoolPointer()
	tempAddr_value := o.TempAddr.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes)
	}
	(*obj).NonTempAddr = nonTempAddr_value
	(*obj).TempAddr = tempAddr_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6Inherited, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrObject
	var assignAddr_pango_entries []aggregate.Layer3Ipv6InheritedAssignAddr
	{
		d := o.AssignAddr.ElementsAs(ctx, &assignAddr_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range assignAddr_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedAssignAddr
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			assignAddr_pango_entries = append(assignAddr_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *aggregate.Layer3Ipv6InheritedNeighborDiscovery
	if o.NeighborDiscovery != nil {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscovery)
		}

		diags.Append(o.NeighborDiscovery.CopyToPango(ctx, &neighborDiscovery_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6Inherited)
	}
	(*obj).AssignAddr = assignAddr_pango_entries
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddr, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *aggregate.Layer3Ipv6InheritedAssignAddrType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddr)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var gua_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGua
	if o.Gua != nil {
		if *obj != nil && (*obj).Gua != nil {
			gua_entry = (*obj).Gua
		} else {
			gua_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGua)
		}

		diags.Append(o.Gua.CopyToPango(ctx, &gua_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ula_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeUla
	if o.Ula != nil {
		if *obj != nil && (*obj).Ula != nil {
			ula_entry = (*obj).Ula
		} else {
			ula_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUla)
		}

		diags.Append(o.Ula.CopyToPango(ctx, &ula_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrType)
	}
	(*obj).Gua = gua_entry
	(*obj).Ula = ula_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGua, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	prefixPool_value := o.PrefixPool.ValueStringPointer()
	var poolType_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType
	if o.PoolType != nil {
		if *obj != nil && (*obj).PoolType != nil {
			poolType_entry = (*obj).PoolType
		} else {
			poolType_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
		}

		diags.Append(o.PoolType.CopyToPango(ctx, &poolType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGua)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).PrefixPool = prefixPool_value
	(*obj).PoolType = poolType_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic
	if o.Dynamic != nil {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
		}

		diags.Append(o.Dynamic.CopyToPango(ctx, &dynamic_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicId_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId
	if o.DynamicId != nil {
		if *obj != nil && (*obj).DynamicId != nil {
			dynamicId_entry = (*obj).DynamicId
		} else {
			dynamicId_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
		}

		diags.Append(o.DynamicId.CopyToPango(ctx, &dynamicId_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).DynamicId = dynamicId_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	identifier_value := o.Identifier.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
	}
	(*obj).Identifier = identifier_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeUla, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	address_value := o.Address.ValueStringPointer()
	prefix_value := o.Prefix.ValueBoolPointer()
	anycast_value := o.Anycast.ValueBoolPointer()
	var advertise_entry *aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUla)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Address = address_value
	(*obj).Prefix = prefix_value
	(*obj).Anycast = anycast_value
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer
	if o.DnsServer != nil {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
		}

		diags.Append(o.DnsServer.CopyToPango(ctx, &dnsServer_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix
	if o.DnsSuffix != nil {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
		}

		diags.Append(o.DnsSuffix.CopyToPango(ctx, &dnsSuffix_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement
	if o.RouterAdvertisement != nil {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
		}

		diags.Append(o.RouterAdvertisement.CopyToPango(ctx, &routerAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource
	if o.Source != nil {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
		}

		diags.Append(o.Source.CopyToPango(ctx, &source_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6
	if o.Dhcpv6 != nil {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}

		diags.Append(o.Dhcpv6.CopyToPango(ctx, &dhcpv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual
	if o.Manual != nil {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
		}

		diags.Append(o.Manual.CopyToPango(ctx, &manual_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
	}
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3LacpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	fastFailover_value := o.FastFailover.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer3LacpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer3LacpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPorts_value := o.MaxPorts.ValueInt64Pointer()
	mode_value := o.Mode.ValueStringPointer()
	systemPriority_value := o.SystemPriority.ValueInt64Pointer()
	transmissionRate_value := o.TransmissionRate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Lacp)
	}
	(*obj).Enable = enable_value
	(*obj).FastFailover = fastFailover_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).MaxPorts = maxPorts_value
	(*obj).Mode = mode_value
	(*obj).SystemPriority = systemPriority_value
	(*obj).TransmissionRate = transmissionRate_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3LacpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3LacpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3LldpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *aggregate.Layer3LldpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.Layer3LldpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3LldpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3NdpProxyObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3NdpProxy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []AggregateInterfaceResourceLayer3NdpProxyAddressObject
	var address_pango_entries []aggregate.Layer3NdpProxyAddress
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *aggregate.Layer3NdpProxyAddress
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3NdpProxy)
	}
	(*obj).Address = address_pango_entries
	(*obj).Enabled = enabled_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3NdpProxyAddressObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3NdpProxyAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3NdpProxyAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Negate = negate_value

	return diags
}
func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	sdwanInterfaceProfile_value := o.SdwanInterfaceProfile.ValueStringPointer()
	var upstreamNat_entry *aggregate.Layer3SdwanLinkSettingsUpstreamNat
	if o.UpstreamNat != nil {
		if *obj != nil && (*obj).UpstreamNat != nil {
			upstreamNat_entry = (*obj).UpstreamNat
		} else {
			upstreamNat_entry = new(aggregate.Layer3SdwanLinkSettingsUpstreamNat)
		}

		diags.Append(o.UpstreamNat.CopyToPango(ctx, &upstreamNat_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettings)
	}
	(*obj).Enable = enable_value
	(*obj).SdwanInterfaceProfile = sdwanInterfaceProfile_value
	(*obj).UpstreamNat = upstreamNat_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var ddns_entry *aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns
	if o.Ddns != nil {
		if *obj != nil && (*obj).Ddns != nil {
			ddns_entry = (*obj).Ddns
		} else {
			ddns_entry = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns)
		}

		diags.Append(o.Ddns.CopyToPango(ctx, &ddns_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp
	if o.StaticIp != nil {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
		}

		diags.Append(o.StaticIp.CopyToPango(ctx, &staticIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettingsUpstreamNat)
	}
	(*obj).Enable = enable_value
	(*obj).Ddns = ddns_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns)
	}

	return diags
}
func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyToPango(ctx context.Context, obj **aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	fqdn_value := o.Fqdn.ValueStringPointer()
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
	}
	(*obj).Fqdn = fqdn_value
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *AggregateInterfaceResourceVirtualWireObject) CopyToPango(ctx context.Context, obj **aggregate.VirtualWire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lldp_entry *aggregate.VirtualWireLldp
	if o.Lldp != nil {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(aggregate.VirtualWireLldp)
		}

		diags.Append(o.Lldp.CopyToPango(ctx, &lldp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.VirtualWire)
	}
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *AggregateInterfaceResourceVirtualWireLldpObject) CopyToPango(ctx context.Context, obj **aggregate.VirtualWireLldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *aggregate.VirtualWireLldpHighAvailability
	if o.HighAvailability != nil {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(aggregate.VirtualWireLldpHighAvailability)
		}

		diags.Append(o.HighAvailability.CopyToPango(ctx, &highAvailability_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(aggregate.VirtualWireLldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *AggregateInterfaceResourceVirtualWireLldpHighAvailabilityObject) CopyToPango(ctx context.Context, obj **aggregate.VirtualWireLldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(aggregate.VirtualWireLldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceResourceModel) CopyFromPango(ctx context.Context, obj *aggregate.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var decryptMirror_object *AggregateInterfaceResourceDecryptMirrorObject
	if obj.DecryptMirror != nil {
		decryptMirror_object = new(AggregateInterfaceResourceDecryptMirrorObject)

		diags.Append(decryptMirror_object.CopyFromPango(ctx, obj.DecryptMirror, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_object *AggregateInterfaceResourceHaObject
	if obj.Ha != nil {
		ha_object = new(AggregateInterfaceResourceHaObject)

		diags.Append(ha_object.CopyFromPango(ctx, obj.Ha, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer2_object *AggregateInterfaceResourceLayer2Object
	if obj.Layer2 != nil {
		layer2_object = new(AggregateInterfaceResourceLayer2Object)

		diags.Append(layer2_object.CopyFromPango(ctx, obj.Layer2, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_object *AggregateInterfaceResourceLayer3Object
	if obj.Layer3 != nil {
		layer3_object = new(AggregateInterfaceResourceLayer3Object)

		diags.Append(layer3_object.CopyFromPango(ctx, obj.Layer3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var virtualWire_object *AggregateInterfaceResourceVirtualWireObject
	if obj.VirtualWire != nil {
		virtualWire_object = new(AggregateInterfaceResourceVirtualWireObject)

		diags.Append(virtualWire_object.CopyFromPango(ctx, obj.VirtualWire, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	o.Name = types.StringValue(obj.Name)
	o.Comment = comment_value
	o.DecryptMirror = decryptMirror_object
	o.Ha = ha_object
	o.Layer2 = layer2_object
	o.Layer3 = layer3_object
	o.VirtualWire = virtualWire_object

	return diags
}

func (o *AggregateInterfaceResourceDecryptMirrorObject) CopyFromPango(ctx context.Context, obj *aggregate.DecryptMirror, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceHaObject) CopyFromPango(ctx context.Context, obj *aggregate.Ha, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_object *AggregateInterfaceResourceHaLacpObject
	if obj.Lacp != nil {
		lacp_object = new(AggregateInterfaceResourceHaLacpObject)

		diags.Append(lacp_object.CopyFromPango(ctx, obj.Lacp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Lacp = lacp_object

	return diags
}

func (o *AggregateInterfaceResourceHaLacpObject) CopyFromPango(ctx context.Context, obj *aggregate.HaLacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var fastFailover_value types.Bool
	if obj.FastFailover != nil {
		fastFailover_value = types.BoolValue(*obj.FastFailover)
	}
	var maxPorts_value types.Int64
	if obj.MaxPorts != nil {
		maxPorts_value = types.Int64Value(*obj.MaxPorts)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var systemPriority_value types.Int64
	if obj.SystemPriority != nil {
		systemPriority_value = types.Int64Value(*obj.SystemPriority)
	}
	var transmissionRate_value types.String
	if obj.TransmissionRate != nil {
		transmissionRate_value = types.StringValue(*obj.TransmissionRate)
	}
	o.Enable = enable_value
	o.FastFailover = fastFailover_value
	o.MaxPorts = maxPorts_value
	o.Mode = mode_value
	o.SystemPriority = systemPriority_value
	o.TransmissionRate = transmissionRate_value

	return diags
}

func (o *AggregateInterfaceResourceLayer2Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer2, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_object *AggregateInterfaceResourceLayer2LacpObject
	if obj.Lacp != nil {
		lacp_object = new(AggregateInterfaceResourceLayer2LacpObject)

		diags.Append(lacp_object.CopyFromPango(ctx, obj.Lacp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_object *AggregateInterfaceResourceLayer2LldpObject
	if obj.Lldp != nil {
		lldp_object = new(AggregateInterfaceResourceLayer2LldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lacp = lacp_object
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *AggregateInterfaceResourceLayer2LacpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceResourceLayer2LacpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceResourceLayer2LacpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var fastFailover_value types.Bool
	if obj.FastFailover != nil {
		fastFailover_value = types.BoolValue(*obj.FastFailover)
	}
	var maxPorts_value types.Int64
	if obj.MaxPorts != nil {
		maxPorts_value = types.Int64Value(*obj.MaxPorts)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var systemPriority_value types.Int64
	if obj.SystemPriority != nil {
		systemPriority_value = types.Int64Value(*obj.SystemPriority)
	}
	var transmissionRate_value types.String
	if obj.TransmissionRate != nil {
		transmissionRate_value = types.StringValue(*obj.TransmissionRate)
	}
	o.Enable = enable_value
	o.FastFailover = fastFailover_value
	o.HighAvailability = highAvailability_object
	o.MaxPorts = maxPorts_value
	o.Mode = mode_value
	o.SystemPriority = systemPriority_value
	o.TransmissionRate = transmissionRate_value

	return diags
}

func (o *AggregateInterfaceResourceLayer2LacpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceResourceLayer2LldpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceResourceLayer2LldpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceResourceLayer2LldpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *AggregateInterfaceResourceLayer2LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer2LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var arp_list types.List
	{
		var arp_tf_entries []AggregateInterfaceResourceLayer3ArpObject
		for _, elt := range obj.Arp {
			var entry AggregateInterfaceResourceLayer3ArpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			arp_tf_entries = append(arp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("arp")
		arp_list, list_diags = types.ListValueFrom(ctx, schemaType, arp_tf_entries)
		diags.Append(list_diags...)
	}
	var ip_list types.List
	{
		var ip_tf_entries []AggregateInterfaceResourceLayer3IpObject
		for _, elt := range obj.Ip {
			var entry AggregateInterfaceResourceLayer3IpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ip_tf_entries = append(ip_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ip")
		ip_list, list_diags = types.ListValueFrom(ctx, schemaType, ip_tf_entries)
		diags.Append(list_diags...)
	}
	var adjustTcpMss_object *AggregateInterfaceResourceLayer3AdjustTcpMssObject
	if obj.AdjustTcpMss != nil {
		adjustTcpMss_object = new(AggregateInterfaceResourceLayer3AdjustTcpMssObject)

		diags.Append(adjustTcpMss_object.CopyFromPango(ctx, obj.AdjustTcpMss, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bonjour_object *AggregateInterfaceResourceLayer3BonjourObject
	if obj.Bonjour != nil {
		bonjour_object = new(AggregateInterfaceResourceLayer3BonjourObject)

		diags.Append(bonjour_object.CopyFromPango(ctx, obj.Bonjour, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsConfig_object *AggregateInterfaceResourceLayer3DdnsConfigObject
	if obj.DdnsConfig != nil {
		ddnsConfig_object = new(AggregateInterfaceResourceLayer3DdnsConfigObject)

		diags.Append(ddnsConfig_object.CopyFromPango(ctx, obj.DdnsConfig, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_object *AggregateInterfaceResourceLayer3DhcpClientObject
	if obj.DhcpClient != nil {
		dhcpClient_object = new(AggregateInterfaceResourceLayer3DhcpClientObject)

		diags.Append(dhcpClient_object.CopyFromPango(ctx, obj.DhcpClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *AggregateInterfaceResourceLayer3Ipv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(AggregateInterfaceResourceLayer3Ipv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lacp_object *AggregateInterfaceResourceLayer3LacpObject
	if obj.Lacp != nil {
		lacp_object = new(AggregateInterfaceResourceLayer3LacpObject)

		diags.Append(lacp_object.CopyFromPango(ctx, obj.Lacp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_object *AggregateInterfaceResourceLayer3LldpObject
	if obj.Lldp != nil {
		lldp_object = new(AggregateInterfaceResourceLayer3LldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ndpProxy_object *AggregateInterfaceResourceLayer3NdpProxyObject
	if obj.NdpProxy != nil {
		ndpProxy_object = new(AggregateInterfaceResourceLayer3NdpProxyObject)

		diags.Append(ndpProxy_object.CopyFromPango(ctx, obj.NdpProxy, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_object *AggregateInterfaceResourceLayer3SdwanLinkSettingsObject
	if obj.SdwanLinkSettings != nil {
		sdwanLinkSettings_object = new(AggregateInterfaceResourceLayer3SdwanLinkSettingsObject)

		diags.Append(sdwanLinkSettings_object.CopyFromPango(ctx, obj.SdwanLinkSettings, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var decryptForward_value types.Bool
	if obj.DecryptForward != nil {
		decryptForward_value = types.BoolValue(*obj.DecryptForward)
	}
	var dfIgnore_value types.Bool
	if obj.DfIgnore != nil {
		dfIgnore_value = types.BoolValue(*obj.DfIgnore)
	}
	var interfaceManagementProfile_value types.String
	if obj.InterfaceManagementProfile != nil {
		interfaceManagementProfile_value = types.StringValue(*obj.InterfaceManagementProfile)
	}
	var mtu_value types.Int64
	if obj.Mtu != nil {
		mtu_value = types.Int64Value(*obj.Mtu)
	}
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	var untaggedSubInterface_value types.Bool
	if obj.UntaggedSubInterface != nil {
		untaggedSubInterface_value = types.BoolValue(*obj.UntaggedSubInterface)
	}
	o.AdjustTcpMss = adjustTcpMss_object
	o.Arp = arp_list
	o.Bonjour = bonjour_object
	o.DdnsConfig = ddnsConfig_object
	o.DecryptForward = decryptForward_value
	o.DfIgnore = dfIgnore_value
	o.DhcpClient = dhcpClient_object
	o.InterfaceManagementProfile = interfaceManagementProfile_value
	o.Ip = ip_list
	o.Ipv6 = ipv6_object
	o.Lacp = lacp_object
	o.Lldp = lldp_object
	o.Mtu = mtu_value
	o.NdpProxy = ndpProxy_object
	o.NetflowProfile = netflowProfile_value
	o.SdwanLinkSettings = sdwanLinkSettings_object
	o.UntaggedSubInterface = untaggedSubInterface_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3AdjustTcpMssObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3AdjustTcpMss, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var ipv4MssAdjustment_value types.Int64
	if obj.Ipv4MssAdjustment != nil {
		ipv4MssAdjustment_value = types.Int64Value(*obj.Ipv4MssAdjustment)
	}
	var ipv6MssAdjustment_value types.Int64
	if obj.Ipv6MssAdjustment != nil {
		ipv6MssAdjustment_value = types.Int64Value(*obj.Ipv6MssAdjustment)
	}
	o.Enable = enable_value
	o.Ipv4MssAdjustment = ipv4MssAdjustment_value
	o.Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3ArpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Arp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3BonjourObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Bonjour, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var groupId_value types.Int64
	if obj.GroupId != nil {
		groupId_value = types.Int64Value(*obj.GroupId)
	}
	var ttlCheck_value types.Bool
	if obj.TtlCheck != nil {
		ttlCheck_value = types.BoolValue(*obj.TtlCheck)
	}
	o.Enable = enable_value
	o.GroupId = groupId_value
	o.TtlCheck = ttlCheck_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3DdnsConfigObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DdnsConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ddnsIp_list types.List
	{
		var list_diags diag.Diagnostics
		ddnsIp_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.DdnsIp)
		diags.Append(list_diags...)
	}
	var ddnsIpv6_list types.List
	{
		var list_diags diag.Diagnostics
		ddnsIpv6_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.DdnsIpv6)
		diags.Append(list_diags...)
	}
	var ddnsVendorConfig_list types.List
	{
		var ddnsVendorConfig_tf_entries []AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject
		for _, elt := range obj.DdnsVendorConfig {
			var entry AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ddnsVendorConfig_tf_entries = append(ddnsVendorConfig_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ddns_vendor_config")
		ddnsVendorConfig_list, list_diags = types.ListValueFrom(ctx, schemaType, ddnsVendorConfig_tf_entries)
		diags.Append(list_diags...)
	}

	var ddnsCertProfile_value types.String
	if obj.DdnsCertProfile != nil {
		ddnsCertProfile_value = types.StringValue(*obj.DdnsCertProfile)
	}
	var ddnsEnabled_value types.Bool
	if obj.DdnsEnabled != nil {
		ddnsEnabled_value = types.BoolValue(*obj.DdnsEnabled)
	}
	var ddnsHostname_value types.String
	if obj.DdnsHostname != nil {
		ddnsHostname_value = types.StringValue(*obj.DdnsHostname)
	}
	var ddnsUpdateInterval_value types.Int64
	if obj.DdnsUpdateInterval != nil {
		ddnsUpdateInterval_value = types.Int64Value(*obj.DdnsUpdateInterval)
	}
	var ddnsVendor_value types.String
	if obj.DdnsVendor != nil {
		ddnsVendor_value = types.StringValue(*obj.DdnsVendor)
	}
	o.DdnsCertProfile = ddnsCertProfile_value
	o.DdnsEnabled = ddnsEnabled_value
	o.DdnsHostname = ddnsHostname_value
	o.DdnsIp = ddnsIp_list
	o.DdnsIpv6 = ddnsIpv6_list
	o.DdnsUpdateInterval = ddnsUpdateInterval_value
	o.DdnsVendor = ddnsVendor_value
	o.DdnsVendorConfig = ddnsVendorConfig_list

	return diags
}

func (o *AggregateInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DdnsConfigDdnsVendorConfig, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3DhcpClientObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sendHostname_object *AggregateInterfaceResourceLayer3DhcpClientSendHostnameObject
	if obj.SendHostname != nil {
		sendHostname_object = new(AggregateInterfaceResourceLayer3DhcpClientSendHostnameObject)

		diags.Append(sendHostname_object.CopyFromPango(ctx, obj.SendHostname, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.SendHostname = sendHostname_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3DhcpClientSendHostnameObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3DhcpClientSendHostname, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.Enable = enable_value
	o.Hostname = hostname_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3IpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var sdwanGateway_value types.String
	if obj.SdwanGateway != nil {
		sdwanGateway_value = types.StringValue(*obj.SdwanGateway)
	}
	o.Name = types.StringValue(obj.Name)
	o.SdwanGateway = sdwanGateway_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []AggregateInterfaceResourceLayer3Ipv6AddressObject
		for _, elt := range obj.Address {
			var entry AggregateInterfaceResourceLayer3Ipv6AddressObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			address_tf_entries = append(address_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}
	var neighborDiscovery_object *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dhcpClient_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientObject
	if obj.DhcpClient != nil {
		dhcpClient_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientObject)

		diags.Append(dhcpClient_object.CopyFromPango(ctx, obj.DhcpClient, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var inherited_object *AggregateInterfaceResourceLayer3Ipv6InheritedObject
	if obj.Inherited != nil {
		inherited_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedObject)

		diags.Append(inherited_object.CopyFromPango(ctx, obj.Inherited, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	var interfaceId_value types.String
	if obj.InterfaceId != nil {
		interfaceId_value = types.StringValue(*obj.InterfaceId)
	}
	o.Address = address_list
	o.Enabled = enabled_value
	o.InterfaceId = interfaceId_value
	o.NeighborDiscovery = neighborDiscovery_object
	o.DhcpClient = dhcpClient_object
	o.Inherited = inherited_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6Address, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var prefix_object *AggregateInterfaceResourceLayer3Ipv6AddressPrefixObject
	if obj.Prefix != nil {
		prefix_object = new(AggregateInterfaceResourceLayer3Ipv6AddressPrefixObject)

		diags.Append(prefix_object.CopyFromPango(ctx, obj.Prefix, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var anycast_object *AggregateInterfaceResourceLayer3Ipv6AddressAnycastObject
	if obj.Anycast != nil {
		anycast_object = new(AggregateInterfaceResourceLayer3Ipv6AddressAnycastObject)

		diags.Append(anycast_object.CopyFromPango(ctx, obj.Anycast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.EnableOnInterface = enableOnInterface_value
	o.Prefix = prefix_object
	o.Anycast = anycast_object
	o.Advertise = advertise_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressPrefixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6AddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressAnycastObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6AddressAnycast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6AddressAdvertiseObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6AddressAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var routerAdvertisement_object *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	if obj.RouterAdvertisement != nil {
		routerAdvertisement_object = new(AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject)

		diags.Append(routerAdvertisement_object.CopyFromPango(ctx, obj.RouterAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_object *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject
	if obj.DnsSupport != nil {
		dnsSupport_object = new(AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject)

		diags.Append(dnsSupport_object.CopyFromPango(ctx, obj.DnsSupport, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.DnsSupport = dnsSupport_object
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
		for _, elt := range obj.Server {
			var entry AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}
	var suffix_list types.List
	{
		var suffix_tf_entries []AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
		for _, elt := range obj.Suffix {
			var entry AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Server = server_list
	o.Suffix = suffix_list

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClient, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighborDiscovery_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var prefixDelegation_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject
	if obj.PrefixDelegation != nil {
		prefixDelegation_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject)

		diags.Append(prefixDelegation_object.CopyFromPango(ctx, obj.PrefixDelegation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var v6Options_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject
	if obj.V6Options != nil {
		v6Options_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject)

		diags.Append(v6Options_object.CopyFromPango(ctx, obj.V6Options, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptRaRoute_value types.Bool
	if obj.AcceptRaRoute != nil {
		acceptRaRoute_value = types.BoolValue(*obj.AcceptRaRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var preference_value types.String
	if obj.Preference != nil {
		preference_value = types.StringValue(*obj.Preference)
	}
	o.AcceptRaRoute = acceptRaRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object
	o.Preference = preference_value
	o.PrefixDelegation = prefixDelegation_object
	o.V6Options = v6Options_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var dnsServer_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject
	if obj.DnsServer != nil {
		dnsServer_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject)

		diags.Append(dnsServer_object.CopyFromPango(ctx, obj.DnsServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject
	if obj.DnsSuffix != nil {
		dnsSuffix_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject)

		diags.Append(dnsSuffix_object.CopyFromPango(ctx, obj.DnsSuffix, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
		for _, elt := range obj.Server {
			var entry AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		for _, elt := range obj.Suffix {
			var entry AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
	if obj.Enable != nil {
		enable_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject)

		diags.Append(enable_object.CopyFromPango(ctx, obj.Enable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Enable = enable_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject
	if obj.No != nil {
		no_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject)

		diags.Append(no_object.CopyFromPango(ctx, obj.No, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
	if obj.Yes != nil {
		yes_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject)

		diags.Append(yes_object.CopyFromPango(ctx, obj.Yes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var pfxPoolName_value types.String
	if obj.PfxPoolName != nil {
		pfxPoolName_value = types.StringValue(*obj.PfxPoolName)
	}
	var prefixLen_value types.Int64
	if obj.PrefixLen != nil {
		prefixLen_value = types.Int64Value(*obj.PrefixLen)
	}
	var prefixLenHint_value types.Bool
	if obj.PrefixLenHint != nil {
		prefixLenHint_value = types.BoolValue(*obj.PrefixLenHint)
	}
	o.PfxPoolName = pfxPoolName_value
	o.PrefixLen = prefixLen_value
	o.PrefixLenHint = prefixLenHint_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6Options, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject
	if obj.Enable != nil {
		enable_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject)

		diags.Append(enable_object.CopyFromPango(ctx, obj.Enable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var duidType_value types.String
	if obj.DuidType != nil {
		duidType_value = types.StringValue(*obj.DuidType)
	}
	var rapidCommit_value types.Bool
	if obj.RapidCommit != nil {
		rapidCommit_value = types.BoolValue(*obj.RapidCommit)
	}
	var supportSrvrReconfig_value types.Bool
	if obj.SupportSrvrReconfig != nil {
		supportSrvrReconfig_value = types.BoolValue(*obj.SupportSrvrReconfig)
	}
	o.DuidType = duidType_value
	o.Enable = enable_object
	o.RapidCommit = rapidCommit_value
	o.SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6OptionsEnable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject
	if obj.No != nil {
		no_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject)

		diags.Append(no_object.CopyFromPango(ctx, obj.No, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_object *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
	if obj.Yes != nil {
		yes_object = new(AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject)

		diags.Append(yes_object.CopyFromPango(ctx, obj.Yes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableNo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6DhcpClientV6OptionsEnableYes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var nonTempAddr_value types.Bool
	if obj.NonTempAddr != nil {
		nonTempAddr_value = types.BoolValue(*obj.NonTempAddr)
	}
	var tempAddr_value types.Bool
	if obj.TempAddr != nil {
		tempAddr_value = types.BoolValue(*obj.TempAddr)
	}
	o.NonTempAddr = nonTempAddr_value
	o.TempAddr = tempAddr_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6Inherited, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_list types.List
	{
		var assignAddr_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrObject
		for _, elt := range obj.AssignAddr {
			var entry AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			assignAddr_tf_entries = append(assignAddr_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("assign_addr")
		assignAddr_list, list_diags = types.ListValueFrom(ctx, schemaType, assignAddr_tf_entries)
		diags.Append(list_diags...)
	}
	var neighborDiscovery_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject
	if obj.NeighborDiscovery != nil {
		neighborDiscovery_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject)

		diags.Append(neighborDiscovery_object.CopyFromPango(ctx, obj.NeighborDiscovery, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.AssignAddr = assignAddr_list
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddr, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject
	if obj.Type != nil {
		type_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Type = type_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var gua_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject
	if obj.Gua != nil {
		gua_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject)

		diags.Append(gua_object.CopyFromPango(ctx, obj.Gua, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ula_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
	if obj.Ula != nil {
		ula_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject)

		diags.Append(ula_object.CopyFromPango(ctx, obj.Ula, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Gua = gua_object
	o.Ula = ula_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGua, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var poolType_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject
	if obj.PoolType != nil {
		poolType_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject)

		diags.Append(poolType_object.CopyFromPango(ctx, obj.PoolType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.PrefixPool = prefixPool_value
	o.PoolType = poolType_object
	o.Advertise = advertise_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject
	if obj.Dynamic != nil {
		dynamic_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject)

		diags.Append(dynamic_object.CopyFromPango(ctx, obj.Dynamic, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicId_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
	if obj.DynamicId != nil {
		dynamicId_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject)

		diags.Append(dynamicId_object.CopyFromPango(ctx, obj.DynamicId, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dynamic = dynamic_object
	o.DynamicId = dynamicId_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var identifier_value types.Int64
	if obj.Identifier != nil {
		identifier_value = types.Int64Value(*obj.Identifier)
	}
	o.Identifier = identifier_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeUla, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var prefix_value types.Bool
	if obj.Prefix != nil {
		prefix_value = types.BoolValue(*obj.Prefix)
	}
	var anycast_value types.Bool
	if obj.Anycast != nil {
		anycast_value = types.BoolValue(*obj.Anycast)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.Address = address_value
	o.Prefix = prefix_value
	o.Anycast = anycast_value
	o.Advertise = advertise_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscovery, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
		for _, elt := range obj.Neighbor {
			var entry AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var dnsServer_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject
	if obj.DnsServer != nil {
		dnsServer_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject)

		diags.Append(dnsServer_object.CopyFromPango(ctx, obj.DnsServer, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject
	if obj.DnsSuffix != nil {
		dnsSuffix_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject)

		diags.Append(dnsSuffix_object.CopyFromPango(ctx, obj.DnsSuffix, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routerAdvertisement_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
	if obj.RouterAdvertisement != nil {
		routerAdvertisement_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject)

		diags.Append(routerAdvertisement_object.CopyFromPango(ctx, obj.RouterAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
		for _, elt := range obj.Server {
			var entry AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			server_tf_entries = append(server_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var source_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
	if obj.Source != nil {
		source_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject)

		diags.Append(source_object.CopyFromPango(ctx, obj.Source, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if obj.Dhcpv6 != nil {
		dhcpv6_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object)

		diags.Append(dhcpv6_object.CopyFromPango(ctx, obj.Dhcpv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_object *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
	if obj.Manual != nil {
		manual_object = new(AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject)

		diags.Append(manual_object.CopyFromPango(ctx, obj.Manual, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		for _, elt := range obj.Suffix {
			var entry AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suffix_tf_entries = append(suffix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3LacpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Lacp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceResourceLayer3LacpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceResourceLayer3LacpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var fastFailover_value types.Bool
	if obj.FastFailover != nil {
		fastFailover_value = types.BoolValue(*obj.FastFailover)
	}
	var maxPorts_value types.Int64
	if obj.MaxPorts != nil {
		maxPorts_value = types.Int64Value(*obj.MaxPorts)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var systemPriority_value types.Int64
	if obj.SystemPriority != nil {
		systemPriority_value = types.Int64Value(*obj.SystemPriority)
	}
	var transmissionRate_value types.String
	if obj.TransmissionRate != nil {
		transmissionRate_value = types.StringValue(*obj.TransmissionRate)
	}
	o.Enable = enable_value
	o.FastFailover = fastFailover_value
	o.HighAvailability = highAvailability_object
	o.MaxPorts = maxPorts_value
	o.Mode = mode_value
	o.SystemPriority = systemPriority_value
	o.TransmissionRate = transmissionRate_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3LacpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3LacpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3LldpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3Lldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceResourceLayer3LldpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceResourceLayer3LldpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3LldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3NdpProxyObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3NdpProxy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []AggregateInterfaceResourceLayer3NdpProxyAddressObject
		for _, elt := range obj.Address {
			var entry AggregateInterfaceResourceLayer3NdpProxyAddressObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			address_tf_entries = append(address_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Address = address_list
	o.Enabled = enabled_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3NdpProxyAddressObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3NdpProxyAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Negate = negate_value

	return diags
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettings, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var upstreamNat_object *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject
	if obj.UpstreamNat != nil {
		upstreamNat_object = new(AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject)

		diags.Append(upstreamNat_object.CopyFromPango(ctx, obj.UpstreamNat, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var sdwanInterfaceProfile_value types.String
	if obj.SdwanInterfaceProfile != nil {
		sdwanInterfaceProfile_value = types.StringValue(*obj.SdwanInterfaceProfile)
	}
	o.Enable = enable_value
	o.SdwanInterfaceProfile = sdwanInterfaceProfile_value
	o.UpstreamNat = upstreamNat_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettingsUpstreamNat, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ddns_object *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject
	if obj.Ddns != nil {
		ddns_object = new(AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject)

		diags.Append(ddns_object.CopyFromPango(ctx, obj.Ddns, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_object *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
	if obj.StaticIp != nil {
		staticIp_object = new(AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject)

		diags.Append(staticIp_object.CopyFromPango(ctx, obj.StaticIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Ddns = ddns_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettingsUpstreamNatDdns, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *AggregateInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyFromPango(ctx context.Context, obj *aggregate.Layer3SdwanLinkSettingsUpstreamNatStaticIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.Fqdn = fqdn_value
	o.IpAddress = ipAddress_value

	return diags
}

func (o *AggregateInterfaceResourceVirtualWireObject) CopyFromPango(ctx context.Context, obj *aggregate.VirtualWire, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var lldp_object *AggregateInterfaceResourceVirtualWireLldpObject
	if obj.Lldp != nil {
		lldp_object = new(AggregateInterfaceResourceVirtualWireLldpObject)

		diags.Append(lldp_object.CopyFromPango(ctx, obj.Lldp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *AggregateInterfaceResourceVirtualWireLldpObject) CopyFromPango(ctx context.Context, obj *aggregate.VirtualWireLldp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_object *AggregateInterfaceResourceVirtualWireLldpHighAvailabilityObject
	if obj.HighAvailability != nil {
		highAvailability_object = new(AggregateInterfaceResourceVirtualWireLldpHighAvailabilityObject)

		diags.Append(highAvailability_object.CopyFromPango(ctx, obj.HighAvailability, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *AggregateInterfaceResourceVirtualWireLldpHighAvailabilityObject) CopyFromPango(ctx context.Context, obj *aggregate.VirtualWireLldpHighAvailability, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (r *AggregateInterfaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state AggregateInterfaceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_aggregate_interface_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location aggregate.Location

	if state.Location.Shared != nil {
		location.Shared = &aggregate.SharedLocation{}
	}
	if state.Location.Template != nil {
		location.Template = &aggregate.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &aggregate.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Ngfw != nil {
		location.Ngfw = &aggregate.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *aggregate.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *AggregateInterfaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state AggregateInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location aggregate.Location

	if savestate.Location.Shared != nil {
		location.Shared = &aggregate.SharedLocation{}
	}
	if savestate.Location.Template != nil {
		location.Template = &aggregate.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &aggregate.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Ngfw != nil {
		location.Ngfw = &aggregate.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_aggregate_interface_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *AggregateInterfaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state AggregateInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location aggregate.Location

	if state.Location.Shared != nil {
		location.Shared = &aggregate.SharedLocation{}
	}
	if state.Location.Template != nil {
		location.Template = &aggregate.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &aggregate.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Ngfw != nil {
		location.Ngfw = &aggregate.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_aggregate_interface_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj, obj.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *AggregateInterfaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state AggregateInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_aggregate_interface_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location aggregate.Location

	if state.Location.Shared != nil {
		location.Shared = &aggregate.SharedLocation{}
	}
	if state.Location.Template != nil {
		location.Template = &aggregate.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &aggregate.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Ngfw != nil {
		location.Ngfw = &aggregate.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}

	err := r.manager.Delete(ctx, location, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

type AggregateInterfaceImportState struct {
	Location AggregateInterfaceLocation `json:"location"`
	Name     string                     `json:"name"`
}

func AggregateInterfaceImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location AggregateInterfaceLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name string
	switch value := nameAttr.(type) {
	case types.String:
		name = value.ValueString()
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := AggregateInterfaceImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *AggregateInterfaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj AggregateInterfaceImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type AggregateInterfaceSharedLocation struct {
}
type AggregateInterfaceTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type AggregateInterfaceTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type AggregateInterfaceNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type AggregateInterfaceLocation struct {
	Shared        *AggregateInterfaceSharedLocation        `tfsdk:"shared"`
	Template      *AggregateInterfaceTemplateLocation      `tfsdk:"template"`
	TemplateStack *AggregateInterfaceTemplateStackLocation `tfsdk:"template_stack"`
	Ngfw          *AggregateInterfaceNgfwLocation          `tfsdk:"ngfw"`
}

func AggregateInterfaceLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.SingleNestedAttribute{
				Description: "Panorama shared object",
				Optional:    true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("shared"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("ngfw"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o AggregateInterfaceSharedLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
	}{}

	return json.Marshal(obj)
}

func (o *AggregateInterfaceSharedLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}

	return nil
}
func (o AggregateInterfaceTemplateLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *AggregateInterfaceTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o AggregateInterfaceTemplateStackLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *AggregateInterfaceTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o AggregateInterfaceNgfwLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		NgfwDevice *string `json:"ngfw_device"`
	}{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *AggregateInterfaceNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o AggregateInterfaceLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Shared        *AggregateInterfaceSharedLocation        `json:"shared"`
		Template      *AggregateInterfaceTemplateLocation      `json:"template"`
		TemplateStack *AggregateInterfaceTemplateStackLocation `json:"template_stack"`
		Ngfw          *AggregateInterfaceNgfwLocation          `json:"ngfw"`
	}{
		Shared:        o.Shared,
		Template:      o.Template,
		TemplateStack: o.TemplateStack,
		Ngfw:          o.Ngfw,
	}

	return json.Marshal(obj)
}

func (o *AggregateInterfaceLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared        *AggregateInterfaceSharedLocation        `json:"shared"`
		Template      *AggregateInterfaceTemplateLocation      `json:"template"`
		TemplateStack *AggregateInterfaceTemplateStackLocation `json:"template_stack"`
		Ngfw          *AggregateInterfaceNgfwLocation          `json:"ngfw"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Shared = shadow.Shared
	o.Template = shadow.Template
	o.TemplateStack = shadow.TemplateStack
	o.Ngfw = shadow.Ngfw

	return nil
}
